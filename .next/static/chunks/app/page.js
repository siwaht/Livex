/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnJ1bm5lciUyRndvcmtzcGFjZSUyRnNyYyUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOEpBQTRFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NDI4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvc3JjL2FwcC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLE1BQU1BLHFCQUFPQyxpREFBVUEsTUFDckIsUUFXRUM7UUFWQSxFQUNFQyxRQUFRLGdCQUNSQyxPQUFPLElBQ1BDLGNBQWMsR0FDZEMsbUJBQUEsRUFDQUMsWUFBWSxJQUNaQyxRQUFBLEVBQ0FDLFFBQUEsRUFDQSxHQUFHQyxNQUFBO0lBSUUscUJBQUFDLG9EQUFhQSxDQUNsQixPQUNBO1FBQ0VUO1FBQ0EsR0FBR1UsNkRBQUE7UUFDSEMsT0FBT1Q7UUFDUFUsUUFBUVY7UUFDUlcsUUFBUVo7UUFDUkUsYUFBYUMsc0JBQXVCVSxPQUFPWCxlQUFlLEtBQU1XLE9BQU9aLFFBQVFDO1FBQy9FRSxXQUFXVSxrRUFBWUEsQ0FBQyxVQUFVVjtRQUNsQyxHQUFHRyxJQUFBO0lBQ0wsR0FDQTtXQUNLRCxTQUFTUyxHQUFBLENBQUk7Z0JBQUMsQ0FBQ0MsS0FBS0MsTUFBVztpQ0FBQVQsb0RBQWFBLENBQUNRLEtBQUtDOztXQUNqREMsTUFBTUMsT0FBQSxDQUFRZCxZQUFZQSxXQUFXO1lBQUNBO1NBQVE7S0FDcEQ7QUFFSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL0ljb24udHM/YWRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgSWNvbk5vZGUsIEx1Y2lkZVByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMgfSBmcm9tICdAbHVjaWRlL3NoYXJlZCc7XG5cbmludGVyZmFjZSBJY29uQ29tcG9uZW50UHJvcHMgZXh0ZW5kcyBMdWNpZGVQcm9wcyB7XG4gIGljb25Ob2RlOiBJY29uTm9kZTtcbn1cblxuLyoqXG4gKiBMdWNpZGUgaWNvbiBjb21wb25lbnRcbiAqXG4gKiBAY29tcG9uZW50IEljb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmNvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMuc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMuc3Ryb2tlV2lkdGggLSBUaGUgc3Ryb2tlIHdpZHRoIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BzLmFic29sdXRlU3Ryb2tlV2lkdGggLSBXaGV0aGVyIHRvIHVzZSBhYnNvbHV0ZSBzdHJva2Ugd2lkdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5jbGFzc05hbWUgLSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtJY29uTm9kZX0gcHJvcHMuY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7SWNvbk5vZGV9IHByb3BzLmljb25Ob2RlIC0gVGhlIGljb24gbm9kZSBvZiB0aGUgaWNvblxuICpcbiAqIEByZXR1cm5zIHtGb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50fSBMdWNpZGVJY29uXG4gKi9cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmPFNWR1NWR0VsZW1lbnQsIEljb25Db21wb25lbnRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBjb2xvciA9ICdjdXJyZW50Q29sb3InLFxuICAgICAgc2l6ZSA9IDI0LFxuICAgICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgICAgYWJzb2x1dGVTdHJva2VXaWR0aCxcbiAgICAgIGNsYXNzTmFtZSA9ICcnLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpY29uTm9kZSxcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZixcbiAgKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3ZnJyxcbiAgICAgIHtcbiAgICAgICAgcmVmLFxuICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyAoTnVtYmVyKHN0cm9rZVdpZHRoKSAqIDI0KSAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcygnbHVjaWRlJywgY2xhc3NOYW1lKSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dKSxcbiAgICAgIF0sXG4gICAgKTtcbiAgfSxcbik7XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iXSwibmFtZXMiOlsiSWNvbiIsImZvcndhcmRSZWYiLCJyZWYiLCJjb2xvciIsInNpemUiLCJzdHJva2VXaWR0aCIsImFic29sdXRlU3Ryb2tlV2lkdGgiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImljb25Ob2RlIiwicmVzdCIsImNyZWF0ZUVsZW1lbnQiLCJkZWZhdWx0QXR0cmlidXRlcyIsIndpZHRoIiwiaGVpZ2h0Iiwic3Ryb2tlIiwiTnVtYmVyIiwibWVyZ2VDbGFzc2VzIiwibWFwIiwidGFnIiwiYXR0cnMiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)(iconName)), className),\n            ...props\n        });\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBV00sTUFBQUEsbUJBQW1CLENBQUNDLFVBQWtCQztJQUMxQyxNQUFNQywwQkFBWUMsaURBQVVBLENBQTZCLFFBQTBCQztZQUF6QixFQUFFQyxTQUFXLEtBQUdDLE9BQVM7NkJBQ2pGQyxvREFBYUEsQ0FBQ0MsZ0RBQUlBLEVBQUU7WUFDbEJKO1lBQ0FIO1lBQ0FJLFdBQVdJLGtFQUFZQSxDQUFDLFVBQStCLE9BQXJCQyxpRUFBV0EsQ0FBQ1YsWUFBYUs7WUFDM0QsR0FBR0MsS0FBQTtRQUFBOztJQUlHSixVQUFBUyxXQUFBLEdBQWMsR0FBVyxPQUFSWDtJQUVwQixPQUFBRTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY3JlYXRlTHVjaWRlSWNvbi50cz8wNDg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuaW1wb3J0IHsgSWNvbk5vZGUsIEx1Y2lkZVByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24nO1xuXG4vKipcbiAqIENyZWF0ZSBhIEx1Y2lkZSBpY29uIGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGljb25OYW1lXG4gKiBAcGFyYW0ge2FycmF5fSBpY29uTm9kZVxuICogQHJldHVybnMge0ZvcndhcmRSZWZFeG90aWNDb21wb25lbnR9IEx1Y2lkZUljb25cbiAqL1xuY29uc3QgY3JlYXRlTHVjaWRlSWNvbiA9IChpY29uTmFtZTogc3RyaW5nLCBpY29uTm9kZTogSWNvbk5vZGUpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZjxTVkdTVkdFbGVtZW50LCBMdWNpZGVQcm9wcz4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+XG4gICAgY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgICByZWYsXG4gICAgICBpY29uTm9kZSxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKGBsdWNpZGUtJHt0b0tlYmFiQ2FzZShpY29uTmFtZSl9YCwgY2xhc3NOYW1lKSxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pLFxuICApO1xuXG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGAke2ljb25OYW1lfWA7XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUx1Y2lkZUljb247XG4iXSwibmFtZXMiOlsiY3JlYXRlTHVjaWRlSWNvbiIsImljb25OYW1lIiwiaWNvbk5vZGUiLCJDb21wb25lbnQiLCJmb3J3YXJkUmVmIiwicmVmIiwiY2xhc3NOYW1lIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiSWNvbiIsIm1lcmdlQ2xhc3NlcyIsInRvS2ViYWJDYXNlIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQUEsSUFBZUEsb0JBQUE7SUFDYkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxlQUFlO0lBQ2ZDLGdCQUFnQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2RlZmF1bHRBdHRyaWJ1dGVzLnRzPzM3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiAnMCAwIDI0IDI0JyxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG59O1xuIl0sIm5hbWVzIjpbImRlZmF1bHRBdHRyaWJ1dGVzIiwieG1sbnMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/arrow-left.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ArrowLeft; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst ArrowLeft = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ArrowLeft\", [\n    [\n        \"path\",\n        {\n            d: \"m12 19-7-7 7-7\",\n            key: \"1l729n\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19 12H5\",\n            key: \"x3x0zl\"\n        }\n    ]\n]);\n //# sourceMappingURL=arrow-left.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYXJyb3ctbGVmdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLFlBQVlDLGdFQUFnQkEsQ0FBQyxhQUFhO0lBQzlDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQWtCQyxLQUFLO1FBQUE7S0FBVTtJQUMvQztRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFZQyxLQUFLO1FBQUE7S0FBVTtDQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2Fycm93LWxlZnQudHM/NDMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEFycm93TGVmdFxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0p0TVRJZ01Ua3ROeTAzSURjdE55SWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1Ua2dNVEpJTlNJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2Fycm93LWxlZnRcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBBcnJvd0xlZnQgPSBjcmVhdGVMdWNpZGVJY29uKCdBcnJvd0xlZnQnLCBbXG4gIFsncGF0aCcsIHsgZDogJ20xMiAxOS03LTcgNy03Jywga2V5OiAnMWw3MjluJyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTE5IDEySDUnLCBrZXk6ICd4M3gwemwnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFycm93TGVmdDtcbiJdLCJuYW1lcyI6WyJBcnJvd0xlZnQiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/bot.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/bot.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Bot; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Bot = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Bot\", [\n    [\n        \"path\",\n        {\n            d: \"M12 8V4H8\",\n            key: \"hb8ula\"\n        }\n    ],\n    [\n        \"rect\",\n        {\n            width: \"16\",\n            height: \"12\",\n            x: \"4\",\n            y: \"8\",\n            rx: \"2\",\n            key: \"enze0r\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M2 14h2\",\n            key: \"vft8re\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M20 14h2\",\n            key: \"4cs60a\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M15 13v2\",\n            key: \"1xurst\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M9 13v2\",\n            key: \"rq6x2g\"\n        }\n    ]\n]);\n //# sourceMappingURL=bot.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYm90LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsTUFBTUMsZ0VBQWdCQSxDQUFDLE9BQU87SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBYUMsS0FBSztRQUFBO0tBQVU7SUFDMUM7UUFBQztRQUFRO1lBQUVDLE9BQU87WUFBTUMsUUFBUTtZQUFNQyxHQUFHO1lBQUtDLEdBQUc7WUFBS0MsSUFBSTtZQUFLTCxLQUFLO1FBQUE7S0FBVTtJQUM5RTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFXQyxLQUFLO1FBQUE7S0FBVTtJQUN4QztRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFZQyxLQUFLO1FBQUE7S0FBVTtJQUN6QztRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFZQyxLQUFLO1FBQUE7S0FBVTtJQUN6QztRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFXQyxLQUFLO1FBQUE7S0FBVTtDQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2JvdC50cz82OGJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQm90XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVElnT0ZZMFNEZ2lJQzgrQ2lBZ1BISmxZM1FnZDJsa2RHZzlJakUySWlCb1pXbG5hSFE5SWpFeUlpQjRQU0kwSWlCNVBTSTRJaUJ5ZUQwaU1pSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1pQXhOR2d5SWlBdlBnb2dJRHh3WVhSb0lHUTlJazB5TUNBeE5HZ3lJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMHhOU0F4TTNZeUlpQXZQZ29nSUR4d1lYUm9JR1E5SWswNUlERXpkaklpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYm90XG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgQm90ID0gY3JlYXRlTHVjaWRlSWNvbignQm90JywgW1xuICBbJ3BhdGgnLCB7IGQ6ICdNMTIgOFY0SDgnLCBrZXk6ICdoYjh1bGEnIH1dLFxuICBbJ3JlY3QnLCB7IHdpZHRoOiAnMTYnLCBoZWlnaHQ6ICcxMicsIHg6ICc0JywgeTogJzgnLCByeDogJzInLCBrZXk6ICdlbnplMHInIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMiAxNGgyJywga2V5OiAndmZ0OHJlJyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTIwIDE0aDInLCBrZXk6ICc0Y3M2MGEnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMTUgMTN2MicsIGtleTogJzF4dXJzdCcgfV0sXG4gIFsncGF0aCcsIHsgZDogJ005IDEzdjInLCBrZXk6ICdycTZ4MmcnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IEJvdDtcbiJdLCJuYW1lcyI6WyJCb3QiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJyeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/bot.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/loader-circle.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LoaderCircle; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst LoaderCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"LoaderCircle\", [\n    [\n        \"path\",\n        {\n            d: \"M21 12a9 9 0 1 1-6.219-8.56\",\n            key: \"13zald\"\n        }\n    ]\n]);\n //# sourceMappingURL=loader-circle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9hZGVyLWNpcmNsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLGVBQWVDLGdFQUFnQkEsQ0FBQyxnQkFBZ0I7SUFDcEQ7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBK0JDLEtBQUs7UUFBQTtLQUFVO0NBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvbG9hZGVyLWNpcmNsZS50cz8xMjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgTG9hZGVyQ2lyY2xlXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NakVnTVRKaE9TQTVJREFnTVNBeExUWXVNakU1TFRndU5UWWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9sb2FkZXItY2lyY2xlXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgTG9hZGVyQ2lyY2xlID0gY3JlYXRlTHVjaWRlSWNvbignTG9hZGVyQ2lyY2xlJywgW1xuICBbJ3BhdGgnLCB7IGQ6ICdNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYnLCBrZXk6ICcxM3phbGQnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IExvYWRlckNpcmNsZTtcbiJdLCJuYW1lcyI6WyJMb2FkZXJDaXJjbGUiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/menu.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Menu; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Menu = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Menu\", [\n    [\n        \"line\",\n        {\n            x1: \"4\",\n            x2: \"20\",\n            y1: \"12\",\n            y2: \"12\",\n            key: \"1e0a9i\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"4\",\n            x2: \"20\",\n            y1: \"6\",\n            y2: \"6\",\n            key: \"1owob3\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"4\",\n            x2: \"20\",\n            y1: \"18\",\n            y2: \"18\",\n            key: \"yk5zj1\"\n        }\n    ]\n]);\n //# sourceMappingURL=menu.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWVudS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLE9BQU9DLGdFQUFnQkEsQ0FBQyxRQUFRO0lBQ3BDO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLEtBQUs7UUFBQTtLQUFVO0lBQ2pFO1FBQUM7UUFBUTtZQUFFSixJQUFJO1lBQUtDLElBQUk7WUFBTUMsSUFBSTtZQUFLQyxJQUFJO1lBQUtDLEtBQUs7UUFBQTtLQUFVO0lBQy9EO1FBQUM7UUFBUTtZQUFFSixJQUFJO1lBQUtDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLEtBQUs7UUFBQTtLQUFVO0NBQ2xFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvbWVudS50cz81OTkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgTWVudVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4YkdsdVpTQjRNVDBpTkNJZ2VESTlJakl3SWlCNU1UMGlNVElpSUhreVBTSXhNaUlnTHo0S0lDQThiR2x1WlNCNE1UMGlOQ0lnZURJOUlqSXdJaUI1TVQwaU5pSWdlVEk5SWpZaUlDOCtDaUFnUEd4cGJtVWdlREU5SWpRaUlIZ3lQU0l5TUNJZ2VURTlJakU0SWlCNU1qMGlNVGdpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvbWVudVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IE1lbnUgPSBjcmVhdGVMdWNpZGVJY29uKCdNZW51JywgW1xuICBbJ2xpbmUnLCB7IHgxOiAnNCcsIHgyOiAnMjAnLCB5MTogJzEyJywgeTI6ICcxMicsIGtleTogJzFlMGE5aScgfV0sXG4gIFsnbGluZScsIHsgeDE6ICc0JywgeDI6ICcyMCcsIHkxOiAnNicsIHkyOiAnNicsIGtleTogJzFvd29iMycgfV0sXG4gIFsnbGluZScsIHsgeDE6ICc0JywgeDI6ICcyMCcsIHkxOiAnMTgnLCB5MjogJzE4Jywga2V5OiAneWs1emoxJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBNZW51O1xuIl0sIm5hbWVzIjpbIk1lbnUiLCJjcmVhdGVMdWNpZGVJY29uIiwieDEiLCJ4MiIsInkxIiwieTIiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mic-off.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MicOff; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst MicOff = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"MicOff\", [\n    [\n        \"line\",\n        {\n            x1: \"2\",\n            x2: \"22\",\n            y1: \"2\",\n            y2: \"22\",\n            key: \"a6p6uj\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M18.89 13.23A7.12 7.12 0 0 0 19 12v-2\",\n            key: \"80xlxr\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M5 10v2a7 7 0 0 0 12 5\",\n            key: \"p2k8kg\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M15 9.34V5a3 3 0 0 0-5.68-1.33\",\n            key: \"1gzdoj\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M9 9v3a3 3 0 0 0 5.12 2.12\",\n            key: \"r2i35w\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12\",\n            y1: \"19\",\n            y2: \"22\",\n            key: \"x3vr5v\"\n        }\n    ]\n]);\n //# sourceMappingURL=mic-off.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWljLW9mZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLFNBQVNDLGdFQUFnQkEsQ0FBQyxVQUFVO0lBQ3hDO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsSUFBSTtZQUFLQyxJQUFJO1lBQU1DLEtBQUs7UUFBQTtLQUFVO0lBQ2hFO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQXlDRCxLQUFLO1FBQUE7S0FBVTtJQUN0RTtRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUEwQkQsS0FBSztRQUFBO0tBQVU7SUFDdkQ7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBa0NELEtBQUs7UUFBQTtLQUFVO0lBQy9EO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQThCRCxLQUFLO1FBQUE7S0FBVTtJQUMzRDtRQUFDO1FBQVE7WUFBRUosSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxLQUFLO1FBQUE7S0FBVTtDQUNuRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL21pYy1vZmYudHM/ODA3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIE1pY09mZlxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4YkdsdVpTQjRNVDBpTWlJZ2VESTlJakl5SWlCNU1UMGlNaUlnZVRJOUlqSXlJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMHhPQzQ0T1NBeE15NHlNMEUzTGpFeUlEY3VNVElnTUNBd0lEQWdNVGtnTVRKMkxUSWlJQzgrQ2lBZ1BIQmhkR2dnWkQwaVRUVWdNVEIyTW1FM0lEY2dNQ0F3SURBZ01USWdOU0lnTHo0S0lDQThjR0YwYUNCa1BTSk5NVFVnT1M0ek5GWTFZVE1nTXlBd0lEQWdNQzAxTGpZNExURXVNek1pSUM4K0NpQWdQSEJoZEdnZ1pEMGlUVGtnT1hZellUTWdNeUF3SURBZ01DQTFMakV5SURJdU1USWlJQzgrQ2lBZ1BHeHBibVVnZURFOUlqRXlJaUI0TWowaU1USWlJSGt4UFNJeE9TSWdlVEk5SWpJeUlpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL21pYy1vZmZcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBNaWNPZmYgPSBjcmVhdGVMdWNpZGVJY29uKCdNaWNPZmYnLCBbXG4gIFsnbGluZScsIHsgeDE6ICcyJywgeDI6ICcyMicsIHkxOiAnMicsIHkyOiAnMjInLCBrZXk6ICdhNnA2dWonIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMTguODkgMTMuMjNBNy4xMiA3LjEyIDAgMCAwIDE5IDEydi0yJywga2V5OiAnODB4bHhyJyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTUgMTB2MmE3IDcgMCAwIDAgMTIgNScsIGtleTogJ3AyazhrZycgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xNSA5LjM0VjVhMyAzIDAgMCAwLTUuNjgtMS4zMycsIGtleTogJzFnemRvaicgfV0sXG4gIFsncGF0aCcsIHsgZDogJ005IDl2M2EzIDMgMCAwIDAgNS4xMiAyLjEyJywga2V5OiAncjJpMzV3JyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzEyJywgeDI6ICcxMicsIHkxOiAnMTknLCB5MjogJzIyJywga2V5OiAneDN2cjV2JyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBNaWNPZmY7XG4iXSwibmFtZXMiOlsiTWljT2ZmIiwiY3JlYXRlTHVjaWRlSWNvbiIsIngxIiwieDIiLCJ5MSIsInkyIiwia2V5IiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mic.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Mic; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Mic = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Mic\", [\n    [\n        \"path\",\n        {\n            d: \"M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\",\n            key: \"131961\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19 10v2a7 7 0 0 1-14 0v-2\",\n            key: \"1vc78b\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12\",\n            y1: \"19\",\n            y2: \"22\",\n            key: \"x3vr5v\"\n        }\n    ]\n]);\n //# sourceMappingURL=mic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsTUFBTUMsZ0VBQWdCQSxDQUFDLE9BQU87SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBd0RDLEtBQUs7UUFBQTtLQUFVO0lBQ3JGO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQThCQyxLQUFLO1FBQUE7S0FBVTtJQUMzRDtRQUFDO1FBQVE7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsSUFBSTtZQUFNSixLQUFLO1FBQUE7S0FBVTtDQUNuRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL21pYy50cz8xMGJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgTWljXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVElnTW1FeklETWdNQ0F3SURBdE15QXpkamRoTXlBeklEQWdNQ0F3SURZZ01GWTFZVE1nTXlBd0lEQWdNQzB6TFROYUlpQXZQZ29nSUR4d1lYUm9JR1E5SWsweE9TQXhNSFl5WVRjZ055QXdJREFnTVMweE5DQXdkaTB5SWlBdlBnb2dJRHhzYVc1bElIZ3hQU0l4TWlJZ2VESTlJakV5SWlCNU1UMGlNVGtpSUhreVBTSXlNaUlnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvbWljXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgTWljID0gY3JlYXRlTHVjaWRlSWNvbignTWljJywgW1xuICBbJ3BhdGgnLCB7IGQ6ICdNMTIgMmEzIDMgMCAwIDAtMyAzdjdhMyAzIDAgMCAwIDYgMFY1YTMgMyAwIDAgMC0zLTNaJywga2V5OiAnMTMxOTYxJyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTE5IDEwdjJhNyA3IDAgMCAxLTE0IDB2LTInLCBrZXk6ICcxdmM3OGInIH1dLFxuICBbJ2xpbmUnLCB7IHgxOiAnMTInLCB4MjogJzEyJywgeTE6ICcxOScsIHkyOiAnMjInLCBrZXk6ICd4M3ZyNXYnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1pYztcbiJdLCJuYW1lcyI6WyJNaWMiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSIsIngxIiwieDIiLCJ5MSIsInkyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone-off.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/phone-off.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PhoneOff; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst PhoneOff = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"PhoneOff\", [\n    [\n        \"path\",\n        {\n            d: \"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\",\n            key: \"z86iuo\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"22\",\n            x2: \"2\",\n            y1: \"2\",\n            y2: \"22\",\n            key: \"11kh81\"\n        }\n    ]\n]);\n //# sourceMappingURL=phone-off.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcGhvbmUtb2ZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsV0FBV0MsZ0VBQWdCQSxDQUFDLFlBQVk7SUFDNUM7UUFDRTtRQUNBO1lBQ0VDLEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Y7SUFDQTtRQUFDO1FBQVE7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQUtDLElBQUk7WUFBS0MsSUFBSTtZQUFNSixLQUFLO1FBQUE7S0FBVTtDQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL3Bob25lLW9mZi50cz9hZDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgUGhvbmVPZmZcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1UQXVOamdnTVRNdU16RmhNVFlnTVRZZ01DQXdJREFnTXk0ME1TQXlMalpzTVM0eU55MHhMakkzWVRJZ01pQXdJREFnTVNBeUxqRXhMUzQwTlNBeE1pNDROQ0F4TWk0NE5DQXdJREFnTUNBeUxqZ3hMamNnTWlBeUlEQWdNQ0F4SURFdU56SWdNbll6WVRJZ01pQXdJREFnTVMweUxqRTRJRElnTVRrdU56a2dNVGt1TnprZ01DQXdJREV0T0M0Mk15MHpMakEzSURFNUxqUXlJREU1TGpReUlEQWdNQ0F4TFRNdU16TXRNaTQyTjIwdE1pNDJOeTB6TGpNMFlURTVMamM1SURFNUxqYzVJREFnTUNBeExUTXVNRGN0T0M0Mk0wRXlJRElnTUNBd0lERWdOQzR4TVNBeWFETmhNaUF5SURBZ01DQXhJRElnTVM0M01pQXhNaTQ0TkNBeE1pNDROQ0F3SURBZ01DQXVOeUF5TGpneElESWdNaUF3SURBZ01TMHVORFVnTWk0eE1VdzRMakE1SURrdU9URWlJQzgrQ2lBZ1BHeHBibVVnZURFOUlqSXlJaUI0TWowaU1pSWdlVEU5SWpJaUlIa3lQU0l5TWlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3Bob25lLW9mZlxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFBob25lT2ZmID0gY3JlYXRlTHVjaWRlSWNvbignUGhvbmVPZmYnLCBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xMC42OCAxMy4zMWExNiAxNiAwIDAgMCAzLjQxIDIuNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuNyAyIDIgMCAwIDEgMS43MiAydjNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNDIgMTkuNDIgMCAwIDEtMy4zMy0yLjY3bS0yLjY3LTMuMzRhMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjYzQTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MScsXG4gICAgICBrZXk6ICd6ODZpdW8nLFxuICAgIH0sXG4gIF0sXG4gIFsnbGluZScsIHsgeDE6ICcyMicsIHgyOiAnMicsIHkxOiAnMicsIHkyOiAnMjInLCBrZXk6ICcxMWtoODEnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBob25lT2ZmO1xuIl0sIm5hbWVzIjpbIlBob25lT2ZmIiwiY3JlYXRlTHVjaWRlSWNvbiIsImQiLCJrZXkiLCJ4MSIsIngyIiwieTEiLCJ5MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone-off.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/phone.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Phone; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Phone = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Phone\", [\n    [\n        \"path\",\n        {\n            d: \"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\",\n            key: \"foiqr5\"\n        }\n    ]\n]);\n //# sourceMappingURL=phone.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcGhvbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxRQUFRQyxnRUFBZ0JBLENBQUMsU0FBUztJQUN0QztRQUNFO1FBQ0E7WUFDRUMsR0FBRztZQUNIQyxLQUFLO1FBQ1A7S0FDRjtDQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvcGhvbmUudHM/ZmZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFBob25lXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NaklnTVRZdU9USjJNMkV5SURJZ01DQXdJREV0TWk0eE9DQXlJREU1TGpjNUlERTVMamM1SURBZ01DQXhMVGd1TmpNdE15NHdOeUF4T1M0MUlERTVMalVnTUNBd0lERXROaTAySURFNUxqYzVJREU1TGpjNUlEQWdNQ0F4TFRNdU1EY3RPQzQyTjBFeUlESWdNQ0F3SURFZ05DNHhNU0F5YUROaE1pQXlJREFnTUNBeElESWdNUzQzTWlBeE1pNDROQ0F4TWk0NE5DQXdJREFnTUNBdU55QXlMamd4SURJZ01pQXdJREFnTVMwdU5EVWdNaTR4TVV3NExqQTVJRGt1T1RGaE1UWWdNVFlnTUNBd0lEQWdOaUEyYkRFdU1qY3RNUzR5TjJFeUlESWdNQ0F3SURFZ01pNHhNUzB1TkRVZ01USXVPRFFnTVRJdU9EUWdNQ0F3SURBZ01pNDRNUzQzUVRJZ01pQXdJREFnTVNBeU1pQXhOaTQ1TW5vaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3Bob25lXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgUGhvbmUgPSBjcmVhdGVMdWNpZGVJY29uKCdQaG9uZScsIFtcbiAgW1xuICAgICdwYXRoJyxcbiAgICB7XG4gICAgICBkOiAnTTIyIDE2LjkydjNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNSAxOS41IDAgMCAxLTYtNiAxOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjdBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxYTE2IDE2IDAgMCAwIDYgNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuN0EyIDIgMCAwIDEgMjIgMTYuOTJ6JyxcbiAgICAgIGtleTogJ2ZvaXFyNScsXG4gICAgfSxcbiAgXSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBQaG9uZTtcbiJdLCJuYW1lcyI6WyJQaG9uZSIsImNyZWF0ZUx1Y2lkZUljb24iLCJkIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/search.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/search.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Search; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Search = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Search\", [\n    [\n        \"circle\",\n        {\n            cx: \"11\",\n            cy: \"11\",\n            r: \"8\",\n            key: \"4ej97u\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m21 21-4.3-4.3\",\n            key: \"1qie3q\"\n        }\n    ]\n]);\n //# sourceMappingURL=search.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2VhcmNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsU0FBU0MsZ0VBQWdCQSxDQUFDLFVBQVU7SUFDeEM7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxHQUFHO1lBQUtDLEtBQUs7UUFBQTtLQUFVO0lBQ3hEO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQWtCRCxLQUFLO1FBQUE7S0FBVTtDQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL3NlYXJjaC50cz9kMzI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgU2VhcmNoXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThZMmx5WTJ4bElHTjRQU0l4TVNJZ1kzazlJakV4SWlCeVBTSTRJaUF2UGdvZ0lEeHdZWFJvSUdROUltMHlNU0F5TVMwMExqTXROQzR6SWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvc2VhcmNoXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgU2VhcmNoID0gY3JlYXRlTHVjaWRlSWNvbignU2VhcmNoJywgW1xuICBbJ2NpcmNsZScsIHsgY3g6ICcxMScsIGN5OiAnMTEnLCByOiAnOCcsIGtleTogJzRlajk3dScgfV0sXG4gIFsncGF0aCcsIHsgZDogJ20yMSAyMS00LjMtNC4zJywga2V5OiAnMXFpZTNxJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2g7XG4iXSwibmFtZXMiOlsiU2VhcmNoIiwiY3JlYXRlTHVjaWRlSWNvbiIsImN4IiwiY3kiLCJyIiwia2V5IiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/search.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/settings.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Settings; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Settings = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Settings\", [\n    [\n        \"path\",\n        {\n            d: \"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z\",\n            key: \"1qme2f\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"3\",\n            key: \"1v7zrd\"\n        }\n    ]\n]);\n //# sourceMappingURL=settings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxXQUFXQyxnRUFBZ0JBLENBQUMsWUFBWTtJQUM1QztRQUNFO1FBQ0E7WUFDRUMsR0FBRztZQUNIQyxLQUFLO1FBQ1A7S0FDRjtJQUNBO1FBQUM7UUFBVTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsR0FBRztZQUFLSCxLQUFLO1FBQUE7S0FBVTtDQUN6RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL3NldHRpbmdzLnRzP2E4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBTZXR0aW5nc1xuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRJdU1qSWdNbWd0TGpRMFlUSWdNaUF3SURBZ01DMHlJREoyTGpFNFlUSWdNaUF3SURBZ01TMHhJREV1TnpOc0xTNDBNeTR5TldFeUlESWdNQ0F3SURFdE1pQXdiQzB1TVRVdExqQTRZVElnTWlBd0lEQWdNQzB5TGpjekxqY3piQzB1TWpJdU16aGhNaUF5SURBZ01DQXdJQzQzTXlBeUxqY3piQzR4TlM0eFlUSWdNaUF3SURBZ01TQXhJREV1TnpKMkxqVXhZVElnTWlBd0lEQWdNUzB4SURFdU56UnNMUzR4TlM0d09XRXlJRElnTUNBd0lEQXRMamN6SURJdU56TnNMakl5TGpNNFlUSWdNaUF3SURBZ01DQXlMamN6TGpjemJDNHhOUzB1TURoaE1pQXlJREFnTUNBeElESWdNR3d1TkRNdU1qVmhNaUF5SURBZ01DQXhJREVnTVM0M00xWXlNR0V5SURJZ01DQXdJREFnTWlBeWFDNDBOR0V5SURJZ01DQXdJREFnTWkweWRpMHVNVGhoTWlBeUlEQWdNQ0F4SURFdE1TNDNNMnd1TkRNdExqSTFZVElnTWlBd0lEQWdNU0F5SURCc0xqRTFMakE0WVRJZ01pQXdJREFnTUNBeUxqY3pMUzQzTTJ3dU1qSXRMak01WVRJZ01pQXdJREFnTUMwdU56TXRNaTQzTTJ3dExqRTFMUzR3T0dFeUlESWdNQ0F3SURFdE1TMHhMamMwZGkwdU5XRXlJRElnTUNBd0lERWdNUzB4TGpjMGJDNHhOUzB1TURsaE1pQXlJREFnTUNBd0lDNDNNeTB5TGpjemJDMHVNakl0TGpNNFlUSWdNaUF3SURBZ01DMHlMamN6TFM0M00yd3RMakUxTGpBNFlUSWdNaUF3SURBZ01TMHlJREJzTFM0ME15MHVNalZoTWlBeUlEQWdNQ0F4TFRFdE1TNDNNMVkwWVRJZ01pQXdJREFnTUMweUxUSjZJaUF2UGdvZ0lEeGphWEpqYkdVZ1kzZzlJakV5SWlCamVUMGlNVElpSUhJOUlqTWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9zZXR0aW5nc1xuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFNldHRpbmdzID0gY3JlYXRlTHVjaWRlSWNvbignU2V0dGluZ3MnLCBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xMi4yMiAyaC0uNDRhMiAyIDAgMCAwLTIgMnYuMThhMiAyIDAgMCAxLTEgMS43M2wtLjQzLjI1YTIgMiAwIDAgMS0yIDBsLS4xNS0uMDhhMiAyIDAgMCAwLTIuNzMuNzNsLS4yMi4zOGEyIDIgMCAwIDAgLjczIDIuNzNsLjE1LjFhMiAyIDAgMCAxIDEgMS43MnYuNTFhMiAyIDAgMCAxLTEgMS43NGwtLjE1LjA5YTIgMiAwIDAgMC0uNzMgMi43M2wuMjIuMzhhMiAyIDAgMCAwIDIuNzMuNzNsLjE1LS4wOGEyIDIgMCAwIDEgMiAwbC40My4yNWEyIDIgMCAwIDEgMSAxLjczVjIwYTIgMiAwIDAgMCAyIDJoLjQ0YTIgMiAwIDAgMCAyLTJ2LS4xOGEyIDIgMCAwIDEgMS0xLjczbC40My0uMjVhMiAyIDAgMCAxIDIgMGwuMTUuMDhhMiAyIDAgMCAwIDIuNzMtLjczbC4yMi0uMzlhMiAyIDAgMCAwLS43My0yLjczbC0uMTUtLjA4YTIgMiAwIDAgMS0xLTEuNzR2LS41YTIgMiAwIDAgMSAxLTEuNzRsLjE1LS4wOWEyIDIgMCAwIDAgLjczLTIuNzNsLS4yMi0uMzhhMiAyIDAgMCAwLTIuNzMtLjczbC0uMTUuMDhhMiAyIDAgMCAxLTIgMGwtLjQzLS4yNWEyIDIgMCAwIDEtMS0xLjczVjRhMiAyIDAgMCAwLTItMnonLFxuICAgICAga2V5OiAnMXFtZTJmJyxcbiAgICB9LFxuICBdLFxuICBbJ2NpcmNsZScsIHsgY3g6ICcxMicsIGN5OiAnMTInLCByOiAnMycsIGtleTogJzF2N3pyZCcgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0dGluZ3M7XG4iXSwibmFtZXMiOlsiU2V0dGluZ3MiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSIsImN4IiwiY3kiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/sparkles.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sparkles; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Sparkles = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Sparkles\", [\n    [\n        \"path\",\n        {\n            d: \"M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z\",\n            key: \"4pj2yx\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M20 3v4\",\n            key: \"1olli1\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M22 5h-4\",\n            key: \"1gvqau\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M4 17v2\",\n            key: \"vumght\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M5 18H3\",\n            key: \"zchphs\"\n        }\n    ]\n]);\n //# sourceMappingURL=sparkles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc3BhcmtsZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxXQUFXQyxnRUFBZ0JBLENBQUMsWUFBWTtJQUM1QztRQUNFO1FBQ0E7WUFDRUMsR0FBRztZQUNIQyxLQUFLO1FBQ1A7S0FDRjtJQUNBO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVdDLEtBQUs7UUFBQTtLQUFVO0lBQ3hDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVlDLEtBQUs7UUFBQTtLQUFVO0lBQ3pDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVdDLEtBQUs7UUFBQTtLQUFVO0lBQ3hDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVdDLEtBQUs7UUFBQTtLQUFVO0NBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvc3BhcmtsZXMudHM/N2ZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFNwYXJrbGVzXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5PUzQ1TXpjZ01UVXVOVUV5SURJZ01DQXdJREFnT0M0MUlERTBMakEyTTJ3dE5pNHhNelV0TVM0MU9ESmhMalV1TlNBd0lEQWdNU0F3TFM0NU5qSk1PQzQxSURrdU9UTTJRVElnTWlBd0lEQWdNQ0E1TGprek55QTRMalZzTVM0MU9ESXROaTR4TXpWaExqVXVOU0F3SURBZ01TQXVPVFl6SURCTU1UUXVNRFl6SURndU5VRXlJRElnTUNBd0lEQWdNVFV1TlNBNUxqa3pOMncyTGpFek5TQXhMalU0TVdFdU5TNDFJREFnTUNBeElEQWdMamsyTkV3eE5TNDFJREUwTGpBMk0yRXlJRElnTUNBd0lEQXRNUzQwTXpjZ01TNDBNemRzTFRFdU5UZ3lJRFl1TVRNMVlTNDFMalVnTUNBd0lERXRMamsyTXlBd2VpSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1qQWdNM1kwSWlBdlBnb2dJRHh3WVhSb0lHUTlJazB5TWlBMWFDMDBJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMDBJREUzZGpJaUlDOCtDaUFnUEhCaGRHZ2daRDBpVFRVZ01UaElNeUlnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvc3BhcmtsZXNcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBTcGFya2xlcyA9IGNyZWF0ZUx1Y2lkZUljb24oJ1NwYXJrbGVzJywgW1xuICBbXG4gICAgJ3BhdGgnLFxuICAgIHtcbiAgICAgIGQ6ICdNOS45MzcgMTUuNUEyIDIgMCAwIDAgOC41IDE0LjA2M2wtNi4xMzUtMS41ODJhLjUuNSAwIDAgMSAwLS45NjJMOC41IDkuOTM2QTIgMiAwIDAgMCA5LjkzNyA4LjVsMS41ODItNi4xMzVhLjUuNSAwIDAgMSAuOTYzIDBMMTQuMDYzIDguNUEyIDIgMCAwIDAgMTUuNSA5LjkzN2w2LjEzNSAxLjU4MWEuNS41IDAgMCAxIDAgLjk2NEwxNS41IDE0LjA2M2EyIDIgMCAwIDAtMS40MzcgMS40MzdsLTEuNTgyIDYuMTM1YS41LjUgMCAwIDEtLjk2MyAweicsXG4gICAgICBrZXk6ICc0cGoyeXgnLFxuICAgIH0sXG4gIF0sXG4gIFsncGF0aCcsIHsgZDogJ00yMCAzdjQnLCBrZXk6ICcxb2xsaTEnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMjIgNWgtNCcsIGtleTogJzFndnFhdScgfV0sXG4gIFsncGF0aCcsIHsgZDogJ000IDE3djInLCBrZXk6ICd2dW1naHQnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNNSAxOEgzJywga2V5OiAnemNocGhzJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBTcGFya2xlcztcbiJdLCJuYW1lcyI6WyJTcGFya2xlcyIsImNyZWF0ZUx1Y2lkZUljb24iLCJkIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trash-2.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/trash-2.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Trash2; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Trash2 = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Trash2\", [\n    [\n        \"path\",\n        {\n            d: \"M3 6h18\",\n            key: \"d0wm0j\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6\",\n            key: \"4alrt4\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2\",\n            key: \"v07s0e\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"10\",\n            x2: \"10\",\n            y1: \"11\",\n            y2: \"17\",\n            key: \"1uufr5\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"14\",\n            x2: \"14\",\n            y1: \"11\",\n            y2: \"17\",\n            key: \"xtxkd\"\n        }\n    ]\n]);\n //# sourceMappingURL=trash-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdHJhc2gtMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLFNBQVNDLGdFQUFnQkEsQ0FBQyxVQUFVO0lBQ3hDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQVdDLEtBQUs7UUFBQTtLQUFVO0lBQ3hDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQXlDQyxLQUFLO1FBQUE7S0FBVTtJQUN0RTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFzQ0MsS0FBSztRQUFBO0tBQVU7SUFDbkU7UUFBQztRQUFRO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBTUosS0FBSztRQUFBO0tBQVU7SUFDbEU7UUFBQztRQUFRO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBTUosS0FBSztRQUFBO0tBQVM7Q0FDbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy90cmFzaC0yLnRzPzg1OTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBUcmFzaDJcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk15QTJhREU0SWlBdlBnb2dJRHh3WVhSb0lHUTlJazB4T1NBMmRqRTBZekFnTVMweElESXRNaUF5U0RkakxURWdNQzB5TFRFdE1pMHlWallpSUM4K0NpQWdQSEJoZEdnZ1pEMGlUVGdnTmxZMFl6QXRNU0F4TFRJZ01pMHlhRFJqTVNBd0lESWdNU0F5SURKMk1pSWdMejRLSUNBOGJHbHVaU0I0TVQwaU1UQWlJSGd5UFNJeE1DSWdlVEU5SWpFeElpQjVNajBpTVRjaUlDOCtDaUFnUEd4cGJtVWdlREU5SWpFMElpQjRNajBpTVRRaUlIa3hQU0l4TVNJZ2VUSTlJakUzSWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvdHJhc2gtMlxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFRyYXNoMiA9IGNyZWF0ZUx1Y2lkZUljb24oJ1RyYXNoMicsIFtcbiAgWydwYXRoJywgeyBkOiAnTTMgNmgxOCcsIGtleTogJ2Qwd20waicgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xOSA2djE0YzAgMS0xIDItMiAySDdjLTEgMC0yLTEtMi0yVjYnLCBrZXk6ICc0YWxydDQnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNOCA2VjRjMC0xIDEtMiAyLTJoNGMxIDAgMiAxIDIgMnYyJywga2V5OiAndjA3czBlJyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzEwJywgeDI6ICcxMCcsIHkxOiAnMTEnLCB5MjogJzE3Jywga2V5OiAnMXV1ZnI1JyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzE0JywgeDI6ICcxNCcsIHkxOiAnMTEnLCB5MjogJzE3Jywga2V5OiAneHR4a2QnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYXNoMjtcbiJdLCJuYW1lcyI6WyJUcmFzaDIiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSIsIngxIiwieDIiLCJ5MSIsInkyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trash-2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/users.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/users.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Users; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Users = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Users\", [\n    [\n        \"path\",\n        {\n            d: \"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2\",\n            key: \"1yyitq\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"9\",\n            cy: \"7\",\n            r: \"4\",\n            key: \"nufk8\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M22 21v-2a4 4 0 0 0-3-3.87\",\n            key: \"kshegd\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M16 3.13a4 4 0 0 1 0 7.75\",\n            key: \"1da9ce\"\n        }\n    ]\n]);\n //# sourceMappingURL=users.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdXNlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxRQUFRQyxnRUFBZ0JBLENBQUMsU0FBUztJQUN0QztRQUFDO1FBQVE7WUFBRUMsR0FBRztZQUE2Q0MsS0FBSztRQUFBO0tBQVU7SUFDMUU7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBS0MsSUFBSTtZQUFLQyxHQUFHO1lBQUtILEtBQUs7UUFBQTtLQUFTO0lBQ3JEO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQThCQyxLQUFLO1FBQUE7S0FBVTtJQUMzRDtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUE2QkMsS0FBSztRQUFBO0tBQVU7Q0FDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy91c2Vycy50cz9iMjVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgVXNlcnNcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1UWWdNakYyTFRKaE5DQTBJREFnTUNBd0xUUXRORWcyWVRRZ05DQXdJREFnTUMwMElEUjJNaUlnTHo0S0lDQThZMmx5WTJ4bElHTjRQU0k1SWlCamVUMGlOeUlnY2owaU5DSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1qSWdNakYyTFRKaE5DQTBJREFnTUNBd0xUTXRNeTQ0TnlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTVRZZ015NHhNMkUwSURRZ01DQXdJREVnTUNBM0xqYzFJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy91c2Vyc1xuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFVzZXJzID0gY3JlYXRlTHVjaWRlSWNvbignVXNlcnMnLCBbXG4gIFsncGF0aCcsIHsgZDogJ00xNiAyMXYtMmE0IDQgMCAwIDAtNC00SDZhNCA0IDAgMCAwLTQgNHYyJywga2V5OiAnMXl5aXRxJyB9XSxcbiAgWydjaXJjbGUnLCB7IGN4OiAnOScsIGN5OiAnNycsIHI6ICc0Jywga2V5OiAnbnVmazgnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMjIgMjF2LTJhNCA0IDAgMCAwLTMtMy44NycsIGtleTogJ2tzaGVnZCcgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xNiAzLjEzYTQgNCAwIDAgMSAwIDcuNzUnLCBrZXk6ICcxZGE5Y2UnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFVzZXJzO1xuIl0sIm5hbWVzIjpbIlVzZXJzIiwiY3JlYXRlTHVjaWRlSWNvbiIsImQiLCJrZXkiLCJjeCIsImN5IiwiciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/users.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/volume-2.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Volume2; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Volume2 = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Volume2\", [\n    [\n        \"polygon\",\n        {\n            points: \"11 5 6 9 2 9 2 15 6 15 11 19 11 5\",\n            key: \"16drj5\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M15.54 8.46a5 5 0 0 1 0 7.07\",\n            key: \"ltjumu\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19.07 4.93a10 10 0 0 1 0 14.14\",\n            key: \"1kegas\"\n        }\n    ]\n]);\n //# sourceMappingURL=volume-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdm9sdW1lLTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxVQUFVQyxnRUFBZ0JBLENBQUMsV0FBVztJQUMxQztRQUFDO1FBQVc7WUFBRUMsUUFBUTtZQUFxQ0MsS0FBSztRQUFBO0tBQVU7SUFDMUU7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBZ0NELEtBQUs7UUFBQTtLQUFVO0lBQzdEO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQW1DRCxLQUFLO1FBQUE7S0FBVTtDQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL3ZvbHVtZS0yLnRzPzEyOWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBWb2x1bWUyXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjRzlzZVdkdmJpQndiMmx1ZEhNOUlqRXhJRFVnTmlBNUlESWdPU0F5SURFMUlEWWdNVFVnTVRFZ01Ua2dNVEVnTlNJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTVRVdU5UUWdPQzQwTm1FMUlEVWdNQ0F3SURFZ01DQTNMakEzSWlBdlBnb2dJRHh3WVhSb0lHUTlJazB4T1M0d055QTBMamt6WVRFd0lERXdJREFnTUNBeElEQWdNVFF1TVRRaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3ZvbHVtZS0yXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgVm9sdW1lMiA9IGNyZWF0ZUx1Y2lkZUljb24oJ1ZvbHVtZTInLCBbXG4gIFsncG9seWdvbicsIHsgcG9pbnRzOiAnMTEgNSA2IDkgMiA5IDIgMTUgNiAxNSAxMSAxOSAxMSA1Jywga2V5OiAnMTZkcmo1JyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTE1LjU0IDguNDZhNSA1IDAgMCAxIDAgNy4wNycsIGtleTogJ2x0anVtdScgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xOS4wNyA0LjkzYTEwIDEwIDAgMCAxIDAgMTQuMTQnLCBrZXk6ICcxa2VnYXMnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFZvbHVtZTI7XG4iXSwibmFtZXMiOlsiVm9sdW1lMiIsImNyZWF0ZUx1Y2lkZUljb24iLCJwb2ludHMiLCJrZXkiLCJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js":
/*!*******************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/x.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ X; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"X\", [\n    [\n        \"path\",\n        {\n            d: \"M18 6 6 18\",\n            key: \"1bl5f8\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m6 6 12 12\",\n            key: \"d8bk6v\"\n        }\n    ]\n]);\n //# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLElBQUlDLGdFQUFnQkEsQ0FBQyxLQUFLO0lBQzlCO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQWNDLEtBQUs7UUFBQTtLQUFVO0lBQzNDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWNDLEtBQUs7UUFBQTtLQUFVO0NBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMveC50cz9iYzM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgWFxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRnZ05pQTJJREU0SWlBdlBnb2dJRHh3WVhSb0lHUTlJbTAySURZZ01USWdNVElpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMveFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFggPSBjcmVhdGVMdWNpZGVJY29uKCdYJywgW1xuICBbJ3BhdGgnLCB7IGQ6ICdNMTggNiA2IDE4Jywga2V5OiAnMWJsNWY4JyB9XSxcbiAgWydwYXRoJywgeyBkOiAnbTYgNiAxMiAxMicsIGtleTogJ2Q4Yms2dicgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgWDtcbiJdLCJuYW1lcyI6WyJYIiwiY3JlYXRlTHVjaWRlSWNvbiIsImQiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.400.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && array.indexOf(className) === index;\n    }).join(\" \");\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBUWEsTUFBQUEsY0FBYyxDQUFDQyxTQUMxQkEsT0FBT0MsT0FBQSxDQUFRLHNCQUFzQixTQUFTQyxXQUFZO0FBc0IvQyxNQUFBQyxlQUFlO3FDQUEyQ0M7UUFBQUE7O1dBQ3JFQSxRQUNHQyxNQUFBLENBQU8sQ0FBQ0MsV0FBV0MsT0FBT0M7UUFDekIsT0FBT0MsUUFBUUgsY0FBY0UsTUFBTUUsT0FBQSxDQUFRSixlQUFlQztJQUM1RCxHQUNDSSxJQUFBLENBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NoYXJlZC9zcmMvdXRpbHMudHM/NjY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW1lbFRvUGFzY2FsIH0gZnJvbSAnLi91dGlsaXR5LXR5cGVzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8ga2ViYWIgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEga2ViYWJpemVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nOiBzdHJpbmcpID0+XG4gIHN0cmluZy5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBwYXNjYWwgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgcGFzY2FsaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvUGFzY2FsQ2FzZSA9IDxUIGV4dGVuZHMgc3RyaW5nPihzdHJpbmc6IFQpOiBDYW1lbFRvUGFzY2FsPFQ+ID0+IHtcbiAgY29uc3QgY2FtZWxDYXNlID0gc3RyaW5nLnJlcGxhY2UoL14oW0EtWl0pfFtcXHMtX10rKFxcdykvZywgKG1hdGNoLCBwMSwgcDIpID0+XG4gICAgcDIgPyBwMi50b1VwcGVyQ2FzZSgpIDogcDEudG9Mb3dlckNhc2UoKSxcbiAgKTtcblxuICByZXR1cm4gKGNhbWVsQ2FzZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsQ2FzZS5zbGljZSgxKSkgYXMgQ2FtZWxUb1Bhc2NhbDxUPjtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGNsYXNzZXMgaW50byBhIHNpbmdsZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBjbGFzc2VzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBvZiBjbGFzc2VzXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZUNsYXNzZXMgPSA8Q2xhc3NUeXBlID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbD4oLi4uY2xhc3NlczogQ2xhc3NUeXBlW10pID0+XG4gIGNsYXNzZXNcbiAgICAuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oY2xhc3NOYW1lKSAmJiBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4O1xuICAgIH0pXG4gICAgLmpvaW4oJyAnKTtcbiJdLCJuYW1lcyI6WyJ0b0tlYmFiQ2FzZSIsInN0cmluZyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsIm1lcmdlQ2xhc3NlcyIsImNsYXNzZXMiLCJmaWx0ZXIiLCJjbGFzc05hbWUiLCJpbmRleCIsImFycmF5IiwiQm9vbGVhbiIsImluZGV4T2YiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/*!********************************************!*\
  !*** ./node_modules/next/dist/api/link.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=link.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1Y7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/MWI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzBiODkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/MjMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9kMzEzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/constants.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_SUFFIX: function() {\n        return ACTION_SUFFIX;\n    },\n    APP_DIR_ALIAS: function() {\n        return APP_DIR_ALIAS;\n    },\n    CACHE_ONE_YEAR: function() {\n        return CACHE_ONE_YEAR;\n    },\n    DOT_NEXT_ALIAS: function() {\n        return DOT_NEXT_ALIAS;\n    },\n    ESLINT_DEFAULT_DIRS: function() {\n        return ESLINT_DEFAULT_DIRS;\n    },\n    GSP_NO_RETURNED_VALUE: function() {\n        return GSP_NO_RETURNED_VALUE;\n    },\n    GSSP_COMPONENT_MEMBER_ERROR: function() {\n        return GSSP_COMPONENT_MEMBER_ERROR;\n    },\n    GSSP_NO_RETURNED_VALUE: function() {\n        return GSSP_NO_RETURNED_VALUE;\n    },\n    INSTRUMENTATION_HOOK_FILENAME: function() {\n        return INSTRUMENTATION_HOOK_FILENAME;\n    },\n    MIDDLEWARE_FILENAME: function() {\n        return MIDDLEWARE_FILENAME;\n    },\n    MIDDLEWARE_LOCATION_REGEXP: function() {\n        return MIDDLEWARE_LOCATION_REGEXP;\n    },\n    NEXT_BODY_SUFFIX: function() {\n        return NEXT_BODY_SUFFIX;\n    },\n    NEXT_CACHE_IMPLICIT_TAG_ID: function() {\n        return NEXT_CACHE_IMPLICIT_TAG_ID;\n    },\n    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {\n        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;\n    },\n    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {\n        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;\n    },\n    NEXT_CACHE_SOFT_TAGS_HEADER: function() {\n        return NEXT_CACHE_SOFT_TAGS_HEADER;\n    },\n    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;\n    },\n    NEXT_CACHE_TAGS_HEADER: function() {\n        return NEXT_CACHE_TAGS_HEADER;\n    },\n    NEXT_CACHE_TAG_MAX_ITEMS: function() {\n        return NEXT_CACHE_TAG_MAX_ITEMS;\n    },\n    NEXT_CACHE_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_TAG_MAX_LENGTH;\n    },\n    NEXT_DATA_SUFFIX: function() {\n        return NEXT_DATA_SUFFIX;\n    },\n    NEXT_INTERCEPTION_MARKER_PREFIX: function() {\n        return NEXT_INTERCEPTION_MARKER_PREFIX;\n    },\n    NEXT_META_SUFFIX: function() {\n        return NEXT_META_SUFFIX;\n    },\n    NEXT_QUERY_PARAM_PREFIX: function() {\n        return NEXT_QUERY_PARAM_PREFIX;\n    },\n    NON_STANDARD_NODE_ENV: function() {\n        return NON_STANDARD_NODE_ENV;\n    },\n    PAGES_DIR_ALIAS: function() {\n        return PAGES_DIR_ALIAS;\n    },\n    PRERENDER_REVALIDATE_HEADER: function() {\n        return PRERENDER_REVALIDATE_HEADER;\n    },\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {\n        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;\n    },\n    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {\n        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;\n    },\n    ROOT_DIR_ALIAS: function() {\n        return ROOT_DIR_ALIAS;\n    },\n    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {\n        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;\n    },\n    RSC_ACTION_ENCRYPTION_ALIAS: function() {\n        return RSC_ACTION_ENCRYPTION_ALIAS;\n    },\n    RSC_ACTION_PROXY_ALIAS: function() {\n        return RSC_ACTION_PROXY_ALIAS;\n    },\n    RSC_ACTION_VALIDATE_ALIAS: function() {\n        return RSC_ACTION_VALIDATE_ALIAS;\n    },\n    RSC_MOD_REF_PROXY_ALIAS: function() {\n        return RSC_MOD_REF_PROXY_ALIAS;\n    },\n    RSC_PREFETCH_SUFFIX: function() {\n        return RSC_PREFETCH_SUFFIX;\n    },\n    RSC_SUFFIX: function() {\n        return RSC_SUFFIX;\n    },\n    SERVER_PROPS_EXPORT_ERROR: function() {\n        return SERVER_PROPS_EXPORT_ERROR;\n    },\n    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {\n        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;\n    },\n    SERVER_PROPS_SSG_CONFLICT: function() {\n        return SERVER_PROPS_SSG_CONFLICT;\n    },\n    SERVER_RUNTIME: function() {\n        return SERVER_RUNTIME;\n    },\n    SSG_FALLBACK_EXPORT_ERROR: function() {\n        return SSG_FALLBACK_EXPORT_ERROR;\n    },\n    SSG_GET_INITIAL_PROPS_CONFLICT: function() {\n        return SSG_GET_INITIAL_PROPS_CONFLICT;\n    },\n    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {\n        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;\n    },\n    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {\n        return UNSTABLE_REVALIDATE_RENAME_ERROR;\n    },\n    WEBPACK_LAYERS: function() {\n        return WEBPACK_LAYERS;\n    },\n    WEBPACK_RESOURCE_QUERIES: function() {\n        return WEBPACK_RESOURCE_QUERIES;\n    }\n});\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\nconst PRERENDER_REVALIDATE_HEADER = \"x-prerender-revalidate\";\nconst PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = \"x-prerender-revalidate-if-generated\";\nconst RSC_PREFETCH_SUFFIX = \".prefetch.rsc\";\nconst RSC_SUFFIX = \".rsc\";\nconst ACTION_SUFFIX = \".action\";\nconst NEXT_DATA_SUFFIX = \".json\";\nconst NEXT_META_SUFFIX = \".meta\";\nconst NEXT_BODY_SUFFIX = \".body\";\nconst NEXT_CACHE_TAGS_HEADER = \"x-next-cache-tags\";\nconst NEXT_CACHE_SOFT_TAGS_HEADER = \"x-next-cache-soft-tags\";\nconst NEXT_CACHE_REVALIDATED_TAGS_HEADER = \"x-next-revalidated-tags\";\nconst NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = \"x-next-revalidate-tag-token\";\nconst NEXT_CACHE_TAG_MAX_ITEMS = 128;\nconst NEXT_CACHE_TAG_MAX_LENGTH = 256;\nconst NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;\nconst NEXT_CACHE_IMPLICIT_TAG_ID = \"_N_T_\";\nconst CACHE_ONE_YEAR = 31536000;\nconst MIDDLEWARE_FILENAME = \"middleware\";\nconst MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;\nconst INSTRUMENTATION_HOOK_FILENAME = \"instrumentation\";\nconst PAGES_DIR_ALIAS = \"private-next-pages\";\nconst DOT_NEXT_ALIAS = \"private-dot-next\";\nconst ROOT_DIR_ALIAS = \"private-next-root-dir\";\nconst APP_DIR_ALIAS = \"private-next-app-dir\";\nconst RSC_MOD_REF_PROXY_ALIAS = \"private-next-rsc-mod-ref-proxy\";\nconst RSC_ACTION_VALIDATE_ALIAS = \"private-next-rsc-action-validate\";\nconst RSC_ACTION_PROXY_ALIAS = \"private-next-rsc-server-reference\";\nconst RSC_ACTION_ENCRYPTION_ALIAS = \"private-next-rsc-action-encryption\";\nconst RSC_ACTION_CLIENT_WRAPPER_ALIAS = \"private-next-rsc-action-client-wrapper\";\nconst PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;\nconst SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;\nconst SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;\nconst SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;\nconst STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;\nconst SERVER_PROPS_EXPORT_ERROR = `pages with \\`getServerSideProps\\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;\nconst GSP_NO_RETURNED_VALUE = \"Your `getStaticProps` function did not return an object. Did you forget to add a `return`?\";\nconst GSSP_NO_RETURNED_VALUE = \"Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?\";\nconst UNSTABLE_REVALIDATE_RENAME_ERROR = \"The `unstable_revalidate` property is available for general use.\\n\" + \"Please use `revalidate` instead.\";\nconst GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;\nconst NON_STANDARD_NODE_ENV = `You are using a non-standard \"NODE_ENV\" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;\nconst SSG_FALLBACK_EXPORT_ERROR = `Pages with \\`fallback\\` enabled in \\`getStaticPaths\\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;\nconst ESLINT_DEFAULT_DIRS = [\n    \"app\",\n    \"pages\",\n    \"components\",\n    \"lib\",\n    \"src\"\n];\nconst SERVER_RUNTIME = {\n    edge: \"edge\",\n    experimentalEdge: \"experimental-edge\",\n    nodejs: \"nodejs\"\n};\n/**\n * The names of the webpack layers. These layers are the primitives for the\n * webpack chunks.\n */ const WEBPACK_LAYERS_NAMES = {\n    /**\n   * The layer for the shared code between the client and server bundles.\n   */ shared: \"shared\",\n    /**\n   * React Server Components layer (rsc).\n   */ reactServerComponents: \"rsc\",\n    /**\n   * Server Side Rendering layer for app (ssr).\n   */ serverSideRendering: \"ssr\",\n    /**\n   * The browser client bundle layer for actions.\n   */ actionBrowser: \"action-browser\",\n    /**\n   * The layer for the API routes.\n   */ api: \"api\",\n    /**\n   * The layer for the middleware code.\n   */ middleware: \"middleware\",\n    /**\n   * The layer for the instrumentation hooks.\n   */ instrument: \"instrument\",\n    /**\n   * The layer for assets on the edge.\n   */ edgeAsset: \"edge-asset\",\n    /**\n   * The browser client bundle layer for App directory.\n   */ appPagesBrowser: \"app-pages-browser\",\n    /**\n   * The server bundle layer for metadata routes.\n   */ appMetadataRoute: \"app-metadata-route\",\n    /**\n   * The layer for the server bundle for App Route handlers.\n   */ appRouteHandler: \"app-route-handler\"\n};\nconst WEBPACK_LAYERS = {\n    ...WEBPACK_LAYERS_NAMES,\n    GROUP: {\n        serverOnly: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.appMetadataRoute,\n            WEBPACK_LAYERS_NAMES.appRouteHandler,\n            WEBPACK_LAYERS_NAMES.instrument\n        ],\n        clientOnly: [\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser\n        ],\n        nonClientServerTarget: [\n            // middleware and pages api\n            WEBPACK_LAYERS_NAMES.middleware,\n            WEBPACK_LAYERS_NAMES.api\n        ],\n        app: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.appMetadataRoute,\n            WEBPACK_LAYERS_NAMES.appRouteHandler,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\n            WEBPACK_LAYERS_NAMES.shared,\n            WEBPACK_LAYERS_NAMES.instrument\n        ]\n    }\n};\nconst WEBPACK_RESOURCE_QUERIES = {\n    edgeSSREntry: \"__next_edge_ssr_entry__\",\n    metadata: \"__next_metadata__\",\n    metadataRoute: \"__next_metadata_route__\",\n    metadataImageMeta: \"__next_metadata_image_meta__\"\n};\n\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FnREw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvY29uc3RhbnRzLmpzP2E1YzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQ1RJT05fU1VGRklYOiBudWxsLFxuICAgIEFQUF9ESVJfQUxJQVM6IG51bGwsXG4gICAgQ0FDSEVfT05FX1lFQVI6IG51bGwsXG4gICAgRE9UX05FWFRfQUxJQVM6IG51bGwsXG4gICAgRVNMSU5UX0RFRkFVTFRfRElSUzogbnVsbCxcbiAgICBHU1BfTk9fUkVUVVJORURfVkFMVUU6IG51bGwsXG4gICAgR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SOiBudWxsLFxuICAgIEdTU1BfTk9fUkVUVVJORURfVkFMVUU6IG51bGwsXG4gICAgSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU6IG51bGwsXG4gICAgTUlERExFV0FSRV9GSUxFTkFNRTogbnVsbCxcbiAgICBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDogbnVsbCxcbiAgICBORVhUX0JPRFlfU1VGRklYOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfUkVWQUxJREFURURfVEFHU19IRUFERVI6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9TT0ZUX1RBR1NfSEVBREVSOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfU09GVF9UQUdfTUFYX0xFTkdUSDogbnVsbCxcbiAgICBORVhUX0NBQ0hFX1RBR1NfSEVBREVSOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUzogbnVsbCxcbiAgICBORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIOiBudWxsLFxuICAgIE5FWFRfREFUQV9TVUZGSVg6IG51bGwsXG4gICAgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWDogbnVsbCxcbiAgICBORVhUX01FVEFfU1VGRklYOiBudWxsLFxuICAgIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYOiBudWxsLFxuICAgIE5PTl9TVEFOREFSRF9OT0RFX0VOVjogbnVsbCxcbiAgICBQQUdFU19ESVJfQUxJQVM6IG51bGwsXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSOiBudWxsLFxuICAgIFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUjogbnVsbCxcbiAgICBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1Q6IG51bGwsXG4gICAgUk9PVF9ESVJfQUxJQVM6IG51bGwsXG4gICAgUlNDX0FDVElPTl9DTElFTlRfV1JBUFBFUl9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVM6IG51bGwsXG4gICAgUlNDX0FDVElPTl9QUk9YWV9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTOiBudWxsLFxuICAgIFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTOiBudWxsLFxuICAgIFJTQ19QUkVGRVRDSF9TVUZGSVg6IG51bGwsXG4gICAgUlNDX1NVRkZJWDogbnVsbCxcbiAgICBTRVJWRVJfUFJPUFNfRVhQT1JUX0VSUk9SOiBudWxsLFxuICAgIFNFUlZFUl9QUk9QU19HRVRfSU5JVF9QUk9QU19DT05GTElDVDogbnVsbCxcbiAgICBTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUOiBudWxsLFxuICAgIFNFUlZFUl9SVU5USU1FOiBudWxsLFxuICAgIFNTR19GQUxMQkFDS19FWFBPUlRfRVJST1I6IG51bGwsXG4gICAgU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUOiBudWxsLFxuICAgIFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUjogbnVsbCxcbiAgICBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUjogbnVsbCxcbiAgICBXRUJQQUNLX0xBWUVSUzogbnVsbCxcbiAgICBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVM6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgQUNUSU9OX1NVRkZJWDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU1VGRklYO1xuICAgIH0sXG4gICAgQVBQX0RJUl9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBUFBfRElSX0FMSUFTO1xuICAgIH0sXG4gICAgQ0FDSEVfT05FX1lFQVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ0FDSEVfT05FX1lFQVI7XG4gICAgfSxcbiAgICBET1RfTkVYVF9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBET1RfTkVYVF9BTElBUztcbiAgICB9LFxuICAgIEVTTElOVF9ERUZBVUxUX0RJUlM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRVNMSU5UX0RFRkFVTFRfRElSUztcbiAgICB9LFxuICAgIEdTUF9OT19SRVRVUk5FRF9WQUxVRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBHU1BfTk9fUkVUVVJORURfVkFMVUU7XG4gICAgfSxcbiAgICBHU1NQX0NPTVBPTkVOVF9NRU1CRVJfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SO1xuICAgIH0sXG4gICAgR1NTUF9OT19SRVRVUk5FRF9WQUxVRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFO1xuICAgIH0sXG4gICAgSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU7XG4gICAgfSxcbiAgICBNSURETEVXQVJFX0ZJTEVOQU1FOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1JRERMRVdBUkVfRklMRU5BTUU7XG4gICAgfSxcbiAgICBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDtcbiAgICB9LFxuICAgIE5FWFRfQk9EWV9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9CT0RZX1NVRkZJWDtcbiAgICB9LFxuICAgIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1NPRlRfVEFHU19IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9TT0ZUX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfU09GVF9UQUdfTUFYX0xFTkdUSDtcbiAgICB9LFxuICAgIE5FWFRfQ0FDSEVfVEFHU19IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9UQUdTX0hFQURFUjtcbiAgICB9LFxuICAgIE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX0NBQ0hFX1RBR19NQVhfSVRFTVM7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEg7XG4gICAgfSxcbiAgICBORVhUX0RBVEFfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfREFUQV9TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVg7XG4gICAgfSxcbiAgICBORVhUX01FVEFfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfTUVUQV9TVUZGSVg7XG4gICAgfSxcbiAgICBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWDtcbiAgICB9LFxuICAgIE5PTl9TVEFOREFSRF9OT0RFX0VOVjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOT05fU1RBTkRBUkRfTk9ERV9FTlY7XG4gICAgfSxcbiAgICBQQUdFU19ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUEFHRVNfRElSX0FMSUFTO1xuICAgIH0sXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUjtcbiAgICB9LFxuICAgIFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQUkVSRU5ERVJfUkVWQUxJREFURV9PTkxZX0dFTkVSQVRFRF9IRUFERVI7XG4gICAgfSxcbiAgICBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUFVCTElDX0RJUl9NSURETEVXQVJFX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgUk9PVF9ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUk9PVF9ESVJfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX0FDVElPTl9FTkNSWVBUSU9OX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9QUk9YWV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1BST1hZX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9WQUxJREFURV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX01PRF9SRUZfUFJPWFlfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX01PRF9SRUZfUFJPWFlfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfUFJFRkVUQ0hfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19QUkVGRVRDSF9TVUZGSVg7XG4gICAgfSxcbiAgICBSU0NfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19TVUZGSVg7XG4gICAgfSxcbiAgICBTRVJWRVJfUFJPUFNfRVhQT1JUX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1I7XG4gICAgfSxcbiAgICBTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU0VSVkVSX1BST1BTX0dFVF9JTklUX1BST1BTX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgU0VSVkVSX1BST1BTX1NTR19DT05GTElDVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgU0VSVkVSX1JVTlRJTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU0VSVkVSX1JVTlRJTUU7XG4gICAgfSxcbiAgICBTU0dfRkFMTEJBQ0tfRVhQT1JUX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNTR19GQUxMQkFDS19FWFBPUlRfRVJST1I7XG4gICAgfSxcbiAgICBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUjtcbiAgICB9LFxuICAgIFVOU1RBQkxFX1JFVkFMSURBVEVfUkVOQU1FX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFVOU1RBQkxFX1JFVkFMSURBVEVfUkVOQU1FX0VSUk9SO1xuICAgIH0sXG4gICAgV0VCUEFDS19MQVlFUlM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gV0VCUEFDS19MQVlFUlM7XG4gICAgfSxcbiAgICBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTO1xuICAgIH1cbn0pO1xuY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSBcIm54dFBcIjtcbmNvbnN0IE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVggPSBcIm54dElcIjtcbmNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiA9IFwieC1wcmVyZW5kZXItcmV2YWxpZGF0ZVwiO1xuY29uc3QgUFJFUkVOREVSX1JFVkFMSURBVEVfT05MWV9HRU5FUkFURURfSEVBREVSID0gXCJ4LXByZXJlbmRlci1yZXZhbGlkYXRlLWlmLWdlbmVyYXRlZFwiO1xuY29uc3QgUlNDX1BSRUZFVENIX1NVRkZJWCA9IFwiLnByZWZldGNoLnJzY1wiO1xuY29uc3QgUlNDX1NVRkZJWCA9IFwiLnJzY1wiO1xuY29uc3QgQUNUSU9OX1NVRkZJWCA9IFwiLmFjdGlvblwiO1xuY29uc3QgTkVYVF9EQVRBX1NVRkZJWCA9IFwiLmpzb25cIjtcbmNvbnN0IE5FWFRfTUVUQV9TVUZGSVggPSBcIi5tZXRhXCI7XG5jb25zdCBORVhUX0JPRFlfU1VGRklYID0gXCIuYm9keVwiO1xuY29uc3QgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiA9IFwieC1uZXh0LWNhY2hlLXRhZ3NcIjtcbmNvbnN0IE5FWFRfQ0FDSEVfU09GVF9UQUdTX0hFQURFUiA9IFwieC1uZXh0LWNhY2hlLXNvZnQtdGFnc1wiO1xuY29uc3QgTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUiA9IFwieC1uZXh0LXJldmFsaWRhdGVkLXRhZ3NcIjtcbmNvbnN0IE5FWFRfQ0FDSEVfUkVWQUxJREFURV9UQUdfVE9LRU5fSEVBREVSID0gXCJ4LW5leHQtcmV2YWxpZGF0ZS10YWctdG9rZW5cIjtcbmNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUyA9IDEyODtcbmNvbnN0IE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEggPSAyNTY7XG5jb25zdCBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEggPSAxMDI0O1xuY29uc3QgTkVYVF9DQUNIRV9JTVBMSUNJVF9UQUdfSUQgPSBcIl9OX1RfXCI7XG5jb25zdCBDQUNIRV9PTkVfWUVBUiA9IDMxNTM2MDAwO1xuY29uc3QgTUlERExFV0FSRV9GSUxFTkFNRSA9IFwibWlkZGxld2FyZVwiO1xuY29uc3QgTUlERExFV0FSRV9MT0NBVElPTl9SRUdFWFAgPSBgKD86c3JjLyk/JHtNSURETEVXQVJFX0ZJTEVOQU1FfWA7XG5jb25zdCBJTlNUUlVNRU5UQVRJT05fSE9PS19GSUxFTkFNRSA9IFwiaW5zdHJ1bWVudGF0aW9uXCI7XG5jb25zdCBQQUdFU19ESVJfQUxJQVMgPSBcInByaXZhdGUtbmV4dC1wYWdlc1wiO1xuY29uc3QgRE9UX05FWFRfQUxJQVMgPSBcInByaXZhdGUtZG90LW5leHRcIjtcbmNvbnN0IFJPT1RfRElSX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcm9vdC1kaXJcIjtcbmNvbnN0IEFQUF9ESVJfQUxJQVMgPSBcInByaXZhdGUtbmV4dC1hcHAtZGlyXCI7XG5jb25zdCBSU0NfTU9EX1JFRl9QUk9YWV9BTElBUyA9IFwicHJpdmF0ZS1uZXh0LXJzYy1tb2QtcmVmLXByb3h5XCI7XG5jb25zdCBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTID0gXCJwcml2YXRlLW5leHQtcnNjLWFjdGlvbi12YWxpZGF0ZVwiO1xuY29uc3QgUlNDX0FDVElPTl9QUk9YWV9BTElBUyA9IFwicHJpdmF0ZS1uZXh0LXJzYy1zZXJ2ZXItcmVmZXJlbmNlXCI7XG5jb25zdCBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVMgPSBcInByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLWVuY3J5cHRpb25cIjtcbmNvbnN0IFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVMgPSBcInByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLWNsaWVudC13cmFwcGVyXCI7XG5jb25zdCBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgaGF2ZSBhICdfbmV4dCcgZm9sZGVyIGluc2lkZSBvZiB5b3VyIHB1YmxpYyBmb2xkZXIuIFRoaXMgY29uZmxpY3RzIHdpdGggdGhlIGludGVybmFsICcvX25leHQnIHJvdXRlLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wdWJsaWMtbmV4dC1mb2xkZXItY29uZmxpY3RgO1xuY29uc3QgU1NHX0dFVF9JTklUSUFMX1BST1BTX0NPTkZMSUNUID0gYFlvdSBjYW4gbm90IHVzZSBnZXRJbml0aWFsUHJvcHMgd2l0aCBnZXRTdGF0aWNQcm9wcy4gVG8gdXNlIFNTRywgcGxlYXNlIHJlbW92ZSB5b3VyIGdldEluaXRpYWxQcm9wc2A7XG5jb25zdCBTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldEluaXRpYWxQcm9wcyB3aXRoIGdldFNlcnZlclNpZGVQcm9wcy4gUGxlYXNlIHJlbW92ZSBnZXRJbml0aWFsUHJvcHMuYDtcbmNvbnN0IFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldFN0YXRpY1Byb3BzIG9yIGdldFN0YXRpY1BhdGhzIHdpdGggZ2V0U2VydmVyU2lkZVByb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIGdldFNlcnZlclNpZGVQcm9wc2A7XG5jb25zdCBTVEFUSUNfU1RBVFVTX1BBR0VfR0VUX0lOSVRJQUxfUFJPUFNfRVJST1IgPSBgY2FuIG5vdCBoYXZlIGdldEluaXRpYWxQcm9wcy9nZXRTZXJ2ZXJTaWRlUHJvcHMsIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLzQwNC1nZXQtaW5pdGlhbC1wcm9wc2A7XG5jb25zdCBTRVJWRVJfUFJPUFNfRVhQT1JUX0VSUk9SID0gYHBhZ2VzIHdpdGggXFxgZ2V0U2VydmVyU2lkZVByb3BzXFxgIGNhbiBub3QgYmUgZXhwb3J0ZWQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ3NzcC1leHBvcnRgO1xuY29uc3QgR1NQX05PX1JFVFVSTkVEX1ZBTFVFID0gXCJZb3VyIGBnZXRTdGF0aWNQcm9wc2AgZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhZGQgYSBgcmV0dXJuYD9cIjtcbmNvbnN0IEdTU1BfTk9fUkVUVVJORURfVkFMVUUgPSBcIllvdXIgYGdldFNlcnZlclNpZGVQcm9wc2AgZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhZGQgYSBgcmV0dXJuYD9cIjtcbmNvbnN0IFVOU1RBQkxFX1JFVkFMSURBVEVfUkVOQU1FX0VSUk9SID0gXCJUaGUgYHVuc3RhYmxlX3JldmFsaWRhdGVgIHByb3BlcnR5IGlzIGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXFxuXCIgKyBcIlBsZWFzZSB1c2UgYHJldmFsaWRhdGVgIGluc3RlYWQuXCI7XG5jb25zdCBHU1NQX0NPTVBPTkVOVF9NRU1CRVJfRVJST1IgPSBgY2FuIG5vdCBiZSBhdHRhY2hlZCB0byBhIHBhZ2UncyBjb21wb25lbnQgYW5kIG11c3QgYmUgZXhwb3J0ZWQgZnJvbSB0aGUgcGFnZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nc3NwLWNvbXBvbmVudC1tZW1iZXJgO1xuY29uc3QgTk9OX1NUQU5EQVJEX05PREVfRU5WID0gYFlvdSBhcmUgdXNpbmcgYSBub24tc3RhbmRhcmQgXCJOT0RFX0VOVlwiIHZhbHVlIGluIHlvdXIgZW52aXJvbm1lbnQuIFRoaXMgY3JlYXRlcyBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIHByb2plY3QgYW5kIGlzIHN0cm9uZ2x5IGFkdmlzZWQgYWdhaW5zdC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9ub24tc3RhbmRhcmQtbm9kZS1lbnZgO1xuY29uc3QgU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUiA9IGBQYWdlcyB3aXRoIFxcYGZhbGxiYWNrXFxgIGVuYWJsZWQgaW4gXFxgZ2V0U3RhdGljUGF0aHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zc2ctZmFsbGJhY2stdHJ1ZS1leHBvcnRgO1xuY29uc3QgRVNMSU5UX0RFRkFVTFRfRElSUyA9IFtcbiAgICBcImFwcFwiLFxuICAgIFwicGFnZXNcIixcbiAgICBcImNvbXBvbmVudHNcIixcbiAgICBcImxpYlwiLFxuICAgIFwic3JjXCJcbl07XG5jb25zdCBTRVJWRVJfUlVOVElNRSA9IHtcbiAgICBlZGdlOiBcImVkZ2VcIixcbiAgICBleHBlcmltZW50YWxFZGdlOiBcImV4cGVyaW1lbnRhbC1lZGdlXCIsXG4gICAgbm9kZWpzOiBcIm5vZGVqc1wiXG59O1xuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIHdlYnBhY2sgbGF5ZXJzLiBUaGVzZSBsYXllcnMgYXJlIHRoZSBwcmltaXRpdmVzIGZvciB0aGVcbiAqIHdlYnBhY2sgY2h1bmtzLlxuICovIGNvbnN0IFdFQlBBQ0tfTEFZRVJTX05BTUVTID0ge1xuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBzaGFyZWQgY29kZSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHNlcnZlciBidW5kbGVzLlxuICAgKi8gc2hhcmVkOiBcInNoYXJlZFwiLFxuICAgIC8qKlxuICAgKiBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBsYXllciAocnNjKS5cbiAgICovIHJlYWN0U2VydmVyQ29tcG9uZW50czogXCJyc2NcIixcbiAgICAvKipcbiAgICogU2VydmVyIFNpZGUgUmVuZGVyaW5nIGxheWVyIGZvciBhcHAgKHNzcikuXG4gICAqLyBzZXJ2ZXJTaWRlUmVuZGVyaW5nOiBcInNzclwiLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBhY3Rpb25zLlxuICAgKi8gYWN0aW9uQnJvd3NlcjogXCJhY3Rpb24tYnJvd3NlclwiLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBBUEkgcm91dGVzLlxuICAgKi8gYXBpOiBcImFwaVwiLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHRoZSBtaWRkbGV3YXJlIGNvZGUuXG4gICAqLyBtaWRkbGV3YXJlOiBcIm1pZGRsZXdhcmVcIixcbiAgICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgaW5zdHJ1bWVudGF0aW9uIGhvb2tzLlxuICAgKi8gaW5zdHJ1bWVudDogXCJpbnN0cnVtZW50XCIsXG4gICAgLyoqXG4gICAqIFRoZSBsYXllciBmb3IgYXNzZXRzIG9uIHRoZSBlZGdlLlxuICAgKi8gZWRnZUFzc2V0OiBcImVkZ2UtYXNzZXRcIixcbiAgICAvKipcbiAgICogVGhlIGJyb3dzZXIgY2xpZW50IGJ1bmRsZSBsYXllciBmb3IgQXBwIGRpcmVjdG9yeS5cbiAgICovIGFwcFBhZ2VzQnJvd3NlcjogXCJhcHAtcGFnZXMtYnJvd3NlclwiLFxuICAgIC8qKlxuICAgKiBUaGUgc2VydmVyIGJ1bmRsZSBsYXllciBmb3IgbWV0YWRhdGEgcm91dGVzLlxuICAgKi8gYXBwTWV0YWRhdGFSb3V0ZTogXCJhcHAtbWV0YWRhdGEtcm91dGVcIixcbiAgICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgc2VydmVyIGJ1bmRsZSBmb3IgQXBwIFJvdXRlIGhhbmRsZXJzLlxuICAgKi8gYXBwUm91dGVIYW5kbGVyOiBcImFwcC1yb3V0ZS1oYW5kbGVyXCJcbn07XG5jb25zdCBXRUJQQUNLX0xBWUVSUyA9IHtcbiAgICAuLi5XRUJQQUNLX0xBWUVSU19OQU1FUyxcbiAgICBHUk9VUDoge1xuICAgICAgICBzZXJ2ZXJPbmx5OiBbXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5yZWFjdFNlcnZlckNvbXBvbmVudHMsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hY3Rpb25Ccm93c2VyLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwTWV0YWRhdGFSb3V0ZSxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFJvdXRlSGFuZGxlcixcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmluc3RydW1lbnRcbiAgICAgICAgXSxcbiAgICAgICAgY2xpZW50T25seTogW1xuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlclxuICAgICAgICBdLFxuICAgICAgICBub25DbGllbnRTZXJ2ZXJUYXJnZXQ6IFtcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgYW5kIHBhZ2VzIGFwaVxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMubWlkZGxld2FyZSxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaVxuICAgICAgICBdLFxuICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcHBNZXRhZGF0YVJvdXRlLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYXBwUm91dGVIYW5kbGVyLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnNoYXJlZCxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmluc3RydW1lbnRcbiAgICAgICAgXVxuICAgIH1cbn07XG5jb25zdCBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVMgPSB7XG4gICAgZWRnZVNTUkVudHJ5OiBcIl9fbmV4dF9lZGdlX3Nzcl9lbnRyeV9fXCIsXG4gICAgbWV0YWRhdGE6IFwiX19uZXh0X21ldGFkYXRhX19cIixcbiAgICBtZXRhZGF0YVJvdXRlOiBcIl9fbmV4dF9tZXRhZGF0YV9yb3V0ZV9fXCIsXG4gICAgbWV0YWRhdGFJbWFnZU1ldGE6IFwiX19uZXh0X21ldGFkYXRhX2ltYWdlX21ldGFfX1wiXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-styles/dist/general/index.css":
/*!************************************************************************!*\
  !*** ./node_modules/@livekit/components-styles/dist/general/index.css ***!
  \************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"9f8e4da49867\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXN0eWxlcy9kaXN0L2dlbmVyYWwvaW5kZXguY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVraXQvY29tcG9uZW50cy1zdHlsZXMvZGlzdC9nZW5lcmFsL2luZGV4LmNzcz84MTdjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiOWY4ZTRkYTQ5ODY3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-styles/dist/general/index.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs2Q0FHYUE7OztlQUFBQTs7O29EQUY4QjtBQUVwQyxNQUFNQSxZQUF1QixTQUFDQyxJQUFBQTtxQ0FBU0MsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsSUFBQUEsT0FBQUEsSUFBQUEsSUFBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7UUFBQUEsSUFBQUEsQ0FBQUEsT0FBQUEsRUFBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O0lBQzVDLElBQUlDLEtBQStCLEVBQUUsRUFJckM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2FkZC1sb2NhbGUudHM/ZmFhZSJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7b0RBSjJCO0FBRTNDLE1BQU1DLFdBQVdDLE1BQW1DLElBQWU7QUFFNUQsU0FBU0YsZ0JBQ2RLLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLE9BQWtCLEVBQ2xCQyxhQUE4QjtJQUU5QixJQUFJTixLQUErQixFQUFFLEVBZ0JyQyxNQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUudHM/MWQ0ZSJdLCJuYW1lcyI6WyJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const doPrefetch = async ()=>{\n        if (isAppRouter) {\n            // note that `appRouter.prefetch()` is currently sync,\n            // so we have to wrap this call in an async function to be able to catch() errors below.\n            return router.prefetch(href, appOptions);\n        } else {\n            return router.prefetch(href, as, options);\n        }\n    };\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7NkJBUzRCQSx5QkFBQUMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt5Q0FDRDt3Q0FDRDt1Q0FDSTs7Ozt1Q0FRRUEsbUJBQUFBLENBQUE7NkNBQ0E7NkNBQ0o7O0FBbUc1QixNQUFNQyxzQkFBaUJDLG1CQUFBQSxDQUFBQSwrSkFBQUE7QUFVdkIsTUFBQUQsYUFDRUUsSUFBQUE7U0FPSUMsU0FBT0MsTUFBQUEsRUFBV0MsSUFBQSxFQUFBQyxFQUFBLEVBQUFDLE9BQWEsRUFBQUMsVUFBQSxFQUFBQyxXQUFBO1FBQ2pDLE9BQUFMLFdBQUE7UUFDRjtJQUVBO0lBQ0EsZ0pBQXVDO1FBQ3JDLENBQUFLLGVBQUEsS0FBQUMsWUFBQUMsVUFBQSxFQUFBTixPQUFBO1FBQ0Y7SUFFQTtJQUNBLDRFQUFZO0lBQ1osWUFBS0U7UUFDSCxDQUFBQSxRQUFNSyxxQkFDSjtRQUNBLE1BQUFBLFNBT0YsT0FBTUMsUUFBQUEsTUFBQUEsS0FBZ0JSLGNBQWtCRSxRQUFNSyxNQUFBQSxHQUFBQSxZQUFBQSxTQUFBQSxPQUFBQSxNQUFBQSxHQUFBQTtRQUU5QyxNQUFBQyxnQkFBQVIsT0FBQSxNQUFBQyxLQUFBLE1BQUFNO1FBQ0Esa0VBQW1DO1lBQ2pDWixXQUFBYyxHQUFBLENBQUFELGdCQUFBO1lBQ0Y7UUFFQTtRQUNBYiwrQkFBZWE7UUFDakJiLFdBQUFlLEdBQUEsQ0FBQUY7SUFFQTtVQUNFRyxhQUFJUDtZQUNGQSxhQUFBO1lBQ0E7WUFDQSx3RkFBb0REO1lBQ3RELE9BQU9OLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUc7ZUFDTDtZQUNGLE9BQUFOLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUMsSUFBQUM7UUFDRjtJQUVBO0lBQ0E7SUFDQSwwREFBc0Q7SUFDdEQ7SUFDQVMseURBQW9CQztpQkFDZEMsS0FBUUMsQ0FBRyxDQUFDQztZQUNkRixJQUFBLEVBQXFDO1lBQ3JDLHFDQUFNRDtZQUNSLE1BQUFBO1FBQ0Y7SUFDRjtBQUVBO1NBQ0VJLGdCQUFvQkMsS0FBTUM7SUFDMUIsTUFBTUMsY0FBU0MsTUFBQUEsYUFBd0I7SUFDdkMsTUFBQUQsU0FDR0EsWUFBVUEsWUFDWEYsQ0FBQUE7SUFJQ0EsT0FBTUksVUFBV0YsV0FBVUUsV0FBWUMsTUFBS0MsT0FBSyxJQUFBTixNQUFBTyxPQUFBLElBQUFQLE1BQUFRLFFBQUEsSUFBQVIsTUFBQVMsTUFBQTtJQUV0RFQsTUFBQUksV0FBQSxJQUFBSixNQUFBSSxXQUFBLENBQUFDLEtBQUE7QUFFQTtTQVdFSyxZQUFnQkMsQ0FBRSxFQUFBL0IsTUFBS3FCLEVBQUFBLElBQUFBLEVBQUFBLEVBQWEsRUFBQVcsT0FBQSxFQUFBQyxPQUFBLEVBQUFDLE1BQUEsRUFBQXhCLE1BQUEsRUFBQUgsV0FBQTtJQUVwQyxRQUFBNEIsUUFBQSxLQUFBSixFQUFBVixhQUFBO0lBQ0Esa0RBQTZDO0lBRTdDLE1BQ0VlLG1CQUNDakIsU0FBQUEsV0FBZ0JZLE9BQ2Y7SUFDQyxJQUFDeEIsb0JBQWdCRSxDQUFBQSxnQkFBQUEsTUFBV04sZ0pBQy9CO29CQUNBLEtBQUFLLFlBQUFDLFVBQUEsRUFBQU4sS0FBQSxHQUE4QztRQUM5QztRQUNGO0lBRUE0QjtJQUVBQSxFQUFBTSxjQUFNQztVQUNKQSxXQUFBO1FBQ0Esd0VBQStCO1FBQy9CLE1BQUlDLGVBQUFMLFVBQW9CbEMsT0FBUWtDLFNBQUE7WUFDOUJsQyxvQkFBaUJBLFFBQUE7a0JBQ2ZpQyxDQUFBQSxVQUFBQSxZQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxJQUFBQTtnQkFDQXZCO2dCQUNBd0I7Z0JBQ0ZBLFFBQUFLO1lBQ0Y7ZUFDRXZDO2tCQUNFa0MsQ0FBQUEsVUFBUUssWUFBQUEsT0FBQUEsQ0FBQUEsTUFBQUEsTUFBQUE7Z0JBQ1ZMLFFBQUFLO1lBQ0Y7UUFDRjtJQUVBO1FBQ0VDLGFBQUFBO1FBQ0ZDLE9BQU9DLE9BQUEsQ0FBQUMsZUFBQSxDQUFBTDtXQUNMQTtRQUNGQTtJQUNGO0FBT0E7U0FDTU0sa0JBQU9DLGNBQW1CO1FBQzVCLE9BQU9BLG1CQUFBQSxVQUFBQTtRQUNULE9BQUFBO0lBRUE7SUFDRixXQUFBQyxXQUFBQyxTQUFBLEVBQUFGO0FBRUE7Ozs7Ozs7O0lBVUksTUFBSUcsT0FBQUEsV0FBQUEsR0FBQUEsR0FBQUEsT0FBQUEsT0FBQUEsQ0FBQUEsVUFBQUEsU0FBQUEsU0FBQUEsY0FBQUEsS0FBQUEsRUFBQUEsWUFBQUE7O0lBRUosSUFBQUE7SUFpQkFBLE1BQUFBLEVBQUFBLE1BQVdDLFFBQUFBLEVBQUFBLElBQUFBLE1BQUFBLEVBQUFBLFVBQUFBLFlBQUFBLEVBQUFBLFVBQUFBLGVBQUFBLElBQUFBLEVBQUFBLFFBQUFBLEVBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLEVBQUFBLE1BQUFBLEVBQUFBLE1BQUFBLEVBQUFBLE9BQUFBLEVBQUFBLGNBQUFBLGdCQUFBQSxFQUFBQSxjQUFBQSxnQkFBQUEsRUFBQUEsaUJBQUFBLEtBQUFBLEVBQUFBLEdBQUFBLFdBQUFBLEdBQUFBO0lBRVhELFdBQ0VFO1FBR0FGLGtCQUFBQSxDQUFBQSxPQUFXQSxhQUFBLFlBQUNHLE9BQUFBLGFBQUFBLFFBQUFBLEdBQUFBO21CQUFHSCxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxLQUFBQTs7UUFDakI7SUFFQTtJQUNBLE1BQU1JLGNBQVlaLE9BQUFBLE9BQU1hLENBQUFBLFVBQVdDLENBQUFBLDRCQUFBQSxhQUFBQTtJQUNuQyxNQUFNdEQsWUFBU3VELE9BQUFBLE9BQUFBLENBQUFBLFVBQUFBLENBQUFBLCtCQUFlSCxnQkFBQUE7SUFFOUIsTUFBQXBELFNBQUF1RCxlQUFBLE9BQUFBLGNBQUFIO0lBQ0EsMERBQXFCRztJQUVyQixNQUFNQyxjQUFBQSxDQUFBQTtJQUNOLE1BQUFBLGtCQUFBQyxpQkFBQTs7Ozs7O0tBU0EsR0FBSXpDLE1BQUFBLGtCQUFvQnlDLGlCQUFtQixPQUFBQyxvQkFBQUMsWUFBQSxDQUFBQyxJQUFBLEdBQUFGLG9CQUFBQyxZQUFBLENBQUFFLElBQUE7UUFDekM3QyxJQUF5QjhDLEVBSXhCO2lCQUNDQyxnQkFDR0QsSUFBQTtZQUtMLFdBQUFFLE1BQUEsaUNBQUFGLEtBQUFHLEdBQUEsb0JBQUFILEtBQUFJLFFBQUEsK0JBQUFKLEtBQUFLLE1BQUEsMEJBQUFqRSxXQUFBO1FBRUE7UUFDQSxzQ0FBNEQ7Y0FDMURDLHFCQUFNO1lBQ1JBLE1BQUE7UUFDQTtRQUdBaUUsTUFBQUEsZ0JBQXNCQyxPQUFDSixJQUFBQSxDQUFBQTtzQkFDakJBLE9BQVEsRUFBQUE7Z0JBQ1ZBLFFBQ0VLLFFBQVU7b0JBR1ZBLEtBQUEsQ0FBTVAsSUFBQUEsSUFBQUEsUUFBZ0IsT0FBQU8sS0FBQSxDQUFBTCxJQUFBLHdCQUFBSyxLQUFBLENBQUFMLElBQUE7MEJBQ3BCQSxnQkFBQUE7d0JBQ0FDO3dCQUNBQyxVQUFRRzt3QkFDVkgsUUFBQUcsS0FBQSxDQUFBTCxJQUFBLDRCQUFBSyxLQUFBLENBQUFMLElBQUE7b0JBQ0Y7Z0JBQ0Y7bUJBQ0U7Z0JBQ0E7Z0JBQ0EsNkRBQWlCQTtnQkFDbkIsTUFBQXJFLElBQUFxRTtZQUNGO1FBRUE7UUFDQSxzQ0FBNEQ7Y0FDMUQ3RCxxQkFBSTtZQUNKNEIsSUFBQUE7WUFDQUUsU0FBUTtZQUNSRCxRQUFBQTtZQUNBc0MsU0FBQUE7WUFDQXRFLFVBQVU7WUFDVlMsVUFBUTtZQUNSOEQsUUFBQUE7WUFDQUMsU0FBQUE7WUFDQUMsY0FBYztZQUNkeEIsY0FBQUE7WUFDRkEsZ0JBQUE7UUFDQTtRQUdBeUIsTUFBQUEsZ0JBQXNCTixPQUFDSixJQUFBQSxDQUFBQTtzQkFDZlcsT0FBVSxFQUFBWDtZQUVoQixNQUFJQSxVQUFRLE9BQU1LLEtBQUEsQ0FBQUwsSUFBQTtnQkFDaEJBLFFBQUlLLE1BQVU7b0JBQ1pBLEtBQUEsQ0FBTVAsSUFBQUEsSUFBQUEsWUFBZ0IsWUFBQWEsWUFBQTswQkFDcEJYLGdCQUFBQTt3QkFDQUM7d0JBQ0FDLFVBQVFTO3dCQUNWVCxRQUFBUztvQkFDRjtnQkFDRjttQkFDRSxJQUFJTixRQUFVLFVBQUlNO29CQUNoQk4sS0FBQSxDQUFNUCxJQUFBQSxJQUFBQSxZQUFnQjswQkFDcEJFLGdCQUFBQTt3QkFDQUM7d0JBQ0FDLFVBQVFTO3dCQUNWVCxRQUFBUztvQkFDRjtnQkFDRjttQkFLRSxJQUFJTixRQUFVLGFBQUlNLFFBQVksa0JBQVlYLFFBQUE7b0JBQ3hDSyxLQUFBLENBQU1QLElBQUFBLElBQUFBLFlBQWdCOzBCQUNwQkUsZ0JBQUFBO3dCQUNBQzt3QkFDQUMsVUFBUVM7d0JBQ1ZULFFBQUFTO29CQUNGO2dCQUNGO21CQVFFLElBQUlOLFFBQVUsYUFBWU0sUUFBQUEsWUFBWVgsUUFBVyxhQUFBQSxRQUFBLGNBQUFBLFFBQUEsY0FBQUEsUUFBQTtvQkFDL0NLLEtBQUEsQ0FBTVAsSUFBQUEsSUFBQUEsUUFBZ0JhLFlBQUE7MEJBQ3BCWCxnQkFBQUE7d0JBQ0FDO3dCQUNBQyxVQUFRUzt3QkFDVlQsUUFBQVM7b0JBQ0Y7Z0JBQ0Y7bUJBQ0U7Z0JBQ0E7Z0JBQ0EsNkRBQWlCWDtnQkFDbkIsTUFBQXJFLElBQUFxRTtZQUNGO1FBRUE7UUFDQSw0RkFBc0Q7UUFDdEQsc0RBQStCO1FBQy9CLE1BQUlLLFlBQWM3QixPQUFLb0MsT0FBQUEsQ0FBVUMsTUFBQUEsQ0FBTztZQUN0Q0QsTUFBQUEsUUFBVUMsSUFBTyxDQUFBRCxVQUFHQyxPQUFBLEtBQUF2RSxhQUFBO1lBQ3BCd0UsVUFBUUMsT0FDTjtZQUVKRCxRQUFBQyxJQUFBO1FBQ0Y7SUFFQTtRQUNFaEUsSUFBb0JpRSxFQUFRO1lBQzFCMUUsZUFBSUosQ0FBQUEsUUFBQUE7WUFDSixJQUFJQTtnQkFDRkEsT0FBTytFLGFBQUFBLFVBQUFBO2dCQUNUL0UsT0FDRStFO21CQUdBL0UsSUFBTytFLE9BQUFBLGFBQWlCLG1CQUFBQSxTQUFBQyxRQUFBO2dCQUMxQmhGLE9BQUErRSxTQUFBQyxRQUFBO1lBRUE7Z0JBQ0VoRixNQUFNaUY7Z0JBSU4sTUFBSUEsb0JBQW1CakYsS0FBQWtGLEtBQUEsTUFBQUMsSUFBQSxFQUFBQyxVQUFBQSxRQUFBQyxVQUFBLFNBQUFELFFBQUFFLFFBQUE7b0JBQ3JCTCxtQkFDRztvQkFFTCxVQUFBcEIsTUFBQSxtQkFBQTdELE9BQUE7Z0JBQ0Y7WUFDRjtRQUNGO0lBRUE7VUFDRSxFQUFJQSxJQUFDb0QsRUFBQUEsRUFBQUEsRUFBQUEsR0FBQUEsT0FBYWIsT0FBQSxDQUFBZ0QsT0FBQTtZQUNoQixDQUFBbkMsYUFBTW9DO1lBQ04sTUFBQUEsZUFBTy9DLGtCQUFBc0M7bUJBQ0wvRTtnQkFDQUMsTUFBSTZFO2dCQUNON0UsSUFBQTZFLFNBQUFyQyxrQkFBQXFDLFVBQUFVO1lBQ0Y7UUFFQTtRQU1BLE9BQU9BLGNBQUFDLFdBQUEsT0FBQUMsYUFBQUMsV0FBQSxFQUFBdkMsYUFBQTJCLFVBQUE7ZUFDTC9FO1lBQ0FDLE1BQUk2RTtZQUdON0UsSUFBQTZFLFNBQUEsSUFBQVksYUFBQUMsV0FBQSxFQUFBdkMsYUFBQTBCLFVBQUFXLGNBQUFEO1FBQ0M7O1FBQWNUO1FBQVVEO1FBQU9BO0tBRWxDO0lBQ0EsTUFBTWMsZUFBYXZELE9BQUFBLE9BQU13RCxDQUFBQSxNQUFlNUYsQ0FBQUE7SUFFeEMsTUFBQTJGLGFBQUF0RCxPQUFBQyxPQUFBLENBQUFzRCxNQUFBLENBQUE1RjtJQUNBLG9GQUFJNkY7SUFDSixJQUFJL0M7UUFDRkEsZ0JBQWdCaEM7WUFDZEYsSUFBYTtnQkFDWCtELFNBQVFDO2dCQUdWRCxRQUFBQyxJQUFBLHFEQUFBRSxXQUFBO1lBQ0E7Z0JBQ0VILGtCQUNHO2dCQUVMQSxRQUFBQyxJQUFBLDBEQUFBRSxXQUFBO1lBQ0E7Z0JBQ0VlO2dCQUNBQSxRQUFPbEYsT0FBSzJCLE9BQUEsQ0FBQXdELFFBQUEsQ0FBQUMsSUFBQSxDQUFBbkQ7cUJBQ1BBLEtBQUFBO29CQUNILENBQUFBLFVBQVVnQjtvQkFHWixVQUFBQSxNQUFBLHVEQUFBa0IsV0FBQTtnQkFDQTtnQkFNRixVQUFBbEIsTUFBQSw2REFBQWtCLFdBQUEsc0dBQUFoRixXQUFBO1lBQ0Y7ZUFDRStGLEVBRUo7V0FDRTtZQUNFakYsSUFBS2dDLEVBQUFBO2dCQUNILENBQUFBLFlBQVVnQixPQUNSLFNBQUFoQixTQUFBb0QsSUFBQTtnQkFFSixVQUFBcEMsTUFBQTtZQUNGO1FBQ0Y7SUFFQTtJQUlBLE1BQU1xQyxXQUFDQyxpQkFBb0JDLFNBQVdDLE9BQUFBLFVBQWdCQyxZQUFBQSxNQUFBQSxHQUFBQSxHQUFBQTtVQUNwREMsQ0FBQUEsb0JBQVlILFdBQUFDLGFBQUEsT0FBQUcsaUJBQUFGLGVBQUE7UUFDZEMsWUFBQTtJQUVBO1VBRUlFLFNBQUFuRSxPQUFBQyxPQUFBLENBQUFtRSxXQUFBLEVBQUFDO1FBQ0EsNEVBQWdFO1lBQzlETixXQUFBQSxPQUFBQSxLQUFBQSxNQUFBQSxhQUFBQSxPQUFBQSxLQUFBQSxNQUFBQTtZQUNBVDtZQUNBZ0IsV0FBQUEsT0FBYWpDLEdBQU8xRTtZQUN0QjJHLGFBQUFqQyxPQUFBLEdBQUEzRTtRQUVBbUc7UUFDQUEsbUJBQWNRO1lBQ1pULFVBQUk7dUJBQ0tBLGFBQU9BLFlBQWFBLFNBQVVTO2lCQUNyQ1QsSUFBQUEsT0FBU3ZCLGFBQVVnQyxVQUFBQTtnQkFDckJULFNBQUF2QixPQUFBLEdBQUFnQztZQUNGO1FBRUY7O1FBQUtUO1FBQVVsRztRQUFNcUc7UUFBY0Y7UUFBbUJBO0tBR3hEO0lBQ0E5RCwyREFBZ0I7V0FDZEUsT0FBQSxDQUFBc0UsU0FBQTtRQUNBLGdIQUEyQztZQUN6Q2hHLElBQUE7WUFDRjtRQUVBO1lBQ0UsQ0FBQWhCLFFBQUE7WUFDRjtRQUVBO1FBQ0EsMkRBQW9DO1lBQ2xDLENBQUF1RyxhQUFBLENBQUEvQyxpQkFBQTtZQUNGO1FBRUE7UUFDQXZELG9CQUVFRTtpQkFFRU8sUUFBQUEsTUFBQUEsSUFBQUE7WUFDRkE7O1lBR0FILE1BQUFBO1FBRUQsR0FBQUE7O1FBRURKO1FBQ0FvRztRQUNBN0Y7UUFDQThDO1FBQ0FEO1FBQ0F2RCxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxZQUFBQSxNQUFBQTtRQUNBTztRQUNBMEc7UUFDREE7S0FFRDtVQU9FQyxhQUFLTjtRQUNMcEMsS0FBQUE7aUJBQ014RCxDQUFBQTtnQkFDRkEsSUFBUTtvQkFDTixDQUFBZSxHQUFBO29CQUdGLFVBQUFpQyxNQUFBO2dCQUNGO1lBRUE7Z0JBQ0VRLENBQUFBLGtCQUFRekMsT0FBQUEsWUFBQUEsWUFBQUE7Z0JBQ1Z5QyxRQUFBekM7WUFFQTtnQkFLRWtFLGtCQUFZekIsTUFBUXpDLEtBQUFBLElBQUFBLE9BQUFBLE1BQUFBLEtBQUFBLENBQUFBLE9BQUFBLEtBQUFBLFlBQUFBO2dCQUN0QmtFLE1BQUEzQixLQUFBLENBQUFFLE9BQUEsQ0FBQXpDO1lBRUE7Z0JBQ0UsQ0FBQS9CLFFBQUE7Z0JBQ0Y7WUFFQTtnQkFDRStCLEVBQUFvRixnQkFBQTtnQkFDRjtZQUVBckY7WUFXRkEsWUFBQUMsR0FBQS9CLFFBQUFHLE1BQUFDLElBQUE0QixTQUFBQyxTQUFBQyxRQUFBeEIsUUFBQUg7UUFDQWtFO3NCQUNPdkIsQ0FBQUE7Z0JBQ0hrRSxDQUFBQSxrQkFBaUJyRixPQUFBQSxxQkFBQUEsWUFBQUE7Z0JBQ25CcUYsaUJBQUFyRjtZQUVBO2dCQUtFa0Usa0JBQVl4QixNQUFZSCxLQUFDdkMsSUFBQUEsT0FBQUEsTUFBQUEsS0FBQUEsQ0FBQUEsWUFBQUEsS0FBQUEsWUFBQUE7Z0JBQzNCa0UsTUFBQTNCLEtBQUEsQ0FBQUcsWUFBQSxDQUFBMUM7WUFFQTtnQkFDRSxDQUFBL0IsUUFBQTtnQkFDRjtZQUVBO2dCQUlFLEVBQUF3RCxtQkFBQXhDLGtCQUFBLGtCQUFBVCxhQUFBO2dCQUNGO1lBRUFOO3FCQUtJUyxRQUFBQSxNQUFBQSxJQUFBQTtnQkFDQTJHO2dCQUNBQSxVQUFBO2dCQUNBQyxnR0FBdUI7Z0JBRXpCQSx1QkFBQTs7Z0JBR0EvRyxNQUFBQTtZQUVKLEdBQUFBO1FBQ0FtRTtzQkFHV3hCLE1BQXlCcUUsR0FBcUJDLENBQUFBLEdBQVksU0FBQTlDLGFBQUEzQyxDQUFBO2dCQUM3RHdGLENBQUFBLGtCQUFpQnhGLE9BQUFBLHFCQUFBQSxZQUFBQTtnQkFDbkJ3RixpQkFBQXhGO1lBRUE7Z0JBS0VrRSxrQkFBWXZCLE1BQVlKLEtBQUN2QyxJQUFBQSxPQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxZQUFBQSxLQUFBQSxZQUFBQTtnQkFDM0JrRSxNQUFBM0IsS0FBQSxDQUFBSSxZQUFBLENBQUEzQztZQUVBO2dCQUNFLENBQUEvQixRQUFBO2dCQUNGO1lBRUE7Z0JBQ0UsQ0FBQXdELG1CQUFBakQsYUFBQTtnQkFDRjtZQUVBTjtxQkFLSVMsUUFBQUEsTUFBQUEsSUFBQUE7Z0JBQ0EyRztnQkFDQUEsVUFBQTtnQkFDQUMsZ0dBQXVCO2dCQUV6QkEsdUJBQUE7O2dCQUdBL0csTUFBQUE7WUFFSixHQUFBQTtRQUNOO0lBRUE7SUFDQSw2RkFBd0Y7SUFDeEYsd0ZBQW9GO0lBQ3BGLG9GQUF1QjtRQUNyQmtILENBQUFBLEdBQUFBLE9BQVd0SCxhQUFPQyxFQUFBQSxLQUFBQTtRQUNwQnFILFdBQ0d2RSxJQUFBQSxHQUFBQTtXQUlELElBQU13RSxDQUFBQSxrQkFDR2hILFlBQVd1RixNQUFBRyxJQUFBLEtBQWMxRixPQUFTNkMsQ0FBQUEsQ0FBQUEsVUFBQUEsTUFBQUEsS0FBQUEsR0FBQUE7UUFFM0MsTUFBQW1FLFlBQUEsT0FBQWhILFdBQUEsY0FBQUEsU0FBQTZDLGVBQXVFLGdCQUFBQSxZQUFBN0MsTUFBQTtRQUN2RSx1RUFBdUU7UUFDdkUsdUVBQ2VpSDtRQVFmRixNQUFBQSxlQUNFRyxDQUFBQSxlQUNBQyxPQUFBQSxLQUFBQSxJQUFBQSxZQUFZQyxjQUFBQSxLQUFBQSxDQUFBQSxHQUFTQyxpQkFBZ0J4RSxlQUFBQSxFQUFBQSxJQUFBQSxXQUFBQSxlQUFheUUsT0FBQUEsS0FBYSxJQUFBekUsWUFBQTBFLE9BQUEsRUFBQTFFLGVBQUEsZ0JBQUFBLFlBQUEyRSxhQUFBO1FBQ25FVCxXQUFBdEgsSUFBQSxHQUFBeUgsZ0JBQUEsSUFBQU8sYUFBQU4sV0FBQSxNQUFBTyxXQUFBTixTQUFBLEVBQUExSCxJQUFBc0gsV0FBQW5FLGVBQUEsZ0JBQUFBLFlBQUF5RSxhQUFBO0lBRUE7V0FHU0ssaUJBQVMsY0FBQTVGLE9BQUFDLE9BQUEsQ0FBQTRGLFlBQUEsQ0FBQXJDLE9BQUF3QixjQUFBLGtCQUFBYyxZQUFBQyxHQUFBO1FBQUcsR0FBR2YsU0FBQUE7cUJBQ25CekU7O0lBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvbGluay50c3g/YWNmMCJdLCJuYW1lcyI6WyJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfIiwicmVxdWlyZSIsInByZWZldGNoZWQiLCJTZXQiLCJyb3V0ZXIiLCJwcmVmZXRjaCIsIndpbmRvdyIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJhcHBPcHRpb25zIiwiaXNBcHBSb3V0ZXIiLCJfaXNsb2NhbHVybCIsImlzTG9jYWxVUkwiLCJsb2NhbGUiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiZG9QcmVmZXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImV2ZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJSZWFjdCIsIl9yZWFjdCIsImRlZmF1bHQiLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiX2Zvcm1hdHVybCIsImZvcm1hdFVybCIsImNoaWxkcmVuIiwiY2hpbGRyZW5Qcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJhIiwiYXBwUm91dGVyIiwidXNlQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJwYWdlc1JvdXRlciIsInByZWZldGNoRW5hYmxlZCIsInByZWZldGNoUHJvcCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsImFyZ3MiLCJjcmVhdGVQcm9wRXJyb3IiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Ub3VjaFN0YXJ0Iiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJhc1Byb3AiLCJocmVmUHJvcCIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJfcmVzb2x2ZWhyZWYiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzQXMiLCJ1c2VSZWYiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJfdXNlaW50ZXJzZWN0aW9uIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInByZXZpb3VzSHJlZiIsInVzZUVmZmVjdCIsImFwcFByZWZldGNoS2luZCIsInJlZiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbk1vdXNlRW50ZXJQcm9wIiwicHJpb3JpdHkiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJvblRvdWNoU3RhcnRQcm9wIiwidW5kZWZpbmVkIiwiY2hpbGRQcm9wcyIsImN1ckxvY2FsZSIsImlzTG9jYWxlRG9tYWluIiwibG9jYWxlRG9tYWluIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJfZ2V0ZG9tYWlubG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX2FkZGJhc2VwYXRoIiwiX2FkZGxvY2FsZSIsInJlc3RQcm9wcyIsImNsb25lRWxlbWVudCIsIl9qc3hydW50aW1lIiwianN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQjtlQUFsQkE7O0lBaEJBQyxxQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLE1BQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQXlCZ0JBOzs7ZUFBQUE7Ozt5Q0F2QnVCO3VDQUNGO2tDQUNoQjttQ0FDb0I7b0RBQ0U7d0NBQ2hCO29DQUNJOzJDQUNEO0FBZ0J2QixTQUFTQSxZQUNkQyxNQUFrQixFQUNsQkMsSUFBUyxFQUNUQyxTQUFtQjtJQUVuQiw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBT0ksQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUNKO0lBRXpFLDZEQUE2RDtJQUM3RCxtREFBbUQ7SUFDbkQsTUFBTUssZ0JBQWdCRixZQUFZRyxLQUFLLENBQUM7SUFDeEMsTUFBTUMscUJBQXFCRixnQkFDdkJGLFlBQVlLLEtBQUssQ0FBQ0gsYUFBYSxDQUFDLEVBQUUsQ0FBQ0ksTUFBTSxJQUN6Q047SUFFSixNQUFNTyxXQUFXSCxtQkFBbUJJLEtBQUssQ0FBQyxLQUFLO0lBRS9DLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJSixLQUFLLENBQUMsY0FBYztRQUMxQ00sUUFBUUMsS0FBSyxDQUNYLG1CQUFpQlYsY0FBWSx1Q0FBb0NKLE9BQU9lLFFBQVEsR0FBQztRQUVuRixNQUFNQyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLHdCQUF3QixFQUFDVDtRQUMvQ0osY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsTUFBTVU7SUFDMUQ7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDRSxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNkLGNBQWM7UUFDNUIsT0FBUUYsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3RDO0lBRUEsSUFBSTtRQUNGRCxPQUFPLElBQUlnQixJQUNUZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUM3RDtJQUVKLEVBQUUsT0FBT08sR0FBRztRQUNWLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN0QjtJQUVBLElBQUk7UUFDRixNQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHUyxDQUFBQSxHQUFBQSx3QkFBQUEsMEJBQTBCLEVBQUNELFNBQVNSLFFBQVE7UUFDaEUsSUFBSVUsaUJBQWlCO1FBRXJCLElBQ0VDLENBQUFBLEdBQUFBLFFBQUFBLGNBQWMsRUFBQ0gsU0FBU1IsUUFBUSxLQUNoQ1EsU0FBU0ksWUFBWSxJQUNyQnpCLFdBQ0E7WUFDQSxNQUFNMEIsUUFBUUMsQ0FBQUEsR0FBQUEsYUFBQUEsc0JBQXNCLEVBQUNOLFNBQVNJLFlBQVk7WUFFMUQsTUFBTSxFQUFFRyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQ3RDVCxTQUFTUixRQUFRLEVBQ2pCUSxTQUFTUixRQUFRLEVBQ2pCYTtZQUdGLElBQUlFLFFBQVE7Z0JBQ1ZMLGlCQUFpQnBCLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQixFQUFDO29CQUNwQ1UsVUFBVWU7b0JBQ1ZHLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPTSxDQUFBQSxHQUFBQSxNQUFBQSxJQUFJLEVBQUNOLE9BQU9HO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsTUFBTUksZUFDSlosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FDM0JiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUMxQ2EsU0FBU3RCLElBQUk7UUFFbkIsT0FBT0MsWUFDSDtZQUFDaUM7WUFBY1Ysa0JBQWtCVTtTQUFhLEdBQzlDQTtJQUNOLEVBQUUsT0FBT2IsR0FBRztRQUNWLE9BQU9wQixZQUFZO1lBQUNFO1NBQVksR0FBR0E7SUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXNvbHZlLWhyZWYudHM/ZTZkMiJdLCJuYW1lcyI6WyJyZXNvbHZlSHJlZiIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwicmVzdWx0IiwicGFyYW1zIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OzttREErRmdCQTs7O2VBQUFBOzs7bUNBL0Z5QztpREFJbEQ7QUFxQlAsTUFBTUMsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUVoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQXVCLEVBQUU7QUFFL0IsU0FBU0MsZUFBZUMsT0FBb0M7SUFDMUQsTUFBTUMsS0FBSztRQUNUQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNoQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FDMUIsQ0FBQ0MsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUUzRCxJQUFJSztJQUVKLElBQUlILFVBQVU7UUFDWkcsV0FBV1osVUFBVWEsR0FBRyxDQUFDSjtRQUN6QixJQUFJRyxVQUFVO1lBQ1osT0FBT0E7UUFDVDtJQUNGO0lBRUEsTUFBTUUsV0FBVyxJQUFJYjtJQUNyQixNQUFNYyxXQUFXLElBQUloQixxQkFBcUIsQ0FBQ2lCO1FBQ3pDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxXQUFXTCxTQUFTRCxHQUFHLENBQUNLLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN6QkYsU0FBU0U7WUFDWDtRQUNGO0lBQ0YsR0FBR2pCO0lBQ0hRLFdBQVc7UUFDVFA7UUFDQVU7UUFDQUQ7SUFDRjtJQUVBWixPQUFPc0IsSUFBSSxDQUFDbkI7SUFDWkwsVUFBVXlCLEdBQUcsQ0FBQ3BCLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTYyxRQUNQQyxPQUFnQixFQUNoQlIsUUFBeUIsRUFDekJmLE9BQW9DO0lBRXBDLE1BQU0sRUFBRUMsRUFBRSxFQUFFVSxRQUFRLEVBQUVELFFBQVEsRUFBRSxHQUFHWCxlQUFlQztJQUNsRFUsU0FBU1csR0FBRyxDQUFDRSxTQUFTUjtJQUV0QkosU0FBU1csT0FBTyxDQUFDQztJQUNqQixPQUFPLFNBQVNDO1FBQ2RkLFNBQVNlLE1BQU0sQ0FBQ0Y7UUFDaEJaLFNBQVNhLFNBQVMsQ0FBQ0Q7UUFFbkIsdURBQXVEO1FBQ3ZELElBQUliLFNBQVNnQixJQUFJLEtBQUssR0FBRztZQUN2QmYsU0FBU2dCLFVBQVU7WUFDbkIvQixVQUFVNkIsTUFBTSxDQUFDeEI7WUFDakIsTUFBTTJCLFFBQVE5QixPQUFPK0IsU0FBUyxDQUM1QixDQUFDdEIsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUUzRCxJQUFJeUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ2Q5QixPQUFPZ0MsTUFBTSxDQUFDRixPQUFPO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU25DLGdCQUFtQ3NDLEtBSWpDO0lBSmlDLE1BQ2pEQyxPQUFPLEVBQ1A1QixVQUFVLEVBQ1Y2QixRQUFRLEVBQ1EsR0FKaUNGO0lBS2pELE1BQU1HLGFBQXNCRCxZQUFZLENBQUN2QztJQUV6QyxNQUFNLENBQUN5QyxTQUFTQyxXQUFXLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQztJQUN2QyxNQUFNQyxhQUFhQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQVc7SUFDcEMsTUFBTUMsYUFBYUMsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDLENBQUNsQjtRQUM5QmUsV0FBV0ksT0FBTyxHQUFHbkI7SUFDdkIsR0FBRyxFQUFFO0lBRUxvQixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJakQseUJBQXlCO1lBQzNCLElBQUl3QyxjQUFjQyxTQUFTO1lBRTNCLE1BQU1aLFVBQVVlLFdBQVdJLE9BQU87WUFDbEMsSUFBSW5CLFdBQVdBLFFBQVFxQixPQUFPLEVBQUU7Z0JBQzlCLE1BQU1wQixZQUFZRixRQUNoQkMsU0FDQSxDQUFDTixZQUFjQSxhQUFhbUIsV0FBV25CLFlBQ3ZDO29CQUFFZixNQUFNOEIsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU1UsT0FBTztvQkFBRXRDO2dCQUFXO2dCQUd2QyxPQUFPb0I7WUFDVDtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNXLFNBQVM7Z0JBQ1osTUFBTVUsZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDLElBQU1WLFdBQVc7Z0JBQzFELE9BQU8sSUFBTVcsQ0FBQUEsR0FBQUEscUJBQUFBLGtCQUFrQixFQUFDRjtZQUNsQztRQUNGO0lBQ0EsdURBQXVEO0lBQ3pELEdBQUc7UUFBQ1g7UUFBWTlCO1FBQVk0QjtRQUFTRztRQUFTRyxXQUFXSSxPQUFPO0tBQUM7SUFFakUsTUFBTU0sZUFBZVAsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDO1FBQy9CTCxXQUFXO0lBQ2IsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUFDSTtRQUFZTDtRQUFTYTtLQUFhO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24udHN4PzU3ZWUiXSwibmFtZXMiOlsidXNlSW50ZXJzZWN0aW9uIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInBhcmFtIiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwidXNlU3RhdGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTs7Ozs7c0RBSTFEQTs7O2VBQUFBOzs7QUFIaEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFFakIsU0FBU0YsbUJBQW1CRyxHQUFXO0lBQzVDLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDekIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDdEM7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLnRzP2RjYjEiXSwibmFtZXMiOlsiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsV0FBUztlQUFUQTs7SUE2REFDLHNCQUFvQjtlQUFwQkE7O0lBZkhDLGVBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBTyxNQUFJUixXQUFTLE1BQUtBLFFBQUFBO1FBQzFELElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNmSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDM0I7SUFDRjtJQUVBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3RDQSxRQUFRTSxPQUFPQyxhQUFZQyxzQkFBc0IsQ0FBQ1I7SUFDcEQ7SUFFQSxJQUFJUyxTQUFTZixPQUFPZSxNQUFNLElBQUtULFNBQVMsTUFBSUEsU0FBWTtJQUV4RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNhLFFBQVEsQ0FBQyxNQUFNYixZQUFZO0lBRXJELElBQ0VILE9BQU9pQixPQUFPLElBQ2IsQ0FBQyxDQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLEtBQWNJLFNBQVMsT0FDNUQ7UUFDQUEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRO1FBQ3ZCLElBQUlILFlBQVlBLFFBQVEsQ0FBQyxFQUFFLEtBQUssS0FBS0EsV0FBVyxNQUFNQTtJQUN4RCxPQUFPLElBQUksQ0FBQ0csTUFBTTtRQUNoQkEsT0FBTztJQUNUO0lBRUEsSUFBSUYsUUFBUUEsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxPQUFPLE1BQU1BO0lBQzFDLElBQUlVLFVBQVVBLE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBS0EsU0FBUyxNQUFNQTtJQUVoRFgsV0FBV0EsU0FBU0ssT0FBTyxDQUFDLFNBQVNEO0lBQ3JDTyxTQUFTQSxPQUFPTixPQUFPLENBQUMsS0FBSztJQUU3QixPQUFPLEtBQUdOLFdBQVdJLE9BQU9ILFdBQVdXLFNBQVNWO0FBQ2xEO0FBRU8sTUFBTVAsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0QscUJBQXFCc0IsR0FBYztJQUNqRCxJQUFJQyxJQUF5QixFQUFlO1FBQzFDLElBQUlELFFBQVEsUUFBUSxPQUFPQSxRQUFRLFVBQVU7WUFDM0NFLE9BQU9DLElBQUksQ0FBQ0gsS0FBS0ksT0FBTyxDQUFDLENBQUNDO2dCQUN4QixJQUFJLENBQUMxQixjQUFjMkIsUUFBUSxDQUFDRCxNQUFNO29CQUNoQ0UsUUFBUUMsSUFBSSxDQUNWLHVEQUFxREg7Z0JBRXpEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzVCLFVBQVV1QjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHM/YTBiMyJdLCJuYW1lcyI6WyJmb3JtYXRVcmwiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybE9iamVjdEtleXMiLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsIiwicHJvY2VzcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQVNBLGlCQUFlO2VBQWZBLGNBQUFBLGVBQWU7O0lBQ2ZDLGdCQUFjO2VBQWRBLFdBQUFBLGNBQWM7OzswQ0FEUzt1Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LnRzPzg3YmIiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFLZ0JBOzs7ZUFBQUE7OzswQ0FIZ0I7d0NBQ0Y7QUFFdkIsU0FBU0EsY0FDZEMsS0FBYSxFQUNiQyxVQUFrQixFQUNsQkMsS0FBcUI7SUFFckIsSUFBSUMsb0JBQW9CO0lBRXhCLE1BQU1DLGVBQWVDLENBQUFBLEdBQUFBLFlBQUFBLGFBQWEsRUFBQ0w7SUFDbkMsTUFBTU0sZ0JBQWdCRixhQUFhRyxNQUFNO0lBQ3pDLE1BQU1DLGlCQUVIUCxDQUFBQSxlQUFlRCxRQUFRUyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFlLEVBQUNMLGNBQWNILGNBQWMsT0FDcEUsZ0RBQWdEO0lBQ2hELHNFQUFzRTtJQUN0RUM7SUFFRkMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTQyxPQUFPQyxJQUFJLENBQUNOO0lBRTNCLElBQ0UsQ0FBQ0ksT0FBT0csS0FBSyxDQUFDLENBQUNDO1FBQ2IsSUFBSUMsUUFBUVAsY0FBYyxDQUFDTSxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFRSxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHWCxhQUFhLENBQUNRLE1BQU07UUFFakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJSSxXQUFXLE1BQUlGLENBQUFBLFNBQVMsUUFBUSxNQUFLRixRQUFNO1FBQy9DLElBQUlHLFVBQVU7WUFDWkMsV0FBVyxDQUFHLENBQUNILFFBQVEsTUFBTSxNQUFHLE1BQUdHLFdBQVM7UUFDOUM7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUEsUUFBUTtZQUFDQTtTQUFNO1FBRXBELE9BQ0UsQ0FBQ0UsWUFBWUgsU0FBU04sY0FBQUEsS0FDdEIsNkNBQTZDO1FBQzVDTCxDQUFBQSxvQkFDQ0Esa0JBQW1Ca0IsT0FBTyxDQUN4QkgsVUFDQUYsU0FDSUQsTUFDR08sR0FBRyxDQUVGLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVlDLG1CQUFtQkQsVUFFakNFLElBQUksQ0FBQyxPQUNSRCxtQkFBbUJULFdBQ3BCO0lBRVgsSUFDQTtRQUNBWixvQkFBb0IsR0FBRyxtQ0FBbUM7O0lBRTFELHVFQUF1RTtJQUN2RSxrREFBa0Q7SUFDcEQ7SUFDQSxPQUFPO1FBQ0xPO1FBQ0FnQixRQUFRdkI7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMudHM/NGYzYiJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUFzIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInZhbHVlIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVFnQkE7OztlQUFBQTs7O2dEQUxUO0FBRVAscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFFWixTQUFTRCxlQUFlRSxLQUFhO0lBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0QsUUFBUTtRQUNyQ0EsUUFBUUUsQ0FBQUEsR0FBQUEsb0JBQUFBLG1DQUFtQyxFQUFDRixPQUFPRyxnQkFBZ0I7SUFDckU7SUFFQSxPQUFPSixXQUFXSyxJQUFJLENBQUNKO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cz85ZTM1Il0sIm5hbWVzIjpbImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsTUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzPzZmYTUiXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiOzs7O3dDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsS0FDZEMsTUFBUyxFQUNUQyxJQUFTO0lBRVQsTUFBTUMsVUFBc0MsQ0FBQztJQUM3Q0MsT0FBT0YsSUFBSSxDQUFDRCxRQUFRSSxPQUFPLENBQUMsQ0FBQ0M7UUFDM0IsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNELE1BQVc7WUFDNUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHTCxNQUFNLENBQUNLLElBQUk7UUFDNUI7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LnRzP2Y2ZDUiXSwibmFtZXMiOlsib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNENnQkEsUUFBTTtlQUFOQTs7SUExQ0FDLHdCQUFzQjtlQUF0QkE7O0lBNEJBQyx3QkFBc0I7ZUFBdEJBOzs7QUE1QlQsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0JELGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUMzQixJQUFJLE9BQU9ILEtBQUssQ0FBQ0csSUFBSSxLQUFLLGFBQWE7WUFDckNILEtBQUssQ0FBQ0csSUFBSSxHQUFHRDtRQUNmLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDTCxLQUFLLENBQUNHLElBQUksR0FBRztZQUNsQ0gsS0FBSyxDQUFDRyxJQUFJLENBQWNHLElBQUksQ0FBQ0o7UUFDakMsT0FBTztZQUNMRixLQUFLLENBQUNHLElBQUksR0FBRztnQkFBQ0gsS0FBSyxDQUFDRyxJQUFJO2dCQUFZRDthQUFNO1FBQzVDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsU0FBU08sdUJBQXVCQyxLQUFjO0lBQzVDLElBQ0UsT0FBT0EsVUFBVSxZQUNoQixPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFDckMsT0FBT0EsVUFBVSxXQUNqQjtRQUNBLE9BQU9FLE9BQU9GO0lBQ2hCLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNWLHVCQUNkYSxRQUF3QjtJQUV4QixNQUFNQyxTQUFTLElBQUlDO0lBQ25CQyxPQUFPQyxPQUFPLENBQUNKLFVBQVVWLE9BQU8sQ0FBQyxDQUFBTztZQUFDLENBQUNMLEtBQUtELE1BQU0sR0FBQU07UUFDNUMsSUFBSUosTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1lBQ3hCQSxNQUFNRCxPQUFPLENBQUMsQ0FBQ2UsT0FBU0osT0FBT0ssTUFBTSxDQUFDZCxLQUFLSSx1QkFBdUJTO1FBQ3BFLE9BQU87WUFDTEosT0FBT00sR0FBRyxDQUFDZixLQUFLSSx1QkFBdUJMO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPVTtBQUNUO0FBRU8sU0FBU2hCLE9BQ2R1QixNQUF1QjtJQUN2QixRQUFBQyxPQUFBQyxVQUFBQyxNQUFBLEVBQUFDLG1CQUFBLElBQUFuQixNQUFBZ0IsT0FBQSxJQUFBQSxPQUFBLFFBQUFJLE9BQUEsR0FBQUEsT0FBQUosTUFBQUksT0FBQTtRQUFHRCxnQkFBQUEsQ0FBSEMsT0FBQSxLQUFBSCxTQUFBLENBQUFHLEtBQXNDOztJQUV0Q0QsaUJBQWlCdEIsT0FBTyxDQUFDLENBQUNGO1FBQ3hCSyxNQUFNcUIsSUFBSSxDQUFDMUIsYUFBYTJCLElBQUksSUFBSXpCLE9BQU8sQ0FBQyxDQUFDRSxNQUFRZ0IsT0FBT1EsTUFBTSxDQUFDeEI7UUFDL0RKLGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQyxNQUFRZ0IsT0FBT0YsTUFBTSxDQUFDZCxLQUFLRDtJQUMxRDtJQUNBLE9BQU9pQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHM/NzRkMyJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQVdnQkE7OztlQUFBQTs7O21DQVZZO0FBVXJCLFNBQVNBLGdCQUFnQkMsS0FBMEI7SUFBMUIsTUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQWMsR0FBMUJGO0lBQzlCLE9BQU8sQ0FBQ0c7UUFDTixNQUFNQyxhQUFhSCxHQUFHSSxJQUFJLENBQUNGO1FBQzNCLElBQUksQ0FBQ0MsWUFBWTtZQUNmLE9BQU87UUFDVDtRQUVBLE1BQU1FLFNBQVMsQ0FBQ047WUFDZCxJQUFJO2dCQUNGLE9BQU9PLG1CQUFtQlA7WUFDNUIsRUFBRSxPQUFPUSxHQUFHO2dCQUNWLE1BQU0sSUFBSUMsT0FBQUEsV0FBVyxDQUFDO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNQyxTQUFxRCxDQUFDO1FBRTVEQyxPQUFPQyxJQUFJLENBQUNWLFFBQVFXLE9BQU8sQ0FBQyxDQUFDQztZQUMzQixNQUFNQyxJQUFJYixNQUFNLENBQUNZLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVosVUFBVSxDQUFDVyxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDbkJSLE1BQU0sQ0FBQ0ksU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUMxQkgsRUFBRUksS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDQyxRQUFVaEIsT0FBT2dCLFVBQ25DUCxFQUFFUSxNQUFNLEdBQ1I7b0JBQUNqQixPQUFPVTtpQkFBRyxHQUNYVixPQUFPVTtZQUNiO1FBQ0Y7UUFDQSxPQUFPTjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzP2M1MDIiXSwibmFtZXMiOlsiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW0iLCJyZSIsImdyb3VwcyIsInBhdGhuYW1lIiwicm91dGVNYXRjaCIsImV4ZWMiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJfIiwiRGVjb2RlRXJyb3IiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwic3BsaXQiLCJtYXAiLCJlbnRyeSIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    parseParameter: function() {\n        return parseParameter;\n    }\n});\nconst _constants = __webpack_require__(/*! ../../../../lib/constants */ \"(app-pages-browser)/./node_modules/next/dist/lib/constants.js\");\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nfunction parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNE5nQkEseUJBQXVCO2VBQXZCQTs7SUFoQkFDLG9CQUFrQjtlQUFsQkE7O0lBbklBQyxlQUFhO2VBQWJBOztJQTlDQUMsZ0JBQWM7ZUFBZEE7Ozt1Q0F4QlQ7Z0RBQ29DOzBDQUNSO2lEQUNDO0FBcUI3QixTQUFTQSxlQUFlQyxLQUFhO0lBQzFDLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNaRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDVkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTztRQUFFRSxLQUFLTjtRQUFPSztRQUFRSjtJQUFTO0FBQ3hDO0FBRUEsU0FBU00scUJBQXFCQyxLQUFhO0lBQ3pDLE1BQU1DLFdBQVdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ0YsT0FBT0osS0FBSyxDQUFDLEdBQUdPLEtBQUssQ0FBQztJQUMzRCxNQUFNQyxTQUF5QyxDQUFDO0lBQ2hELElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNMQyxvQkFBb0JMLFNBQ2pCTSxHQUFHLENBQUMsQ0FBQ0M7WUFDSixNQUFNQyxjQUFjQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUNuREosUUFBUWQsVUFBVSxDQUFDa0I7WUFFckIsTUFBTUMsZUFBZUwsUUFBUU0sS0FBSyxDQUFDLHVCQUF1Qix1QkFBdUI7O1lBRWpGLElBQUlMLGVBQWVJLGNBQWM7Z0JBQy9CLE1BQU0sRUFBRWYsR0FBRyxFQUFFTCxRQUFRLEVBQUVJLE1BQU0sRUFBRSxHQUFHTixlQUFlc0IsWUFBWSxDQUFDLEVBQUU7Z0JBQ2hFVCxNQUFNLENBQUNOLElBQUksR0FBRztvQkFBRWlCLEtBQUtWO29CQUFjUjtvQkFBUUo7Z0JBQVM7Z0JBQ3BELE9BQU8sTUFBSXVCLENBQUFBLEdBQUFBLGNBQUFBLGtCQUFrQixFQUFDUCxlQUFhO1lBQzdDLE9BQU8sSUFBSUksY0FBYztnQkFDdkIsTUFBTSxFQUFFZixHQUFHLEVBQUVELE1BQU0sRUFBRUosUUFBUSxFQUFFLEdBQUdGLGVBQWVzQixZQUFZLENBQUMsRUFBRTtnQkFDaEVULE1BQU0sQ0FBQ04sSUFBSSxHQUFHO29CQUFFaUIsS0FBS1Y7b0JBQWNSO29CQUFRSjtnQkFBUztnQkFDcEQsT0FBT0ksU0FBVUosV0FBVyxnQkFBZ0IsV0FBWTtZQUMxRCxPQUFPO2dCQUNMLE9BQU8sTUFBSXVCLENBQUFBLEdBQUFBLGNBQUFBLGtCQUFrQixFQUFDUjtZQUNoQztRQUNGLEdBQ0NTLElBQUksQ0FBQztRQUNSYjtJQUNGO0FBQ0Y7QUFPTyxTQUFTZCxjQUFjNEIsZUFBdUI7SUFDbkQsTUFBTSxFQUFFWixrQkFBa0IsRUFBRUYsTUFBTSxFQUFFLEdBQUdMLHFCQUFxQm1CO0lBQzVELE9BQU87UUFDTEMsSUFBSSxJQUFJQyxPQUFPLE1BQUlkLHFCQUFtQjtRQUN0Q0YsUUFBUUE7SUFDVjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2lCO0lBQ1AsSUFBSUMsSUFBSTtJQUVSLE9BQU87UUFDTCxJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsSUFBSSxFQUFFRjtRQUNWLE1BQU9FLElBQUksRUFBRztZQUNaRCxZQUFZRSxPQUFPQyxZQUFZLENBQUMsS0FBTSxDQUFDRixJQUFJLEtBQUs7WUFDaERBLElBQUlHLEtBQUtDLEtBQUssQ0FBQyxDQUFDSixJQUFJLEtBQUs7UUFDM0I7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSxTQUFTTSxzQkFBc0JyQyxLQVk5QjtJQVo4QixNQUM3QnNDLGtCQUFrQixFQUNsQkMsZUFBZSxFQUNmdkIsT0FBTyxFQUNQd0IsU0FBUyxFQUNUQyxTQUFTLEVBT1YsR0FaOEJ6QztJQWE3QixNQUFNLEVBQUVNLEdBQUcsRUFBRUwsUUFBUSxFQUFFSSxNQUFNLEVBQUUsR0FBR04sZUFBZWlCO0lBRWpELHVEQUF1RDtJQUN2RCxrQkFBa0I7SUFDbEIsSUFBSTBCLGFBQWFwQyxJQUFJcUMsT0FBTyxDQUFDLE9BQU87SUFFcEMsSUFBSUYsV0FBVztRQUNiQyxhQUFhLEtBQUdELFlBQVlDO0lBQzlCO0lBQ0EsSUFBSUUsYUFBYTtJQUVqQixrRUFBa0U7SUFDbEUsV0FBVztJQUNYLElBQUlGLFdBQVdHLE1BQU0sS0FBSyxLQUFLSCxXQUFXRyxNQUFNLEdBQUcsSUFBSTtRQUNyREQsYUFBYTtJQUNmO0lBQ0EsSUFBSSxDQUFDRSxNQUFNQyxTQUFTTCxXQUFXdEMsS0FBSyxDQUFDLEdBQUcsTUFBTTtRQUM1Q3dDLGFBQWE7SUFDZjtJQUVBLElBQUlBLFlBQVk7UUFDZEYsYUFBYUg7SUFDZjtJQUVBLElBQUlFLFdBQVc7UUFDYkQsU0FBUyxDQUFDRSxXQUFXLEdBQUcsS0FBR0QsWUFBWW5DO0lBQ3pDLE9BQU87UUFDTGtDLFNBQVMsQ0FBQ0UsV0FBVyxHQUFHcEM7SUFDMUI7SUFFQSx3RkFBd0Y7SUFDeEYsMEZBQTBGO0lBQzFGLHFGQUFxRjtJQUNyRixNQUFNMEMscUJBQXFCVixxQkFDdkJkLENBQUFBLEdBQUFBLGNBQUFBLGtCQUFrQixFQUFDYyxzQkFDbkI7SUFFSixPQUFPakMsU0FDSEosV0FDRSxTQUFPK0MscUJBQW1CLFFBQUtOLGFBQVcsWUFDMUMsTUFBSU0scUJBQW1CLFFBQUtOLGFBQVcsVUFDekMsTUFBSU0scUJBQW1CLFFBQUtOLGFBQVc7QUFDN0M7QUFFQSxTQUFTTywwQkFBMEJ6QyxLQUFhLEVBQUUwQyxlQUF3QjtJQUN4RSxNQUFNekMsV0FBV0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDRixPQUFPSixLQUFLLENBQUMsR0FBR08sS0FBSyxDQUFDO0lBQzNELE1BQU00QixrQkFBa0JWO0lBQ3hCLE1BQU1XLFlBQXlDLENBQUM7SUFDaEQsT0FBTztRQUNMVyx5QkFBeUIxQyxTQUN0Qk0sR0FBRyxDQUFDLENBQUNDO1lBQ0osTUFBTW9DLHdCQUF3QmxDLG9CQUFBQSwwQkFBMEIsQ0FBQ21DLElBQUksQ0FBQyxDQUFDakMsSUFDN0RKLFFBQVFkLFVBQVUsQ0FBQ2tCO1lBRXJCLE1BQU1DLGVBQWVMLFFBQVFNLEtBQUssQ0FBQyx1QkFBdUIsdUJBQXVCOztZQUVqRixJQUFJOEIseUJBQXlCL0IsY0FBYztnQkFDekMsTUFBTSxDQUFDaUMsV0FBVyxHQUFHdEMsUUFBUUwsS0FBSyxDQUFDVSxZQUFZLENBQUMsRUFBRTtnQkFFbEQsT0FBT2dCLHNCQUFzQjtvQkFDM0JFO29CQUNBRCxvQkFBb0JnQjtvQkFDcEJ0QyxTQUFTSyxZQUFZLENBQUMsRUFBRTtvQkFDeEJtQjtvQkFDQUMsV0FBV1Msa0JBQ1BLLFdBQUFBLCtCQUErQixHQUMvQkM7Z0JBQ047WUFDRixPQUFPLElBQUluQyxjQUFjO2dCQUN2QixPQUFPZ0Isc0JBQXNCO29CQUMzQkU7b0JBQ0F2QixTQUFTSyxZQUFZLENBQUMsRUFBRTtvQkFDeEJtQjtvQkFDQUMsV0FBV1Msa0JBQWtCTyxXQUFBQSx1QkFBdUIsR0FBR0Q7Z0JBQ3pEO1lBQ0YsT0FBTztnQkFDTCxPQUFPLE1BQUloQyxDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQ1I7WUFDaEM7UUFDRixHQUNDUyxJQUFJLENBQUM7UUFDUmU7SUFDRjtBQUNGO0FBVU8sU0FBUzNDLG1CQUNkNkIsZUFBdUIsRUFDdkJnQyxjQUF1QjtJQUV2QixNQUFNQyxTQUFTViwwQkFBMEJ2QixpQkFBaUJnQztJQUMxRCxPQUFPO1FBQ0wsR0FBRzVELGNBQWM0QixnQkFBZ0I7UUFDakNrQyxZQUFZLE1BQUlELE9BQU9SLHVCQUF1QixHQUFDO1FBQy9DWCxXQUFXbUIsT0FBT25CLFNBQVM7SUFDN0I7QUFDRjtBQU1PLFNBQVM1Qyx3QkFDZDhCLGVBQXVCLEVBQ3ZCbUMsT0FFQztJQUVELE1BQU0sRUFBRS9DLGtCQUFrQixFQUFFLEdBQUdQLHFCQUFxQm1CO0lBQ3BELE1BQU0sRUFBRW9DLFdBQVcsSUFBSSxFQUFFLEdBQUdEO0lBQzVCLElBQUkvQyx1QkFBdUIsS0FBSztRQUM5QixJQUFJaUQsZ0JBQWdCRCxXQUFXLE9BQU87UUFDdEMsT0FBTztZQUNMRixZQUFZLE9BQUtHLGdCQUFjO1FBQ2pDO0lBQ0Y7SUFFQSxNQUFNLEVBQUVaLHVCQUF1QixFQUFFLEdBQUdGLDBCQUNsQ3ZCLGlCQUNBO0lBRUYsSUFBSXNDLHVCQUF1QkYsV0FBVyxlQUFlO0lBQ3JELE9BQU87UUFDTEYsWUFBWSxNQUFJVCwwQkFBMEJhLHVCQUFxQjtJQUNqRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHM/MmQzYSJdLCJuYW1lcyI6WyJnZXROYW1lZE1pZGRsZXdhcmVSZWdleCIsImdldE5hbWVkUm91dGVSZWdleCIsImdldFJvdXRlUmVnZXgiLCJwYXJzZVBhcmFtZXRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzbGljZSIsInJlcGVhdCIsImtleSIsImdldFBhcmFtZXRyaXplZFJvdXRlIiwicm91dGUiLCJzZWdtZW50cyIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJzcGxpdCIsImdyb3VwcyIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJtYXAiLCJzZWdtZW50IiwibWFya2VyTWF0Y2giLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImZpbmQiLCJtIiwicGFyYW1NYXRjaGVzIiwibWF0Y2giLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwibm9ybWFsaXplZFJvdXRlIiwicmUiLCJSZWdFeHAiLCJidWlsZEdldFNhZmVSb3V0ZUtleSIsImkiLCJyb3V0ZUtleSIsImoiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJNYXRoIiwiZmxvb3IiLCJnZXRTYWZlS2V5RnJvbVNlZ21lbnQiLCJpbnRlcmNlcHRpb25NYXJrZXIiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleXMiLCJrZXlQcmVmaXgiLCJjbGVhbmVkS2V5IiwicmVwbGFjZSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50IiwiaW50ZXJjZXB0aW9uUHJlZml4IiwiZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZSIsInByZWZpeFJvdXRlS2V5cyIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiaGFzSW50ZXJjZXB0aW9uTWFya2VyIiwic29tZSIsInVzZWRNYXJrZXIiLCJORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIiwidW5kZWZpbmVkIiwiTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQXFNZ0JBOzs7ZUFBQUE7OztBQXJNaEIsTUFBTUM7SUFPSkMsT0FBT0MsT0FBZSxFQUFRO1FBQzVCLElBQUksQ0FBQ0MsT0FBTyxDQUFDRCxRQUFRRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQyxVQUFVLEVBQUUsRUFBRTtJQUN2RDtJQUVBQyxTQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUNyQjtJQUVRQSxRQUFRQyxNQUFvQixFQUFZO1FBQWhDQSxJQUFBQSxXQUFBQSxLQUFBQSxHQUFBQSxTQUFpQjtRQUMvQixNQUFNQyxnQkFBZ0I7ZUFBSSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUFHLENBQUNDLElBQUk7UUFDcEQsSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQzFCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3BEO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzlCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3ZEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDdENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDekQ7UUFFQSxNQUFNRyxTQUFTVCxjQUNaVSxHQUFHLENBQUMsQ0FBQ0MsSUFBTSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csR0FBRyxDQUFDRCxHQUFJYixPQUFPLENBQUMsS0FBR0MsU0FBU1ksSUFBRSxNQUN2REUsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQVM7bUJBQUlEO21CQUFTQzthQUFLLEVBQUUsRUFBRTtRQUVoRCxJQUFJLElBQUksQ0FBQ1gsUUFBUSxLQUFLLE1BQU07WUFDMUJLLE9BQU9PLElBQUksSUFDTixJQUFJLENBQUNmLFFBQVEsQ0FBQ1csR0FBRyxDQUFDLE1BQU9kLE9BQU8sQ0FBQ0MsU0FBVSxNQUFHLElBQUksQ0FBQ0ssUUFBUSxHQUFDO1FBRW5FO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ2EsV0FBVyxFQUFFO1lBQ3JCLE1BQU1DLElBQUluQixXQUFXLE1BQU0sTUFBTUEsT0FBT29CLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUNYLG9CQUFvQixJQUFJLE1BQU07Z0JBQ3JDLE1BQU0sSUFBSVksTUFDUix5RkFBdUZGLElBQUUsWUFBU0EsSUFBRSxVQUFPLElBQUksQ0FBQ1Ysb0JBQW9CLEdBQUM7WUFFekk7WUFFQUMsT0FBT1ksT0FBTyxDQUFDSDtRQUNqQjtRQUVBLElBQUksSUFBSSxDQUFDWCxZQUFZLEtBQUssTUFBTTtZQUM5QkUsT0FBT08sSUFBSSxJQUNOLElBQUksQ0FBQ2YsUUFBUSxDQUNiVyxHQUFHLENBQUMsU0FDSmQsT0FBTyxDQUFDQyxTQUFVLFNBQU0sSUFBSSxDQUFDUSxZQUFZLEdBQUM7UUFFakQ7UUFFQSxJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLEtBQUssTUFBTTtZQUN0Q0MsT0FBT08sSUFBSSxJQUNOLElBQUksQ0FBQ2YsUUFBUSxDQUNiVyxHQUFHLENBQUMsV0FDSmQsT0FBTyxDQUFDQyxTQUFVLFVBQU8sSUFBSSxDQUFDUyxvQkFBb0IsR0FBQztRQUUxRDtRQUVBLE9BQU9DO0lBQ1Q7SUFFUWhCLFFBQ042QixRQUFrQixFQUNsQkMsU0FBbUIsRUFDbkJDLFVBQW1CLEVBQ2I7UUFDTixJQUFJRixTQUFTRyxNQUFNLEtBQUssR0FBRztZQUN6QixJQUFJLENBQUNSLFdBQVcsR0FBRztZQUNuQjtRQUNGO1FBRUEsSUFBSU8sWUFBWTtZQUNkLE1BQU0sSUFBSUosTUFBTztRQUNuQjtRQUVBLHdDQUF3QztRQUN4QyxJQUFJTSxjQUFjSixRQUFRLENBQUMsRUFBRTtRQUU3Qiw2Q0FBNkM7UUFDN0MsSUFBSUksWUFBWUMsVUFBVSxDQUFDLFFBQVFELFlBQVlFLFFBQVEsQ0FBQyxNQUFNO1lBQzVELDhDQUE4QztZQUM5QyxJQUFJQyxjQUFjSCxZQUFZUCxLQUFLLENBQUMsR0FBRyxDQUFDO1lBRXhDLElBQUlXLGFBQWE7WUFDakIsSUFBSUQsWUFBWUYsVUFBVSxDQUFDLFFBQVFFLFlBQVlELFFBQVEsQ0FBQyxNQUFNO2dCQUM1RCx1REFBdUQ7Z0JBQ3ZEQyxjQUFjQSxZQUFZVixLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUNwQ1csYUFBYTtZQUNmO1lBRUEsSUFBSUQsWUFBWUYsVUFBVSxDQUFDLFFBQVE7Z0JBQ2pDLHdDQUF3QztnQkFDeENFLGNBQWNBLFlBQVlFLFNBQVMsQ0FBQztnQkFDcENQLGFBQWE7WUFDZjtZQUVBLElBQUlLLFlBQVlGLFVBQVUsQ0FBQyxRQUFRRSxZQUFZRCxRQUFRLENBQUMsTUFBTTtnQkFDNUQsTUFBTSxJQUFJUixNQUNSLDhEQUE0RFMsY0FBWTtZQUU1RTtZQUVBLElBQUlBLFlBQVlGLFVBQVUsQ0FBQyxNQUFNO2dCQUMvQixNQUFNLElBQUlQLE1BQ1IsMERBQXdEUyxjQUFZO1lBRXhFO1lBRUEsU0FBU0csV0FBV0MsWUFBMkIsRUFBRUMsUUFBZ0I7Z0JBQy9ELElBQUlELGlCQUFpQixNQUFNO29CQUN6Qiw2RUFBNkU7b0JBQzdFLGlDQUFpQztvQkFDakMsd0JBQXdCO29CQUN4QixzQkFBc0I7b0JBQ3RCLHdGQUF3RjtvQkFDeEYsSUFBSUEsaUJBQWlCQyxVQUFVO3dCQUM3Qix3SEFBd0g7d0JBQ3hILE1BQU0sSUFBSWQsTUFDUixxRUFBbUVhLGVBQWEsWUFBU0MsV0FBUztvQkFFdEc7Z0JBQ0Y7Z0JBRUFYLFVBQVVZLE9BQU8sQ0FBQyxDQUFDQztvQkFDakIsSUFBSUEsU0FBU0YsVUFBVTt3QkFDckIsTUFBTSxJQUFJZCxNQUNSLHlDQUF1Q2MsV0FBUztvQkFFcEQ7b0JBRUEsSUFBSUUsS0FBS0MsT0FBTyxDQUFDLE9BQU8sUUFBUVgsWUFBWVcsT0FBTyxDQUFDLE9BQU8sS0FBSzt3QkFDOUQsTUFBTSxJQUFJakIsTUFDUixxQ0FBbUNnQixPQUFLLFlBQVNGLFdBQVM7b0JBRTlEO2dCQUNGO2dCQUVBWCxVQUFVUCxJQUFJLENBQUNrQjtZQUNqQjtZQUVBLElBQUlWLFlBQVk7Z0JBQ2QsSUFBSU0sWUFBWTtvQkFDZCxJQUFJLElBQUksQ0FBQ3ZCLFlBQVksSUFBSSxNQUFNO3dCQUM3QixNQUFNLElBQUlhLE1BQ1IsMEZBQXdGLElBQUksQ0FBQ2IsWUFBWSxHQUFDLGFBQVVlLFFBQVEsQ0FBQyxFQUFFLEdBQUM7b0JBRXBJO29CQUVBVSxXQUFXLElBQUksQ0FBQ3hCLG9CQUFvQixFQUFFcUI7b0JBQ3RDLDZEQUE2RDtvQkFDN0QsSUFBSSxDQUFDckIsb0JBQW9CLEdBQUdxQjtvQkFDNUIsb0ZBQW9GO29CQUNwRkgsY0FBYztnQkFDaEIsT0FBTztvQkFDTCxJQUFJLElBQUksQ0FBQ2xCLG9CQUFvQixJQUFJLE1BQU07d0JBQ3JDLE1BQU0sSUFBSVksTUFDUiwyRkFBeUYsSUFBSSxDQUFDWixvQkFBb0IsR0FBQyxjQUFXYyxRQUFRLENBQUMsRUFBRSxHQUFDO29CQUU5STtvQkFFQVUsV0FBVyxJQUFJLENBQUN6QixZQUFZLEVBQUVzQjtvQkFDOUIsNkRBQTZEO29CQUM3RCxJQUFJLENBQUN0QixZQUFZLEdBQUdzQjtvQkFDcEIsa0ZBQWtGO29CQUNsRkgsY0FBYztnQkFDaEI7WUFDRixPQUFPO2dCQUNMLElBQUlJLFlBQVk7b0JBQ2QsTUFBTSxJQUFJVixNQUNSLHVEQUFxREUsUUFBUSxDQUFDLEVBQUUsR0FBQztnQkFFckU7Z0JBQ0FVLFdBQVcsSUFBSSxDQUFDNUIsUUFBUSxFQUFFeUI7Z0JBQzFCLDZEQUE2RDtnQkFDN0QsSUFBSSxDQUFDekIsUUFBUSxHQUFHeUI7Z0JBQ2hCLCtFQUErRTtnQkFDL0VILGNBQWM7WUFDaEI7UUFDRjtRQUVBLGlGQUFpRjtRQUNqRixJQUFJLENBQUMsSUFBSSxDQUFDekIsUUFBUSxDQUFDcUMsR0FBRyxDQUFDWixjQUFjO1lBQ25DLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQ3NDLEdBQUcsQ0FBQ2IsYUFBYSxJQUFJcEM7UUFDckM7UUFFQSxJQUFJLENBQUNXLFFBQVEsQ0FDVlcsR0FBRyxDQUFDYyxhQUNKakMsT0FBTyxDQUFDNkIsU0FBU0gsS0FBSyxDQUFDLElBQUlJLFdBQVdDO0lBQzNDOzthQWpNQVAsV0FBQUEsR0FBdUI7YUFDdkJoQixRQUFBQSxHQUFpQyxJQUFJdUM7YUFDckNwQyxRQUFBQSxHQUEwQjthQUMxQkcsWUFBQUEsR0FBOEI7YUFDOUJDLG9CQUFBQSxHQUFzQzs7QUE4THhDO0FBRU8sU0FBU25CLGdCQUNkb0QsZUFBc0M7SUFFdEMsa0ZBQWtGO0lBQ2xGLDRFQUE0RTtJQUM1RSwyQ0FBMkM7SUFFM0MseUVBQXlFO0lBQ3pFLDJCQUEyQjtJQUMzQixvQ0FBb0M7SUFDcEMsOEVBQThFO0lBQzlFLHdFQUF3RTtJQUN4RSxnSEFBZ0g7SUFDaEgsNEVBQTRFO0lBQzVFLE1BQU1DLE9BQU8sSUFBSXBEO0lBRWpCLDZGQUE2RjtJQUM3Rm1ELGdCQUFnQk4sT0FBTyxDQUFDLENBQUNRLFdBQWFELEtBQUtuRCxNQUFNLENBQUNvRDtJQUNsRCw0R0FBNEc7SUFDNUcsT0FBT0QsS0FBSzdDLE1BQU07QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLnRzPzg3YTUiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiVXJsTm9kZSIsImluc2VydCIsInVybFBhdGgiLCJfaW5zZXJ0Iiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwic21vb3NoIiwiX3Ntb29zaCIsInByZWZpeCIsImNoaWxkcmVuUGF0aHMiLCJjaGlsZHJlbiIsImtleXMiLCJzb3J0Iiwic2x1Z05hbWUiLCJzcGxpY2UiLCJpbmRleE9mIiwicmVzdFNsdWdOYW1lIiwib3B0aW9uYWxSZXN0U2x1Z05hbWUiLCJyb3V0ZXMiLCJtYXAiLCJjIiwiZ2V0IiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJwdXNoIiwicGxhY2Vob2xkZXIiLCJyIiwic2xpY2UiLCJFcnJvciIsInVuc2hpZnQiLCJ1cmxQYXRocyIsInNsdWdOYW1lcyIsImlzQ2F0Y2hBbGwiLCJsZW5ndGgiLCJuZXh0U2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNlZ21lbnROYW1lIiwiaXNPcHRpb25hbCIsInN1YnN0cmluZyIsImhhbmRsZVNsdWciLCJwcmV2aW91c1NsdWciLCJuZXh0U2x1ZyIsImZvckVhY2giLCJzbHVnIiwicmVwbGFjZSIsImhhcyIsInNldCIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLGFBQVc7ZUFBWEE7O0lBb0JBQyx5QkFBdUI7ZUFBdkJBOztJQVBBQyxtQkFBaUI7ZUFBakJBOztJQVpBQyxnQkFBYztlQUFkQTs7SUFDQUMsbUJBQWlCO2VBQWpCQTs7SUFUQUMsSUFBRTtlQUFGQTs7SUFDQUMsSUFBRTtlQUFGQTs7SUFsWEFDLFlBQVU7ZUFBVkE7O0lBc1FHQyxVQUFRO2VBQVJBOztJQStCQUMsZ0JBQWM7ZUFBZEE7O0lBWEFDLG1CQUFpQjtlQUFqQkE7O0lBS0FDLFFBQU07ZUFBTkE7O0lBUEhDLGVBQWE7ZUFBYkE7O0lBbUJHQyxXQUFTO2VBQVRBOztJQWtCTUMscUJBQW1CO2VBQW5CQTs7SUFkTkMsMEJBQXdCO2VBQXhCQTs7SUErR0FDLGdCQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxHQUFHQyxPQUFPQyxRQUFRO0lBQ3BELE9BQU9KLFdBQVksT0FBSUMsV0FBV0MsQ0FBQUEsT0FBTyxNQUFNQSxPQUFPO0FBQ3hEO0FBRU8sU0FBU2Y7SUFDZCxNQUFNLEVBQUVrQixJQUFJLEVBQUUsR0FBR0YsT0FBT0MsUUFBUTtJQUNoQyxNQUFNRSxTQUFTcEI7SUFDZixPQUFPbUIsS0FBS0UsU0FBUyxDQUFDRCxPQUFPRSxNQUFNO0FBQ3JDO0FBRU8sU0FBU3ZCLGVBQWtCd0IsU0FBMkI7SUFDM0QsT0FBTyxPQUFPQSxjQUFjLFdBQ3hCQSxZQUNBQSxVQUFVQyxXQUFXLElBQUlELFVBQVVFLElBQUksSUFBSTtBQUNqRDtBQUVPLFNBQVN0QixVQUFVdUIsR0FBbUI7SUFDM0MsT0FBT0EsSUFBSUMsUUFBUSxJQUFJRCxJQUFJRSxXQUFXO0FBQ3hDO0FBRU8sU0FBU3ZCLHlCQUF5Qk8sR0FBVztJQUNsRCxNQUFNaUIsV0FBV2pCLElBQUlrQixLQUFLLENBQUM7SUFDM0IsTUFBTUMsYUFBYUYsUUFBUSxDQUFDLEVBQUU7SUFFOUIsT0FDRUUsV0FDRSw0REFBNEQ7SUFDNUQsMENBQTBDO0tBQ3pDQyxPQUFPLENBQUMsT0FBTyxLQUNmQSxPQUFPLENBQUMsVUFBVSxPQUNwQkgsQ0FBQUEsUUFBUSxDQUFDLEVBQUUsR0FBRyxNQUFJQSxTQUFTSSxLQUFLLENBQUMsR0FBR0MsSUFBSSxDQUFDLE9BQVM7QUFFdkQ7QUFFTyxlQUFlOUIsb0JBSXBCK0IsR0FBZ0MsRUFBRUMsR0FBTTtJQUN4QyxJQUFJQyxJQUF5QixFQUFjO1lBQ3JDRjtRQUFKLEtBQUlBLGlCQUFBQSxJQUFJRyxTQUFTLHFCQUFiSCxlQUFlSSxlQUFlLEVBQUU7WUFDbEMsTUFBTUMsVUFBVSxNQUFJekMsZUFDbEJvQyxPQUNBO1lBQ0YsTUFBTSxJQUFJTSxNQUFNRDtRQUNsQjtJQUNGO0lBQ0EsaURBQWlEO0lBQ2pELE1BQU1kLE1BQU1VLElBQUlWLEdBQUcsSUFBS1UsSUFBSUEsR0FBRyxJQUFJQSxJQUFJQSxHQUFHLENBQUNWLEdBQUc7SUFFOUMsSUFBSSxDQUFDUyxJQUFJSSxlQUFlLEVBQUU7UUFDeEIsSUFBSUgsSUFBSUEsR0FBRyxJQUFJQSxJQUFJYixTQUFTLEVBQUU7WUFDNUIsK0JBQStCO1lBQy9CLE9BQU87Z0JBQ0xtQixXQUFXLE1BQU10QyxvQkFBb0JnQyxJQUFJYixTQUFTLEVBQUVhLElBQUlBLEdBQUc7WUFDN0Q7UUFDRjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBRUEsTUFBTU8sUUFBUSxNQUFNUixJQUFJSSxlQUFlLENBQUNIO0lBRXhDLElBQUlWLE9BQU92QixVQUFVdUIsTUFBTTtRQUN6QixPQUFPaUI7SUFDVDtJQUVBLElBQUksQ0FBQ0EsT0FBTztRQUNWLE1BQU1ILFVBQVUsTUFBSXpDLGVBQ2xCb0MsT0FDQSxpRUFBOERRLFFBQU07UUFDdEUsTUFBTSxJQUFJRixNQUFNRDtJQUNsQjtJQUVBLElBQUlILElBQXlCLEVBQWM7UUFDekMsSUFBSU8sT0FBT0MsSUFBSSxDQUFDRixPQUFPckIsTUFBTSxLQUFLLEtBQUssQ0FBQ2MsSUFBSUEsR0FBRyxFQUFFO1lBQy9DVSxRQUFRQyxJQUFJLENBQ1YsS0FBR2hELGVBQ0RvQyxPQUNBO1FBRU47SUFDRjtJQUVBLE9BQU9RO0FBQ1Q7QUFFTyxNQUFNaEQsS0FBSyxPQUFPcUQsZ0JBQWdCO0FBQ2xDLE1BQU1wRCxLQUNYRCxNQUNBO0lBQUU7SUFBUTtJQUFXO0NBQW1CLENBQVdzRCxLQUFLLENBQ3RELENBQUNDLFNBQVcsT0FBT0YsV0FBVyxDQUFDRSxPQUFPLEtBQUs7QUFHeEMsTUFBTTVELG9CQUFvQm1EO0FBQU87QUFDakMsTUFBTWhELHVCQUF1QmdEO0FBQU87QUFDcEMsTUFBTS9DLDBCQUEwQitDO0lBR3JDVSxZQUFZQyxJQUFZLENBQUU7UUFDeEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDNUIsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDZSxPQUFPLEdBQUcsa0NBQWdDWTtJQUNqRDtBQUNGO0FBRU8sTUFBTTVELDBCQUEwQmlEO0lBQ3JDVSxZQUFZQyxJQUFZLEVBQUVaLE9BQWUsQ0FBRTtRQUN6QyxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUcsMENBQXdDWSxPQUFLLE1BQUdaO0lBQ2pFO0FBQ0Y7QUFFTyxNQUFNakQsZ0NBQWdDa0Q7SUFFM0NVLGFBQWM7UUFDWixLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNiLE9BQU8sR0FBSTtJQUNsQjtBQUNGO0FBV08sU0FBU2xDLGVBQWVnRCxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFaEIsU0FBU2MsTUFBTWQsT0FBTztRQUFFaUIsT0FBT0gsTUFBTUcsS0FBSztJQUFDO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi91dGlscy50cz8xYmQ1Il0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Navbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Navbar */ \"(app-pages-browser)/./src/components/Navbar.tsx\");\n/* harmony import */ var _components_AgentCard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/AgentCard */ \"(app-pages-browser)/./src/components/AgentCard.tsx\");\n/* harmony import */ var _components_VoiceCall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/VoiceCall */ \"(app-pages-browser)/./src/components/VoiceCall.tsx\");\n/* harmony import */ var _barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Search,Sparkles!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Search,Sparkles!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/search.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Search,Sparkles!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction HomePage() {\n    _s();\n    const [agents, setAgents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [activeCall, setActiveCall] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        fetchAgents();\n    }, []);\n    async function fetchAgents() {\n        try {\n            const response = await fetch(\"/api/agents\");\n            const data = await response.json();\n            setAgents(data.filter((a)=>a.status === \"active\"));\n        } catch (error) {\n            console.error(\"Failed to fetch agents:\", error);\n        } finally{\n            setLoading(false);\n        }\n    }\n    const filteredAgents = agents.filter((agent)=>agent.displayName.toLowerCase().includes(searchQuery.toLowerCase()) || agent.description.toLowerCase().includes(searchQuery.toLowerCase()));\n    if (activeCall) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"page-container\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Navbar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex-1 flex\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VoiceCall__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        agent: activeCall,\n                        onEnd: ()=>setActiveCall(null)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 43,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/runner/workspace/src/app/page.tsx\",\n            lineNumber: 40,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"page-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Navbar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"page-content\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"page-header\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                        className: \"page-title flex items-center gap-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                                className: \"text-sky-400\",\n                                                size: 28\n                                            }, void 0, false, {\n                                                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                                lineNumber: 59,\n                                                columnNumber: 17\n                                            }, this),\n                                            \"Voice Agents\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                        lineNumber: 58,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"page-subtitle\",\n                                        children: \"Select an agent to start a voice conversation\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                            lineNumber: 56,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 55,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-6\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"relative max-w-md\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                    className: \"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400\",\n                                    size: 20\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                    lineNumber: 72,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    placeholder: \"Search agents...\",\n                                    value: searchQuery,\n                                    onChange: (e)=>setSearchQuery(e.target.value),\n                                    className: \"input pl-12\"\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                    lineNumber: 73,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                            lineNumber: 71,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 9\n                    }, this),\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center justify-center py-16\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"spinner w-10 h-10\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                            lineNumber: 86,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 85,\n                        columnNumber: 11\n                    }, this) : filteredAgents.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"empty-state\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-16 h-16 bg-slate-800 rounded-2xl flex items-center justify-center mx-auto mb-4\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Search_Sparkles_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                    className: \"empty-state-icon\",\n                                    size: 32\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                lineNumber: 90,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"empty-state-text\",\n                                children: searchQuery ? \"No agents match your search\" : \"No agents available\"\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                lineNumber: 93,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 89,\n                        columnNumber: 11\n                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid-cards\",\n                        children: filteredAgents.map((agent)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AgentCard__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                agent: agent,\n                                onCall: setActiveCall\n                            }, agent.id, false, {\n                                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                                lineNumber: 100,\n                                columnNumber: 15\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                        lineNumber: 98,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/runner/workspace/src/app/page.tsx\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/runner/workspace/src/app/page.tsx\",\n        lineNumber: 50,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"nQp2ahaUuQsq5edwMQrTY8F1i2M=\");\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRTJDO0FBQ0g7QUFDTTtBQUNBO0FBRVE7QUFFdkMsU0FBU1E7O0lBQ3RCLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHVCwrQ0FBUUEsQ0FBVSxFQUFFO0lBQ2hELE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNZLFlBQVlDLGNBQWMsR0FBR2IsK0NBQVFBLENBQWU7SUFDM0QsTUFBTSxDQUFDYyxhQUFhQyxlQUFlLEdBQUdmLCtDQUFRQSxDQUFDO0lBRS9DRCxnREFBU0EsQ0FBQztRQUNSaUI7SUFDRixHQUFHLEVBQUU7SUFFTCxlQUFlQTtRQUNiLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU07WUFDN0IsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBQ2hDWCxVQUFVVSxLQUFLRSxNQUFNLENBQUMsQ0FBQ0MsSUFBYUEsRUFBRUMsTUFBTSxLQUFLO1FBQ25ELEVBQUUsT0FBT0MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtRQUMzQyxTQUFVO1lBQ1JiLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTWUsaUJBQWlCbEIsT0FBT2EsTUFBTSxDQUNsQyxDQUFDTSxRQUNDQSxNQUFNQyxXQUFXLENBQUNDLFdBQVcsR0FBR0MsUUFBUSxDQUFDaEIsWUFBWWUsV0FBVyxPQUNoRUYsTUFBTUksV0FBVyxDQUFDRixXQUFXLEdBQUdDLFFBQVEsQ0FBQ2hCLFlBQVllLFdBQVc7SUFHcEUsSUFBSWpCLFlBQVk7UUFDZCxxQkFDRSw4REFBQ29CO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDaEMsMERBQU1BOzs7Ozs4QkFDUCw4REFBQytCO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDOUIsNkRBQVNBO3dCQUFDd0IsT0FBT2Y7d0JBQVlzQixPQUFPLElBQU1yQixjQUFjOzs7Ozs7Ozs7Ozs7Ozs7OztJQUlqRTtJQUVBLHFCQUNFLDhEQUFDbUI7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNoQywwREFBTUE7Ozs7OzBCQUVQLDhEQUFDa0M7Z0JBQUtGLFdBQVU7O2tDQUVkLDhEQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0Q7NEJBQUlDLFdBQVU7c0NBQ2IsNEVBQUNEOztrREFDQyw4REFBQ0k7d0NBQUdILFdBQVU7OzBEQUNaLDhEQUFDM0IsaUdBQVFBO2dEQUFDMkIsV0FBVTtnREFBZUksTUFBTTs7Ozs7OzRDQUFNOzs7Ozs7O2tEQUdqRCw4REFBQ0M7d0NBQUVMLFdBQVU7a0RBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQVFuQyw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQzVCLGlHQUFNQTtvQ0FBQzRCLFdBQVU7b0NBQTBESSxNQUFNOzs7Ozs7OENBQ2xGLDhEQUFDRTtvQ0FDQ0MsTUFBSztvQ0FDTEMsYUFBWTtvQ0FDWkMsT0FBTzVCO29DQUNQNkIsVUFBVSxDQUFDQyxJQUFNN0IsZUFBZTZCLEVBQUVDLE1BQU0sQ0FBQ0gsS0FBSztvQ0FDOUNULFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU1mdkIsd0JBQ0MsOERBQUNzQjt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0Q7NEJBQUlDLFdBQVU7Ozs7Ozs7Ozs7K0JBRWZQLGVBQWVvQixNQUFNLEtBQUssa0JBQzVCLDhEQUFDZDt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNEO2dDQUFJQyxXQUFVOzBDQUNiLDRFQUFDN0IsaUdBQUtBO29DQUFDNkIsV0FBVTtvQ0FBbUJJLE1BQU07Ozs7Ozs7Ozs7OzBDQUU1Qyw4REFBQ0M7Z0NBQUVMLFdBQVU7MENBQ1ZuQixjQUFjLGdDQUFnQzs7Ozs7Ozs7Ozs7NkNBSW5ELDhEQUFDa0I7d0JBQUlDLFdBQVU7a0NBQ1pQLGVBQWVxQixHQUFHLENBQUMsQ0FBQ3BCLHNCQUNuQiw4REFBQ3pCLDZEQUFTQTtnQ0FFUnlCLE9BQU9BO2dDQUNQcUIsUUFBUW5DOytCQUZIYyxNQUFNc0IsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVU3QjtHQXJHd0IxQztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3BhZ2UudHN4P2Y2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBOYXZiYXIgZnJvbSAnQC9jb21wb25lbnRzL05hdmJhcidcbmltcG9ydCBBZ2VudENhcmQgZnJvbSAnQC9jb21wb25lbnRzL0FnZW50Q2FyZCdcbmltcG9ydCBWb2ljZUNhbGwgZnJvbSAnQC9jb21wb25lbnRzL1ZvaWNlQ2FsbCdcbmltcG9ydCB7IEFnZW50IH0gZnJvbSAnQC90eXBlcy9hZ2VudCdcbmltcG9ydCB7IFBob25lLCBTZWFyY2gsIFNwYXJrbGVzIH0gZnJvbSAnbHVjaWRlLXJlYWN0J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lUGFnZSgpIHtcbiAgY29uc3QgW2FnZW50cywgc2V0QWdlbnRzXSA9IHVzZVN0YXRlPEFnZW50W10+KFtdKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbYWN0aXZlQ2FsbCwgc2V0QWN0aXZlQ2FsbF0gPSB1c2VTdGF0ZTxBZ2VudCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGUoJycpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaEFnZW50cygpXG4gIH0sIFtdKVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQWdlbnRzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2FnZW50cycpXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICBzZXRBZ2VudHMoZGF0YS5maWx0ZXIoKGE6IEFnZW50KSA9PiBhLnN0YXR1cyA9PT0gJ2FjdGl2ZScpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWdlbnRzOicsIGVycm9yKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbHRlcmVkQWdlbnRzID0gYWdlbnRzLmZpbHRlcihcbiAgICAoYWdlbnQpID0+XG4gICAgICBhZ2VudC5kaXNwbGF5TmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBhZ2VudC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCkpXG4gIClcblxuICBpZiAoYWN0aXZlQ2FsbCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInBhZ2UtY29udGFpbmVyXCI+XG4gICAgICAgIDxOYXZiYXIgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgZmxleFwiPlxuICAgICAgICAgIDxWb2ljZUNhbGwgYWdlbnQ9e2FjdGl2ZUNhbGx9IG9uRW5kPXsoKSA9PiBzZXRBY3RpdmVDYWxsKG51bGwpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwYWdlLWNvbnRhaW5lclwiPlxuICAgICAgPE5hdmJhciAvPlxuXG4gICAgICA8bWFpbiBjbGFzc05hbWU9XCJwYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYWdlLWhlYWRlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzbTpmbGV4LXJvdyBzbTppdGVtcy1jZW50ZXIgc206anVzdGlmeS1iZXR3ZWVuIGdhcC00XCI+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwicGFnZS10aXRsZSBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtM1wiPlxuICAgICAgICAgICAgICAgIDxTcGFya2xlcyBjbGFzc05hbWU9XCJ0ZXh0LXNreS00MDBcIiBzaXplPXsyOH0gLz5cbiAgICAgICAgICAgICAgICBWb2ljZSBBZ2VudHNcbiAgICAgICAgICAgICAgPC9oMT5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwicGFnZS1zdWJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgIFNlbGVjdCBhbiBhZ2VudCB0byBzdGFydCBhIHZvaWNlIGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIFNlYXJjaCAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBtYXgtdy1tZFwiPlxuICAgICAgICAgICAgPFNlYXJjaCBjbGFzc05hbWU9XCJhYnNvbHV0ZSBsZWZ0LTQgdG9wLTEvMiAtdHJhbnNsYXRlLXktMS8yIHRleHQtc2xhdGUtNDAwXCIgc2l6ZT17MjB9IC8+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaCBhZ2VudHMuLi5cIlxuICAgICAgICAgICAgICB2YWx1ZT17c2VhcmNoUXVlcnl9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0U2VhcmNoUXVlcnkoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dCBwbC0xMlwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7LyogQ29udGVudCAqL31cbiAgICAgICAge2xvYWRpbmcgPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweS0xNlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyIHctMTAgaC0xMFwiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkgOiBmaWx0ZXJlZEFnZW50cy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbXB0eS1zdGF0ZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTE2IGgtMTYgYmctc2xhdGUtODAwIHJvdW5kZWQtMnhsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG14LWF1dG8gbWItNFwiPlxuICAgICAgICAgICAgICA8UGhvbmUgY2xhc3NOYW1lPVwiZW1wdHktc3RhdGUtaWNvblwiIHNpemU9ezMyfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJlbXB0eS1zdGF0ZS10ZXh0XCI+XG4gICAgICAgICAgICAgIHtzZWFyY2hRdWVyeSA/ICdObyBhZ2VudHMgbWF0Y2ggeW91ciBzZWFyY2gnIDogJ05vIGFnZW50cyBhdmFpbGFibGUnfVxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZC1jYXJkc1wiPlxuICAgICAgICAgICAge2ZpbHRlcmVkQWdlbnRzLm1hcCgoYWdlbnQpID0+IChcbiAgICAgICAgICAgICAgPEFnZW50Q2FyZFxuICAgICAgICAgICAgICAgIGtleT17YWdlbnQuaWR9XG4gICAgICAgICAgICAgICAgYWdlbnQ9e2FnZW50fVxuICAgICAgICAgICAgICAgIG9uQ2FsbD17c2V0QWN0aXZlQ2FsbH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9tYWluPlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJOYXZiYXIiLCJBZ2VudENhcmQiLCJWb2ljZUNhbGwiLCJQaG9uZSIsIlNlYXJjaCIsIlNwYXJrbGVzIiwiSG9tZVBhZ2UiLCJhZ2VudHMiLCJzZXRBZ2VudHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImFjdGl2ZUNhbGwiLCJzZXRBY3RpdmVDYWxsIiwic2VhcmNoUXVlcnkiLCJzZXRTZWFyY2hRdWVyeSIsImZldGNoQWdlbnRzIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiZmlsdGVyIiwiYSIsInN0YXR1cyIsImVycm9yIiwiY29uc29sZSIsImZpbHRlcmVkQWdlbnRzIiwiYWdlbnQiLCJkaXNwbGF5TmFtZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJkZXNjcmlwdGlvbiIsImRpdiIsImNsYXNzTmFtZSIsIm9uRW5kIiwibWFpbiIsImgxIiwic2l6ZSIsInAiLCJpbnB1dCIsInR5cGUiLCJwbGFjZWhvbGRlciIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwibGVuZ3RoIiwibWFwIiwib25DYWxsIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/AgentCard.tsx":
/*!**************************************!*\
  !*** ./src/components/AgentCard.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AgentCard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Settings,Trash2,Volume2!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Settings,Trash2,Volume2!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trash-2.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Settings,Trash2,Volume2!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js\");\n/* harmony import */ var _barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Phone,Settings,Trash2,Volume2!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nfunction AgentCard(param) {\n    let { agent, onCall, onEdit, onDelete, showAdminControls = false } = param;\n    const statusConfig = {\n        active: {\n            class: \"badge-success\",\n            label: \"Active\"\n        },\n        inactive: {\n            class: \"badge-danger\",\n            label: \"Inactive\"\n        },\n        draft: {\n            class: \"badge-warning\",\n            label: \"Draft\"\n        }\n    };\n    const status = statusConfig[agent.status];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"card card-hover p-5 sm:p-6 flex flex-col h-full animate-fade-in\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-start justify-between gap-3 mb-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 min-w-0\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"text-lg font-semibold text-white truncate mb-1\",\n                                children: agent.displayName\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                lineNumber: 34,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: status.class,\n                                children: status.label\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                lineNumber: 37,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, this),\n                    showAdminControls && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-1 flex-shrink-0\",\n                        children: [\n                            onEdit && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>onEdit(agent),\n                                className: \"btn-icon\",\n                                \"aria-label\": \"Edit agent\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                    size: 18\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                    lineNumber: 47,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                lineNumber: 42,\n                                columnNumber: 15\n                            }, this),\n                            onDelete && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>onDelete(agent),\n                                className: \"btn-icon hover:!text-red-400\",\n                                \"aria-label\": \"Delete agent\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    size: 18\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                    lineNumber: 56,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                                lineNumber: 51,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 40,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                lineNumber: 32,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-slate-400 text-sm mb-4 line-clamp-2 flex-1\",\n                children: agent.description || \"No description provided\"\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-2 text-sm text-slate-500 mb-5\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        size: 14\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"capitalize\",\n                        children: agent.voice\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                lineNumber: 69,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>onCall(agent),\n                disabled: agent.status !== \"active\",\n                className: \"btn-primary w-full\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Phone_Settings_Trash2_Volume2_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        size: 18\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 80,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        children: \"Start Call\"\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                        lineNumber: 81,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n                lineNumber: 75,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/runner/workspace/src/components/AgentCard.tsx\",\n        lineNumber: 30,\n        columnNumber: 5\n    }, this);\n}\n_c = AgentCard;\nvar _c;\n$RefreshReg$(_c, \"AgentCard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0FnZW50Q2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUUrRDtBQVdoRCxTQUFTSSxVQUFVLEtBTWpCO1FBTmlCLEVBQ2hDQyxLQUFLLEVBQ0xDLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxRQUFRLEVBQ1JDLG9CQUFvQixLQUFLLEVBQ1YsR0FOaUI7SUFPaEMsTUFBTUMsZUFBZTtRQUNuQkMsUUFBUTtZQUFFQyxPQUFPO1lBQWlCQyxPQUFPO1FBQVM7UUFDbERDLFVBQVU7WUFBRUYsT0FBTztZQUFnQkMsT0FBTztRQUFXO1FBQ3JERSxPQUFPO1lBQUVILE9BQU87WUFBaUJDLE9BQU87UUFBUTtJQUNsRDtJQUVBLE1BQU1HLFNBQVNOLFlBQVksQ0FBQ0wsTUFBTVcsTUFBTSxDQUFDO0lBRXpDLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFFYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRDt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNDO2dDQUFHRCxXQUFVOzBDQUNYYixNQUFNZSxXQUFXOzs7Ozs7MENBRXBCLDhEQUFDQztnQ0FBS0gsV0FBV0YsT0FBT0osS0FBSzswQ0FBR0ksT0FBT0gsS0FBSzs7Ozs7Ozs7Ozs7O29CQUU3Q0osbUNBQ0MsOERBQUNRO3dCQUFJQyxXQUFVOzs0QkFDWlgsd0JBQ0MsOERBQUNlO2dDQUNDQyxTQUFTLElBQU1oQixPQUFPRjtnQ0FDdEJhLFdBQVU7Z0NBQ1ZNLGNBQVc7MENBRVgsNEVBQUN2Qix5R0FBUUE7b0NBQUN3QixNQUFNOzs7Ozs7Ozs7Ozs0QkFHbkJqQiwwQkFDQyw4REFBQ2M7Z0NBQ0NDLFNBQVMsSUFBTWYsU0FBU0g7Z0NBQ3hCYSxXQUFVO2dDQUNWTSxjQUFXOzBDQUVYLDRFQUFDdEIseUdBQU1BO29DQUFDdUIsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUXhCLDhEQUFDQztnQkFBRVIsV0FBVTswQkFDVmIsTUFBTXNCLFdBQVcsSUFBSTs7Ozs7OzBCQUl4Qiw4REFBQ1Y7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDZix5R0FBT0E7d0JBQUNzQixNQUFNOzs7Ozs7a0NBQ2YsOERBQUNKO3dCQUFLSCxXQUFVO2tDQUFjYixNQUFNdUIsS0FBSzs7Ozs7Ozs7Ozs7OzBCQUkzQyw4REFBQ047Z0JBQ0NDLFNBQVMsSUFBTWpCLE9BQU9EO2dCQUN0QndCLFVBQVV4QixNQUFNVyxNQUFNLEtBQUs7Z0JBQzNCRSxXQUFVOztrQ0FFViw4REFBQ2xCLHlHQUFLQTt3QkFBQ3lCLE1BQU07Ozs7OztrQ0FDYiw4REFBQ0o7a0NBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlkO0tBdkV3QmpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0FnZW50Q2FyZC50c3g/NWZjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgUGhvbmUsIFNldHRpbmdzLCBUcmFzaDIsIFZvbHVtZTIgfSBmcm9tICdsdWNpZGUtcmVhY3QnXG5pbXBvcnQgeyBBZ2VudCB9IGZyb20gJ0AvdHlwZXMvYWdlbnQnXG5cbmludGVyZmFjZSBBZ2VudENhcmRQcm9wcyB7XG4gIGFnZW50OiBBZ2VudFxuICBvbkNhbGw6IChhZ2VudDogQWdlbnQpID0+IHZvaWRcbiAgb25FZGl0PzogKGFnZW50OiBBZ2VudCkgPT4gdm9pZFxuICBvbkRlbGV0ZT86IChhZ2VudDogQWdlbnQpID0+IHZvaWRcbiAgc2hvd0FkbWluQ29udHJvbHM/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFnZW50Q2FyZCh7XG4gIGFnZW50LFxuICBvbkNhbGwsXG4gIG9uRWRpdCxcbiAgb25EZWxldGUsXG4gIHNob3dBZG1pbkNvbnRyb2xzID0gZmFsc2UsXG59OiBBZ2VudENhcmRQcm9wcykge1xuICBjb25zdCBzdGF0dXNDb25maWcgPSB7XG4gICAgYWN0aXZlOiB7IGNsYXNzOiAnYmFkZ2Utc3VjY2VzcycsIGxhYmVsOiAnQWN0aXZlJyB9LFxuICAgIGluYWN0aXZlOiB7IGNsYXNzOiAnYmFkZ2UtZGFuZ2VyJywgbGFiZWw6ICdJbmFjdGl2ZScgfSxcbiAgICBkcmFmdDogeyBjbGFzczogJ2JhZGdlLXdhcm5pbmcnLCBsYWJlbDogJ0RyYWZ0JyB9LFxuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhdHVzQ29uZmlnW2FnZW50LnN0YXR1c11cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBjYXJkLWhvdmVyIHAtNSBzbTpwLTYgZmxleCBmbGV4LWNvbCBoLWZ1bGwgYW5pbWF0ZS1mYWRlLWluXCI+XG4gICAgICB7LyogSGVhZGVyICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLXN0YXJ0IGp1c3RpZnktYmV0d2VlbiBnYXAtMyBtYi00XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG1pbi13LTBcIj5cbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgdHJ1bmNhdGUgbWItMVwiPlxuICAgICAgICAgICAge2FnZW50LmRpc3BsYXlOYW1lfVxuICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdGF0dXMuY2xhc3N9PntzdGF0dXMubGFiZWx9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAge3Nob3dBZG1pbkNvbnRyb2xzICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTEgZmxleC1zaHJpbmstMFwiPlxuICAgICAgICAgICAge29uRWRpdCAmJiAoXG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkVkaXQoYWdlbnQpfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1pY29uXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiRWRpdCBhZ2VudFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8U2V0dGluZ3Mgc2l6ZT17MTh9IC8+XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtvbkRlbGV0ZSAmJiAoXG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkRlbGV0ZShhZ2VudCl9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLWljb24gaG92ZXI6IXRleHQtcmVkLTQwMFwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkRlbGV0ZSBhZ2VudFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8VHJhc2gyIHNpemU9ezE4fSAvPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIERlc2NyaXB0aW9uICovfVxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS00MDAgdGV4dC1zbSBtYi00IGxpbmUtY2xhbXAtMiBmbGV4LTFcIj5cbiAgICAgICAge2FnZW50LmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBwcm92aWRlZCd9XG4gICAgICA8L3A+XG5cbiAgICAgIHsvKiBWb2ljZSBpbmZvICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiB0ZXh0LXNtIHRleHQtc2xhdGUtNTAwIG1iLTVcIj5cbiAgICAgICAgPFZvbHVtZTIgc2l6ZT17MTR9IC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcGl0YWxpemVcIj57YWdlbnQudm9pY2V9PC9zcGFuPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBBY3Rpb24gYnV0dG9uICovfVxuICAgICAgPGJ1dHRvblxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkNhbGwoYWdlbnQpfVxuICAgICAgICBkaXNhYmxlZD17YWdlbnQuc3RhdHVzICE9PSAnYWN0aXZlJ31cbiAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgdy1mdWxsXCJcbiAgICAgID5cbiAgICAgICAgPFBob25lIHNpemU9ezE4fSAvPlxuICAgICAgICA8c3Bhbj5TdGFydCBDYWxsPC9zcGFuPlxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJQaG9uZSIsIlNldHRpbmdzIiwiVHJhc2gyIiwiVm9sdW1lMiIsIkFnZW50Q2FyZCIsImFnZW50Iiwib25DYWxsIiwib25FZGl0Iiwib25EZWxldGUiLCJzaG93QWRtaW5Db250cm9scyIsInN0YXR1c0NvbmZpZyIsImFjdGl2ZSIsImNsYXNzIiwibGFiZWwiLCJpbmFjdGl2ZSIsImRyYWZ0Iiwic3RhdHVzIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDMiLCJkaXNwbGF5TmFtZSIsInNwYW4iLCJidXR0b24iLCJvbkNsaWNrIiwiYXJpYS1sYWJlbCIsInNpemUiLCJwIiwiZGVzY3JpcHRpb24iLCJ2b2ljZSIsImRpc2FibGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/AgentCard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Navbar.tsx":
/*!***********************************!*\
  !*** ./src/components/Navbar.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Navbar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/bot.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/users.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/sparkles.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Bot,Menu,Phone,Sparkles,Users,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst links = [\n    {\n        href: \"/\",\n        label: \"Call Agents\",\n        icon: _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    },\n    {\n        href: \"/admin\",\n        label: \"Agents\",\n        icon: _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n    },\n    {\n        href: \"/admin/users\",\n        label: \"Users\",\n        icon: _barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\n    }\n];\nfunction Navbar() {\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname)();\n    const [mobileMenuOpen, setMobileMenuOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: \"bg-slate-900/80 backdrop-blur-xl border-b border-slate-800/50 sticky top-0 z-50\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between h-16\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            href: \"/\",\n                            className: \"flex items-center gap-3 group\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-10 h-10 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-xl flex items-center justify-center shadow-lg shadow-sky-500/25 group-hover:shadow-sky-500/40 transition-shadow\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                        size: 20,\n                                        className: \"text-white\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                        lineNumber: 25,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                    lineNumber: 24,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"font-bold text-xl hidden sm:block bg-gradient-to-r from-white to-slate-300 bg-clip-text text-transparent\",\n                                    children: \"VoiceAgent\"\n                                }, void 0, false, {\n                                    fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                    lineNumber: 27,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"hidden md:flex items-center gap-1\",\n                            children: links.map((link)=>{\n                                const Icon = link.icon;\n                                const isActive = pathname === link.href;\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    href: link.href,\n                                    className: \"flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 \".concat(isActive ? \"bg-sky-500/20 text-sky-400 shadow-inner\" : \"text-slate-400 hover:text-white hover:bg-slate-800/50\"),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Icon, {\n                                            size: 18\n                                        }, void 0, false, {\n                                            fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                            lineNumber: 47,\n                                            columnNumber: 19\n                                        }, this),\n                                        link.label\n                                    ]\n                                }, link.href, true, {\n                                    fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                    lineNumber: 38,\n                                    columnNumber: 17\n                                }, this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                            lineNumber: 33,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: ()=>setMobileMenuOpen(!mobileMenuOpen),\n                            className: \"md:hidden btn-icon\",\n                            \"aria-label\": \"Toggle menu\",\n                            children: mobileMenuOpen ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                size: 22\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 31\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bot_Menu_Phone_Sparkles_Users_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                size: 22\n                            }, void 0, false, {\n                                fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 49\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                            lineNumber: 55,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                    lineNumber: 21,\n                    columnNumber: 9\n                }, this),\n                mobileMenuOpen && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"md:hidden py-4 border-t border-slate-800/50 animate-slide-down\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col gap-1\",\n                        children: links.map((link)=>{\n                            const Icon = link.icon;\n                            const isActive = pathname === link.href;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                href: link.href,\n                                onClick: ()=>setMobileMenuOpen(false),\n                                className: \"flex items-center gap-3 px-4 py-3 rounded-xl text-sm font-medium transition-all \".concat(isActive ? \"bg-sky-500/20 text-sky-400\" : \"text-slate-400 hover:text-white hover:bg-slate-800/50\"),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Icon, {\n                                        size: 20\n                                    }, void 0, false, {\n                                        fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                        lineNumber: 82,\n                                        columnNumber: 21\n                                    }, this),\n                                    link.label\n                                ]\n                            }, link.href, true, {\n                                fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 19\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                        lineNumber: 67,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n                    lineNumber: 66,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n            lineNumber: 20,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/runner/workspace/src/components/Navbar.tsx\",\n        lineNumber: 19,\n        columnNumber: 5\n    }, this);\n}\n_s(Navbar, \"FIkGCiZnrKK5dgKLT9oC7ZzKVWM=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname\n    ];\n});\n_c = Navbar;\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05hdmJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFZ0M7QUFDSjtBQUNpQjtBQUNzQjtBQUVuRSxNQUFNUyxRQUFRO0lBQ1o7UUFBRUMsTUFBTTtRQUFLQyxPQUFPO1FBQWVDLE1BQU1ULDJHQUFLQTtJQUFDO0lBQy9DO1FBQUVPLE1BQU07UUFBVUMsT0FBTztRQUFVQyxNQUFNUiwyR0FBR0E7SUFBQztJQUM3QztRQUFFTSxNQUFNO1FBQWdCQyxPQUFPO1FBQVNDLE1BQU1QLDJHQUFLQTtJQUFDO0NBQ3JEO0FBRWMsU0FBU1E7O0lBQ3RCLE1BQU1DLFdBQVdaLDREQUFXQTtJQUM1QixNQUFNLENBQUNhLGdCQUFnQkMsa0JBQWtCLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUVyRCxxQkFDRSw4REFBQ2lCO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNDO1lBQUlELFdBQVU7OzhCQUNiLDhEQUFDQztvQkFBSUQsV0FBVTs7c0NBRWIsOERBQUNqQixpREFBSUE7NEJBQUNTLE1BQUs7NEJBQUlRLFdBQVU7OzhDQUN2Qiw4REFBQ0M7b0NBQUlELFdBQVU7OENBQ2IsNEVBQUNWLDJHQUFRQTt3Q0FBQ1ksTUFBTTt3Q0FBSUYsV0FBVTs7Ozs7Ozs7Ozs7OENBRWhDLDhEQUFDRztvQ0FBS0gsV0FBVTs4Q0FBMkc7Ozs7Ozs7Ozs7OztzQ0FNN0gsOERBQUNDOzRCQUFJRCxXQUFVO3NDQUNaVCxNQUFNYSxHQUFHLENBQUMsQ0FBQ0M7Z0NBQ1YsTUFBTUMsT0FBT0QsS0FBS1gsSUFBSTtnQ0FDdEIsTUFBTWEsV0FBV1gsYUFBYVMsS0FBS2IsSUFBSTtnQ0FDdkMscUJBQ0UsOERBQUNULGlEQUFJQTtvQ0FFSFMsTUFBTWEsS0FBS2IsSUFBSTtvQ0FDZlEsV0FBVyxnR0FJVixPQUhDTyxXQUNJLDRDQUNBOztzREFHTiw4REFBQ0Q7NENBQUtKLE1BQU07Ozs7Ozt3Q0FDWEcsS0FBS1osS0FBSzs7bUNBVE5ZLEtBQUtiLElBQUk7Ozs7OzRCQVlwQjs7Ozs7O3NDQUlGLDhEQUFDZ0I7NEJBQ0NDLFNBQVMsSUFBTVgsa0JBQWtCLENBQUNEOzRCQUNsQ0csV0FBVTs0QkFDVlUsY0FBVztzQ0FFVmIsK0JBQWlCLDhEQUFDUiwyR0FBQ0E7Z0NBQUNhLE1BQU07Ozs7O3FEQUFTLDhEQUFDZCwyR0FBSUE7Z0NBQUNjLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUtuREwsZ0NBQ0MsOERBQUNJO29CQUFJRCxXQUFVOzhCQUNiLDRFQUFDQzt3QkFBSUQsV0FBVTtrQ0FDWlQsTUFBTWEsR0FBRyxDQUFDLENBQUNDOzRCQUNWLE1BQU1DLE9BQU9ELEtBQUtYLElBQUk7NEJBQ3RCLE1BQU1hLFdBQVdYLGFBQWFTLEtBQUtiLElBQUk7NEJBQ3ZDLHFCQUNFLDhEQUFDVCxpREFBSUE7Z0NBRUhTLE1BQU1hLEtBQUtiLElBQUk7Z0NBQ2ZpQixTQUFTLElBQU1YLGtCQUFrQjtnQ0FDakNFLFdBQVcsbUZBSVYsT0FIQ08sV0FDSSwrQkFDQTs7a0RBR04sOERBQUNEO3dDQUFLSixNQUFNOzs7Ozs7b0NBQ1hHLEtBQUtaLEtBQUs7OytCQVZOWSxLQUFLYixJQUFJOzs7Ozt3QkFhcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPZDtHQS9Fd0JHOztRQUNMWCx3REFBV0E7OztLQUROVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9OYXZiYXIudHN4PzlhNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXG5pbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcbmltcG9ydCB7IFBob25lLCBCb3QsIFVzZXJzLCBNZW51LCBYLCBTcGFya2xlcyB9IGZyb20gJ2x1Y2lkZS1yZWFjdCdcblxuY29uc3QgbGlua3MgPSBbXG4gIHsgaHJlZjogJy8nLCBsYWJlbDogJ0NhbGwgQWdlbnRzJywgaWNvbjogUGhvbmUgfSxcbiAgeyBocmVmOiAnL2FkbWluJywgbGFiZWw6ICdBZ2VudHMnLCBpY29uOiBCb3QgfSxcbiAgeyBocmVmOiAnL2FkbWluL3VzZXJzJywgbGFiZWw6ICdVc2VycycsIGljb246IFVzZXJzIH0sXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5hdmJhcigpIHtcbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpXG4gIGNvbnN0IFttb2JpbGVNZW51T3Blbiwgc2V0TW9iaWxlTWVudU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgcmV0dXJuIChcbiAgICA8bmF2IGNsYXNzTmFtZT1cImJnLXNsYXRlLTkwMC84MCBiYWNrZHJvcC1ibHVyLXhsIGJvcmRlci1iIGJvcmRlci1zbGF0ZS04MDAvNTAgc3RpY2t5IHRvcC0wIHotNTBcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctN3hsIG14LWF1dG8gcHgtNCBzbTpweC02IGxnOnB4LThcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gaC0xNlwiPlxuICAgICAgICAgIHsvKiBMb2dvICovfVxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCIgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgZ3JvdXBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0xMCBoLTEwIGJnLWdyYWRpZW50LXRvLWJyIGZyb20tc2t5LTUwMCB0by1jeWFuLTUwMCByb3VuZGVkLXhsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHNoYWRvdy1sZyBzaGFkb3ctc2t5LTUwMC8yNSBncm91cC1ob3ZlcjpzaGFkb3ctc2t5LTUwMC80MCB0cmFuc2l0aW9uLXNoYWRvd1wiPlxuICAgICAgICAgICAgICA8U3BhcmtsZXMgc2l6ZT17MjB9IGNsYXNzTmFtZT1cInRleHQtd2hpdGVcIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGQgdGV4dC14bCBoaWRkZW4gc206YmxvY2sgYmctZ3JhZGllbnQtdG8tciBmcm9tLXdoaXRlIHRvLXNsYXRlLTMwMCBiZy1jbGlwLXRleHQgdGV4dC10cmFuc3BhcmVudFwiPlxuICAgICAgICAgICAgICBWb2ljZUFnZW50XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9MaW5rPlxuXG4gICAgICAgICAgey8qIERlc2t0b3AgTmF2aWdhdGlvbiAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiBtZDpmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMVwiPlxuICAgICAgICAgICAge2xpbmtzLm1hcCgobGluaykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBJY29uID0gbGluay5pY29uXG4gICAgICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gcGF0aG5hbWUgPT09IGxpbmsuaHJlZlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICAgICAgICBrZXk9e2xpbmsuaHJlZn1cbiAgICAgICAgICAgICAgICAgIGhyZWY9e2xpbmsuaHJlZn1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHB4LTQgcHktMiByb3VuZGVkLXhsIHRleHQtc20gZm9udC1tZWRpdW0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwICR7XG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYmctc2t5LTUwMC8yMCB0ZXh0LXNreS00MDAgc2hhZG93LWlubmVyJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3RleHQtc2xhdGUtNDAwIGhvdmVyOnRleHQtd2hpdGUgaG92ZXI6Ymctc2xhdGUtODAwLzUwJ1xuICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPEljb24gc2l6ZT17MTh9IC8+XG4gICAgICAgICAgICAgICAgICB7bGluay5sYWJlbH1cbiAgICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIE1vYmlsZSBNZW51IEJ1dHRvbiAqL31cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNb2JpbGVNZW51T3BlbighbW9iaWxlTWVudU9wZW4pfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWQ6aGlkZGVuIGJ0bi1pY29uXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJUb2dnbGUgbWVudVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge21vYmlsZU1lbnVPcGVuID8gPFggc2l6ZT17MjJ9IC8+IDogPE1lbnUgc2l6ZT17MjJ9IC8+fVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7LyogTW9iaWxlIE5hdmlnYXRpb24gKi99XG4gICAgICAgIHttb2JpbGVNZW51T3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZDpoaWRkZW4gcHktNCBib3JkZXItdCBib3JkZXItc2xhdGUtODAwLzUwIGFuaW1hdGUtc2xpZGUtZG93blwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0xXCI+XG4gICAgICAgICAgICAgIHtsaW5rcy5tYXAoKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBJY29uID0gbGluay5pY29uXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBwYXRobmFtZSA9PT0gbGluay5ocmVmXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICAgICAgICAgIGtleT17bGluay5ocmVmfVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtsaW5rLmhyZWZ9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE1vYmlsZU1lbnVPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgcHgtNCBweS0zIHJvdW5kZWQteGwgdGV4dC1zbSBmb250LW1lZGl1bSB0cmFuc2l0aW9uLWFsbCAke1xuICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1za3ktNTAwLzIwIHRleHQtc2t5LTQwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RleHQtc2xhdGUtNDAwIGhvdmVyOnRleHQtd2hpdGUgaG92ZXI6Ymctc2xhdGUtODAwLzUwJ1xuICAgICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPEljb24gc2l6ZT17MjB9IC8+XG4gICAgICAgICAgICAgICAgICAgIHtsaW5rLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvbmF2PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJMaW5rIiwidXNlUGF0aG5hbWUiLCJQaG9uZSIsIkJvdCIsIlVzZXJzIiwiTWVudSIsIlgiLCJTcGFya2xlcyIsImxpbmtzIiwiaHJlZiIsImxhYmVsIiwiaWNvbiIsIk5hdmJhciIsInBhdGhuYW1lIiwibW9iaWxlTWVudU9wZW4iLCJzZXRNb2JpbGVNZW51T3BlbiIsIm5hdiIsImNsYXNzTmFtZSIsImRpdiIsInNpemUiLCJzcGFuIiwibWFwIiwibGluayIsIkljb24iLCJpc0FjdGl2ZSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJhcmlhLWxhYmVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Navbar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/VoiceCall.tsx":
/*!**************************************!*\
  !*** ./src/components/VoiceCall.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ VoiceCall; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-yU-srrIO.mjs\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-DuRBtGp8.mjs\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs\");\n/* harmony import */ var _livekit_components_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @livekit/components-styles */ \"(app-pages-browser)/./node_modules/@livekit/components-styles/dist/general/index.css\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,Loader2,Mic,MicOff,PhoneOff!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic-off.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,Loader2,Mic,MicOff,PhoneOff!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mic.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,Loader2,Mic,MicOff,PhoneOff!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/phone-off.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,Loader2,Mic,MicOff,PhoneOff!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,Loader2,Mic,MicOff,PhoneOff!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/loader-circle.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\nfunction AgentVisualizer() {\n    _s();\n    const { state, audioTrack } = (0,_livekit_components_react__WEBPACK_IMPORTED_MODULE_3__.X)();\n    const stateLabels = {\n        listening: \"Listening...\",\n        thinking: \"Thinking...\",\n        speaking: \"Speaking...\",\n        idle: \"Ready\",\n        connecting: \"Connecting...\"\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center gap-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"badge-info text-sm px-4 py-2\",\n                children: stateLabels[state] || state\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 33,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"h-32 sm:h-40 w-full max-w-xs\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.B, {\n                    state: state,\n                    trackRef: audioTrack,\n                    barCount: 7,\n                    options: {\n                        minHeight: 10\n                    }\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 37,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n        lineNumber: 32,\n        columnNumber: 5\n    }, this);\n}\n_s(AgentVisualizer, \"j4tAc3C/JJbHjgL3PIoaZKEQa5E=\", false, function() {\n    return [\n        _livekit_components_react__WEBPACK_IMPORTED_MODULE_3__.X\n    ];\n});\n_c = AgentVisualizer;\nfunction CallControls(param) {\n    let { onDisconnect } = param;\n    _s1();\n    const [isMuted, setIsMuted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-center gap-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>setIsMuted(!isMuted),\n                className: \"p-4 sm:p-5 rounded-2xl transition-all duration-200 \".concat(isMuted ? \"bg-red-500 hover:bg-red-600 shadow-lg shadow-red-500/30\" : \"bg-slate-700 hover:bg-slate-600\"),\n                \"aria-label\": isMuted ? \"Unmute\" : \"Mute\",\n                children: isMuted ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                    size: 24\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 62,\n                    columnNumber: 20\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    size: 24\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 62,\n                    columnNumber: 43\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.D, {\n                onClick: onDisconnect,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-4 sm:p-5 rounded-2xl bg-red-500 hover:bg-red-600 transition-all duration-200 cursor-pointer shadow-lg shadow-red-500/30\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                        size: 24\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 65,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n        lineNumber: 52,\n        columnNumber: 5\n    }, this);\n}\n_s1(CallControls, \"X5OQ1lfso32t+hl9x/r7wjVuwPw=\");\n_c1 = CallControls;\nfunction VoiceCall(param) {\n    let { agent, onEnd } = param;\n    _s2();\n    const [connectionDetails, setConnectionDetails] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function connect() {\n            try {\n                const response = await fetch(\"/api/token\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        agentId: agent.id\n                    })\n                });\n                if (!response.ok) {\n                    throw new Error(\"Failed to get connection token\");\n                }\n                const data = await response.json();\n                setConnectionDetails({\n                    token: data.token,\n                    wsUrl: data.wsUrl\n                });\n            } catch (err) {\n                setError(err instanceof Error ? err.message : \"Connection failed\");\n            } finally{\n                setIsConnecting(false);\n            }\n        }\n        connect();\n    }, [\n        agent.id\n    ]);\n    const handleDisconnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        onEnd();\n    }, [\n        onEnd\n    ]);\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex flex-col items-center justify-center h-full gap-6 p-6 text-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-16 h-16 bg-red-500/20 rounded-2xl flex items-center justify-center\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                        size: 32,\n                        className: \"text-red-400\"\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 114,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 113,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"text-xl font-semibold mb-2\",\n                            children: \"Connection Failed\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 117,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-slate-400\",\n                            children: error\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 116,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: onEnd,\n                    className: \"btn-secondary\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                            size: 18\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 121,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            children: \"Go Back\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 122,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 120,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n            lineNumber: 112,\n            columnNumber: 7\n        }, this);\n    }\n    if (isConnecting || !connectionDetails) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex flex-col items-center justify-center h-full gap-6 p-6 text-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-20 h-20 bg-sky-500/20 rounded-2xl flex items-center justify-center animate-pulse-glow\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_Loader2_Mic_MicOff_PhoneOff_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                        size: 36,\n                        className: \"text-sky-400 animate-spin\"\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 132,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 131,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"text-xl font-semibold mb-2\",\n                            children: \"Connecting...\"\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 135,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-slate-400\",\n                            children: [\n                                \"Starting call with \",\n                                agent.displayName\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 136,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                    lineNumber: 134,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n            lineNumber: 130,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_10__.L, {\n        token: connectionDetails.token,\n        serverUrl: connectionDetails.wsUrl,\n        connect: true,\n        audio: true,\n        video: false,\n        onDisconnected: handleDisconnect,\n        \"data-lk-theme\": \"default\",\n        className: \"h-full flex flex-col items-center justify-center gap-8 p-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-20 h-20 bg-gradient-to-br from-sky-500 to-cyan-500 rounded-2xl flex items-center justify-center mx-auto mb-4 shadow-lg shadow-sky-500/25\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-3xl font-bold text-white\",\n                            children: agent.displayName.charAt(0)\n                        }, void 0, false, {\n                            fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                            lineNumber: 156,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 155,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-2xl font-bold mb-1\",\n                        children: agent.displayName\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 160,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-slate-400 text-sm max-w-xs mx-auto\",\n                        children: agent.description\n                    }, void 0, false, {\n                        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                        lineNumber: 161,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 154,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AgentVisualizer, {}, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 165,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CallControls, {\n                onDisconnect: handleDisconnect\n            }, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 168,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.R, {}, void 0, false, {\n                fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n                lineNumber: 170,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/runner/workspace/src/components/VoiceCall.tsx\",\n        lineNumber: 143,\n        columnNumber: 5\n    }, this);\n}\n_s2(VoiceCall, \"sctbVFx9wtUIj6gnFdRT5EmY1+E=\");\n_c2 = VoiceCall;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AgentVisualizer\");\n$RefreshReg$(_c1, \"CallControls\");\n$RefreshReg$(_c2, \"VoiceCall\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1ZvaWNlQ2FsbC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXdEO0FBT3RCO0FBQ0M7QUFDcUM7QUFReEUsU0FBU2E7O0lBQ1AsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRSxHQUFHViw0REFBaUJBO0lBRS9DLE1BQU1XLGNBQXNDO1FBQzFDQyxXQUFXO1FBQ1hDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFlBQVk7SUFDZDtJQUVBLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ1pQLFdBQVcsQ0FBQ0YsTUFBTSxJQUFJQTs7Ozs7OzBCQUV6Qiw4REFBQ1E7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNqQix3REFBYUE7b0JBQ1pRLE9BQU9BO29CQUNQVSxVQUFVVDtvQkFDVlUsVUFBVTtvQkFDVkMsU0FBUzt3QkFBRUMsV0FBVztvQkFBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLbkM7R0ExQlNkOztRQUN1QlIsd0RBQWlCQTs7O0tBRHhDUTtBQTRCVCxTQUFTZSxhQUFhLEtBQThDO1FBQTlDLEVBQUVDLFlBQVksRUFBZ0MsR0FBOUM7O0lBQ3BCLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHOUIsK0NBQVFBLENBQUM7SUFFdkMscUJBQ0UsOERBQUNxQjtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ1M7Z0JBQ0NDLFNBQVMsSUFBTUYsV0FBVyxDQUFDRDtnQkFDM0JQLFdBQVcsc0RBSVYsT0FIQ08sVUFDSSw0REFDQTtnQkFFTkksY0FBWUosVUFBVSxXQUFXOzBCQUVoQ0Esd0JBQVUsOERBQUNyQixpSEFBTUE7b0JBQUMwQixNQUFNOzs7Ozt5Q0FBUyw4REFBQzNCLGlIQUFHQTtvQkFBQzJCLE1BQU07Ozs7Ozs7Ozs7OzBCQUUvQyw4REFBQzVCLHdEQUFnQkE7Z0JBQUMwQixTQUFTSjswQkFDekIsNEVBQUNQO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDYixpSEFBUUE7d0JBQUN5QixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzFCO0lBdkJTUDtNQUFBQTtBQXlCTSxTQUFTUSxVQUFVLEtBQWdDO1FBQWhDLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFrQixHQUFoQzs7SUFDaEMsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHdkMsK0NBQVFBLENBR2hEO0lBQ1YsTUFBTSxDQUFDd0MsT0FBT0MsU0FBUyxHQUFHekMsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQzBDLGNBQWNDLGdCQUFnQixHQUFHM0MsK0NBQVFBLENBQUM7SUFFakRELGdEQUFTQSxDQUFDO1FBQ1IsZUFBZTZDO1lBQ2IsSUFBSTtnQkFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sY0FBYztvQkFDekNDLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFBRUMsU0FBU2hCLE1BQU1pQixFQUFFO29CQUFDO2dCQUMzQztnQkFFQSxJQUFJLENBQUNSLFNBQVNTLEVBQUUsRUFBRTtvQkFDaEIsTUFBTSxJQUFJQyxNQUFNO2dCQUNsQjtnQkFFQSxNQUFNQyxPQUFPLE1BQU1YLFNBQVNZLElBQUk7Z0JBQ2hDbEIscUJBQXFCO29CQUFFbUIsT0FBT0YsS0FBS0UsS0FBSztvQkFBRUMsT0FBT0gsS0FBS0csS0FBSztnQkFBQztZQUM5RCxFQUFFLE9BQU9DLEtBQUs7Z0JBQ1puQixTQUFTbUIsZUFBZUwsUUFBUUssSUFBSUMsT0FBTyxHQUFHO1lBQ2hELFNBQVU7Z0JBQ1JsQixnQkFBZ0I7WUFDbEI7UUFDRjtRQUVBQztJQUNGLEdBQUc7UUFBQ1IsTUFBTWlCLEVBQUU7S0FBQztJQUViLE1BQU1TLG1CQUFtQjdELGtEQUFXQSxDQUFDO1FBQ25Db0M7SUFDRixHQUFHO1FBQUNBO0tBQU07SUFFVixJQUFJRyxPQUFPO1FBQ1QscUJBQ0UsOERBQUNuQjtZQUFJQyxXQUFVOzs4QkFDYiw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQ2IsNEVBQUNiLGlIQUFRQTt3QkFBQ3lCLE1BQU07d0JBQUlaLFdBQVU7Ozs7Ozs7Ozs7OzhCQUVoQyw4REFBQ0Q7O3NDQUNDLDhEQUFDMEM7NEJBQUd6QyxXQUFVO3NDQUE2Qjs7Ozs7O3NDQUMzQyw4REFBQzBDOzRCQUFFMUMsV0FBVTtzQ0FBa0JrQjs7Ozs7Ozs7Ozs7OzhCQUVqQyw4REFBQ1Q7b0JBQU9DLFNBQVNLO29CQUFPZixXQUFVOztzQ0FDaEMsOERBQUNaLGlIQUFTQTs0QkFBQ3dCLE1BQU07Ozs7OztzQ0FDakIsOERBQUMrQjtzQ0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSWQ7SUFFQSxJQUFJdkIsZ0JBQWdCLENBQUNKLG1CQUFtQjtRQUN0QyxxQkFDRSw4REFBQ2pCO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDRDtvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ1gsaUhBQU9BO3dCQUFDdUIsTUFBTTt3QkFBSVosV0FBVTs7Ozs7Ozs7Ozs7OEJBRS9CLDhEQUFDRDs7c0NBQ0MsOERBQUMwQzs0QkFBR3pDLFdBQVU7c0NBQTZCOzs7Ozs7c0NBQzNDLDhEQUFDMEM7NEJBQUUxQyxXQUFVOztnQ0FBaUI7Z0NBQW9CYyxNQUFNOEIsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUkzRTtJQUVBLHFCQUNFLDhEQUFDaEUseURBQVdBO1FBQ1Z3RCxPQUFPcEIsa0JBQWtCb0IsS0FBSztRQUM5QlMsV0FBVzdCLGtCQUFrQnFCLEtBQUs7UUFDbENmLFNBQVM7UUFDVHdCLE9BQU87UUFDUEMsT0FBTztRQUNQQyxnQkFBZ0JSO1FBQ2hCUyxpQkFBYztRQUNkakQsV0FBVTs7MEJBR1YsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUMyQzs0QkFBSzNDLFdBQVU7c0NBQ2JjLE1BQU04QixXQUFXLENBQUNNLE1BQU0sQ0FBQzs7Ozs7Ozs7Ozs7a0NBRzlCLDhEQUFDQzt3QkFBR25ELFdBQVU7a0NBQTJCYyxNQUFNOEIsV0FBVzs7Ozs7O2tDQUMxRCw4REFBQ0Y7d0JBQUUxQyxXQUFVO2tDQUEyQ2MsTUFBTXNDLFdBQVc7Ozs7Ozs7Ozs7OzswQkFJM0UsOERBQUM5RDs7Ozs7MEJBR0QsOERBQUNlO2dCQUFhQyxjQUFja0M7Ozs7OzswQkFFNUIsOERBQUMzRCx3REFBaUJBOzs7Ozs7Ozs7OztBQUd4QjtJQXBHd0JnQztNQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Wb2ljZUNhbGwudHN4PzA3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICBMaXZlS2l0Um9vbSxcbiAgUm9vbUF1ZGlvUmVuZGVyZXIsXG4gIHVzZVZvaWNlQXNzaXN0YW50LFxuICBCYXJWaXN1YWxpemVyLFxuICBEaXNjb25uZWN0QnV0dG9uLFxufSBmcm9tICdAbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0J1xuaW1wb3J0ICdAbGl2ZWtpdC9jb21wb25lbnRzLXN0eWxlcydcbmltcG9ydCB7IE1pYywgTWljT2ZmLCBQaG9uZU9mZiwgQXJyb3dMZWZ0LCBMb2FkZXIyIH0gZnJvbSAnbHVjaWRlLXJlYWN0J1xuaW1wb3J0IHsgQWdlbnQgfSBmcm9tICdAL3R5cGVzL2FnZW50J1xuXG5pbnRlcmZhY2UgVm9pY2VDYWxsUHJvcHMge1xuICBhZ2VudDogQWdlbnRcbiAgb25FbmQ6ICgpID0+IHZvaWRcbn1cblxuZnVuY3Rpb24gQWdlbnRWaXN1YWxpemVyKCkge1xuICBjb25zdCB7IHN0YXRlLCBhdWRpb1RyYWNrIH0gPSB1c2VWb2ljZUFzc2lzdGFudCgpXG5cbiAgY29uc3Qgc3RhdGVMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgbGlzdGVuaW5nOiAnTGlzdGVuaW5nLi4uJyxcbiAgICB0aGlua2luZzogJ1RoaW5raW5nLi4uJyxcbiAgICBzcGVha2luZzogJ1NwZWFraW5nLi4uJyxcbiAgICBpZGxlOiAnUmVhZHknLFxuICAgIGNvbm5lY3Rpbmc6ICdDb25uZWN0aW5nLi4uJyxcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtNlwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJiYWRnZS1pbmZvIHRleHQtc20gcHgtNCBweS0yXCI+XG4gICAgICAgIHtzdGF0ZUxhYmVsc1tzdGF0ZV0gfHwgc3RhdGV9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC0zMiBzbTpoLTQwIHctZnVsbCBtYXgtdy14c1wiPlxuICAgICAgICA8QmFyVmlzdWFsaXplclxuICAgICAgICAgIHN0YXRlPXtzdGF0ZX1cbiAgICAgICAgICB0cmFja1JlZj17YXVkaW9UcmFja31cbiAgICAgICAgICBiYXJDb3VudD17N31cbiAgICAgICAgICBvcHRpb25zPXt7IG1pbkhlaWdodDogMTAgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIENhbGxDb250cm9scyh7IG9uRGlzY29ubmVjdCB9OiB7IG9uRGlzY29ubmVjdDogKCkgPT4gdm9pZCB9KSB7XG4gIGNvbnN0IFtpc011dGVkLCBzZXRJc011dGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBnYXAtNFwiPlxuICAgICAgPGJ1dHRvblxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc011dGVkKCFpc011dGVkKX1cbiAgICAgICAgY2xhc3NOYW1lPXtgcC00IHNtOnAtNSByb3VuZGVkLTJ4bCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgJHtcbiAgICAgICAgICBpc011dGVkIFxuICAgICAgICAgICAgPyAnYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHNoYWRvdy1sZyBzaGFkb3ctcmVkLTUwMC8zMCcgXG4gICAgICAgICAgICA6ICdiZy1zbGF0ZS03MDAgaG92ZXI6Ymctc2xhdGUtNjAwJ1xuICAgICAgICB9YH1cbiAgICAgICAgYXJpYS1sYWJlbD17aXNNdXRlZCA/ICdVbm11dGUnIDogJ011dGUnfVxuICAgICAgPlxuICAgICAgICB7aXNNdXRlZCA/IDxNaWNPZmYgc2l6ZT17MjR9IC8+IDogPE1pYyBzaXplPXsyNH0gLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxEaXNjb25uZWN0QnV0dG9uIG9uQ2xpY2s9e29uRGlzY29ubmVjdH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC00IHNtOnAtNSByb3VuZGVkLTJ4bCBiZy1yZWQtNTAwIGhvdmVyOmJnLXJlZC02MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGN1cnNvci1wb2ludGVyIHNoYWRvdy1sZyBzaGFkb3ctcmVkLTUwMC8zMFwiPlxuICAgICAgICAgIDxQaG9uZU9mZiBzaXplPXsyNH0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0Rpc2Nvbm5lY3RCdXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVm9pY2VDYWxsKHsgYWdlbnQsIG9uRW5kIH06IFZvaWNlQ2FsbFByb3BzKSB7XG4gIGNvbnN0IFtjb25uZWN0aW9uRGV0YWlscywgc2V0Q29ubmVjdGlvbkRldGFpbHNdID0gdXNlU3RhdGU8e1xuICAgIHRva2VuOiBzdHJpbmdcbiAgICB3c1VybDogc3RyaW5nXG4gIH0gfCBudWxsPihudWxsKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdG9rZW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhZ2VudElkOiBhZ2VudC5pZCB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGNvbm5lY3Rpb24gdG9rZW4nKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBzZXRDb25uZWN0aW9uRGV0YWlscyh7IHRva2VuOiBkYXRhLnRva2VuLCB3c1VybDogZGF0YS53c1VybCB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQ29ubmVjdGlvbiBmYWlsZWQnKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3QoKVxuICB9LCBbYWdlbnQuaWRdKVxuXG4gIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgb25FbmQoKVxuICB9LCBbb25FbmRdKVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtZnVsbCBnYXAtNiBwLTYgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTE2IGgtMTYgYmctcmVkLTUwMC8yMCByb3VuZGVkLTJ4bCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgIDxQaG9uZU9mZiBzaXplPXszMn0gY2xhc3NOYW1lPVwidGV4dC1yZWQtNDAwXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCBtYi0yXCI+Q29ubmVjdGlvbiBGYWlsZWQ8L2gzPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc2xhdGUtNDAwXCI+e2Vycm9yfTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17b25FbmR9IGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnlcIj5cbiAgICAgICAgICA8QXJyb3dMZWZ0IHNpemU9ezE4fSAvPlxuICAgICAgICAgIDxzcGFuPkdvIEJhY2s8L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgaWYgKGlzQ29ubmVjdGluZyB8fCAhY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGwgZ2FwLTYgcC02IHRleHQtY2VudGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0yMCBoLTIwIGJnLXNreS01MDAvMjAgcm91bmRlZC0yeGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYW5pbWF0ZS1wdWxzZS1nbG93XCI+XG4gICAgICAgICAgPExvYWRlcjIgc2l6ZT17MzZ9IGNsYXNzTmFtZT1cInRleHQtc2t5LTQwMCBhbmltYXRlLXNwaW5cIiAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LXNlbWlib2xkIG1iLTJcIj5Db25uZWN0aW5nLi4uPC9oMz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNsYXRlLTQwMFwiPlN0YXJ0aW5nIGNhbGwgd2l0aCB7YWdlbnQuZGlzcGxheU5hbWV9PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPExpdmVLaXRSb29tXG4gICAgICB0b2tlbj17Y29ubmVjdGlvbkRldGFpbHMudG9rZW59XG4gICAgICBzZXJ2ZXJVcmw9e2Nvbm5lY3Rpb25EZXRhaWxzLndzVXJsfVxuICAgICAgY29ubmVjdD17dHJ1ZX1cbiAgICAgIGF1ZGlvPXt0cnVlfVxuICAgICAgdmlkZW89e2ZhbHNlfVxuICAgICAgb25EaXNjb25uZWN0ZWQ9e2hhbmRsZURpc2Nvbm5lY3R9XG4gICAgICBkYXRhLWxrLXRoZW1lPVwiZGVmYXVsdFwiXG4gICAgICBjbGFzc05hbWU9XCJoLWZ1bGwgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZ2FwLTggcC02XCJcbiAgICA+XG4gICAgICB7LyogQWdlbnQgaW5mbyAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTIwIGgtMjAgYmctZ3JhZGllbnQtdG8tYnIgZnJvbS1za3ktNTAwIHRvLWN5YW4tNTAwIHJvdW5kZWQtMnhsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG14LWF1dG8gbWItNCBzaGFkb3ctbGcgc2hhZG93LXNreS01MDAvMjVcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAge2FnZW50LmRpc3BsYXlOYW1lLmNoYXJBdCgwKX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIG1iLTFcIj57YWdlbnQuZGlzcGxheU5hbWV9PC9oMj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbGF0ZS00MDAgdGV4dC1zbSBtYXgtdy14cyBteC1hdXRvXCI+e2FnZW50LmRlc2NyaXB0aW9ufTwvcD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogVmlzdWFsaXplciAqL31cbiAgICAgIDxBZ2VudFZpc3VhbGl6ZXIgLz5cblxuICAgICAgey8qIENvbnRyb2xzICovfVxuICAgICAgPENhbGxDb250cm9scyBvbkRpc2Nvbm5lY3Q9e2hhbmRsZURpc2Nvbm5lY3R9IC8+XG5cbiAgICAgIDxSb29tQXVkaW9SZW5kZXJlciAvPlxuICAgIDwvTGl2ZUtpdFJvb20+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiTGl2ZUtpdFJvb20iLCJSb29tQXVkaW9SZW5kZXJlciIsInVzZVZvaWNlQXNzaXN0YW50IiwiQmFyVmlzdWFsaXplciIsIkRpc2Nvbm5lY3RCdXR0b24iLCJNaWMiLCJNaWNPZmYiLCJQaG9uZU9mZiIsIkFycm93TGVmdCIsIkxvYWRlcjIiLCJBZ2VudFZpc3VhbGl6ZXIiLCJzdGF0ZSIsImF1ZGlvVHJhY2siLCJzdGF0ZUxhYmVscyIsImxpc3RlbmluZyIsInRoaW5raW5nIiwic3BlYWtpbmciLCJpZGxlIiwiY29ubmVjdGluZyIsImRpdiIsImNsYXNzTmFtZSIsInRyYWNrUmVmIiwiYmFyQ291bnQiLCJvcHRpb25zIiwibWluSGVpZ2h0IiwiQ2FsbENvbnRyb2xzIiwib25EaXNjb25uZWN0IiwiaXNNdXRlZCIsInNldElzTXV0ZWQiLCJidXR0b24iLCJvbkNsaWNrIiwiYXJpYS1sYWJlbCIsInNpemUiLCJWb2ljZUNhbGwiLCJhZ2VudCIsIm9uRW5kIiwiY29ubmVjdGlvbkRldGFpbHMiLCJzZXRDb25uZWN0aW9uRGV0YWlscyIsImVycm9yIiwic2V0RXJyb3IiLCJpc0Nvbm5lY3RpbmciLCJzZXRJc0Nvbm5lY3RpbmciLCJjb25uZWN0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImFnZW50SWQiLCJpZCIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsInRva2VuIiwid3NVcmwiLCJlcnIiLCJtZXNzYWdlIiwiaGFuZGxlRGlzY29ubmVjdCIsImgzIiwicCIsInNwYW4iLCJkaXNwbGF5TmFtZSIsInNlcnZlclVybCIsImF1ZGlvIiwidmlkZW8iLCJvbkRpc2Nvbm5lY3RlZCIsImRhdGEtbGstdGhlbWUiLCJjaGFyQXQiLCJoMiIsImRlc2NyaXB0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/VoiceCall.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9jZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZWZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-DuRBtGp8.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/components-DuRBtGp8.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ Pt; },\n/* harmony export */   A: function() { return /* binding */ Ma; },\n/* harmony export */   B: function() { return /* binding */ Kt; },\n/* harmony export */   C: function() { return /* binding */ sa; },\n/* harmony export */   D: function() { return /* binding */ ia; },\n/* harmony export */   E: function() { return /* binding */ pt; },\n/* harmony export */   F: function() { return /* binding */ Ea; },\n/* harmony export */   G: function() { return /* binding */ wa; },\n/* harmony export */   H: function() { return /* binding */ wt; },\n/* harmony export */   I: function() { return /* binding */ ie; },\n/* harmony export */   J: function() { return /* binding */ kt; },\n/* harmony export */   K: function() { return /* binding */ Rt; },\n/* harmony export */   L: function() { return /* binding */ Ra; },\n/* harmony export */   M: function() { return /* binding */ fa; },\n/* harmony export */   N: function() { return /* binding */ Mt; },\n/* harmony export */   O: function() { return /* binding */ yt; },\n/* harmony export */   P: function() { return /* binding */ Ot; },\n/* harmony export */   Q: function() { return /* binding */ bt; },\n/* harmony export */   R: function() { return /* binding */ ba; },\n/* harmony export */   S: function() { return /* binding */ oa; },\n/* harmony export */   T: function() { return /* binding */ va; },\n/* harmony export */   U: function() { return /* binding */ St; },\n/* harmony export */   V: function() { return /* binding */ Bt; },\n/* harmony export */   W: function() { return /* binding */ Ct; },\n/* harmony export */   X: function() { return /* binding */ It; },\n/* harmony export */   Y: function() { return /* binding */ Re; },\n/* harmony export */   Z: function() { return /* binding */ xt; },\n/* harmony export */   _: function() { return /* binding */ oe; },\n/* harmony export */   a: function() { return /* binding */ xa; },\n/* harmony export */   b: function() { return /* binding */ Nt; },\n/* harmony export */   c: function() { return /* binding */ ua; },\n/* harmony export */   d: function() { return /* binding */ da; },\n/* harmony export */   e: function() { return /* binding */ ma; },\n/* harmony export */   f: function() { return /* binding */ ga; },\n/* harmony export */   g: function() { return /* binding */ ka; },\n/* harmony export */   h: function() { return /* binding */ pa; },\n/* harmony export */   i: function() { return /* binding */ Ia; },\n/* harmony export */   j: function() { return /* binding */ Ce; },\n/* harmony export */   k: function() { return /* binding */ Ca; },\n/* harmony export */   l: function() { return /* binding */ Gt; },\n/* harmony export */   m: function() { return /* binding */ Pa; },\n/* harmony export */   n: function() { return /* binding */ ca; },\n/* harmony export */   o: function() { return /* binding */ la; },\n/* harmony export */   p: function() { return /* binding */ Tt; },\n/* harmony export */   q: function() { return /* binding */ ha; },\n/* harmony export */   r: function() { return /* binding */ ye; },\n/* harmony export */   s: function() { return /* binding */ ne; },\n/* harmony export */   t: function() { return /* binding */ K; },\n/* harmony export */   u: function() { return /* binding */ be; },\n/* harmony export */   v: function() { return /* binding */ ya; },\n/* harmony export */   w: function() { return /* binding */ Sa; },\n/* harmony export */   x: function() { return /* binding */ jt; },\n/* harmony export */   y: function() { return /* binding */ _t; },\n/* harmony export */   z: function() { return /* binding */ Ta; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks-yU-srrIO.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-yU-srrIO.mjs\");\n/* harmony import */ var _room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./room-Bb6uLxS5.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contexts-CsO1QZ3r.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs\");\n\n\n\n\n\n\nconst ca = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function(n, a) {\n    const { buttonProps: c } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(n);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...c }, n.children);\n  }\n), la = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ room: n, ...a }, c) {\n    const r = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(n);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: c, ...a }, r);\n  }\n), sa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function(n, a) {\n    const { mergedProps: c } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.b)({ props: n });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...c }, n.children);\n  }\n), ia = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function(n, a) {\n    const { buttonProps: c } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(n);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...c }, n.children);\n  }\n), pt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708L11 10.293V4.5A1.5 1.5 0 0 0 9.5 3H3.707zM0 4.5a1.5 1.5 0 0 1 .943-1.393l9.532 9.533c-.262.224-.603.36-.975.36h-8A1.5 1.5 0 0 1 0 11.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"m15.2 3.6-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z\" })), wt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 4.5A1.5 1.5 0 0 1 1.5 3h8A1.5 1.5 0 0 1 11 4.5v7A1.5 1.5 0 0 1 9.5 13h-8A1.5 1.5 0 0 1 0 11.5zM15.2 3.6l-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z\" })), oa = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, viewBox: \"0 0 24 24\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"#FFF\",\n    d: \"M4.99 3.99a1 1 0 0 0-.697 1.717L10.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414L12 13.414l6.293 6.293a1 1 0 1 0 1.414-1.414L13.414 12l6.293-6.293a1 1 0 0 0-.727-1.717 1 1 0 0 0-.687.303L12 10.586 5.707 4.293a1 1 0 0 0-.717-.303z\"\n  }\n)), ua = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 18, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M0 2.75A2.75 2.75 0 0 1 2.75 0h10.5A2.75 2.75 0 0 1 16 2.75v13.594a.75.75 0 0 1-1.234.572l-3.691-3.12a1.25 1.25 0 0 0-.807-.296H2.75A2.75 2.75 0 0 1 0 10.75v-8ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v8c0 .69.56 1.25 1.25 1.25h7.518c.65 0 1.279.23 1.775.65l2.457 2.077V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z\",\n    clipRule: \"evenodd\"\n  }\n)), ie = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentcolor\",\n    fillRule: \"evenodd\",\n    d: \"M5.293 2.293a1 1 0 0 1 1.414 0l4.823 4.823a1.25 1.25 0 0 1 0 1.768l-4.823 4.823a1 1 0 0 1-1.414-1.414L9.586 8 5.293 3.707a1 1 0 0 1 0-1.414z\",\n    clipRule: \"evenodd\"\n  }\n)), kt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 1.5 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M10 1.75h4.25m0 0V6m0-4.25L9 7M6 14.25H1.75m0 0V10m0 4.25L7 9\" }))), da = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentcolor\",\n    fillRule: \"evenodd\",\n    d: \"M8.961.894C8.875-.298 7.125-.298 7.04.894c-.066.912-1.246 1.228-1.76.472-.67-.99-2.186-.115-1.664.96.399.824-.465 1.688-1.288 1.289-1.076-.522-1.95.994-.961 1.665.756.513.44 1.693-.472 1.759-1.192.086-1.192 1.836 0 1.922.912.066 1.228 1.246.472 1.76-.99.67-.115 2.186.96 1.664.824-.399 1.688.465 1.289 1.288-.522 1.076.994 1.95 1.665.961.513-.756 1.693-.44 1.759.472.086 1.192 1.836 1.192 1.922 0 .066-.912 1.246-1.228 1.76-.472.67.99 2.186.115 1.664-.96-.399-.824.465-1.688 1.288-1.289 1.076.522 1.95-.994.961-1.665-.756-.513-.44-1.693.472-1.759 1.192-.086 1.192-1.836 0-1.922-.912-.066-1.228-1.246-.472-1.76.99-.67.115-2.186-.96-1.664-.824.399-1.688-.465-1.289-1.288.522-1.076-.994-1.95-1.665-.961-.513.756-1.693.44-1.759-.472ZM8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10Z\",\n    clipRule: \"evenodd\"\n  }\n)), ma = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M2 2.75A2.75 2.75 0 0 1 4.75 0h6.5A2.75 2.75 0 0 1 14 2.75v10.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-.5a.75.75 0 0 1 1.5 0v.5c0 .69.56 1.25 1.25 1.25h6.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25h-6.5c-.69 0-1.25.56-1.25 1.25v.5a.75.75 0 0 1-1.5 0v-.5Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M8.78 7.47a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 1 1-1.06-1.06l.97-.97H1.75a.75.75 0 0 1 0-1.5h4.69l-.97-.97a.75.75 0 0 1 1.06-1.06l2.25 2.25Z\",\n    clipRule: \"evenodd\"\n  }\n)), Rt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentcolor\",\n    fillRule: \"evenodd\",\n    d: \"M4 6.104V4a4 4 0 1 1 8 0v2.104c1.154.326 2 1.387 2 2.646v4.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-4.5c0-1.259.846-2.32 2-2.646ZM5.5 4a2.5 2.5 0 0 1 5 0v2h-5V4Z\",\n    clipRule: \"evenodd\"\n  }\n)), Mt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12.227 11.52a5.477 5.477 0 0 0 1.246-2.97.5.5 0 0 0-.995-.1 4.478 4.478 0 0 1-.962 2.359l-1.07-1.07C10.794 9.247 11 8.647 11 8V3a3 3 0 0 0-6 0v1.293L1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708zM8 12.5c.683 0 1.33-.152 1.911-.425l.743.743c-.649.359-1.378.59-2.154.66V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .995-.098A4.5 4.5 0 0 0 8 12.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M8.743 10.907 5 7.164V8a3 3 0 0 0 3.743 2.907z\" })), yt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fillRule: \"evenodd\",\n    d: \"M2.975 8.002a.5.5 0 0 1 .547.449 4.5 4.5 0 0 0 8.956 0 .5.5 0 1 1 .995.098A5.502 5.502 0 0 1 8.5 13.478V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .448-.547z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M5 3a3 3 0 1 1 6 0v5a3 3 0 0 1-6 0z\" })), bt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" })), St = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }))), Ct = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }))), It = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z\" }))), Re = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 20, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M0 2.75A2.75 2.75 0 0 1 2.75 0h14.5A2.75 2.75 0 0 1 20 2.75v10.5A2.75 2.75 0 0 1 17.25 16H2.75A2.75 2.75 0 0 1 0 13.25V2.75ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h14.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M9.47 4.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1-1.06 1.06l-.97-.97v4.69a.75.75 0 0 1-1.5 0V6.56l-.97.97a.75.75 0 0 1-1.06-1.06l2.25-2.25Z\",\n    clipRule: \"evenodd\"\n  }\n)), xt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 20, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { fill: \"currentColor\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M7.28 4.22a.75.75 0 0 0-1.06 1.06L8.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L10 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L11.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L10 6.94z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fillRule: \"evenodd\",\n    d: \"M2.75 0A2.75 2.75 0 0 0 0 2.75v10.5A2.75 2.75 0 0 0 2.75 16h14.5A2.75 2.75 0 0 0 20 13.25V2.75A2.75 2.75 0 0 0 17.25 0zM1.5 2.75c0-.69.56-1.25 1.25-1.25h14.5c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H2.75c-.69 0-1.25-.56-1.25-1.25z\",\n    clipRule: \"evenodd\"\n  }\n))), oe = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M8 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8 0Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M8 12a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 8 12Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.7\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M12 1.072a.75.75 0 0 1 .274 1.024l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 12 1.072Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M6 11.464a.75.75 0 0 1 .274 1.025l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 6 11.464Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.6\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M14.928 4a.75.75 0 0 1-.274 1.025l-2.165 1.25a.75.75 0 1 1-.75-1.3l2.165-1.25A.75.75 0 0 1 14.928 4Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M4.536 10a.75.75 0 0 1-.275 1.024l-2.165 1.25a.75.75 0 0 1-.75-1.298l2.165-1.25A.75.75 0 0 1 4.536 10Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.5\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M16 8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 16 8Z\",\n    clipRule: \"evenodd\"\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M4 8a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 8Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.4\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M14.928 12a.75.75 0 0 1-1.024.274l-2.165-1.25a.75.75 0 0 1 .75-1.299l2.165 1.25A.75.75 0 0 1 14.928 12Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.9\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M4.536 6a.75.75 0 0 1-1.025.275l-2.165-1.25a.75.75 0 1 1 .75-1.3l2.165 1.25A.75.75 0 0 1 4.536 6Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.3\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M12 14.928a.75.75 0 0 1-1.024-.274l-1.25-2.165a.75.75 0 0 1 1.298-.75l1.25 2.165A.75.75 0 0 1 12 14.928Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.8\n  }\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"path\",\n  {\n    fill: \"currentColor\",\n    fillRule: \"evenodd\",\n    d: \"M6 4.536a.75.75 0 0 1-1.024-.275l-1.25-2.165a.75.75 0 1 1 1.299-.75l1.25 2.165A.75.75 0 0 1 6 4.536Z\",\n    clipRule: \"evenodd\",\n    opacity: 0.2\n  }\n)), Pt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 1.5 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M13.25 7H9m0 0V2.75M9 7l5.25-5.25M2.75 9H7m0 0v4.25M7 9l-5.25 5.25\" }))), Tt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ trackRef: n, ...a }, c) {\n    const r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ae)(), { mergedProps: s, inFocus: o } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.d)({\n      trackRef: n ?? r,\n      props: a\n    });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.af.Consumer, null, (l) => l !== void 0 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: c, ...s }, a.children ? a.children : o ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(kt, null)));\n  }\n), fa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({\n    kind: n,\n    initialSelection: a,\n    onActiveDeviceChange: c,\n    onDeviceListChange: r,\n    onDeviceSelectError: s,\n    exactMatch: o,\n    track: l,\n    requestPermissions: i,\n    onError: d,\n    ...u\n  }, v) {\n    const f = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.w)(), p = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"default\"), E = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      (w) => {\n        f && f.emit(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, w), d == null || d(w);\n      },\n      [f, d]\n    ), { devices: h, activeDeviceId: m, setActiveMediaDevice: y, className: C } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.e)({\n      kind: n,\n      room: f,\n      track: l,\n      requestPermissions: i,\n      onError: E\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      a !== void 0 && y(a);\n    }, [y]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      typeof r == \"function\" && r(h);\n    }, [r, h]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      m !== p.current && (c == null || c(m)), p.current = m;\n    }, [m]);\n    const A = async (w) => {\n      try {\n        await y(w, { exact: o ?? !0 });\n      } catch (M) {\n        if (M instanceof Error)\n          s == null || s(M);\n        else\n          throw M;\n      }\n    }, N = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n      () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(u, { className: C }, { className: \"lk-list\" }),\n      [C, u]\n    ), g = !!h.find((w) => w.label.toLowerCase().startsWith(\"default\"));\n    function R(w, M, P) {\n      return w === M || !g && P === 0 && M === \"default\";\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", { ref: v, ...N }, h.map((w, M) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"li\",\n      {\n        key: w.deviceId,\n        id: w.deviceId,\n        \"data-lk-active\": R(w.deviceId, m, M),\n        \"aria-selected\": R(w.deviceId, m, M),\n        role: \"option\"\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: () => A(w.deviceId) }, w.label)\n    )));\n  }\n), ha = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ label: n = \"Allow Audio\", ...a }, c) {\n    const r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.u)(a.room), { mergedProps: s } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.f)({ room: r, props: a });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: c, ...s }, n);\n  }\n), ga = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ label: n, ...a }, c) {\n    const r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.f)(), { mergedProps: s, canPlayAudio: o } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.f)({ room: r, props: a }), { mergedProps: l, canPlayVideo: i } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.g)({ room: r, props: s }), { style: d, ...u } = l;\n    return d.display = o && i ? \"none\" : \"block\", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: c, style: d, ...u }, n ?? `Start ${o ? \"Video\" : \"Audio\"}`);\n  }\n);\nfunction Me(t, n) {\n  switch (t) {\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone:\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(yt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mt, null);\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera:\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(wt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(pt, null);\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare:\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(xt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Re, null);\n    default:\n      return;\n  }\n}\nfunction At(t) {\n  switch (t) {\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Excellent:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bt, null);\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Good:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(St, null);\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Poor:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ct, null);\n    default:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(It, null);\n  }\n}\nconst va = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ showIcon: n, ...a }, c) {\n  const { buttonProps: r, enabled: s } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(a), [o, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    l(!0);\n  }, []), o && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: c, ...r }, (n ?? !0) && Me(a.source, s), a.children);\n}), ye = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(n, a) {\n  const { className: c, quality: r } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(n), s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({ ...(0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n, { className: c }), \"data-lk-quality\": r }), [r, n, c]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: a, ...s }, n.children ?? At(r));\n}), K = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ participant: n, ...a }, c) {\n    const r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.c)(n), { className: s, infoObserver: o } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ag)(r), [r]), { identity: l, name: i } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.j)(o, {\n      name: r.name,\n      identity: r.identity,\n      metadata: r.metadata\n    }), d = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(a, { className: s, \"data-lk-participant-name\": i }), [a, s, i]);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { ref: c, ...d }, i !== \"\" ? i : l, a.children);\n  }\n), be = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ trackRef: n, show: a = \"always\", ...c }, r) {\n    const { className: s, isMuted: o } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.k)(n), l = a === \"always\" || a === \"muted\" && o || a === \"unmuted\" && !o, i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n      () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(c, {\n        className: s\n      }),\n      [s, c]\n    );\n    return l ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: r, ...i, \"data-lk-muted\": o }, c.children ?? Me(n.source, !o)) : null;\n  }\n), Nt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n  \"svg\",\n  {\n    width: 320,\n    height: 320,\n    viewBox: \"0 0 320 320\",\n    preserveAspectRatio: \"xMidYMid meet\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    ...t\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"path\",\n    {\n      d: \"M160 180C204.182 180 240 144.183 240 100C240 55.8172 204.182 20 160 20C115.817 20 79.9997 55.8172 79.9997 100C79.9997 144.183 115.817 180 160 180Z\",\n      fill: \"white\",\n      fillOpacity: 0.25\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"path\",\n    {\n      d: \"M97.6542 194.614C103.267 191.818 109.841 192.481 115.519 195.141C129.025 201.466 144.1 205 159.999 205C175.899 205 190.973 201.466 204.48 195.141C210.158 192.481 216.732 191.818 222.345 194.614C262.703 214.719 291.985 253.736 298.591 300.062C300.15 310.997 291.045 320 280 320H39.9997C28.954 320 19.8495 310.997 21.4087 300.062C28.014 253.736 57.2966 214.72 97.6542 194.614Z\",\n      fill: \"white\",\n      fillOpacity: 0.25\n    }\n  )\n);\nfunction Se(t, n = {}) {\n  const [a, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState((0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.X)(t)), [r, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.isMuted), [o, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.isSubscribed), [i, d] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.track), [u, v] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"landscape\"), f = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), { className: p, trackObserver: E } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.Y)(t), [\n    t.participant.sid ?? t.participant.identity,\n    t.source,\n    (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(t) && t.publication.trackSid\n  ]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const h = E.subscribe((m) => {\n      _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"update track\", m), c(m), s(m == null ? void 0 : m.isMuted), l(m == null ? void 0 : m.isSubscribed), d(m == null ? void 0 : m.track);\n    });\n    return () => h == null ? void 0 : h.unsubscribe();\n  }, [E]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var h, m;\n    return i && (f.current && i.detach(f.current), (h = n.element) != null && h.current && !(t.participant.isLocal && (i == null ? void 0 : i.kind) === \"audio\") && i.attach(n.element.current)), f.current = (m = n.element) == null ? void 0 : m.current, () => {\n      f.current && (i == null || i.detach(f.current));\n    };\n  }, [i, n.element]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var h, m;\n    if (typeof ((h = a == null ? void 0 : a.dimensions) == null ? void 0 : h.width) == \"number\" && typeof ((m = a == null ? void 0 : a.dimensions) == null ? void 0 : m.height) == \"number\") {\n      const y = a.dimensions.width > a.dimensions.height ? \"landscape\" : \"portrait\";\n      v(y);\n    }\n  }, [a]), {\n    publication: a,\n    isMuted: r,\n    isSubscribed: o,\n    track: i,\n    elementProps: (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n.props, {\n      className: p,\n      \"data-lk-local-participant\": t.participant.isLocal,\n      \"data-lk-source\": a == null ? void 0 : a.source,\n      ...(a == null ? void 0 : a.kind) === \"video\" && { \"data-lk-orientation\": u }\n    })\n  };\n}\nvar Y, ue;\nfunction Lt() {\n  if (ue) return Y;\n  ue = 1;\n  var t = \"Expected a function\", n = NaN, a = \"[object Symbol]\", c = /^\\s+|\\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, o = /^0o[0-7]+$/i, l = parseInt, i = typeof _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ah == \"object\" && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ah && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ah.Object === Object && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ah, d = typeof self == \"object\" && self && self.Object === Object && self, u = i || d || Function(\"return this\")(), v = Object.prototype, f = v.toString, p = Math.max, E = Math.min, h = function() {\n    return u.Date.now();\n  };\n  function m(g, R, w) {\n    var M, P, O, L, b, T, F = 0, re = !1, Z = !1, D = !0;\n    if (typeof g != \"function\")\n      throw new TypeError(t);\n    R = N(R) || 0, y(w) && (re = !!w.leading, Z = \"maxWait\" in w, O = Z ? p(N(w.maxWait) || 0, R) : O, D = \"trailing\" in w ? !!w.trailing : D);\n    function U(k) {\n      var x = M, H = P;\n      return M = P = void 0, F = k, L = g.apply(H, x), L;\n    }\n    function xe(k) {\n      return F = k, b = setTimeout(W, R), re ? U(k) : L;\n    }\n    function Pe(k) {\n      var x = k - T, H = k - F, se = R - x;\n      return Z ? E(se, O - H) : se;\n    }\n    function ce(k) {\n      var x = k - T, H = k - F;\n      return T === void 0 || x >= R || x < 0 || Z && H >= O;\n    }\n    function W() {\n      var k = h();\n      if (ce(k))\n        return le(k);\n      b = setTimeout(W, Pe(k));\n    }\n    function le(k) {\n      return b = void 0, D && M ? U(k) : (M = P = void 0, L);\n    }\n    function Te() {\n      b !== void 0 && clearTimeout(b), F = 0, M = T = P = b = void 0;\n    }\n    function Ae() {\n      return b === void 0 ? L : le(h());\n    }\n    function G() {\n      var k = h(), x = ce(k);\n      if (M = arguments, P = this, T = k, x) {\n        if (b === void 0)\n          return xe(T);\n        if (Z)\n          return b = setTimeout(W, R), U(T);\n      }\n      return b === void 0 && (b = setTimeout(W, R)), L;\n    }\n    return G.cancel = Te, G.flush = Ae, G;\n  }\n  function y(g) {\n    var R = typeof g;\n    return !!g && (R == \"object\" || R == \"function\");\n  }\n  function C(g) {\n    return !!g && typeof g == \"object\";\n  }\n  function A(g) {\n    return typeof g == \"symbol\" || C(g) && f.call(g) == a;\n  }\n  function N(g) {\n    if (typeof g == \"number\")\n      return g;\n    if (A(g))\n      return n;\n    if (y(g)) {\n      var R = typeof g.valueOf == \"function\" ? g.valueOf() : g;\n      g = y(R) ? R + \"\" : R;\n    }\n    if (typeof g != \"string\")\n      return g === 0 ? g : +g;\n    g = g.replace(c, \"\");\n    var w = s.test(g);\n    return w || o.test(g) ? l(g.slice(2), w ? 2 : 8) : r.test(g) ? n : +g;\n  }\n  return Y = m, Y;\n}\nvar zt = Lt();\nconst de = /* @__PURE__ */ (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ai)(zt);\nfunction Vt(t) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\n  n.current = t, (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => () => {\n      n.current();\n    },\n    []\n  );\n}\nfunction Ft(t, n = 500, a) {\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  Vt(() => {\n    c.current && c.current.cancel();\n  });\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const s = de(t, n, a), o = (...l) => s(...l);\n    return o.cancel = () => {\n      s.cancel();\n    }, o.isPending = () => !!c.current, o.flush = () => s.flush(), o;\n  }, [t, n, a]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c.current = de(t, n, a);\n  }, [t, n, a]), r;\n}\nfunction Zt(t, n, a) {\n  const c = ((d, u) => d === u), r = t instanceof Function ? t() : t, [s, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(r), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(r), i = Ft(\n    o,\n    n,\n    a\n  );\n  return c(l.current, r) || (i(r), l.current = r), [s, i];\n}\nfunction Ht({\n  threshold: t = 0,\n  root: n = null,\n  rootMargin: a = \"0%\",\n  freezeOnceVisible: c = !1,\n  initialIsIntersecting: r = !1,\n  onChange: s\n} = {}) {\n  var o;\n  const [l, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [d, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({\n    isIntersecting: r,\n    entry: void 0\n  })), v = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  v.current = s;\n  const f = ((o = d.entry) == null ? void 0 : o.isIntersecting) && c;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!l || !(\"IntersectionObserver\" in window) || f)\n      return;\n    const h = new IntersectionObserver(\n      (m) => {\n        const y = Array.isArray(h.thresholds) ? h.thresholds : [h.thresholds];\n        m.forEach((C) => {\n          const A = C.isIntersecting && y.some((N) => C.intersectionRatio >= N);\n          u({ isIntersecting: A, entry: C }), v.current && v.current(A, C);\n        });\n      },\n      { threshold: t, root: n, rootMargin: a }\n    );\n    return h.observe(l), () => {\n      h.disconnect();\n    };\n  }, [\n    l,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(t),\n    n,\n    a,\n    f,\n    c\n  ]);\n  const p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var h;\n    !l && ((h = d.entry) != null && h.target) && !c && !f && p.current !== d.entry.target && (p.current = d.entry.target, u({ isIntersecting: r, entry: void 0 }));\n  }, [l, d.entry, c, f, r]);\n  const E = [\n    i,\n    !!d.isIntersecting,\n    d.entry\n  ];\n  return E.ref = E[0], E.isIntersecting = E[1], E.entry = E[2], E;\n}\nconst Bt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({\n    onTrackClick: n,\n    onClick: a,\n    onSubscriptionStatusChanged: c,\n    trackRef: r,\n    manageSubscription: s,\n    ...o\n  }, l) {\n    const i = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(r), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(l, () => d.current);\n    const u = Ht({ root: d.current }), [v] = Zt(u, 3e3);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      s && i.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication && (v == null ? void 0 : v.isIntersecting) === !1 && (u == null ? void 0 : u.isIntersecting) === !1 && i.publication.setSubscribed(!1);\n    }, [v, i, s]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      s && i.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication && (u == null ? void 0 : u.isIntersecting) === !0 && i.publication.setSubscribed(!0);\n    }, [u, i, s]);\n    const {\n      elementProps: f,\n      publication: p,\n      isSubscribed: E\n    } = Se(i, {\n      element: d,\n      props: o\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      c == null || c(!!E);\n    }, [E, c]);\n    const h = (m) => {\n      a == null || a(m), n == null || n({ participant: i == null ? void 0 : i.participant, track: p });\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\", { ref: d, ...f, muted: !0, onClick: h });\n  }\n), ne = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ trackRef: n, onSubscriptionStatusChanged: a, volume: c, ...r }, s) {\n    const o = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), l = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(s, () => l.current);\n    const {\n      elementProps: i,\n      isSubscribed: d,\n      track: u,\n      publication: v\n    } = Se(o, {\n      element: l,\n      props: r\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      a == null || a(!!d);\n    }, [d, a]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      u === void 0 || c === void 0 || (u instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteAudioTrack ? u.setVolume(c) : _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.l.warn(\"Volume can only be set on remote audio tracks.\"));\n    }, [c, u]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      v === void 0 || r.muted === void 0 || (v instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication ? v.setEnabled(!r.muted) : _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.l.warn(\"Can only call setEnabled on remote track publications.\"));\n    }, [r.muted, v, u]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"audio\", { ref: l, ...i });\n  }\n);\nfunction jt(t) {\n  const n = !!(0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.B)();\n  return t.participant && !n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.aj.Provider, { value: t.participant }, t.children) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.children);\n}\nfunction _t(t) {\n  const n = !!(0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ae)();\n  return t.trackRef && !n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ak.Provider, { value: t.trackRef }, t.children) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.children);\n}\nconst Ot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({\n    trackRef: n,\n    children: a,\n    onParticipantClick: c,\n    disableSpeakingIndicator: r,\n    ...s\n  }, o) {\n    var p, E;\n    const l = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), { elementProps: i } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.l)({\n      htmlProps: s,\n      disableSpeakingIndicator: r,\n      onParticipantClick: c,\n      trackRef: l\n    }), d = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(l.participant), u = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.j)(), v = (p = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.al)()) == null ? void 0 : p.autoSubscription, f = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      (h) => {\n        l.source && !h && u && u.pin.dispatch && (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(l, u.pin.state) && u.pin.dispatch({ msg: \"clear_pin\" });\n      },\n      [l, u]\n    );\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, style: { position: \"relative\" }, ...i }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_t, { trackRef: l }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(jt, { participant: l.participant }, a ?? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && (((E = l.publication) == null ? void 0 : E.kind) === \"video\" || l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera || l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      Bt,\n      {\n        trackRef: l,\n        onSubscriptionStatusChanged: f,\n        manageSubscription: v\n      }\n    ) : (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      ne,\n      {\n        trackRef: l,\n        onSubscriptionStatusChanged: f\n      }\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-placeholder\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Nt, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata-item\" }, l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, d && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Rt, { style: { marginRight: \"0.25rem\" } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      be,\n      {\n        trackRef: {\n          participant: l.participant,\n          source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone\n        },\n        show: \"muted\"\n      }\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null)) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Re, { style: { marginRight: \"0.25rem\" } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null, \"'s screen\"))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ye, { className: \"lk-participant-metadata-item\" }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tt, { trackRef: l }))));\n  }\n);\nfunction Ea(t) {\n  const n = (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(t, { className: \"lk-focus-layout\" });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...n }, t.children);\n}\nfunction pa({ trackRef: t, ...n }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ot, { trackRef: t, ...n });\n}\nfunction Ce({ tracks: t, ...n }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.map((a) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ak.Provider,\n    {\n      value: a,\n      key: (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.p)(a)\n    },\n    (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(n.children)\n  )));\n}\nfunction Wt({\n  totalPageCount: t,\n  nextPage: n,\n  prevPage: a,\n  currentPage: c,\n  pagesContainer: r\n}) {\n  const [s, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let l;\n    return r && (l = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.am)(r.current, 2e3).subscribe(\n      o\n    )), () => {\n      l && l.unsubscribe();\n    };\n  }, [r]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-pagination-control\", \"data-lk-user-interaction\": s }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: a }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ie, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-pagination-count\" }, `${c} of ${t}`), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: n }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ie, null)));\n}\nconst qt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ totalPageCount: n, currentPage: a }, c) {\n    const r = new Array(n).fill(\"\").map((s, o) => o + 1 === a ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { \"data-lk-active\": !0, key: o }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { key: o }));\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: c, className: \"lk-pagination-indicator\" }, r);\n  }\n);\nfunction wa({ tracks: t, ...n }) {\n  const a = react__WEBPACK_IMPORTED_MODULE_0__.createRef(), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n, { className: \"lk-grid-layout\" }),\n    [n]\n  ), { layout: r } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.n)(a, t.length), s = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.o)(r.maxTiles, t);\n  return (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(a, {\n    onLeftSwipe: s.nextPage,\n    onRightSwipe: s.prevPage\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: a, \"data-lk-pagination\": s.totalPageCount > 1, ...c }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ce, { tracks: s.tracks }, n.children), t.length > r.maxTiles && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    qt,\n    {\n      totalPageCount: s.totalPageCount,\n      currentPage: s.currentPage\n    }\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wt, { pagesContainer: a, ...s })));\n}\nconst $t = 130, Dt = 140, me = 1, Ie = 16 / 10, Ut = (1 - Ie) * -1;\nfunction ka({ tracks: t, orientation: n, ...a }) {\n  const c = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), [r, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0), { width: o, height: l } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(c), i = n || (l >= o ? \"vertical\" : \"horizontal\"), d = i === \"vertical\" ? Math.max(o * Ut, $t) : Math.max(l * Ie, Dt), u = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.an)(), v = Math.max(i === \"vertical\" ? (l - u) / d : (o - u) / d, me);\n  let f = Math.round(v);\n  Math.abs(v - r) < 0.5 ? f = Math.round(r) : r !== v && s(v);\n  const p = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(t, f);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    c.current && (c.current.dataset.lkOrientation = i, c.current.style.setProperty(\"--lk-max-visible-tiles\", f.toString()));\n  }, [f, i]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"aside\", { key: i, className: \"lk-carousel\", ref: c, ...a }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ce, { tracks: p }, a.children));\n}\nfunction Ra({\n  value: t,\n  onPinChange: n,\n  onWidgetChange: a,\n  children: c\n}) {\n  const r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ao)(t);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"PinState Updated\", { state: r.pin.state }), n && r.pin.state && n(r.pin.state);\n  }, [r.pin.state, n]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"Widget Updated\", { widgetState: r.widget.state }), a && r.widget.state && a(r.widget.state);\n  }, [a, r.widget.state]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.af.Provider, { value: r }, c);\n}\nconst Ma = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ trackRef: n, ...a }, c) {\n    const u = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), v = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(u, { bands: 7, loPass: 300 });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"svg\",\n      {\n        ref: c,\n        width: \"100%\",\n        height: \"100%\",\n        viewBox: \"0 0 200 90\",\n        ...a,\n        className: \"lk-audio-visualizer\"\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\" }),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"g\",\n        {\n          style: {\n            transform: `translate(${130 / 2}px, 0)`\n          }\n        },\n        v.map((f, p) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n          \"rect\",\n          {\n            key: p,\n            x: p * 10,\n            y: 90 / 2 - f * 50 / 2,\n            width: 6,\n            height: f * 50\n          }\n        ))\n      )\n    );\n  }\n);\nfunction ya({ participants: t, ...n }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.map((a) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.aj.Provider, { value: a, key: a.identity }, (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(n.children))));\n}\nfunction ba({ room: t, volume: n, muted: a }) {\n  const c = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShareAudio, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown],\n    {\n      updateOnlyOn: [],\n      onlySubscribed: !0,\n      room: t\n    }\n  ).filter((r) => !r.participant.isLocal && r.publication.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Kind.Audio);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { display: \"none\" } }, c.map((r) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    ne,\n    {\n      key: (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.p)(r),\n      trackRef: r,\n      volume: n,\n      muted: a\n    }\n  )));\n}\nconst Sa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ childrenPosition: n = \"before\", children: a, ...c }, r) {\n  const { name: s } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.v)();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { ref: r, ...c }, n === \"before\" && a, s, n === \"after\" && a);\n});\nfunction Gt(t) {\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(t, { className: \"lk-toast\" }), [t]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...n }, t.children);\n}\nconst Qt = (t) => {\n  const n = [];\n  for (let a = 0; a < t; a++)\n    n.push([a, t - 1 - a]);\n  return n;\n}, fe = (t) => [[Math.floor(t / 2)], [-1]], Xt = (t, n, a) => {\n  const [c, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), [s, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([[]]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (t === \"thinking\")\n      o(fe(n));\n    else if (t === \"connecting\" || t === \"initializing\") {\n      const i = [...Qt(n)];\n      o(i);\n    } else o(t === \"listening\" ? fe(n) : t === void 0 || t === \"speaking\" ? [new Array(n).fill(0).map((i, d) => d)] : [[]]);\n    r(0);\n  }, [t, n]);\n  const l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let i = performance.now();\n    const d = (u) => {\n      u - i >= a && (r((f) => f + 1), i = u), l.current = requestAnimationFrame(d);\n    };\n    return l.current = requestAnimationFrame(d), () => {\n      l.current !== null && cancelAnimationFrame(l.current);\n    };\n  }, [a, n, t, s.length]), s[c % s.length];\n}, Yt = /* @__PURE__ */ new Map([\n  [\"connecting\", 2e3],\n  [\"initializing\", 2e3],\n  [\"listening\", 500],\n  [\"thinking\", 150]\n]), Jt = (t, n) => {\n  if (t === void 0)\n    return 1e3;\n  let a = Yt.get(t);\n  if (a)\n    switch (t) {\n      case \"connecting\":\n        a /= n;\n        break;\n    }\n  return a;\n}, Kt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ state: n, options: a, barCount: c = 15, trackRef: r, track: s, children: o, ...l }, i) {\n    const d = (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(l, { className: \"lk-audio-bar-visualizer\" });\n    let u = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ae)();\n    (r || s) && (u = r || s);\n    const v = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(u, {\n      bands: c,\n      loPass: 100,\n      hiPass: 200\n    }), f = (a == null ? void 0 : a.minHeight) ?? 20, p = (a == null ? void 0 : a.maxHeight) ?? 100, E = Xt(\n      n,\n      c,\n      Jt(n, c) ?? 100\n    );\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: i, ...d, \"data-lk-va-state\": n }, v.map(\n      (h, m) => o ? (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(o, {\n        \"data-lk-highlighted\": E.includes(m),\n        \"data-lk-bar-index\": m,\n        className: \"lk-audio-bar\",\n        style: { height: `${Math.min(p, Math.max(f, h * 100 + 5))}%` }\n      }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"span\",\n        {\n          key: m,\n          \"data-lk-highlighted\": E.includes(m),\n          \"data-lk-bar-index\": m,\n          className: `lk-audio-bar ${E.includes(m) && \"lk-highlighted\"}`,\n          style: {\n            // TODO transform animations would be more performant, however the border-radius gets distorted when using scale transforms. a 9-slice approach (or 3 in this case) could work\n            // transform: `scale(1, ${Math.min(maxHeight, Math.max(minHeight, volume))}`,\n            height: `${Math.min(p, Math.max(f, h * 100 + 5))}%`\n          }\n        }\n      )\n    ));\n  }\n), Ca = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({\n    children: n,\n    disableSpeakingIndicator: a,\n    onParticipantClick: c,\n    trackRef: r,\n    ...s\n  }, o) {\n    const l = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(r), { elementProps: i } = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.l)({\n      trackRef: l,\n      htmlProps: s,\n      disableSpeakingIndicator: a,\n      onParticipantClick: c\n    });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, style: { position: \"relative\", minHeight: \"160px\" }, ...i }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ak.Provider, { value: l }, n ?? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ne, { trackRef: l }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Kt, { barCount: 7, options: { minHeight: 8 } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata-item\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(be, { trackRef: l }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ye, { className: \"lk-participant-metadata-item\" })))));\n  }\n);\nfunction Ia(t) {\n  const [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0), c = (0,_hooks_yU_srrIO_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(t.room);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    switch (c) {\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Reconnecting:\n        a(\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(oe, { className: \"lk-spinner\" }), \" Reconnecting\")\n        );\n        break;\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting:\n        a(\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(oe, { className: \"lk-spinner\" }), \" Connecting\")\n        );\n        break;\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected:\n        a(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"Disconnected\"));\n        break;\n      default:\n        a(void 0);\n        break;\n    }\n  }, [c]), n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Gt, { className: \"lk-toast-connection-state\" }, n) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n}\nconst xa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function({ entry: n, hideName: a = !1, hideTimestamp: c = !1, messageFormatter: r, ...s }, o) {\n    var f, p, E, h;\n    const l = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => r ? r(n.message) : n.message, [n.message, r]), i = !!n.editTimestamp, d = new Date(n.timestamp), u = typeof navigator < \"u\" ? navigator.language : \"en-US\", v = ((f = n.from) == null ? void 0 : f.name) ?? ((p = n.from) == null ? void 0 : p.identity);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"li\",\n      {\n        ref: o,\n        className: \"lk-chat-entry\",\n        title: d.toLocaleTimeString(u, { timeStyle: \"full\" }),\n        \"data-lk-message-origin\": (E = n.from) != null && E.isLocal ? \"local\" : \"remote\",\n        ...s\n      },\n      (!c || !a || i) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-meta-data\" }, !a && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"strong\", { className: \"lk-participant-name\" }, v), (!c || i) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-timestamp\" }, i && \"edited \", d.toLocaleTimeString(u, { timeStyle: \"short\" }))),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-message-body\" }, l),\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-message-attachements\" }, (h = n.attachedFiles) == null ? void 0 : h.map(\n        (m) => m.type.startsWith(\"image/\") && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n          \"img\",\n          {\n            style: { maxWidth: \"300px\", maxHeight: \"300px\" },\n            key: m.name,\n            src: URL.createObjectURL(m),\n            alt: m.name\n          }\n        )\n      ))\n    );\n  }\n);\nfunction Pa(t) {\n  return (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ap)(t, (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.aq)()).map((n, a) => {\n    if (typeof n == \"string\")\n      return n;\n    {\n      const c = n.content.toString(), r = n.type === \"url\" ? /^http(s?):\\/\\//.test(c) ? c : `https://${c}` : `mailto:${c}`;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { className: \"lk-chat-link\", key: a, href: r, target: \"_blank\", rel: \"noreferrer\" }, c);\n    }\n  });\n}\nfunction Ta(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.ar.Provider, { value: t.session }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_3__.R.Provider, { value: t.session.room }, t.children));\n}\n\n//# sourceMappingURL=components-DuRBtGp8.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy1EdVJCdEdwOC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkI7QUFDdUQ7QUFDMEo7QUFDdEw7QUFDMEc7QUFDZ0o7QUFDaFQsMkJBQTJCLDZDQUFZO0FBQ3ZDO0FBQ0EsWUFBWSxpQkFBaUIsRUFBRSxzREFBRTtBQUNqQywyQkFBMkIsZ0RBQWUsYUFBYSxjQUFjO0FBQ3JFO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDLGFBQWEsZUFBZTtBQUM1QixjQUFjLHNEQUFFO0FBQ2hCLDJCQUEyQixnREFBZSxVQUFVLGNBQWM7QUFDbEU7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEM7QUFDQSxZQUFZLGlCQUFpQixFQUFFLHNEQUFFLEdBQUcsVUFBVTtBQUM5QywyQkFBMkIsZ0RBQWUsYUFBYSxjQUFjO0FBQ3JFO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDO0FBQ0EsWUFBWSxpQkFBaUIsRUFBRSxzREFBRTtBQUNqQywyQkFBMkIsZ0RBQWUsYUFBYSxjQUFjO0FBQ3JFO0FBQ0EsK0JBQStCLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxXQUFXLHVNQUF1TSxtQkFBbUIsZ0RBQWUsV0FBVyxxR0FBcUcsZ0NBQWdDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxXQUFXLHVNQUF1TSxnQ0FBZ0MsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlO0FBQzNrQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLFVBQVUsZ0ZBQWdGLGtCQUFrQixnREFBZTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlLFFBQVEsMkZBQTJGLGtCQUFrQixnREFBZSxXQUFXLG9FQUFvRSxpQ0FBaUMsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlO0FBQ3hpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxXQUFXLHFaQUFxWixtQkFBbUIsZ0RBQWUsV0FBVyxxREFBcUQsZ0NBQWdDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZTtBQUN0MkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlLFdBQVcsMENBQTBDLGdDQUFnQyxnREFBZSxVQUFVLHdGQUF3RixrQkFBa0IsZ0RBQWUsV0FBVyxxUEFBcVAsbUJBQW1CLGdEQUFlLFdBQVcscVBBQXFQLGdDQUFnQyxnREFBZSxVQUFVLHdGQUF3RixrQkFBa0IsZ0RBQWUsV0FBVyxzS0FBc0ssbUJBQW1CLGdEQUFlLFdBQVcsc0tBQXNLLG1CQUFtQixnREFBZSxRQUFRLGVBQWUsa0JBQWtCLGdEQUFlLFdBQVcsd0ZBQXdGLG1CQUFtQixnREFBZSxXQUFXLHdGQUF3RixpQ0FBaUMsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlLFdBQVcsd0ZBQXdGLG1CQUFtQixnREFBZSxXQUFXLHdGQUF3RixtQkFBbUIsZ0RBQWUsUUFBUSxlQUFlLGtCQUFrQixnREFBZSxXQUFXLHVGQUF1RixtQkFBbUIsZ0RBQWUsV0FBVyxzS0FBc0ssbUJBQW1CLGdEQUFlLFdBQVcsd0ZBQXdGLGlDQUFpQyxnREFBZSxVQUFVLHdGQUF3RixrQkFBa0IsZ0RBQWUsUUFBUSxlQUFlLGtCQUFrQixnREFBZSxXQUFXLDhQQUE4UCxtQkFBbUIsZ0RBQWUsV0FBVyw4UEFBOFAsaUNBQWlDLGdEQUFlLFVBQVUsZ0ZBQWdGLGtCQUFrQixnREFBZTtBQUM1aEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlLFFBQVEsc0JBQXNCLGtCQUFrQixnREFBZSxXQUFXLDRLQUE0SyxtQkFBbUIsZ0RBQWU7QUFDbGM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFlLFVBQVUsZ0ZBQWdGLGtCQUFrQixnREFBZTtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlLFFBQVEsMkZBQTJGLGtCQUFrQixnREFBZSxXQUFXLHlFQUF5RSwwQkFBMEIsNkNBQVk7QUFDeGEsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYywwREFBRSxNQUFNLDZCQUE2QixFQUFFLHNEQUFFO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLGdEQUFlLENBQUMsc0RBQUUsd0RBQXdELGdEQUFlLGFBQWEsY0FBYyxnREFBZ0QsZ0RBQWUsNkJBQTZCLGdEQUFlO0FBQzFQO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyx5REFBRSxRQUFRLHlDQUFRLGlCQUFpQiw4Q0FBYTtBQUM5RDtBQUNBLG9CQUFvQixxREFBRTtBQUN0QixPQUFPO0FBQ1A7QUFDQSxTQUFTLHVFQUF1RSxFQUFFLHNEQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBVztBQUNmO0FBQ0EsS0FBSyxRQUFRLDRDQUFXO0FBQ3hCO0FBQ0EsS0FBSyxXQUFXLDRDQUFXO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNLDBDQUFTO0FBQ3BCLFlBQVkscURBQUMsTUFBTSxjQUFjLElBQUksc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWUsU0FBUyxjQUFjLGtDQUFrQyxnREFBZTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsZ0RBQWUsYUFBYSxzREFBc0Q7QUFDeEc7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQyxhQUFhLGdDQUFnQztBQUM3QyxjQUFjLHlEQUFFLFlBQVksaUJBQWlCLEVBQUUsc0RBQUUsR0FBRyxtQkFBbUI7QUFDdkUsMkJBQTJCLGdEQUFlLGFBQWEsY0FBYztBQUNyRTtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQyxhQUFhLGdCQUFnQjtBQUM3QixjQUFjLHlEQUFFLE1BQU0sa0NBQWtDLEVBQUUsc0RBQUUsR0FBRyxtQkFBbUIsS0FBSyxrQ0FBa0MsRUFBRSxzREFBRSxHQUFHLG1CQUFtQixLQUFLLGlCQUFpQjtBQUN6SyxrRUFBa0UsZ0RBQWUsYUFBYSx3QkFBd0IsZ0JBQWdCLHNCQUFzQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQUM7QUFDVixpQ0FBaUMsZ0RBQWUsNkJBQTZCLGdEQUFlO0FBQzVGLFNBQVMsaURBQUM7QUFDVixpQ0FBaUMsZ0RBQWUsNkJBQTZCLGdEQUFlO0FBQzVGLFNBQVMsaURBQUM7QUFDVixpQ0FBaUMsZ0RBQWUsNkJBQTZCLGdEQUFlO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkRBQUM7QUFDViw2QkFBNkIsZ0RBQWU7QUFDNUMsU0FBUyw2REFBQztBQUNWLDZCQUE2QixnREFBZTtBQUM1QyxTQUFTLDZEQUFDO0FBQ1YsNkJBQTZCLGdEQUFlO0FBQzVDO0FBQ0EsNkJBQTZCLGdEQUFlO0FBQzVDO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQVksWUFBWSxtQkFBbUI7QUFDdEUsVUFBVSw2QkFBNkIsRUFBRSxzREFBRSxjQUFjLDJDQUFVO0FBQ25FLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxHQUFHLDRCQUE0QixnREFBZSxhQUFhLGNBQWM7QUFDekUsQ0FBQyx3QkFBd0IsNkNBQVk7QUFDckMsVUFBVSwyQkFBMkIsRUFBRSxzREFBRSxTQUFTLDBDQUFTLFVBQVUsR0FBRyxxREFBQyxNQUFNLGNBQWMseUJBQXlCO0FBQ3RILHlCQUF5QixnREFBZSxVQUFVLGNBQWM7QUFDaEUsQ0FBQyx1QkFBdUIsNkNBQVk7QUFDcEMsYUFBYSxzQkFBc0I7QUFDbkMsY0FBYyx5REFBRSxPQUFPLGdDQUFnQyxFQUFFLDBDQUFTLE9BQU8sMERBQUUsYUFBYSx1QkFBdUIsRUFBRSxzREFBRTtBQUNuSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sMENBQVMsT0FBTyxxREFBQyxNQUFNLDZDQUE2QztBQUNoRiwyQkFBMkIsZ0RBQWUsV0FBVyxjQUFjO0FBQ25FO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDLGFBQWEsdUNBQXVDO0FBQ3BELFlBQVksMkJBQTJCLEVBQUUsc0RBQUUsNEVBQTRFLDBDQUFTO0FBQ2hJLFlBQVkscURBQUM7QUFDYjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0JBQStCLGdEQUFlLFVBQVUsa0NBQWtDO0FBQzFGO0FBQ0EsK0JBQStCLGdEQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsZ0RBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUIsMkNBQVUsQ0FBQyx5REFBRSxlQUFlLDJDQUFVLDJDQUEyQywyQ0FBVSxnREFBZ0QsMkNBQVUseUNBQXlDLDJDQUFVLG1CQUFtQix5Q0FBUSxNQUFNLGlDQUFpQyxFQUFFLDBDQUFTLE9BQU8seURBQUU7QUFDL1M7QUFDQTtBQUNBLElBQUksMERBQUM7QUFDTDtBQUNBLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxNQUFNLHFEQUFDO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRyxRQUFRLDRDQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQkFBbUIsNENBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBQztBQUNuQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJLQUEySyxzREFBQyxnQkFBZ0Isc0RBQUMsSUFBSSxzREFBQyxzQkFBc0Isc0RBQUM7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBRTtBQUM3QjtBQUNBLFlBQVksNkNBQUM7QUFDYixpQkFBaUIsZ0RBQUM7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQUM7QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksOENBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILFNBQVMsZ0RBQUM7QUFDVjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0VBQStFLCtDQUFDLFNBQVMsNkNBQUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBLGlCQUFpQiwrQ0FBQyxpQkFBaUIsK0NBQUM7QUFDcEM7QUFDQTtBQUNBLEdBQUcsUUFBUSw2Q0FBQztBQUNaO0FBQ0E7QUFDQSxFQUFFLGdEQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQyxTQUFTO0FBQ1QsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBQztBQUNiLEVBQUUsZ0RBQUM7QUFDSDtBQUNBLDhIQUE4SCxrQ0FBa0M7QUFDaEssR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMseURBQUMsU0FBUyx5Q0FBUTtBQUNoQyxJQUFJLHNEQUFxQjtBQUN6QixtQkFBbUIsaUJBQWlCO0FBQ3BDLElBQUksNENBQVc7QUFDZixvQ0FBb0Msa0VBQUM7QUFDckMsS0FBSyxjQUFjLDRDQUFXO0FBQzlCLG9DQUFvQyxrRUFBQztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFXO0FBQ2Y7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsMkRBQTJEO0FBQ3JHO0FBQ0EsMkJBQTJCLGdEQUFlLFlBQVkscUNBQXFDO0FBQzNGO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDLGFBQWEsOERBQThEO0FBQzNFLGNBQWMseURBQUMsU0FBUyx5Q0FBUTtBQUNoQyxJQUFJLHNEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyw0Q0FBVztBQUN0QjtBQUNBLEtBQUssV0FBVyw0Q0FBVztBQUMzQixvREFBb0QsNERBQUUsb0JBQW9CLHFEQUFDO0FBQzNFLEtBQUssV0FBVyw0Q0FBVztBQUMzQiwwREFBMEQsa0VBQUMsNEJBQTRCLHFEQUFDO0FBQ3hGLEtBQUssb0NBQW9DLGdEQUFlLFlBQVksY0FBYztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFFO0FBQ2hCLCtDQUErQyxnREFBZSxDQUFDLHNEQUFFLGFBQWEsc0JBQXNCLGdDQUFnQyxnREFBZSxDQUFDLDJDQUFVO0FBQzlKO0FBQ0E7QUFDQSxjQUFjLDBEQUFFO0FBQ2hCLDRDQUE0QyxnREFBZSxDQUFDLHNEQUFFLGFBQWEsbUJBQW1CLGdDQUFnQyxnREFBZSxDQUFDLDJDQUFVO0FBQ3hKO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMseURBQUMsT0FBTyxrQkFBa0IsRUFBRSxzREFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTyxzREFBRSxxQkFBcUIseURBQUUsYUFBYSwwREFBRSwrQ0FBK0MsOENBQWE7QUFDaEg7QUFDQSxpREFBaUQseURBQUUscUNBQXFDLGtCQUFrQjtBQUMxRyxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixnREFBZSxVQUFVLGlCQUFpQixzQkFBc0IsUUFBUSxrQkFBa0IsZ0RBQWUsT0FBTyxhQUFhLGtCQUFrQixnREFBZSxPQUFPLDRCQUE0Qix1QkFBdUIsZ0RBQWUsQ0FBQywyQ0FBVSxRQUFRLDBEQUFDLG9GQUFvRixpREFBQywrQkFBK0IsaURBQUMsdUNBQXVDLGdEQUFlO0FBQ2pjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQUMsdUJBQXVCLGdEQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWUsVUFBVSx5Q0FBeUMsa0JBQWtCLGdEQUFlLDZCQUE2QixnREFBZSxVQUFVLHNDQUFzQyxrQkFBa0IsZ0RBQWUsVUFBVSwyQ0FBMkMsZUFBZSxpREFBQyxpQ0FBaUMsZ0RBQWUsQ0FBQywyQ0FBVSw2QkFBNkIsZ0RBQWUsT0FBTyxTQUFTLDBCQUEwQixtQkFBbUIsZ0RBQWU7QUFDL2U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQUM7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWUsNkJBQTZCLGdEQUFlLENBQUMsMkNBQVUsd0JBQXdCLGdEQUFlLE9BQU8sU0FBUywwQkFBMEIsbUJBQW1CLGdEQUFlLDBDQUEwQyxnREFBZSxPQUFPLDJDQUEyQyxxQkFBcUIsZ0RBQWUsT0FBTyxhQUFhO0FBQ25YO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQUMsTUFBTSw4QkFBOEI7QUFDakQseUJBQXlCLGdEQUFlLFVBQVUsTUFBTTtBQUN4RDtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLHlCQUF5QixnREFBZSxPQUFPLG1CQUFtQjtBQUNsRTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLHlCQUF5QixnREFBZSxDQUFDLDJDQUFVLHFDQUFxQyxnREFBZTtBQUN2RyxJQUFJLHNEQUFFO0FBQ047QUFDQTtBQUNBLFdBQVcseURBQUU7QUFDYixLQUFLO0FBQ0wsSUFBSSxxREFBRTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDJDQUFVO0FBQzNCLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxxQkFBcUIsMERBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdCQUF3QixnREFBZSxVQUFVLG1FQUFtRSxrQkFBa0IsZ0RBQWUsYUFBYSxvQ0FBb0Msa0JBQWtCLGdEQUFlLDZCQUE2QixnREFBZSxXQUFXLGtDQUFrQyxLQUFLLEdBQUcsS0FBSyxFQUFFLG9CQUFvQixnREFBZSxhQUFhLG9DQUFvQyxrQkFBa0IsZ0RBQWU7QUFDdmM7QUFDQSwyQkFBMkIsNkNBQVk7QUFDdkMsYUFBYSxtQ0FBbUM7QUFDaEQsZ0ZBQWdGLGdEQUFlLFdBQVcsOEJBQThCLG9CQUFvQixnREFBZSxXQUFXLFFBQVE7QUFDOUwsMkJBQTJCLGdEQUFlLFVBQVUsOENBQThDO0FBQ2xHO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixZQUFZLDRDQUFXLFFBQVEsMENBQVM7QUFDeEMsVUFBVSxxREFBQyxNQUFNLDZCQUE2QjtBQUM5QztBQUNBLE9BQU8sWUFBWSxFQUFFLHNEQUFFLG1CQUFtQixzREFBRTtBQUM1QyxTQUFTLHNEQUFFO0FBQ1g7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLGdEQUFlLFVBQVUsMERBQTBELGtCQUFrQixnREFBZSxPQUFPLGtCQUFrQix3REFBd0QsZ0RBQWUsQ0FBQywyQ0FBVSx3QkFBd0IsZ0RBQWU7QUFDNVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBZSxPQUFPLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0MsWUFBWSx5Q0FBUSxpQkFBaUIsMkNBQVUsT0FBTyxzQkFBc0IsRUFBRSxzREFBRSw0SEFBNEgsMERBQUU7QUFDOU07QUFDQTtBQUNBLFlBQVksc0RBQUU7QUFDZCxTQUFTLGtEQUFpQjtBQUMxQjtBQUNBLEdBQUcsMkJBQTJCLGdEQUFlLFlBQVksZ0RBQWdELGtCQUFrQixnREFBZSxPQUFPLFdBQVc7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVksMERBQUU7QUFDZCxTQUFTLDRDQUFXO0FBQ3BCLElBQUkscURBQUMsNkJBQTZCLG9CQUFvQjtBQUN0RCxHQUFHLHFCQUFxQiw0Q0FBVztBQUNuQyxJQUFJLHFEQUFDLDJCQUEyQiw2QkFBNkI7QUFDN0QsR0FBRyx3Q0FBd0MsZ0RBQWUsQ0FBQyxzREFBRSxhQUFhLFVBQVU7QUFDcEY7QUFDQSwyQkFBMkIsNkNBQVk7QUFDdkMsYUFBYSxtQkFBbUI7QUFDaEMsY0FBYyx5REFBQyxTQUFTLHNEQUFFLE1BQU0sdUJBQXVCO0FBQ3ZELDJCQUEyQixnREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixnREFBZSxXQUFXLCtDQUErQztBQUMvRixzQkFBc0IsZ0RBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGdEQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMseUJBQXlCLGdEQUFlLENBQUMsMkNBQVUscUNBQXFDLGdEQUFlLENBQUMsc0RBQUUsYUFBYSwyQkFBMkIsRUFBRSxxREFBRTtBQUN0SjtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLFlBQVksc0RBQUU7QUFDZCxLQUFLLGlEQUFDLG9CQUFvQixpREFBQywwQkFBMEIsaURBQUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpREFBQztBQUNwRSx5QkFBeUIsZ0RBQWUsVUFBVSxTQUFTLG1CQUFtQiwrQkFBK0IsZ0RBQWU7QUFDNUg7QUFDQTtBQUNBLFdBQVcseURBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQVksWUFBWSxtREFBbUQ7QUFDdEcsVUFBVSxVQUFVLEVBQUUsc0RBQUU7QUFDeEIseUJBQXlCLGdEQUFlLFdBQVcsY0FBYztBQUNqRSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLDBDQUFTLE9BQU8scURBQUMsTUFBTSx1QkFBdUI7QUFDMUQseUJBQXlCLGdEQUFlLFVBQVUsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwrQ0FBQyxjQUFjLCtDQUFDO0FBQ2pDLEVBQUUsZ0RBQUM7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNILFlBQVksNkNBQUM7QUFDYixTQUFTLGdEQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLDZDQUFZO0FBQ3BDLGFBQWEsa0ZBQWtGO0FBQy9GLGNBQWMscURBQUMsTUFBTSxzQ0FBc0M7QUFDM0QsWUFBWSwwREFBRTtBQUNkO0FBQ0EsY0FBYyxzREFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWUsVUFBVSxxQ0FBcUM7QUFDekYsb0JBQW9CLHFEQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXLHNDQUFzQztBQUNsRSxPQUFPLG9CQUFvQixnREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2Rix1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMseURBQUMsT0FBTyxrQkFBa0IsRUFBRSxzREFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsZ0RBQWUsVUFBVSxpQkFBaUIsMENBQTBDLFFBQVEsa0JBQWtCLGdEQUFlLENBQUMsc0RBQUUsYUFBYSxVQUFVLHVCQUF1QixnREFBZSxDQUFDLDJDQUFVLFFBQVEsMERBQUMsdUJBQXVCLGdEQUFlLE9BQU8sYUFBYSxtQkFBbUIsZ0RBQWUsT0FBTyx3QkFBd0IsZ0JBQWdCLG1CQUFtQixnREFBZSxVQUFVLHNDQUFzQyxrQkFBa0IsZ0RBQWUsVUFBVSwyQ0FBMkMsa0JBQWtCLGdEQUFlLE9BQU8sYUFBYSxtQkFBbUIsZ0RBQWUsNEJBQTRCLGdEQUFlLE9BQU8sMkNBQTJDO0FBQ250QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVUsY0FBYyxzREFBRTtBQUMzQyxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsV0FBVywyREFBQztBQUNaO0FBQ0EsMEJBQTBCLGdEQUFlLENBQUMsMkNBQVUsd0JBQXdCLGdEQUFlLE9BQU8seUJBQXlCO0FBQzNIO0FBQ0E7QUFDQSxXQUFXLDJEQUFDO0FBQ1o7QUFDQSwwQkFBMEIsZ0RBQWUsQ0FBQywyQ0FBVSx3QkFBd0IsZ0RBQWUsT0FBTyx5QkFBeUI7QUFDM0g7QUFDQTtBQUNBLFdBQVcsMkRBQUM7QUFDWiwwQkFBMEIsZ0RBQWUsQ0FBQywyQ0FBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsZ0RBQWUsT0FBTyx3Q0FBd0MsdUJBQXVCLGdEQUFlLENBQUMsMkNBQVU7QUFDOUk7QUFDQSwyQkFBMkIsNkNBQVk7QUFDdkMsYUFBYSw4RUFBOEU7QUFDM0Y7QUFDQSxjQUFjLDBDQUFTO0FBQ3ZCLDJCQUEyQixnREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBLE9BQU87QUFDUCx5Q0FBeUMsZ0RBQWUsV0FBVywyQkFBMkIsd0JBQXdCLGdEQUFlLGFBQWEsa0NBQWtDLG1DQUFtQyxnREFBZSxXQUFXLDJCQUEyQiw0Q0FBNEMsb0JBQW9CO0FBQzVVLHNCQUFzQixnREFBZSxXQUFXLDhCQUE4QjtBQUM5RSxzQkFBc0IsZ0RBQWUsV0FBVyxzQ0FBc0M7QUFDdEYsOERBQThELGdEQUFlO0FBQzdFO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBRSxJQUFJLDBEQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxFQUFFLGNBQWMsRUFBRTtBQUN6SCw2QkFBNkIsZ0RBQWUsUUFBUSxpRkFBaUY7QUFDckk7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlCQUF5QixnREFBZSxDQUFDLHNEQUFFLGFBQWEsa0JBQWtCLGtCQUFrQixnREFBZSxDQUFDLHFEQUFFLGFBQWEsdUJBQXVCO0FBQ2xKO0FBd0RFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZla2l0L2NvbXBvbmVudHMtcmVhY3QvZGlzdC9jb21wb25lbnRzLUR1UkJ0R3A4Lm1qcz84NGMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGUgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyBCLCB1c2VSZWYgYXMgeiwgdXNlRWZmZWN0IGFzIFYsIHVzZU1lbW8gYXMgTmUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHUgYXMgTGUsIGEgYXMgaGUsIGIgYXMgemUsIGMgYXMgVmUsIGQgYXMgRmUsIGUgYXMgWmUsIGYgYXMgZ2UsIGcgYXMgSGUsIGggYXMgQmUsIGkgYXMgamUsIGogYXMgX2UsIGsgYXMgT2UsIGwgYXMgdmUsIG0gYXMgV2UsIG4gYXMgcWUsIG8gYXMgJGUsIHAgYXMgRGUsIHEgYXMgVWUsIHIgYXMgR2UsIHMgYXMgRWUsIHQgYXMgUWUsIHYgYXMgWGUgfSBmcm9tIFwiLi9ob29rcy15VS1zcnJJTy5tanNcIjtcbmltcG9ydCB7IGEgYXMgSSwgYyBhcyBlZSB9IGZyb20gXCIuL3Jvb20tQmI2dUx4UzUubWpzXCI7XG5pbXBvcnQgeyBSb29tRXZlbnQgYXMgWWUsIFRyYWNrIGFzIFMsIENvbm5lY3Rpb25RdWFsaXR5IGFzIFEsIFJlbW90ZVRyYWNrUHVibGljYXRpb24gYXMgSiwgUmVtb3RlQXVkaW9UcmFjayBhcyBKZSwgQ29ubmVjdGlvblN0YXRlIGFzIFggfSBmcm9tIFwibGl2ZWtpdC1jbGllbnRcIjtcbmltcG9ydCB7IGFlIGFzIHRlLCBhZiBhcyBwZSwgdyBhcyBLZSwgdSBhcyBldCwgZiBhcyB0dCwgYyBhcyBhdCwgYWcgYXMgbnQsIFggYXMgcnQsIFkgYXMgY3QsIGExIGFzICQsIGwgYXMgaiwgYWggYXMgcSwgYWkgYXMgbHQsIGkgYXMgXywgQiBhcyBzdCwgYWogYXMgd2UsIGFrIGFzIGFlLCBqIGFzIGl0LCBhbCBhcyBvdCwgbSBhcyB1dCwgcCBhcyBrZSwgYW0gYXMgZHQsIGFuIGFzIG10LCBhbyBhcyBmdCwgYXAgYXMgaHQsIGFxIGFzIGd0LCBhciBhcyB2dCwgUiBhcyBFdCB9IGZyb20gXCIuL2NvbnRleHRzLUNzTzFRWjNyLm1qc1wiO1xuY29uc3QgY2EgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbihuLCBhKSB7XG4gICAgY29uc3QgeyBidXR0b25Qcm9wczogYyB9ID0gTGUobik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGEsIC4uLmMgfSwgbi5jaGlsZHJlbik7XG4gIH1cbiksIGxhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oeyByb29tOiBuLCAuLi5hIH0sIGMpIHtcbiAgICBjb25zdCByID0gaGUobik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGMsIC4uLmEgfSwgcik7XG4gIH1cbiksIHNhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24obiwgYSkge1xuICAgIGNvbnN0IHsgbWVyZ2VkUHJvcHM6IGMgfSA9IHplKHsgcHJvcHM6IG4gfSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGEsIC4uLmMgfSwgbi5jaGlsZHJlbik7XG4gIH1cbiksIGlhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24obiwgYSkge1xuICAgIGNvbnN0IHsgYnV0dG9uUHJvcHM6IGMgfSA9IFZlKG4pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcmVmOiBhLCAuLi5jIH0sIG4uY2hpbGRyZW4pO1xuICB9XG4pLCBwdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMS4zNTQuNjQ2YS41LjUgMCAxIDAtLjcwOC43MDhsMTQgMTRhLjUuNSAwIDAgMCAuNzA4LS43MDhMMTEgMTAuMjkzVjQuNUExLjUgMS41IDAgMCAwIDkuNSAzSDMuNzA3ek0wIDQuNWExLjUgMS41IDAgMCAxIC45NDMtMS4zOTNsOS41MzIgOS41MzNjLS4yNjIuMjI0LS42MDMuMzYtLjk3NS4zNmgtOEExLjUgMS41IDAgMCAxIDAgMTEuNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIm0xNS4yIDMuNi0yLjggMi4xYTEgMSAwIDAgMC0uNC44djNhMSAxIDAgMCAwIC40LjhsMi44IDIuMWEuNS41IDAgMCAwIC44LS40VjRhLjUuNSAwIDAgMC0uOC0uNHpcIiB9KSksIHd0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDQuNUExLjUgMS41IDAgMCAxIDEuNSAzaDhBMS41IDEuNSAwIDAgMSAxMSA0LjV2N0ExLjUgMS41IDAgMCAxIDkuNSAxM2gtOEExLjUgMS41IDAgMCAxIDAgMTEuNXpNMTUuMiAzLjZsLTIuOCAyLjFhMSAxIDAgMCAwLS40Ljh2M2ExIDEgMCAwIDAgLjQuOGwyLjggMi4xYS41LjUgMCAwIDAgLjgtLjRWNGEuNS41IDAgMCAwLS44LS40elwiIH0pKSwgb2EgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiI0ZGRlwiLFxuICAgIGQ6IFwiTTQuOTkgMy45OWExIDEgMCAwIDAtLjY5NyAxLjcxN0wxMC41ODYgMTJsLTYuMjkzIDYuMjkzYTEgMSAwIDEgMCAxLjQxNCAxLjQxNEwxMiAxMy40MTRsNi4yOTMgNi4yOTNhMSAxIDAgMSAwIDEuNDE0LTEuNDE0TDEzLjQxNCAxMmw2LjI5My02LjI5M2ExIDEgMCAwIDAtLjcyNy0xLjcxNyAxIDEgMCAwIDAtLjY4Ny4zMDNMMTIgMTAuNTg2IDUuNzA3IDQuMjkzYTEgMSAwIDAgMC0uNzE3LS4zMDN6XCJcbiAgfVxuKSksIHVhID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTgsIGZpbGw6IFwibm9uZVwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwicGF0aFwiLFxuICB7XG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMCAyLjc1QTIuNzUgMi43NSAwIDAgMSAyLjc1IDBoMTAuNUEyLjc1IDIuNzUgMCAwIDEgMTYgMi43NXYxMy41OTRhLjc1Ljc1IDAgMCAxLTEuMjM0LjU3MmwtMy42OTEtMy4xMmExLjI1IDEuMjUgMCAwIDAtLjgwNy0uMjk2SDIuNzVBMi43NSAyLjc1IDAgMCAxIDAgMTAuNzV2LThaTTIuNzUgMS41Yy0uNjkgMC0xLjI1LjU2LTEuMjUgMS4yNXY4YzAgLjY5LjU2IDEuMjUgMS4yNSAxLjI1aDcuNTE4Yy42NSAwIDEuMjc5LjIzIDEuNzc1LjY1bDIuNDU3IDIuMDc3VjIuNzVjMC0uNjktLjU2LTEuMjUtMS4yNS0xLjI1SDIuNzVaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwicGF0aFwiLFxuICB7XG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMyA0LjVhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05YS41LjUgMCAwIDEtLjUtLjVabTAgMmEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlhLjUuNSAwIDAgMS0uNS0uNVptMCAyYS41LjUgMCAwIDEgLjUtLjVoNWEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxLS41LS41WlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pKSwgaWUgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRjb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk01LjI5MyAyLjI5M2ExIDEgMCAwIDEgMS40MTQgMGw0LjgyMyA0LjgyM2ExLjI1IDEuMjUgMCAwIDEgMCAxLjc2OGwtNC44MjMgNC44MjNhMSAxIDAgMCAxLTEuNDE0LTEuNDE0TDkuNTg2IDggNS4yOTMgMy43MDdhMSAxIDAgMCAxIDAtMS40MTR6XCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbikpLCBrdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBzdHJva2VXaWR0aDogMS41IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTAgMS43NWg0LjI1bTAgMFY2bTAtNC4yNUw5IDdNNiAxNC4yNUgxLjc1bTAgMFYxMG0wIDQuMjVMNyA5XCIgfSkpKSwgZGEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRjb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk04Ljk2MS44OTRDOC44NzUtLjI5OCA3LjEyNS0uMjk4IDcuMDQuODk0Yy0uMDY2LjkxMi0xLjI0NiAxLjIyOC0xLjc2LjQ3Mi0uNjctLjk5LTIuMTg2LS4xMTUtMS42NjQuOTYuMzk5LjgyNC0uNDY1IDEuNjg4LTEuMjg4IDEuMjg5LTEuMDc2LS41MjItMS45NS45OTQtLjk2MSAxLjY2NS43NTYuNTEzLjQ0IDEuNjkzLS40NzIgMS43NTktMS4xOTIuMDg2LTEuMTkyIDEuODM2IDAgMS45MjIuOTEyLjA2NiAxLjIyOCAxLjI0Ni40NzIgMS43Ni0uOTkuNjctLjExNSAyLjE4Ni45NiAxLjY2NC44MjQtLjM5OSAxLjY4OC40NjUgMS4yODkgMS4yODgtLjUyMiAxLjA3Ni45OTQgMS45NSAxLjY2NS45NjEuNTEzLS43NTYgMS42OTMtLjQ0IDEuNzU5LjQ3Mi4wODYgMS4xOTIgMS44MzYgMS4xOTIgMS45MjIgMCAuMDY2LS45MTIgMS4yNDYtMS4yMjggMS43Ni0uNDcyLjY3Ljk5IDIuMTg2LjExNSAxLjY2NC0uOTYtLjM5OS0uODI0LjQ2NS0xLjY4OCAxLjI4OC0xLjI4OSAxLjA3Ni41MjIgMS45NS0uOTk0Ljk2MS0xLjY2NS0uNzU2LS41MTMtLjQ0LTEuNjkzLjQ3Mi0xLjc1OSAxLjE5Mi0uMDg2IDEuMTkyLTEuODM2IDAtMS45MjItLjkxMi0uMDY2LTEuMjI4LTEuMjQ2LS40NzItMS43Ni45OS0uNjcuMTE1LTIuMTg2LS45Ni0xLjY2NC0uODI0LjM5OS0xLjY4OC0uNDY1LTEuMjg5LTEuMjg4LjUyMi0xLjA3Ni0uOTk0LTEuOTUtMS42NjUtLjk2MS0uNTEzLjc1Ni0xLjY5My40NC0xLjc1OS0uNDcyWk04IDEzQTUgNSAwIDEgMCA4IDNhNSA1IDAgMCAwIDAgMTBaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbikpLCBtYSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTIgMi43NUEyLjc1IDIuNzUgMCAwIDEgNC43NSAwaDYuNUEyLjc1IDIuNzUgMCAwIDEgMTQgMi43NXYxMC41QTIuNzUgMi43NSAwIDAgMSAxMS4yNSAxNmgtNi41QTIuNzUgMi43NSAwIDAgMSAyIDEzLjI1di0uNWEuNzUuNzUgMCAwIDEgMS41IDB2LjVjMCAuNjkuNTYgMS4yNSAxLjI1IDEuMjVoNi41Yy42OSAwIDEuMjUtLjU2IDEuMjUtMS4yNVYyLjc1YzAtLjY5LS41Ni0xLjI1LTEuMjUtMS4yNWgtNi41Yy0uNjkgMC0xLjI1LjU2LTEuMjUgMS4yNXYuNWEuNzUuNzUgMCAwIDEtMS41IDB2LS41WlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTguNzggNy40N2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0yLjI1IDIuMjVhLjc1Ljc1IDAgMSAxLTEuMDYtMS4wNmwuOTctLjk3SDEuNzVhLjc1Ljc1IDAgMCAxIDAtMS41aDQuNjlsLS45Ny0uOTdhLjc1Ljc1IDAgMCAxIDEuMDYtMS4wNmwyLjI1IDIuMjVaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbikpLCBSdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTQgNi4xMDRWNGE0IDQgMCAxIDEgOCAwdjIuMTA0YzEuMTU0LjMyNiAyIDEuMzg3IDIgMi42NDZ2NC41QTIuNzUgMi43NSAwIDAgMSAxMS4yNSAxNmgtNi41QTIuNzUgMi43NSAwIDAgMSAyIDEzLjI1di00LjVjMC0xLjI1OS44NDYtMi4zMiAyLTIuNjQ2Wk01LjUgNGEyLjUgMi41IDAgMCAxIDUgMHYyaC01VjRaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbikpLCBNdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTIuMjI3IDExLjUyYTUuNDc3IDUuNDc3IDAgMCAwIDEuMjQ2LTIuOTcuNS41IDAgMCAwLS45OTUtLjEgNC40NzggNC40NzggMCAwIDEtLjk2MiAyLjM1OWwtMS4wNy0xLjA3QzEwLjc5NCA5LjI0NyAxMSA4LjY0NyAxMSA4VjNhMyAzIDAgMCAwLTYgMHYxLjI5M0wxLjM1NC42NDZhLjUuNSAwIDEgMC0uNzA4LjcwOGwxNCAxNGEuNS41IDAgMCAwIC43MDgtLjcwOHpNOCAxMi41Yy42ODMgMCAxLjMzLS4xNTIgMS45MTEtLjQyNWwuNzQzLjc0M2MtLjY0OS4zNTktMS4zNzguNTktMi4xNTQuNjZWMTVoMmEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxIDAtMWgydi0xLjUyMmE1LjUwMiA1LjUwMiAwIDAgMS00Ljk3My00LjkyOS41LjUgMCAwIDEgLjk5NS0uMDk4QTQuNSA0LjUgMCAwIDAgOCAxMi41elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTguNzQzIDEwLjkwNyA1IDcuMTY0VjhhMyAzIDAgMCAwIDMuNzQzIDIuOTA3elwiIH0pKSwgeXQgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0yLjk3NSA4LjAwMmEuNS41IDAgMCAxIC41NDcuNDQ5IDQuNSA0LjUgMCAwIDAgOC45NTYgMCAuNS41IDAgMSAxIC45OTUuMDk4QTUuNTAyIDUuNTAyIDAgMCAxIDguNSAxMy40NzhWMTVoMmEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxIDAtMWgydi0xLjUyMmE1LjUwMiA1LjUwMiAwIDAgMS00Ljk3My00LjkyOS41LjUgMCAwIDEgLjQ0OC0uNTQ3elwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTUgM2EzIDMgMCAxIDEgNiAwdjVhMyAzIDAgMCAxLTYgMHpcIiB9KSksIGJ0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSksIFN0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAgMTEuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djRhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6bTYtNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djlhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgb3BhY2l0eTogMC4yNSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEyIC41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTIgLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSkpLCBDdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcImN1cnJlbnRjb2xvclwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IG9wYWNpdHk6IDAuMjUgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02IDYuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djlhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2LjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMiAuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djE1YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pKSksIEl0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImdcIiwgeyBvcGFjaXR5OiAwLjI1IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtNFptNi01YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2OWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtOVptNi02YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjVWLjVaXCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtNFptNi01YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2OWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtOVptNi02YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjVWLjVaXCIgfSkpKSwgUmUgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAyMCwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0wIDIuNzVBMi43NSAyLjc1IDAgMCAxIDIuNzUgMGgxNC41QTIuNzUgMi43NSAwIDAgMSAyMCAyLjc1djEwLjVBMi43NSAyLjc1IDAgMCAxIDE3LjI1IDE2SDIuNzVBMi43NSAyLjc1IDAgMCAxIDAgMTMuMjVWMi43NVpNMi43NSAxLjVjLS42OSAwLTEuMjUuNTYtMS4yNSAxLjI1djEwLjVjMCAuNjkuNTYgMS4yNSAxLjI1IDEuMjVoMTQuNWMuNjkgMCAxLjI1LS41NiAxLjI1LTEuMjVWMi43NWMwLS42OS0uNTYtMS4yNS0xLjI1LTEuMjVIMi43NVpcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcbiAgfVxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk05LjQ3IDQuMjJhLjc1Ljc1IDAgMCAxIDEuMDYgMGwyLjI1IDIuMjVhLjc1Ljc1IDAgMCAxLTEuMDYgMS4wNmwtLjk3LS45N3Y0LjY5YS43NS43NSAwIDAgMS0xLjUgMFY2LjU2bC0uOTcuOTdhLjc1Ljc1IDAgMCAxLTEuMDYtMS4wNmwyLjI1LTIuMjVaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbikpLCB4dCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDIwLCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk03LjI4IDQuMjJhLjc1Ljc1IDAgMCAwLTEuMDYgMS4wNkw4Ljk0IDhsLTIuNzIgMi43MmEuNzUuNzUgMCAxIDAgMS4wNiAxLjA2TDEwIDkuMDZsMi43MiAyLjcyYS43NS43NSAwIDEgMCAxLjA2LTEuMDZMMTEuMDYgOGwyLjcyLTIuNzJhLjc1Ljc1IDAgMCAwLTEuMDYtMS4wNkwxMCA2Ljk0elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0yLjc1IDBBMi43NSAyLjc1IDAgMCAwIDAgMi43NXYxMC41QTIuNzUgMi43NSAwIDAgMCAyLjc1IDE2aDE0LjVBMi43NSAyLjc1IDAgMCAwIDIwIDEzLjI1VjIuNzVBMi43NSAyLjc1IDAgMCAwIDE3LjI1IDB6TTEuNSAyLjc1YzAtLjY5LjU2LTEuMjUgMS4yNS0xLjI1aDE0LjVjLjY5IDAgMS4yNS41NiAxLjI1IDEuMjV2MTAuNWMwIC42OS0uNTYgMS4yNS0xLjI1IDEuMjVIMi43NWMtLjY5IDAtMS4yNS0uNTYtMS4yNS0xLjI1elwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pKSksIG9lID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwibm9uZVwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwicGF0aFwiLFxuICB7XG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNOCAwYS43NS43NSAwIDAgMSAuNzUuNzV2Mi41YS43NS43NSAwIDAgMS0xLjUgMFYuNzVBLjc1Ljc1IDAgMCAxIDggMFpcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcbiAgfVxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk04IDEyYS43NS43NSAwIDAgMSAuNzUuNzV2Mi41YS43NS43NSAwIDAgMS0xLjUgMHYtMi41QS43NS43NSAwIDAgMSA4IDEyWlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBvcGFjaXR5OiAwLjdcbiAgfVxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0xMiAxLjA3MmEuNzUuNzUgMCAwIDEgLjI3NCAxLjAyNGwtMS4yNSAyLjE2NWEuNzUuNzUgMCAwIDEtMS4yOTktLjc1bDEuMjUtMi4xNjVBLjc1Ljc1IDAgMCAxIDEyIDEuMDcyWlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTYgMTEuNDY0YS43NS43NSAwIDAgMSAuMjc0IDEuMDI1bC0xLjI1IDIuMTY1YS43NS43NSAwIDAgMS0xLjI5OS0uNzVsMS4yNS0yLjE2NUEuNzUuNzUgMCAwIDEgNiAxMS40NjRaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIG9wYWNpdHk6IDAuNlxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTE0LjkyOCA0YS43NS43NSAwIDAgMS0uMjc0IDEuMDI1bC0yLjE2NSAxLjI1YS43NS43NSAwIDEgMS0uNzUtMS4zbDIuMTY1LTEuMjVBLjc1Ljc1IDAgMCAxIDE0LjkyOCA0WlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTQuNTM2IDEwYS43NS43NSAwIDAgMS0uMjc1IDEuMDI0bC0yLjE2NSAxLjI1YS43NS43NSAwIDAgMS0uNzUtMS4yOThsMi4xNjUtMS4yNUEuNzUuNzUgMCAwIDEgNC41MzYgMTBaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIG9wYWNpdHk6IDAuNVxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTE2IDhhLjc1Ljc1IDAgMCAxLS43NS43NWgtMi41YS43NS43NSAwIDAgMSAwLTEuNWgyLjVBLjc1Ljc1IDAgMCAxIDE2IDhaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH1cbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwicGF0aFwiLFxuICB7XG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNCA4YS43NS43NSAwIDAgMS0uNzUuNzVILjc1YS43NS43NSAwIDAgMSAwLTEuNWgyLjVBLjc1Ljc1IDAgMCAxIDQgOFpcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgb3BhY2l0eTogMC40XG4gIH1cbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwicGF0aFwiLFxuICB7XG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMTQuOTI4IDEyYS43NS43NSAwIDAgMS0xLjAyNC4yNzRsLTIuMTY1LTEuMjVhLjc1Ljc1IDAgMCAxIC43NS0xLjI5OWwyLjE2NSAxLjI1QS43NS43NSAwIDAgMSAxNC45MjggMTJaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIG9wYWNpdHk6IDAuOVxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTQuNTM2IDZhLjc1Ljc1IDAgMCAxLTEuMDI1LjI3NWwtMi4xNjUtMS4yNWEuNzUuNzUgMCAxIDEgLjc1LTEuM2wyLjE2NSAxLjI1QS43NS43NSAwIDAgMSA0LjUzNiA2WlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBvcGFjaXR5OiAwLjNcbiAgfVxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJwYXRoXCIsXG4gIHtcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0xMiAxNC45MjhhLjc1Ljc1IDAgMCAxLTEuMDI0LS4yNzRsLTEuMjUtMi4xNjVhLjc1Ljc1IDAgMCAxIDEuMjk4LS43NWwxLjI1IDIuMTY1QS43NS43NSAwIDAgMSAxMiAxNC45MjhaXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIG9wYWNpdHk6IDAuOFxuICB9XG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInBhdGhcIixcbiAge1xuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTYgNC41MzZhLjc1Ljc1IDAgMCAxLTEuMDI0LS4yNzVsLTEuMjUtMi4xNjVhLjc1Ljc1IDAgMSAxIDEuMjk5LS43NWwxLjI1IDIuMTY1QS43NS43NSAwIDAgMSA2IDQuNTM2WlwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBvcGFjaXR5OiAwLjJcbiAgfVxuKSksIFB0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwibm9uZVwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHN0cm9rZVdpZHRoOiAxLjUgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMy4yNSA3SDltMCAwVjIuNzVNOSA3bDUuMjUtNS4yNU0yLjc1IDlIN20wIDB2NC4yNU03IDlsLTUuMjUgNS4yNVwiIH0pKSksIFR0ID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oeyB0cmFja1JlZjogbiwgLi4uYSB9LCBjKSB7XG4gICAgY29uc3QgciA9IHRlKCksIHsgbWVyZ2VkUHJvcHM6IHMsIGluRm9jdXM6IG8gfSA9IEZlKHtcbiAgICAgIHRyYWNrUmVmOiBuID8/IHIsXG4gICAgICBwcm9wczogYVxuICAgIH0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHBlLkNvbnN1bWVyLCBudWxsLCAobCkgPT4gbCAhPT0gdm9pZCAwICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGMsIC4uLnMgfSwgYS5jaGlsZHJlbiA/IGEuY2hpbGRyZW4gOiBvID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChQdCwgbnVsbCkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGt0LCBudWxsKSkpO1xuICB9XG4pLCBmYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHtcbiAgICBraW5kOiBuLFxuICAgIGluaXRpYWxTZWxlY3Rpb246IGEsXG4gICAgb25BY3RpdmVEZXZpY2VDaGFuZ2U6IGMsXG4gICAgb25EZXZpY2VMaXN0Q2hhbmdlOiByLFxuICAgIG9uRGV2aWNlU2VsZWN0RXJyb3I6IHMsXG4gICAgZXhhY3RNYXRjaDogbyxcbiAgICB0cmFjazogbCxcbiAgICByZXF1ZXN0UGVybWlzc2lvbnM6IGksXG4gICAgb25FcnJvcjogZCxcbiAgICAuLi51XG4gIH0sIHYpIHtcbiAgICBjb25zdCBmID0gS2UoKSwgcCA9IGUudXNlUmVmKFwiZGVmYXVsdFwiKSwgRSA9IGUudXNlQ2FsbGJhY2soXG4gICAgICAodykgPT4ge1xuICAgICAgICBmICYmIGYuZW1pdChZZS5NZWRpYURldmljZXNFcnJvciwgdyksIGQgPT0gbnVsbCB8fCBkKHcpO1xuICAgICAgfSxcbiAgICAgIFtmLCBkXVxuICAgICksIHsgZGV2aWNlczogaCwgYWN0aXZlRGV2aWNlSWQ6IG0sIHNldEFjdGl2ZU1lZGlhRGV2aWNlOiB5LCBjbGFzc05hbWU6IEMgfSA9IFplKHtcbiAgICAgIGtpbmQ6IG4sXG4gICAgICByb29tOiBmLFxuICAgICAgdHJhY2s6IGwsXG4gICAgICByZXF1ZXN0UGVybWlzc2lvbnM6IGksXG4gICAgICBvbkVycm9yOiBFXG4gICAgfSk7XG4gICAgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgYSAhPT0gdm9pZCAwICYmIHkoYSk7XG4gICAgfSwgW3ldKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIHIoaCk7XG4gICAgfSwgW3IsIGhdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbSAhPT0gcC5jdXJyZW50ICYmIChjID09IG51bGwgfHwgYyhtKSksIHAuY3VycmVudCA9IG07XG4gICAgfSwgW21dKTtcbiAgICBjb25zdCBBID0gYXN5bmMgKHcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHkodywgeyBleGFjdDogbyA/PyAhMCB9KTtcbiAgICAgIH0gY2F0Y2ggKE0pIHtcbiAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICBzID09IG51bGwgfHwgcyhNKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IE07XG4gICAgICB9XG4gICAgfSwgTiA9IGUudXNlTWVtbyhcbiAgICAgICgpID0+IEkodSwgeyBjbGFzc05hbWU6IEMgfSwgeyBjbGFzc05hbWU6IFwibGstbGlzdFwiIH0pLFxuICAgICAgW0MsIHVdXG4gICAgKSwgZyA9ICEhaC5maW5kKCh3KSA9PiB3LmxhYmVsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImRlZmF1bHRcIikpO1xuICAgIGZ1bmN0aW9uIFIodywgTSwgUCkge1xuICAgICAgcmV0dXJuIHcgPT09IE0gfHwgIWcgJiYgUCA9PT0gMCAmJiBNID09PSBcImRlZmF1bHRcIjtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IHJlZjogdiwgLi4uTiB9LCBoLm1hcCgodywgTSkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIFwibGlcIixcbiAgICAgIHtcbiAgICAgICAga2V5OiB3LmRldmljZUlkLFxuICAgICAgICBpZDogdy5kZXZpY2VJZCxcbiAgICAgICAgXCJkYXRhLWxrLWFjdGl2ZVwiOiBSKHcuZGV2aWNlSWQsIG0sIE0pLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogUih3LmRldmljZUlkLCBtLCBNKSxcbiAgICAgICAgcm9sZTogXCJvcHRpb25cIlxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwibGstYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IEEody5kZXZpY2VJZCkgfSwgdy5sYWJlbClcbiAgICApKSk7XG4gIH1cbiksIGhhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oeyBsYWJlbDogbiA9IFwiQWxsb3cgQXVkaW9cIiwgLi4uYSB9LCBjKSB7XG4gICAgY29uc3QgciA9IGV0KGEucm9vbSksIHsgbWVyZ2VkUHJvcHM6IHMgfSA9IGdlKHsgcm9vbTogciwgcHJvcHM6IGEgfSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGMsIC4uLnMgfSwgbik7XG4gIH1cbiksIGdhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oeyBsYWJlbDogbiwgLi4uYSB9LCBjKSB7XG4gICAgY29uc3QgciA9IHR0KCksIHsgbWVyZ2VkUHJvcHM6IHMsIGNhblBsYXlBdWRpbzogbyB9ID0gZ2UoeyByb29tOiByLCBwcm9wczogYSB9KSwgeyBtZXJnZWRQcm9wczogbCwgY2FuUGxheVZpZGVvOiBpIH0gPSBIZSh7IHJvb206IHIsIHByb3BzOiBzIH0pLCB7IHN0eWxlOiBkLCAuLi51IH0gPSBsO1xuICAgIHJldHVybiBkLmRpc3BsYXkgPSBvICYmIGkgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIiwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYywgc3R5bGU6IGQsIC4uLnUgfSwgbiA/PyBgU3RhcnQgJHtvID8gXCJWaWRlb1wiIDogXCJBdWRpb1wifWApO1xuICB9XG4pO1xuZnVuY3Rpb24gTWUodCwgbikge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFMuU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICByZXR1cm4gbiA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoeXQsIG51bGwpIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChNdCwgbnVsbCk7XG4gICAgY2FzZSBTLlNvdXJjZS5DYW1lcmE6XG4gICAgICByZXR1cm4gbiA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQod3QsIG51bGwpIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChwdCwgbnVsbCk7XG4gICAgY2FzZSBTLlNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgIHJldHVybiBuID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh4dCwgbnVsbCkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFJlLCBudWxsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBBdCh0KSB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgUS5FeGNlbGxlbnQ6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChidCwgbnVsbCk7XG4gICAgY2FzZSBRLkdvb2Q6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChTdCwgbnVsbCk7XG4gICAgY2FzZSBRLlBvb3I6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChDdCwgbnVsbCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEl0LCBudWxsKTtcbiAgfVxufVxuY29uc3QgdmEgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKGZ1bmN0aW9uKHsgc2hvd0ljb246IG4sIC4uLmEgfSwgYykge1xuICBjb25zdCB7IGJ1dHRvblByb3BzOiByLCBlbmFibGVkOiBzIH0gPSBCZShhKSwgW28sIGxdID0gZS51c2VTdGF0ZSghMSk7XG4gIHJldHVybiBlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbCghMCk7XG4gIH0sIFtdKSwgbyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcmVmOiBjLCAuLi5yIH0sIChuID8/ICEwKSAmJiBNZShhLnNvdXJjZSwgcyksIGEuY2hpbGRyZW4pO1xufSksIHllID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihmdW5jdGlvbihuLCBhKSB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lOiBjLCBxdWFsaXR5OiByIH0gPSBqZShuKSwgcyA9IGUudXNlTWVtbygoKSA9PiAoeyAuLi5JKG4sIHsgY2xhc3NOYW1lOiBjIH0pLCBcImRhdGEtbGstcXVhbGl0eVwiOiByIH0pLCBbciwgbiwgY10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYSwgLi4ucyB9LCBuLmNoaWxkcmVuID8/IEF0KHIpKTtcbn0pLCBLID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oeyBwYXJ0aWNpcGFudDogbiwgLi4uYSB9LCBjKSB7XG4gICAgY29uc3QgciA9IGF0KG4pLCB7IGNsYXNzTmFtZTogcywgaW5mb09ic2VydmVyOiBvIH0gPSBlLnVzZU1lbW8oKCkgPT4gbnQociksIFtyXSksIHsgaWRlbnRpdHk6IGwsIG5hbWU6IGkgfSA9IF9lKG8sIHtcbiAgICAgIG5hbWU6IHIubmFtZSxcbiAgICAgIGlkZW50aXR5OiByLmlkZW50aXR5LFxuICAgICAgbWV0YWRhdGE6IHIubWV0YWRhdGFcbiAgICB9KSwgZCA9IGUudXNlTWVtbygoKSA9PiBJKGEsIHsgY2xhc3NOYW1lOiBzLCBcImRhdGEtbGstcGFydGljaXBhbnQtbmFtZVwiOiBpIH0pLCBbYSwgcywgaV0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHJlZjogYywgLi4uZCB9LCBpICE9PSBcIlwiID8gaSA6IGwsIGEuY2hpbGRyZW4pO1xuICB9XG4pLCBiZSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHsgdHJhY2tSZWY6IG4sIHNob3c6IGEgPSBcImFsd2F5c1wiLCAuLi5jIH0sIHIpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogcywgaXNNdXRlZDogbyB9ID0gT2UobiksIGwgPSBhID09PSBcImFsd2F5c1wiIHx8IGEgPT09IFwibXV0ZWRcIiAmJiBvIHx8IGEgPT09IFwidW5tdXRlZFwiICYmICFvLCBpID0gZS51c2VNZW1vKFxuICAgICAgKCkgPT4gSShjLCB7XG4gICAgICAgIGNsYXNzTmFtZTogc1xuICAgICAgfSksXG4gICAgICBbcywgY11cbiAgICApO1xuICAgIHJldHVybiBsID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogciwgLi4uaSwgXCJkYXRhLWxrLW11dGVkXCI6IG8gfSwgYy5jaGlsZHJlbiA/PyBNZShuLnNvdXJjZSwgIW8pKSA6IG51bGw7XG4gIH1cbiksIE50ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICB3aWR0aDogMzIwLFxuICAgIGhlaWdodDogMzIwLFxuICAgIHZpZXdCb3g6IFwiMCAwIDMyMCAzMjBcIixcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcInhNaWRZTWlkIG1lZXRcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIC4uLnRcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0xNjAgMTgwQzIwNC4xODIgMTgwIDI0MCAxNDQuMTgzIDI0MCAxMDBDMjQwIDU1LjgxNzIgMjA0LjE4MiAyMCAxNjAgMjBDMTE1LjgxNyAyMCA3OS45OTk3IDU1LjgxNzIgNzkuOTk5NyAxMDBDNzkuOTk5NyAxNDQuMTgzIDExNS44MTcgMTgwIDE2MCAxODBaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCIsXG4gICAgICBmaWxsT3BhY2l0eTogMC4yNVxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk05Ny42NTQyIDE5NC42MTRDMTAzLjI2NyAxOTEuODE4IDEwOS44NDEgMTkyLjQ4MSAxMTUuNTE5IDE5NS4xNDFDMTI5LjAyNSAyMDEuNDY2IDE0NC4xIDIwNSAxNTkuOTk5IDIwNUMxNzUuODk5IDIwNSAxOTAuOTczIDIwMS40NjYgMjA0LjQ4IDE5NS4xNDFDMjEwLjE1OCAxOTIuNDgxIDIxNi43MzIgMTkxLjgxOCAyMjIuMzQ1IDE5NC42MTRDMjYyLjcwMyAyMTQuNzE5IDI5MS45ODUgMjUzLjczNiAyOTguNTkxIDMwMC4wNjJDMzAwLjE1IDMxMC45OTcgMjkxLjA0NSAzMjAgMjgwIDMyMEgzOS45OTk3QzI4Ljk1NCAzMjAgMTkuODQ5NSAzMTAuOTk3IDIxLjQwODcgMzAwLjA2MkMyOC4wMTQgMjUzLjczNiA1Ny4yOTY2IDIxNC43MiA5Ny42NTQyIDE5NC42MTRaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCIsXG4gICAgICBmaWxsT3BhY2l0eTogMC4yNVxuICAgIH1cbiAgKVxuKTtcbmZ1bmN0aW9uIFNlKHQsIG4gPSB7fSkge1xuICBjb25zdCBbYSwgY10gPSBlLnVzZVN0YXRlKHJ0KHQpKSwgW3IsIHNdID0gZS51c2VTdGF0ZShhID09IG51bGwgPyB2b2lkIDAgOiBhLmlzTXV0ZWQpLCBbbywgbF0gPSBlLnVzZVN0YXRlKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuaXNTdWJzY3JpYmVkKSwgW2ksIGRdID0gZS51c2VTdGF0ZShhID09IG51bGwgPyB2b2lkIDAgOiBhLnRyYWNrKSwgW3UsIHZdID0gZS51c2VTdGF0ZShcImxhbmRzY2FwZVwiKSwgZiA9IGUudXNlUmVmKCksIHsgY2xhc3NOYW1lOiBwLCB0cmFja09ic2VydmVyOiBFIH0gPSBlLnVzZU1lbW8oKCkgPT4gY3QodCksIFtcbiAgICB0LnBhcnRpY2lwYW50LnNpZCA/PyB0LnBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgIHQuc291cmNlLFxuICAgICQodCkgJiYgdC5wdWJsaWNhdGlvbi50cmFja1NpZFxuICBdKTtcbiAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoID0gRS5zdWJzY3JpYmUoKG0pID0+IHtcbiAgICAgIGouZGVidWcoXCJ1cGRhdGUgdHJhY2tcIiwgbSksIGMobSksIHMobSA9PSBudWxsID8gdm9pZCAwIDogbS5pc011dGVkKSwgbChtID09IG51bGwgPyB2b2lkIDAgOiBtLmlzU3Vic2NyaWJlZCksIGQobSA9PSBudWxsID8gdm9pZCAwIDogbS50cmFjayk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGggPT0gbnVsbCA/IHZvaWQgMCA6IGgudW5zdWJzY3JpYmUoKTtcbiAgfSwgW0VdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBoLCBtO1xuICAgIHJldHVybiBpICYmIChmLmN1cnJlbnQgJiYgaS5kZXRhY2goZi5jdXJyZW50KSwgKGggPSBuLmVsZW1lbnQpICE9IG51bGwgJiYgaC5jdXJyZW50ICYmICEodC5wYXJ0aWNpcGFudC5pc0xvY2FsICYmIChpID09IG51bGwgPyB2b2lkIDAgOiBpLmtpbmQpID09PSBcImF1ZGlvXCIpICYmIGkuYXR0YWNoKG4uZWxlbWVudC5jdXJyZW50KSksIGYuY3VycmVudCA9IChtID0gbi5lbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogbS5jdXJyZW50LCAoKSA9PiB7XG4gICAgICBmLmN1cnJlbnQgJiYgKGkgPT0gbnVsbCB8fCBpLmRldGFjaChmLmN1cnJlbnQpKTtcbiAgICB9O1xuICB9LCBbaSwgbi5lbGVtZW50XSksIGUudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgaCwgbTtcbiAgICBpZiAodHlwZW9mICgoaCA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGltZW5zaW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IGgud2lkdGgpID09IFwibnVtYmVyXCIgJiYgdHlwZW9mICgobSA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGltZW5zaW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG0uaGVpZ2h0KSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCB5ID0gYS5kaW1lbnNpb25zLndpZHRoID4gYS5kaW1lbnNpb25zLmhlaWdodCA/IFwibGFuZHNjYXBlXCIgOiBcInBvcnRyYWl0XCI7XG4gICAgICB2KHkpO1xuICAgIH1cbiAgfSwgW2FdKSwge1xuICAgIHB1YmxpY2F0aW9uOiBhLFxuICAgIGlzTXV0ZWQ6IHIsXG4gICAgaXNTdWJzY3JpYmVkOiBvLFxuICAgIHRyYWNrOiBpLFxuICAgIGVsZW1lbnRQcm9wczogSShuLnByb3BzLCB7XG4gICAgICBjbGFzc05hbWU6IHAsXG4gICAgICBcImRhdGEtbGstbG9jYWwtcGFydGljaXBhbnRcIjogdC5wYXJ0aWNpcGFudC5pc0xvY2FsLFxuICAgICAgXCJkYXRhLWxrLXNvdXJjZVwiOiBhID09IG51bGwgPyB2b2lkIDAgOiBhLnNvdXJjZSxcbiAgICAgIC4uLihhID09IG51bGwgPyB2b2lkIDAgOiBhLmtpbmQpID09PSBcInZpZGVvXCIgJiYgeyBcImRhdGEtbGstb3JpZW50YXRpb25cIjogdSB9XG4gICAgfSlcbiAgfTtcbn1cbnZhciBZLCB1ZTtcbmZ1bmN0aW9uIEx0KCkge1xuICBpZiAodWUpIHJldHVybiBZO1xuICB1ZSA9IDE7XG4gIHZhciB0ID0gXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsIG4gPSBOYU4sIGEgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBjID0gL15cXHMrfFxccyskL2csIHIgPSAvXlstK10weFswLTlhLWZdKyQvaSwgcyA9IC9eMGJbMDFdKyQvaSwgbyA9IC9eMG9bMC03XSskL2ksIGwgPSBwYXJzZUludCwgaSA9IHR5cGVvZiBxID09IFwib2JqZWN0XCIgJiYgcSAmJiBxLk9iamVjdCA9PT0gT2JqZWN0ICYmIHEsIGQgPSB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmLCB1ID0gaSB8fCBkIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSwgdiA9IE9iamVjdC5wcm90b3R5cGUsIGYgPSB2LnRvU3RyaW5nLCBwID0gTWF0aC5tYXgsIEUgPSBNYXRoLm1pbiwgaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1LkRhdGUubm93KCk7XG4gIH07XG4gIGZ1bmN0aW9uIG0oZywgUiwgdykge1xuICAgIHZhciBNLCBQLCBPLCBMLCBiLCBULCBGID0gMCwgcmUgPSAhMSwgWiA9ICExLCBEID0gITA7XG4gICAgaWYgKHR5cGVvZiBnICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodCk7XG4gICAgUiA9IE4oUikgfHwgMCwgeSh3KSAmJiAocmUgPSAhIXcubGVhZGluZywgWiA9IFwibWF4V2FpdFwiIGluIHcsIE8gPSBaID8gcChOKHcubWF4V2FpdCkgfHwgMCwgUikgOiBPLCBEID0gXCJ0cmFpbGluZ1wiIGluIHcgPyAhIXcudHJhaWxpbmcgOiBEKTtcbiAgICBmdW5jdGlvbiBVKGspIHtcbiAgICAgIHZhciB4ID0gTSwgSCA9IFA7XG4gICAgICByZXR1cm4gTSA9IFAgPSB2b2lkIDAsIEYgPSBrLCBMID0gZy5hcHBseShILCB4KSwgTDtcbiAgICB9XG4gICAgZnVuY3Rpb24geGUoaykge1xuICAgICAgcmV0dXJuIEYgPSBrLCBiID0gc2V0VGltZW91dChXLCBSKSwgcmUgPyBVKGspIDogTDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGUoaykge1xuICAgICAgdmFyIHggPSBrIC0gVCwgSCA9IGsgLSBGLCBzZSA9IFIgLSB4O1xuICAgICAgcmV0dXJuIFogPyBFKHNlLCBPIC0gSCkgOiBzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2Uoaykge1xuICAgICAgdmFyIHggPSBrIC0gVCwgSCA9IGsgLSBGO1xuICAgICAgcmV0dXJuIFQgPT09IHZvaWQgMCB8fCB4ID49IFIgfHwgeCA8IDAgfHwgWiAmJiBIID49IE87XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoKSB7XG4gICAgICB2YXIgayA9IGgoKTtcbiAgICAgIGlmIChjZShrKSlcbiAgICAgICAgcmV0dXJuIGxlKGspO1xuICAgICAgYiA9IHNldFRpbWVvdXQoVywgUGUoaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZShrKSB7XG4gICAgICByZXR1cm4gYiA9IHZvaWQgMCwgRCAmJiBNID8gVShrKSA6IChNID0gUCA9IHZvaWQgMCwgTCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRlKCkge1xuICAgICAgYiAhPT0gdm9pZCAwICYmIGNsZWFyVGltZW91dChiKSwgRiA9IDAsIE0gPSBUID0gUCA9IGIgPSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFlKCkge1xuICAgICAgcmV0dXJuIGIgPT09IHZvaWQgMCA/IEwgOiBsZShoKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHKCkge1xuICAgICAgdmFyIGsgPSBoKCksIHggPSBjZShrKTtcbiAgICAgIGlmIChNID0gYXJndW1lbnRzLCBQID0gdGhpcywgVCA9IGssIHgpIHtcbiAgICAgICAgaWYgKGIgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4geGUoVCk7XG4gICAgICAgIGlmIChaKVxuICAgICAgICAgIHJldHVybiBiID0gc2V0VGltZW91dChXLCBSKSwgVShUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiID09PSB2b2lkIDAgJiYgKGIgPSBzZXRUaW1lb3V0KFcsIFIpKSwgTDtcbiAgICB9XG4gICAgcmV0dXJuIEcuY2FuY2VsID0gVGUsIEcuZmx1c2ggPSBBZSwgRztcbiAgfVxuICBmdW5jdGlvbiB5KGcpIHtcbiAgICB2YXIgUiA9IHR5cGVvZiBnO1xuICAgIHJldHVybiAhIWcgJiYgKFIgPT0gXCJvYmplY3RcIiB8fCBSID09IFwiZnVuY3Rpb25cIik7XG4gIH1cbiAgZnVuY3Rpb24gQyhnKSB7XG4gICAgcmV0dXJuICEhZyAmJiB0eXBlb2YgZyA9PSBcIm9iamVjdFwiO1xuICB9XG4gIGZ1bmN0aW9uIEEoZykge1xuICAgIHJldHVybiB0eXBlb2YgZyA9PSBcInN5bWJvbFwiIHx8IEMoZykgJiYgZi5jYWxsKGcpID09IGE7XG4gIH1cbiAgZnVuY3Rpb24gTihnKSB7XG4gICAgaWYgKHR5cGVvZiBnID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gZztcbiAgICBpZiAoQShnKSlcbiAgICAgIHJldHVybiBuO1xuICAgIGlmICh5KGcpKSB7XG4gICAgICB2YXIgUiA9IHR5cGVvZiBnLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gZy52YWx1ZU9mKCkgOiBnO1xuICAgICAgZyA9IHkoUikgPyBSICsgXCJcIiA6IFI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZyAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGcgPT09IDAgPyBnIDogK2c7XG4gICAgZyA9IGcucmVwbGFjZShjLCBcIlwiKTtcbiAgICB2YXIgdyA9IHMudGVzdChnKTtcbiAgICByZXR1cm4gdyB8fCBvLnRlc3QoZykgPyBsKGcuc2xpY2UoMiksIHcgPyAyIDogOCkgOiByLnRlc3QoZykgPyBuIDogK2c7XG4gIH1cbiAgcmV0dXJuIFkgPSBtLCBZO1xufVxudmFyIHp0ID0gTHQoKTtcbmNvbnN0IGRlID0gLyogQF9fUFVSRV9fICovIGx0KHp0KTtcbmZ1bmN0aW9uIFZ0KHQpIHtcbiAgY29uc3QgbiA9IHoodCk7XG4gIG4uY3VycmVudCA9IHQsIFYoXG4gICAgKCkgPT4gKCkgPT4ge1xuICAgICAgbi5jdXJyZW50KCk7XG4gICAgfSxcbiAgICBbXVxuICApO1xufVxuZnVuY3Rpb24gRnQodCwgbiA9IDUwMCwgYSkge1xuICBjb25zdCBjID0geigpO1xuICBWdCgoKSA9PiB7XG4gICAgYy5jdXJyZW50ICYmIGMuY3VycmVudC5jYW5jZWwoKTtcbiAgfSk7XG4gIGNvbnN0IHIgPSBOZSgoKSA9PiB7XG4gICAgY29uc3QgcyA9IGRlKHQsIG4sIGEpLCBvID0gKC4uLmwpID0+IHMoLi4ubCk7XG4gICAgcmV0dXJuIG8uY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcy5jYW5jZWwoKTtcbiAgICB9LCBvLmlzUGVuZGluZyA9ICgpID0+ICEhYy5jdXJyZW50LCBvLmZsdXNoID0gKCkgPT4gcy5mbHVzaCgpLCBvO1xuICB9LCBbdCwgbiwgYV0pO1xuICByZXR1cm4gVigoKSA9PiB7XG4gICAgYy5jdXJyZW50ID0gZGUodCwgbiwgYSk7XG4gIH0sIFt0LCBuLCBhXSksIHI7XG59XG5mdW5jdGlvbiBadCh0LCBuLCBhKSB7XG4gIGNvbnN0IGMgPSAoKGQsIHUpID0+IGQgPT09IHUpLCByID0gdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdCgpIDogdCwgW3MsIG9dID0gQihyKSwgbCA9IHoociksIGkgPSBGdChcbiAgICBvLFxuICAgIG4sXG4gICAgYVxuICApO1xuICByZXR1cm4gYyhsLmN1cnJlbnQsIHIpIHx8IChpKHIpLCBsLmN1cnJlbnQgPSByKSwgW3MsIGldO1xufVxuZnVuY3Rpb24gSHQoe1xuICB0aHJlc2hvbGQ6IHQgPSAwLFxuICByb290OiBuID0gbnVsbCxcbiAgcm9vdE1hcmdpbjogYSA9IFwiMCVcIixcbiAgZnJlZXplT25jZVZpc2libGU6IGMgPSAhMSxcbiAgaW5pdGlhbElzSW50ZXJzZWN0aW5nOiByID0gITEsXG4gIG9uQ2hhbmdlOiBzXG59ID0ge30pIHtcbiAgdmFyIG87XG4gIGNvbnN0IFtsLCBpXSA9IEIobnVsbCksIFtkLCB1XSA9IEIoKCkgPT4gKHtcbiAgICBpc0ludGVyc2VjdGluZzogcixcbiAgICBlbnRyeTogdm9pZCAwXG4gIH0pKSwgdiA9IHooKTtcbiAgdi5jdXJyZW50ID0gcztcbiAgY29uc3QgZiA9ICgobyA9IGQuZW50cnkpID09IG51bGwgPyB2b2lkIDAgOiBvLmlzSW50ZXJzZWN0aW5nKSAmJiBjO1xuICBWKCgpID0+IHtcbiAgICBpZiAoIWwgfHwgIShcIkludGVyc2VjdGlvbk9ic2VydmVyXCIgaW4gd2luZG93KSB8fCBmKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGggPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAobSkgPT4ge1xuICAgICAgICBjb25zdCB5ID0gQXJyYXkuaXNBcnJheShoLnRocmVzaG9sZHMpID8gaC50aHJlc2hvbGRzIDogW2gudGhyZXNob2xkc107XG4gICAgICAgIG0uZm9yRWFjaCgoQykgPT4ge1xuICAgICAgICAgIGNvbnN0IEEgPSBDLmlzSW50ZXJzZWN0aW5nICYmIHkuc29tZSgoTikgPT4gQy5pbnRlcnNlY3Rpb25SYXRpbyA+PSBOKTtcbiAgICAgICAgICB1KHsgaXNJbnRlcnNlY3Rpbmc6IEEsIGVudHJ5OiBDIH0pLCB2LmN1cnJlbnQgJiYgdi5jdXJyZW50KEEsIEMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7IHRocmVzaG9sZDogdCwgcm9vdDogbiwgcm9vdE1hcmdpbjogYSB9XG4gICAgKTtcbiAgICByZXR1cm4gaC5vYnNlcnZlKGwpLCAoKSA9PiB7XG4gICAgICBoLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbXG4gICAgbCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgSlNPTi5zdHJpbmdpZnkodCksXG4gICAgbixcbiAgICBhLFxuICAgIGYsXG4gICAgY1xuICBdKTtcbiAgY29uc3QgcCA9IHoobnVsbCk7XG4gIFYoKCkgPT4ge1xuICAgIHZhciBoO1xuICAgICFsICYmICgoaCA9IGQuZW50cnkpICE9IG51bGwgJiYgaC50YXJnZXQpICYmICFjICYmICFmICYmIHAuY3VycmVudCAhPT0gZC5lbnRyeS50YXJnZXQgJiYgKHAuY3VycmVudCA9IGQuZW50cnkudGFyZ2V0LCB1KHsgaXNJbnRlcnNlY3Rpbmc6IHIsIGVudHJ5OiB2b2lkIDAgfSkpO1xuICB9LCBbbCwgZC5lbnRyeSwgYywgZiwgcl0pO1xuICBjb25zdCBFID0gW1xuICAgIGksXG4gICAgISFkLmlzSW50ZXJzZWN0aW5nLFxuICAgIGQuZW50cnlcbiAgXTtcbiAgcmV0dXJuIEUucmVmID0gRVswXSwgRS5pc0ludGVyc2VjdGluZyA9IEVbMV0sIEUuZW50cnkgPSBFWzJdLCBFO1xufVxuY29uc3QgQnQgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbih7XG4gICAgb25UcmFja0NsaWNrOiBuLFxuICAgIG9uQ2xpY2s6IGEsXG4gICAgb25TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiBjLFxuICAgIHRyYWNrUmVmOiByLFxuICAgIG1hbmFnZVN1YnNjcmlwdGlvbjogcyxcbiAgICAuLi5vXG4gIH0sIGwpIHtcbiAgICBjb25zdCBpID0gXyhyKSwgZCA9IGUudXNlUmVmKG51bGwpO1xuICAgIGUudXNlSW1wZXJhdGl2ZUhhbmRsZShsLCAoKSA9PiBkLmN1cnJlbnQpO1xuICAgIGNvbnN0IHUgPSBIdCh7IHJvb3Q6IGQuY3VycmVudCB9KSwgW3ZdID0gWnQodSwgM2UzKTtcbiAgICBlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzICYmIGkucHVibGljYXRpb24gaW5zdGFuY2VvZiBKICYmICh2ID09IG51bGwgPyB2b2lkIDAgOiB2LmlzSW50ZXJzZWN0aW5nKSA9PT0gITEgJiYgKHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUuaXNJbnRlcnNlY3RpbmcpID09PSAhMSAmJiBpLnB1YmxpY2F0aW9uLnNldFN1YnNjcmliZWQoITEpO1xuICAgIH0sIFt2LCBpLCBzXSksIGUudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHMgJiYgaS5wdWJsaWNhdGlvbiBpbnN0YW5jZW9mIEogJiYgKHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUuaXNJbnRlcnNlY3RpbmcpID09PSAhMCAmJiBpLnB1YmxpY2F0aW9uLnNldFN1YnNjcmliZWQoITApO1xuICAgIH0sIFt1LCBpLCBzXSk7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFByb3BzOiBmLFxuICAgICAgcHVibGljYXRpb246IHAsXG4gICAgICBpc1N1YnNjcmliZWQ6IEVcbiAgICB9ID0gU2UoaSwge1xuICAgICAgZWxlbWVudDogZCxcbiAgICAgIHByb3BzOiBvXG4gICAgfSk7XG4gICAgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgYyA9PSBudWxsIHx8IGMoISFFKTtcbiAgICB9LCBbRSwgY10pO1xuICAgIGNvbnN0IGggPSAobSkgPT4ge1xuICAgICAgYSA9PSBudWxsIHx8IGEobSksIG4gPT0gbnVsbCB8fCBuKHsgcGFydGljaXBhbnQ6IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucGFydGljaXBhbnQsIHRyYWNrOiBwIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCB7IHJlZjogZCwgLi4uZiwgbXV0ZWQ6ICEwLCBvbkNsaWNrOiBoIH0pO1xuICB9XG4pLCBuZSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHsgdHJhY2tSZWY6IG4sIG9uU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZDogYSwgdm9sdW1lOiBjLCAuLi5yIH0sIHMpIHtcbiAgICBjb25zdCBvID0gXyhuKSwgbCA9IGUudXNlUmVmKG51bGwpO1xuICAgIGUudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCAoKSA9PiBsLmN1cnJlbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRQcm9wczogaSxcbiAgICAgIGlzU3Vic2NyaWJlZDogZCxcbiAgICAgIHRyYWNrOiB1LFxuICAgICAgcHVibGljYXRpb246IHZcbiAgICB9ID0gU2Uobywge1xuICAgICAgZWxlbWVudDogbCxcbiAgICAgIHByb3BzOiByXG4gICAgfSk7XG4gICAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGEgPT0gbnVsbCB8fCBhKCEhZCk7XG4gICAgfSwgW2QsIGFdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdSA9PT0gdm9pZCAwIHx8IGMgPT09IHZvaWQgMCB8fCAodSBpbnN0YW5jZW9mIEplID8gdS5zZXRWb2x1bWUoYykgOiBqLndhcm4oXCJWb2x1bWUgY2FuIG9ubHkgYmUgc2V0IG9uIHJlbW90ZSBhdWRpbyB0cmFja3MuXCIpKTtcbiAgICB9LCBbYywgdV0pLCBlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB2ID09PSB2b2lkIDAgfHwgci5tdXRlZCA9PT0gdm9pZCAwIHx8ICh2IGluc3RhbmNlb2YgSiA/IHYuc2V0RW5hYmxlZCghci5tdXRlZCkgOiBqLndhcm4oXCJDYW4gb25seSBjYWxsIHNldEVuYWJsZWQgb24gcmVtb3RlIHRyYWNrIHB1YmxpY2F0aW9ucy5cIikpO1xuICAgIH0sIFtyLm11dGVkLCB2LCB1XSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiLCB7IHJlZjogbCwgLi4uaSB9KTtcbiAgfVxuKTtcbmZ1bmN0aW9uIGp0KHQpIHtcbiAgY29uc3QgbiA9ICEhc3QoKTtcbiAgcmV0dXJuIHQucGFydGljaXBhbnQgJiYgIW4gPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHdlLlByb3ZpZGVyLCB7IHZhbHVlOiB0LnBhcnRpY2lwYW50IH0sIHQuY2hpbGRyZW4pIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCB0LmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF90KHQpIHtcbiAgY29uc3QgbiA9ICEhdGUoKTtcbiAgcmV0dXJuIHQudHJhY2tSZWYgJiYgIW4gPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGFlLlByb3ZpZGVyLCB7IHZhbHVlOiB0LnRyYWNrUmVmIH0sIHQuY2hpbGRyZW4pIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCB0LmNoaWxkcmVuKTtcbn1cbmNvbnN0IE90ID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24oe1xuICAgIHRyYWNrUmVmOiBuLFxuICAgIGNoaWxkcmVuOiBhLFxuICAgIG9uUGFydGljaXBhbnRDbGljazogYyxcbiAgICBkaXNhYmxlU3BlYWtpbmdJbmRpY2F0b3I6IHIsXG4gICAgLi4uc1xuICB9LCBvKSB7XG4gICAgdmFyIHAsIEU7XG4gICAgY29uc3QgbCA9IF8obiksIHsgZWxlbWVudFByb3BzOiBpIH0gPSB2ZSh7XG4gICAgICBodG1sUHJvcHM6IHMsXG4gICAgICBkaXNhYmxlU3BlYWtpbmdJbmRpY2F0b3I6IHIsXG4gICAgICBvblBhcnRpY2lwYW50Q2xpY2s6IGMsXG4gICAgICB0cmFja1JlZjogbFxuICAgIH0pLCBkID0gV2UobC5wYXJ0aWNpcGFudCksIHUgPSBpdCgpLCB2ID0gKHAgPSBvdCgpKSA9PSBudWxsID8gdm9pZCAwIDogcC5hdXRvU3Vic2NyaXB0aW9uLCBmID0gZS51c2VDYWxsYmFjayhcbiAgICAgIChoKSA9PiB7XG4gICAgICAgIGwuc291cmNlICYmICFoICYmIHUgJiYgdS5waW4uZGlzcGF0Y2ggJiYgdXQobCwgdS5waW4uc3RhdGUpICYmIHUucGluLmRpc3BhdGNoKHsgbXNnOiBcImNsZWFyX3BpblwiIH0pO1xuICAgICAgfSxcbiAgICAgIFtsLCB1XVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG8sIHN0eWxlOiB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSwgLi4uaSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KF90LCB7IHRyYWNrUmVmOiBsIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoanQsIHsgcGFydGljaXBhbnQ6IGwucGFydGljaXBhbnQgfSwgYSA/PyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsICQobCkgJiYgKCgoRSA9IGwucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBFLmtpbmQpID09PSBcInZpZGVvXCIgfHwgbC5zb3VyY2UgPT09IFMuU291cmNlLkNhbWVyYSB8fCBsLnNvdXJjZSA9PT0gUy5Tb3VyY2UuU2NyZWVuU2hhcmUpID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIEJ0LFxuICAgICAge1xuICAgICAgICB0cmFja1JlZjogbCxcbiAgICAgICAgb25TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiBmLFxuICAgICAgICBtYW5hZ2VTdWJzY3JpcHRpb246IHZcbiAgICAgIH1cbiAgICApIDogJChsKSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgbmUsXG4gICAgICB7XG4gICAgICAgIHRyYWNrUmVmOiBsLFxuICAgICAgICBvblN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQ6IGZcbiAgICAgIH1cbiAgICApLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LXBsYWNlaG9sZGVyXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOdCwgbnVsbCkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW1ldGFkYXRhXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1tZXRhZGF0YS1pdGVtXCIgfSwgbC5zb3VyY2UgPT09IFMuU291cmNlLkNhbWVyYSA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgZCAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFJ0LCB7IHN0eWxlOiB7IG1hcmdpblJpZ2h0OiBcIjAuMjVyZW1cIiB9IH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgYmUsXG4gICAgICB7XG4gICAgICAgIHRyYWNrUmVmOiB7XG4gICAgICAgICAgcGFydGljaXBhbnQ6IGwucGFydGljaXBhbnQsXG4gICAgICAgICAgc291cmNlOiBTLlNvdXJjZS5NaWNyb3Bob25lXG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IFwibXV0ZWRcIlxuICAgICAgfVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSywgbnVsbCkpIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFJlLCB7IHN0eWxlOiB7IG1hcmdpblJpZ2h0OiBcIjAuMjVyZW1cIiB9IH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEssIG51bGwsIFwiJ3Mgc2NyZWVuXCIpKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoeWUsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW1ldGFkYXRhLWl0ZW1cIiB9KSkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFR0LCB7IHRyYWNrUmVmOiBsIH0pKSkpO1xuICB9XG4pO1xuZnVuY3Rpb24gRWEodCkge1xuICBjb25zdCBuID0gSSh0LCB7IGNsYXNzTmFtZTogXCJsay1mb2N1cy1sYXlvdXRcIiB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5uIH0sIHQuY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gcGEoeyB0cmFja1JlZjogdCwgLi4ubiB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE90LCB7IHRyYWNrUmVmOiB0LCAuLi5uIH0pO1xufVxuZnVuY3Rpb24gQ2UoeyB0cmFja3M6IHQsIC4uLm4gfSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCB0Lm1hcCgoYSkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBhZS5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogYSxcbiAgICAgIGtleToga2UoYSlcbiAgICB9LFxuICAgIGVlKG4uY2hpbGRyZW4pXG4gICkpKTtcbn1cbmZ1bmN0aW9uIFd0KHtcbiAgdG90YWxQYWdlQ291bnQ6IHQsXG4gIG5leHRQYWdlOiBuLFxuICBwcmV2UGFnZTogYSxcbiAgY3VycmVudFBhZ2U6IGMsXG4gIHBhZ2VzQ29udGFpbmVyOiByXG59KSB7XG4gIGNvbnN0IFtzLCBvXSA9IGUudXNlU3RhdGUoITEpO1xuICByZXR1cm4gZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBsO1xuICAgIHJldHVybiByICYmIChsID0gZHQoci5jdXJyZW50LCAyZTMpLnN1YnNjcmliZShcbiAgICAgIG9cbiAgICApKSwgKCkgPT4ge1xuICAgICAgbCAmJiBsLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW3JdKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsay1wYWdpbmF0aW9uLWNvbnRyb2xcIiwgXCJkYXRhLWxrLXVzZXItaW50ZXJhY3Rpb25cIjogcyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcImxrLWJ1dHRvblwiLCBvbkNsaWNrOiBhIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoaWUsIG51bGwpKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwibGstcGFnaW5hdGlvbi1jb3VudFwiIH0sIGAke2N9IG9mICR7dH1gKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJsay1idXR0b25cIiwgb25DbGljazogbiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGllLCBudWxsKSkpO1xufVxuY29uc3QgcXQgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbih7IHRvdGFsUGFnZUNvdW50OiBuLCBjdXJyZW50UGFnZTogYSB9LCBjKSB7XG4gICAgY29uc3QgciA9IG5ldyBBcnJheShuKS5maWxsKFwiXCIpLm1hcCgocywgbykgPT4gbyArIDEgPT09IGEgPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiZGF0YS1say1hY3RpdmVcIjogITAsIGtleTogbyB9KSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBvIH0pKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYywgY2xhc3NOYW1lOiBcImxrLXBhZ2luYXRpb24taW5kaWNhdG9yXCIgfSwgcik7XG4gIH1cbik7XG5mdW5jdGlvbiB3YSh7IHRyYWNrczogdCwgLi4ubiB9KSB7XG4gIGNvbnN0IGEgPSBlLmNyZWF0ZVJlZigpLCBjID0gZS51c2VNZW1vKFxuICAgICgpID0+IEkobiwgeyBjbGFzc05hbWU6IFwibGstZ3JpZC1sYXlvdXRcIiB9KSxcbiAgICBbbl1cbiAgKSwgeyBsYXlvdXQ6IHIgfSA9IHFlKGEsIHQubGVuZ3RoKSwgcyA9ICRlKHIubWF4VGlsZXMsIHQpO1xuICByZXR1cm4gRGUoYSwge1xuICAgIG9uTGVmdFN3aXBlOiBzLm5leHRQYWdlLFxuICAgIG9uUmlnaHRTd2lwZTogcy5wcmV2UGFnZVxuICB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYSwgXCJkYXRhLWxrLXBhZ2luYXRpb25cIjogcy50b3RhbFBhZ2VDb3VudCA+IDEsIC4uLmMgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChDZSwgeyB0cmFja3M6IHMudHJhY2tzIH0sIG4uY2hpbGRyZW4pLCB0Lmxlbmd0aCA+IHIubWF4VGlsZXMgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIHF0LFxuICAgIHtcbiAgICAgIHRvdGFsUGFnZUNvdW50OiBzLnRvdGFsUGFnZUNvdW50LFxuICAgICAgY3VycmVudFBhZ2U6IHMuY3VycmVudFBhZ2VcbiAgICB9XG4gICksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoV3QsIHsgcGFnZXNDb250YWluZXI6IGEsIC4uLnMgfSkpKTtcbn1cbmNvbnN0ICR0ID0gMTMwLCBEdCA9IDE0MCwgbWUgPSAxLCBJZSA9IDE2IC8gMTAsIFV0ID0gKDEgLSBJZSkgKiAtMTtcbmZ1bmN0aW9uIGthKHsgdHJhY2tzOiB0LCBvcmllbnRhdGlvbjogbiwgLi4uYSB9KSB7XG4gIGNvbnN0IGMgPSBlLnVzZVJlZihudWxsKSwgW3IsIHNdID0gZS51c2VTdGF0ZSgwKSwgeyB3aWR0aDogbywgaGVpZ2h0OiBsIH0gPSBVZShjKSwgaSA9IG4gfHwgKGwgPj0gbyA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKSwgZCA9IGkgPT09IFwidmVydGljYWxcIiA/IE1hdGgubWF4KG8gKiBVdCwgJHQpIDogTWF0aC5tYXgobCAqIEllLCBEdCksIHUgPSBtdCgpLCB2ID0gTWF0aC5tYXgoaSA9PT0gXCJ2ZXJ0aWNhbFwiID8gKGwgLSB1KSAvIGQgOiAobyAtIHUpIC8gZCwgbWUpO1xuICBsZXQgZiA9IE1hdGgucm91bmQodik7XG4gIE1hdGguYWJzKHYgLSByKSA8IDAuNSA/IGYgPSBNYXRoLnJvdW5kKHIpIDogciAhPT0gdiAmJiBzKHYpO1xuICBjb25zdCBwID0gR2UodCwgZik7XG4gIHJldHVybiBlLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYy5jdXJyZW50ICYmIChjLmN1cnJlbnQuZGF0YXNldC5sa09yaWVudGF0aW9uID0gaSwgYy5jdXJyZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1say1tYXgtdmlzaWJsZS10aWxlc1wiLCBmLnRvU3RyaW5nKCkpKTtcbiAgfSwgW2YsIGldKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImFzaWRlXCIsIHsga2V5OiBpLCBjbGFzc05hbWU6IFwibGstY2Fyb3VzZWxcIiwgcmVmOiBjLCAuLi5hIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoQ2UsIHsgdHJhY2tzOiBwIH0sIGEuY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIFJhKHtcbiAgdmFsdWU6IHQsXG4gIG9uUGluQ2hhbmdlOiBuLFxuICBvbldpZGdldENoYW5nZTogYSxcbiAgY2hpbGRyZW46IGNcbn0pIHtcbiAgY29uc3QgciA9IGZ0KHQpO1xuICByZXR1cm4gZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGouZGVidWcoXCJQaW5TdGF0ZSBVcGRhdGVkXCIsIHsgc3RhdGU6IHIucGluLnN0YXRlIH0pLCBuICYmIHIucGluLnN0YXRlICYmIG4oci5waW4uc3RhdGUpO1xuICB9LCBbci5waW4uc3RhdGUsIG5dKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGouZGVidWcoXCJXaWRnZXQgVXBkYXRlZFwiLCB7IHdpZGdldFN0YXRlOiByLndpZGdldC5zdGF0ZSB9KSwgYSAmJiByLndpZGdldC5zdGF0ZSAmJiBhKHIud2lkZ2V0LnN0YXRlKTtcbiAgfSwgW2EsIHIud2lkZ2V0LnN0YXRlXSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQocGUuUHJvdmlkZXIsIHsgdmFsdWU6IHIgfSwgYyk7XG59XG5jb25zdCBNYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHsgdHJhY2tSZWY6IG4sIC4uLmEgfSwgYykge1xuICAgIGNvbnN0IHUgPSBfKG4pLCB2ID0gRWUodSwgeyBiYW5kczogNywgbG9QYXNzOiAzMDAgfSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICByZWY6IGMsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgdmlld0JveDogXCIwIDAgMjAwIDkwXCIsXG4gICAgICAgIC4uLmEsXG4gICAgICAgIGNsYXNzTmFtZTogXCJsay1hdWRpby12aXN1YWxpemVyXCJcbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHg6IFwiMFwiLCB5OiBcIjBcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJnXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7MTMwIC8gMn1weCwgMClgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2Lm1hcCgoZiwgcCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBcInJlY3RcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IHAsXG4gICAgICAgICAgICB4OiBwICogMTAsXG4gICAgICAgICAgICB5OiA5MCAvIDIgLSBmICogNTAgLyAyLFxuICAgICAgICAgICAgd2lkdGg6IDYsXG4gICAgICAgICAgICBoZWlnaHQ6IGYgKiA1MFxuICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICAgIClcbiAgICApO1xuICB9XG4pO1xuZnVuY3Rpb24geWEoeyBwYXJ0aWNpcGFudHM6IHQsIC4uLm4gfSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCB0Lm1hcCgoYSkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh3ZS5Qcm92aWRlciwgeyB2YWx1ZTogYSwga2V5OiBhLmlkZW50aXR5IH0sIGVlKG4uY2hpbGRyZW4pKSkpO1xufVxuZnVuY3Rpb24gYmEoeyByb29tOiB0LCB2b2x1bWU6IG4sIG11dGVkOiBhIH0pIHtcbiAgY29uc3QgYyA9IFFlKFxuICAgIFtTLlNvdXJjZS5NaWNyb3Bob25lLCBTLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvLCBTLlNvdXJjZS5Vbmtub3duXSxcbiAgICB7XG4gICAgICB1cGRhdGVPbmx5T246IFtdLFxuICAgICAgb25seVN1YnNjcmliZWQ6ICEwLFxuICAgICAgcm9vbTogdFxuICAgIH1cbiAgKS5maWx0ZXIoKHIpID0+ICFyLnBhcnRpY2lwYW50LmlzTG9jYWwgJiYgci5wdWJsaWNhdGlvbi5raW5kID09PSBTLktpbmQuQXVkaW8pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfSwgYy5tYXAoKHIpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgbmUsXG4gICAge1xuICAgICAga2V5OiBrZShyKSxcbiAgICAgIHRyYWNrUmVmOiByLFxuICAgICAgdm9sdW1lOiBuLFxuICAgICAgbXV0ZWQ6IGFcbiAgICB9XG4gICkpKTtcbn1cbmNvbnN0IFNhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihmdW5jdGlvbih7IGNoaWxkcmVuUG9zaXRpb246IG4gPSBcImJlZm9yZVwiLCBjaGlsZHJlbjogYSwgLi4uYyB9LCByKSB7XG4gIGNvbnN0IHsgbmFtZTogcyB9ID0gWGUoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiByLCAuLi5jIH0sIG4gPT09IFwiYmVmb3JlXCIgJiYgYSwgcywgbiA9PT0gXCJhZnRlclwiICYmIGEpO1xufSk7XG5mdW5jdGlvbiBHdCh0KSB7XG4gIGNvbnN0IG4gPSBlLnVzZU1lbW8oKCkgPT4gSSh0LCB7IGNsYXNzTmFtZTogXCJsay10b2FzdFwiIH0pLCBbdF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLm4gfSwgdC5jaGlsZHJlbik7XG59XG5jb25zdCBRdCA9ICh0KSA9PiB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCB0OyBhKyspXG4gICAgbi5wdXNoKFthLCB0IC0gMSAtIGFdKTtcbiAgcmV0dXJuIG47XG59LCBmZSA9ICh0KSA9PiBbW01hdGguZmxvb3IodCAvIDIpXSwgWy0xXV0sIFh0ID0gKHQsIG4sIGEpID0+IHtcbiAgY29uc3QgW2MsIHJdID0gQigwKSwgW3MsIG9dID0gQihbW11dKTtcbiAgVigoKSA9PiB7XG4gICAgaWYgKHQgPT09IFwidGhpbmtpbmdcIilcbiAgICAgIG8oZmUobikpO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiY29ubmVjdGluZ1wiIHx8IHQgPT09IFwiaW5pdGlhbGl6aW5nXCIpIHtcbiAgICAgIGNvbnN0IGkgPSBbLi4uUXQobildO1xuICAgICAgbyhpKTtcbiAgICB9IGVsc2Ugbyh0ID09PSBcImxpc3RlbmluZ1wiID8gZmUobikgOiB0ID09PSB2b2lkIDAgfHwgdCA9PT0gXCJzcGVha2luZ1wiID8gW25ldyBBcnJheShuKS5maWxsKDApLm1hcCgoaSwgZCkgPT4gZCldIDogW1tdXSk7XG4gICAgcigwKTtcbiAgfSwgW3QsIG5dKTtcbiAgY29uc3QgbCA9IHoobnVsbCk7XG4gIHJldHVybiBWKCgpID0+IHtcbiAgICBsZXQgaSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGQgPSAodSkgPT4ge1xuICAgICAgdSAtIGkgPj0gYSAmJiAocigoZikgPT4gZiArIDEpLCBpID0gdSksIGwuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkKTtcbiAgICB9O1xuICAgIHJldHVybiBsLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZCksICgpID0+IHtcbiAgICAgIGwuY3VycmVudCAhPT0gbnVsbCAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShsLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFthLCBuLCB0LCBzLmxlbmd0aF0pLCBzW2MgJSBzLmxlbmd0aF07XG59LCBZdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiY29ubmVjdGluZ1wiLCAyZTNdLFxuICBbXCJpbml0aWFsaXppbmdcIiwgMmUzXSxcbiAgW1wibGlzdGVuaW5nXCIsIDUwMF0sXG4gIFtcInRoaW5raW5nXCIsIDE1MF1cbl0pLCBKdCA9ICh0LCBuKSA9PiB7XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgcmV0dXJuIDFlMztcbiAgbGV0IGEgPSBZdC5nZXQodCk7XG4gIGlmIChhKVxuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgYSAvPSBuO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBhO1xufSwgS3QgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbih7IHN0YXRlOiBuLCBvcHRpb25zOiBhLCBiYXJDb3VudDogYyA9IDE1LCB0cmFja1JlZjogciwgdHJhY2s6IHMsIGNoaWxkcmVuOiBvLCAuLi5sIH0sIGkpIHtcbiAgICBjb25zdCBkID0gSShsLCB7IGNsYXNzTmFtZTogXCJsay1hdWRpby1iYXItdmlzdWFsaXplclwiIH0pO1xuICAgIGxldCB1ID0gdGUoKTtcbiAgICAociB8fCBzKSAmJiAodSA9IHIgfHwgcyk7XG4gICAgY29uc3QgdiA9IEVlKHUsIHtcbiAgICAgIGJhbmRzOiBjLFxuICAgICAgbG9QYXNzOiAxMDAsXG4gICAgICBoaVBhc3M6IDIwMFxuICAgIH0pLCBmID0gKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEubWluSGVpZ2h0KSA/PyAyMCwgcCA9IChhID09IG51bGwgPyB2b2lkIDAgOiBhLm1heEhlaWdodCkgPz8gMTAwLCBFID0gWHQoXG4gICAgICBuLFxuICAgICAgYyxcbiAgICAgIEp0KG4sIGMpID8/IDEwMFxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGksIC4uLmQsIFwiZGF0YS1say12YS1zdGF0ZVwiOiBuIH0sIHYubWFwKFxuICAgICAgKGgsIG0pID0+IG8gPyBlZShvLCB7XG4gICAgICAgIFwiZGF0YS1say1oaWdobGlnaHRlZFwiOiBFLmluY2x1ZGVzKG0pLFxuICAgICAgICBcImRhdGEtbGstYmFyLWluZGV4XCI6IG0sXG4gICAgICAgIGNsYXNzTmFtZTogXCJsay1hdWRpby1iYXJcIixcbiAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBgJHtNYXRoLm1pbihwLCBNYXRoLm1heChmLCBoICogMTAwICsgNSkpfSVgIH1cbiAgICAgIH0pIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IG0sXG4gICAgICAgICAgXCJkYXRhLWxrLWhpZ2hsaWdodGVkXCI6IEUuaW5jbHVkZXMobSksXG4gICAgICAgICAgXCJkYXRhLWxrLWJhci1pbmRleFwiOiBtLFxuICAgICAgICAgIGNsYXNzTmFtZTogYGxrLWF1ZGlvLWJhciAke0UuaW5jbHVkZXMobSkgJiYgXCJsay1oaWdobGlnaHRlZFwifWAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC8vIFRPRE8gdHJhbnNmb3JtIGFuaW1hdGlvbnMgd291bGQgYmUgbW9yZSBwZXJmb3JtYW50LCBob3dldmVyIHRoZSBib3JkZXItcmFkaXVzIGdldHMgZGlzdG9ydGVkIHdoZW4gdXNpbmcgc2NhbGUgdHJhbnNmb3Jtcy4gYSA5LXNsaWNlIGFwcHJvYWNoIChvciAzIGluIHRoaXMgY2FzZSkgY291bGQgd29ya1xuICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiBgc2NhbGUoMSwgJHtNYXRoLm1pbihtYXhIZWlnaHQsIE1hdGgubWF4KG1pbkhlaWdodCwgdm9sdW1lKSl9YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7TWF0aC5taW4ocCwgTWF0aC5tYXgoZiwgaCAqIDEwMCArIDUpKX0lYFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICkpO1xuICB9XG4pLCBDYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHtcbiAgICBjaGlsZHJlbjogbixcbiAgICBkaXNhYmxlU3BlYWtpbmdJbmRpY2F0b3I6IGEsXG4gICAgb25QYXJ0aWNpcGFudENsaWNrOiBjLFxuICAgIHRyYWNrUmVmOiByLFxuICAgIC4uLnNcbiAgfSwgbykge1xuICAgIGNvbnN0IGwgPSBfKHIpLCB7IGVsZW1lbnRQcm9wczogaSB9ID0gdmUoe1xuICAgICAgdHJhY2tSZWY6IGwsXG4gICAgICBodG1sUHJvcHM6IHMsXG4gICAgICBkaXNhYmxlU3BlYWtpbmdJbmRpY2F0b3I6IGEsXG4gICAgICBvblBhcnRpY2lwYW50Q2xpY2s6IGNcbiAgICB9KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogbywgc3R5bGU6IHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiwgbWluSGVpZ2h0OiBcIjE2MHB4XCIgfSwgLi4uaSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGFlLlByb3ZpZGVyLCB7IHZhbHVlOiBsIH0sIG4gPz8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAkKGwpICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQobmUsIHsgdHJhY2tSZWY6IGwgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoS3QsIHsgYmFyQ291bnQ6IDcsIG9wdGlvbnM6IHsgbWluSGVpZ2h0OiA4IH0gfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibGstcGFydGljaXBhbnQtbWV0YWRhdGFcIiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW1ldGFkYXRhLWl0ZW1cIiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGJlLCB7IHRyYWNrUmVmOiBsIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEssIG51bGwpKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh5ZSwgeyBjbGFzc05hbWU6IFwibGstcGFydGljaXBhbnQtbWV0YWRhdGEtaXRlbVwiIH0pKSkpKTtcbiAgfVxuKTtcbmZ1bmN0aW9uIElhKHQpIHtcbiAgY29uc3QgW24sIGFdID0gZS51c2VTdGF0ZSh2b2lkIDApLCBjID0gaGUodC5yb29tKTtcbiAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgWC5SZWNvbm5lY3Rpbmc6XG4gICAgICAgIGEoXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KG9lLCB7IGNsYXNzTmFtZTogXCJsay1zcGlubmVyXCIgfSksIFwiIFJlY29ubmVjdGluZ1wiKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgWC5Db25uZWN0aW5nOlxuICAgICAgICBhKFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChvZSwgeyBjbGFzc05hbWU6IFwibGstc3Bpbm5lclwiIH0pLCBcIiBDb25uZWN0aW5nXCIpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBYLkRpc2Nvbm5lY3RlZDpcbiAgICAgICAgYSgvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsIFwiRGlzY29ubmVjdGVkXCIpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhKHZvaWQgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSwgW2NdKSwgbiA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoR3QsIHsgY2xhc3NOYW1lOiBcImxrLXRvYXN0LWNvbm5lY3Rpb24tc3RhdGVcIiB9LCBuKSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCk7XG59XG5jb25zdCB4YSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uKHsgZW50cnk6IG4sIGhpZGVOYW1lOiBhID0gITEsIGhpZGVUaW1lc3RhbXA6IGMgPSAhMSwgbWVzc2FnZUZvcm1hdHRlcjogciwgLi4ucyB9LCBvKSB7XG4gICAgdmFyIGYsIHAsIEUsIGg7XG4gICAgY29uc3QgbCA9IGUudXNlTWVtbygoKSA9PiByID8gcihuLm1lc3NhZ2UpIDogbi5tZXNzYWdlLCBbbi5tZXNzYWdlLCByXSksIGkgPSAhIW4uZWRpdFRpbWVzdGFtcCwgZCA9IG5ldyBEYXRlKG4udGltZXN0YW1wKSwgdSA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiA/IG5hdmlnYXRvci5sYW5ndWFnZSA6IFwiZW4tVVNcIiwgdiA9ICgoZiA9IG4uZnJvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYubmFtZSkgPz8gKChwID0gbi5mcm9tKSA9PSBudWxsID8gdm9pZCAwIDogcC5pZGVudGl0eSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImxpXCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogbyxcbiAgICAgICAgY2xhc3NOYW1lOiBcImxrLWNoYXQtZW50cnlcIixcbiAgICAgICAgdGl0bGU6IGQudG9Mb2NhbGVUaW1lU3RyaW5nKHUsIHsgdGltZVN0eWxlOiBcImZ1bGxcIiB9KSxcbiAgICAgICAgXCJkYXRhLWxrLW1lc3NhZ2Utb3JpZ2luXCI6IChFID0gbi5mcm9tKSAhPSBudWxsICYmIEUuaXNMb2NhbCA/IFwibG9jYWxcIiA6IFwicmVtb3RlXCIsXG4gICAgICAgIC4uLnNcbiAgICAgIH0sXG4gICAgICAoIWMgfHwgIWEgfHwgaSkgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwibGstbWV0YS1kYXRhXCIgfSwgIWEgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0cm9uZ1wiLCB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1uYW1lXCIgfSwgdiksICghYyB8fCBpKSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJsay10aW1lc3RhbXBcIiB9LCBpICYmIFwiZWRpdGVkIFwiLCBkLnRvTG9jYWxlVGltZVN0cmluZyh1LCB7IHRpbWVTdHlsZTogXCJzaG9ydFwiIH0pKSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJsay1tZXNzYWdlLWJvZHlcIiB9LCBsKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImxrLW1lc3NhZ2UtYXR0YWNoZW1lbnRzXCIgfSwgKGggPSBuLmF0dGFjaGVkRmlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBoLm1hcChcbiAgICAgICAgKG0pID0+IG0udHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJpbWdcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZTogeyBtYXhXaWR0aDogXCIzMDBweFwiLCBtYXhIZWlnaHQ6IFwiMzAwcHhcIiB9LFxuICAgICAgICAgICAga2V5OiBtLm5hbWUsXG4gICAgICAgICAgICBzcmM6IFVSTC5jcmVhdGVPYmplY3RVUkwobSksXG4gICAgICAgICAgICBhbHQ6IG0ubmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSlcbiAgICApO1xuICB9XG4pO1xuZnVuY3Rpb24gUGEodCkge1xuICByZXR1cm4gaHQodCwgZ3QoKSkubWFwKChuLCBhKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gbjtcbiAgICB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LnRvU3RyaW5nKCksIHIgPSBuLnR5cGUgPT09IFwidXJsXCIgPyAvXmh0dHAocz8pOlxcL1xcLy8udGVzdChjKSA/IGMgOiBgaHR0cHM6Ly8ke2N9YCA6IGBtYWlsdG86JHtjfWA7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwibGstY2hhdC1saW5rXCIsIGtleTogYSwgaHJlZjogciwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9yZWZlcnJlclwiIH0sIGMpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBUYSh0KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHZ0LlByb3ZpZGVyLCB7IHZhbHVlOiB0LnNlc3Npb24gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChFdC5Qcm92aWRlciwgeyB2YWx1ZTogdC5zZXNzaW9uLnJvb20gfSwgdC5jaGlsZHJlbikpO1xufVxuZXhwb3J0IHtcbiAgUHQgYXMgJCxcbiAgTWEgYXMgQSxcbiAgS3QgYXMgQixcbiAgc2EgYXMgQyxcbiAgaWEgYXMgRCxcbiAgcHQgYXMgRSxcbiAgRWEgYXMgRixcbiAgd2EgYXMgRyxcbiAgd3QgYXMgSCxcbiAgaWUgYXMgSSxcbiAga3QgYXMgSixcbiAgUnQgYXMgSyxcbiAgUmEgYXMgTCxcbiAgZmEgYXMgTSxcbiAgTXQgYXMgTixcbiAgeXQgYXMgTyxcbiAgT3QgYXMgUCxcbiAgYnQgYXMgUSxcbiAgYmEgYXMgUixcbiAgb2EgYXMgUyxcbiAgdmEgYXMgVCxcbiAgU3QgYXMgVSxcbiAgQnQgYXMgVixcbiAgQ3QgYXMgVyxcbiAgSXQgYXMgWCxcbiAgUmUgYXMgWSxcbiAgeHQgYXMgWixcbiAgb2UgYXMgXyxcbiAgeGEgYXMgYSxcbiAgTnQgYXMgYixcbiAgdWEgYXMgYyxcbiAgZGEgYXMgZCxcbiAgbWEgYXMgZSxcbiAgZ2EgYXMgZixcbiAga2EgYXMgZyxcbiAgcGEgYXMgaCxcbiAgSWEgYXMgaSxcbiAgQ2UgYXMgaixcbiAgQ2EgYXMgayxcbiAgR3QgYXMgbCxcbiAgUGEgYXMgbSxcbiAgY2EgYXMgbixcbiAgbGEgYXMgbyxcbiAgVHQgYXMgcCxcbiAgaGEgYXMgcSxcbiAgeWUgYXMgcixcbiAgbmUgYXMgcyxcbiAgSyBhcyB0LFxuICBiZSBhcyB1LFxuICB5YSBhcyB2LFxuICBTYSBhcyB3LFxuICBqdCBhcyB4LFxuICBfdCBhcyB5LFxuICBUYSBhcyB6XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50cy1EdVJCdEdwOC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-DuRBtGp8.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ Xs; },\n/* harmony export */   A: function() { return /* binding */ bs; },\n/* harmony export */   B: function() { return /* binding */ Go; },\n/* harmony export */   C: function() { return /* binding */ _o; },\n/* harmony export */   D: function() { return /* binding */ Us; },\n/* harmony export */   E: function() { return /* binding */ Os; },\n/* harmony export */   F: function() { return /* binding */ na; },\n/* harmony export */   G: function() { return /* binding */ fs; },\n/* harmony export */   H: function() { return /* binding */ As; },\n/* harmony export */   I: function() { return /* binding */ _s; },\n/* harmony export */   J: function() { return /* binding */ xs; },\n/* harmony export */   K: function() { return /* binding */ Ss; },\n/* harmony export */   L: function() { return /* binding */ Xo; },\n/* harmony export */   M: function() { return /* binding */ gs; },\n/* harmony export */   N: function() { return /* binding */ js; },\n/* harmony export */   O: function() { return /* binding */ Bs; },\n/* harmony export */   P: function() { return /* binding */ Vs; },\n/* harmony export */   Q: function() { return /* binding */ Ns; },\n/* harmony export */   R: function() { return /* binding */ Hn; },\n/* harmony export */   S: function() { return /* binding */ Is; },\n/* harmony export */   T: function() { return /* binding */ Ms; },\n/* harmony export */   U: function() { return /* binding */ ho; },\n/* harmony export */   V: function() { return /* binding */ qs; },\n/* harmony export */   W: function() { return /* binding */ vs; },\n/* harmony export */   X: function() { return /* binding */ zt; },\n/* harmony export */   Y: function() { return /* binding */ ys; },\n/* harmony export */   Z: function() { return /* binding */ Ws; },\n/* harmony export */   _: function() { return /* binding */ Zs; },\n/* harmony export */   a: function() { return /* binding */ ta; },\n/* harmony export */   a0: function() { return /* binding */ Es; },\n/* harmony export */   a1: function() { return /* binding */ B; },\n/* harmony export */   a2: function() { return /* binding */ Ks; },\n/* harmony export */   a3: function() { return /* binding */ Qs; },\n/* harmony export */   a4: function() { return /* binding */ Gs; },\n/* harmony export */   a5: function() { return /* binding */ hs; },\n/* harmony export */   a6: function() { return /* binding */ ps; },\n/* harmony export */   a7: function() { return /* binding */ Ls; },\n/* harmony export */   a8: function() { return /* binding */ po; },\n/* harmony export */   a9: function() { return /* binding */ Cs; },\n/* harmony export */   aA: function() { return /* binding */ aa; },\n/* harmony export */   aB: function() { return /* binding */ fa; },\n/* harmony export */   aC: function() { return /* binding */ oa; },\n/* harmony export */   aa: function() { return /* binding */ ea; },\n/* harmony export */   ab: function() { return /* binding */ Mo; },\n/* harmony export */   ac: function() { return /* binding */ Jo; },\n/* harmony export */   ad: function() { return /* binding */ da; },\n/* harmony export */   ae: function() { return /* binding */ Bn; },\n/* harmony export */   af: function() { return /* binding */ Wn; },\n/* harmony export */   ag: function() { return /* binding */ Fs; },\n/* harmony export */   ah: function() { return /* binding */ es; },\n/* harmony export */   ai: function() { return /* binding */ Hr; },\n/* harmony export */   aj: function() { return /* binding */ Vn; },\n/* harmony export */   ak: function() { return /* binding */ jn; },\n/* harmony export */   al: function() { return /* binding */ pa; },\n/* harmony export */   am: function() { return /* binding */ Js; },\n/* harmony export */   an: function() { return /* binding */ rs; },\n/* harmony export */   ao: function() { return /* binding */ ia; },\n/* harmony export */   ap: function() { return /* binding */ cs; },\n/* harmony export */   aq: function() { return /* binding */ as; },\n/* harmony export */   ar: function() { return /* binding */ zn; },\n/* harmony export */   as: function() { return /* binding */ os; },\n/* harmony export */   at: function() { return /* binding */ ss; },\n/* harmony export */   au: function() { return /* binding */ ds; },\n/* harmony export */   av: function() { return /* binding */ ra; },\n/* harmony export */   aw: function() { return /* binding */ ts; },\n/* harmony export */   ax: function() { return /* binding */ is; },\n/* harmony export */   ay: function() { return /* binding */ us; },\n/* harmony export */   az: function() { return /* binding */ ls; },\n/* harmony export */   b: function() { return /* binding */ zs; },\n/* harmony export */   c: function() { return /* binding */ ca; },\n/* harmony export */   d: function() { return /* binding */ $s; },\n/* harmony export */   e: function() { return /* binding */ ws; },\n/* harmony export */   f: function() { return /* binding */ ua; },\n/* harmony export */   g: function() { return /* binding */ Do; },\n/* harmony export */   h: function() { return /* binding */ Ds; },\n/* harmony export */   i: function() { return /* binding */ sa; },\n/* harmony export */   j: function() { return /* binding */ Ko; },\n/* harmony export */   k: function() { return /* binding */ Hs; },\n/* harmony export */   l: function() { return /* binding */ L; },\n/* harmony export */   m: function() { return /* binding */ ns; },\n/* harmony export */   n: function() { return /* binding */ lo; },\n/* harmony export */   o: function() { return /* binding */ Io; },\n/* harmony export */   p: function() { return /* binding */ N; },\n/* harmony export */   q: function() { return /* binding */ Ps; },\n/* harmony export */   r: function() { return /* binding */ Oo; },\n/* harmony export */   s: function() { return /* binding */ Ys; },\n/* harmony export */   t: function() { return /* binding */ Dn; },\n/* harmony export */   u: function() { return /* binding */ la; },\n/* harmony export */   v: function() { return /* binding */ ks; },\n/* harmony export */   w: function() { return /* binding */ Qo; },\n/* harmony export */   x: function() { return /* binding */ Ts; },\n/* harmony export */   y: function() { return /* binding */ Rs; },\n/* harmony export */   z: function() { return /* binding */ ms; }\n/* harmony export */ });\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\nconst De = Math.min, ue = Math.max, $e = Math.round, _e = Math.floor, J = (e) => ({\n  x: e,\n  y: e\n}), Jn = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n}, Xn = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Et(e, t, n) {\n  return ue(e, De(t, n));\n}\nfunction He(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction le(e) {\n  return e.split(\"-\")[0];\n}\nfunction ze(e) {\n  return e.split(\"-\")[1];\n}\nfunction Qt(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction Jt(e) {\n  return e === \"y\" ? \"height\" : \"width\";\n}\nconst Zn = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction ie(e) {\n  return Zn.has(le(e)) ? \"y\" : \"x\";\n}\nfunction Xt(e) {\n  return Qt(ie(e));\n}\nfunction er(e, t, n) {\n  n === void 0 && (n = !1);\n  const r = ze(e), i = Xt(e), o = Jt(i);\n  let s = i === \"x\" ? r === (n ? \"end\" : \"start\") ? \"right\" : \"left\" : r === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[o] > t.floating[o] && (s = Ne(s)), [s, Ne(s)];\n}\nfunction tr(e) {\n  const t = Ne(e);\n  return [st(e), t, st(t)];\n}\nfunction st(e) {\n  return e.replace(/start|end/g, (t) => Xn[t]);\n}\nconst Ct = [\"left\", \"right\"], Pt = [\"right\", \"left\"], nr = [\"top\", \"bottom\"], rr = [\"bottom\", \"top\"];\nfunction ir(e, t, n) {\n  switch (e) {\n    case \"top\":\n    case \"bottom\":\n      return n ? t ? Pt : Ct : t ? Ct : Pt;\n    case \"left\":\n    case \"right\":\n      return t ? nr : rr;\n    default:\n      return [];\n  }\n}\nfunction or(e, t, n, r) {\n  const i = ze(e);\n  let o = ir(le(e), n === \"start\", r);\n  return i && (o = o.map((s) => s + \"-\" + i), t && (o = o.concat(o.map(st)))), o;\n}\nfunction Ne(e) {\n  return e.replace(/left|right|bottom|top/g, (t) => Jn[t]);\n}\nfunction sr(e) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...e\n  };\n}\nfunction ar(e) {\n  return typeof e != \"number\" ? sr(e) : {\n    top: e,\n    right: e,\n    bottom: e,\n    left: e\n  };\n}\nfunction Fe(e) {\n  const {\n    x: t,\n    y: n,\n    width: r,\n    height: i\n  } = e;\n  return {\n    width: r,\n    height: i,\n    top: n,\n    left: t,\n    right: t + r,\n    bottom: n + i,\n    x: t,\n    y: n\n  };\n}\nfunction Ot(e, t, n) {\n  let {\n    reference: r,\n    floating: i\n  } = e;\n  const o = ie(t), s = Xt(t), a = Jt(s), c = le(t), u = o === \"y\", l = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, v = r[a] / 2 - i[a] / 2;\n  let d;\n  switch (c) {\n    case \"top\":\n      d = {\n        x: l,\n        y: r.y - i.height\n      };\n      break;\n    case \"bottom\":\n      d = {\n        x: l,\n        y: r.y + r.height\n      };\n      break;\n    case \"right\":\n      d = {\n        x: r.x + r.width,\n        y: f\n      };\n      break;\n    case \"left\":\n      d = {\n        x: r.x - i.width,\n        y: f\n      };\n      break;\n    default:\n      d = {\n        x: r.x,\n        y: r.y\n      };\n  }\n  switch (ze(t)) {\n    case \"start\":\n      d[s] -= v * (n && u ? -1 : 1);\n      break;\n    case \"end\":\n      d[s] += v * (n && u ? -1 : 1);\n      break;\n  }\n  return d;\n}\nconst cr = async (e, t, n) => {\n  const {\n    placement: r = \"bottom\",\n    strategy: i = \"absolute\",\n    middleware: o = [],\n    platform: s\n  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));\n  let u = await s.getElementRects({\n    reference: e,\n    floating: t,\n    strategy: i\n  }), {\n    x: l,\n    y: f\n  } = Ot(u, r, c), v = r, d = {}, m = 0;\n  for (let p = 0; p < a.length; p++) {\n    const {\n      name: g,\n      fn: h\n    } = a[p], {\n      x,\n      y: E,\n      data: O,\n      reset: b\n    } = await h({\n      x: l,\n      y: f,\n      initialPlacement: r,\n      placement: v,\n      strategy: i,\n      middlewareData: d,\n      rects: u,\n      platform: s,\n      elements: {\n        reference: e,\n        floating: t\n      }\n    });\n    l = x ?? l, f = E ?? f, d = {\n      ...d,\n      [g]: {\n        ...d[g],\n        ...O\n      }\n    }, b && m <= 50 && (m++, typeof b == \"object\" && (b.placement && (v = b.placement), b.rects && (u = b.rects === !0 ? await s.getElementRects({\n      reference: e,\n      floating: t,\n      strategy: i\n    }) : b.rects), {\n      x: l,\n      y: f\n    } = Ot(u, v, c)), p = -1);\n  }\n  return {\n    x: l,\n    y: f,\n    placement: v,\n    strategy: i,\n    middlewareData: d\n  };\n};\nasync function Zt(e, t) {\n  var n;\n  t === void 0 && (t = {});\n  const {\n    x: r,\n    y: i,\n    platform: o,\n    rects: s,\n    elements: a,\n    strategy: c\n  } = e, {\n    boundary: u = \"clippingAncestors\",\n    rootBoundary: l = \"viewport\",\n    elementContext: f = \"floating\",\n    altBoundary: v = !1,\n    padding: d = 0\n  } = He(t, e), m = ar(d), g = a[v ? f === \"floating\" ? \"reference\" : \"floating\" : f], h = Fe(await o.getClippingRect({\n    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),\n    boundary: u,\n    rootBoundary: l,\n    strategy: c\n  })), x = f === \"floating\" ? {\n    x: r,\n    y: i,\n    width: s.floating.width,\n    height: s.floating.height\n  } : s.reference, E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), O = await (o.isElement == null ? void 0 : o.isElement(E)) ? await (o.getScale == null ? void 0 : o.getScale(E)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  }, b = Fe(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements: a,\n    rect: x,\n    offsetParent: E,\n    strategy: c\n  }) : x);\n  return {\n    top: (h.top - b.top + m.top) / O.y,\n    bottom: (b.bottom - h.bottom + m.bottom) / O.y,\n    left: (h.left - b.left + m.left) / O.x,\n    right: (b.right - h.right + m.right) / O.x\n  };\n}\nconst ur = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"flip\",\n    options: e,\n    async fn(t) {\n      var n, r;\n      const {\n        placement: i,\n        middlewareData: o,\n        rects: s,\n        initialPlacement: a,\n        platform: c,\n        elements: u\n      } = t, {\n        mainAxis: l = !0,\n        crossAxis: f = !0,\n        fallbackPlacements: v,\n        fallbackStrategy: d = \"bestFit\",\n        fallbackAxisSideDirection: m = \"none\",\n        flipAlignment: p = !0,\n        ...g\n      } = He(e, t);\n      if ((n = o.arrow) != null && n.alignmentOffset)\n        return {};\n      const h = le(i), x = ie(a), E = le(a) === a, O = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), b = v || (E || !p ? [Ne(a)] : tr(a)), S = m !== \"none\";\n      !v && S && b.push(...or(a, p, m, O));\n      const C = [a, ...b], $ = await Zt(t, g), M = [];\n      let V = ((r = o.flip) == null ? void 0 : r.overflows) || [];\n      if (l && M.push($[h]), f) {\n        const Q = er(i, s, O);\n        M.push($[Q[0]], $[Q[1]]);\n      }\n      if (V = [...V, {\n        placement: i,\n        overflows: M\n      }], !M.every((Q) => Q <= 0)) {\n        var T, _;\n        const Q = (((T = o.flip) == null ? void 0 : T.index) || 0) + 1, Se = C[Q];\n        if (Se && (!(f === \"alignment\" ? x !== ie(Se) : !1) || // We leave the current main axis only if every placement on that axis\n        // overflows the main axis.\n        V.every((Y) => ie(Y.placement) === x ? Y.overflows[0] > 0 : !0)))\n          return {\n            data: {\n              index: Q,\n              overflows: V\n            },\n            reset: {\n              placement: Se\n            }\n          };\n        let Te = (_ = V.filter((ae) => ae.overflows[0] <= 0).sort((ae, Y) => ae.overflows[1] - Y.overflows[1])[0]) == null ? void 0 : _.placement;\n        if (!Te)\n          switch (d) {\n            case \"bestFit\": {\n              var ee;\n              const ae = (ee = V.filter((Y) => {\n                if (S) {\n                  const re = ie(Y.placement);\n                  return re === x || // Create a bias to the `y` side axis due to horizontal\n                  // reading directions favoring greater width.\n                  re === \"y\";\n                }\n                return !0;\n              }).map((Y) => [Y.placement, Y.overflows.filter((re) => re > 0).reduce((re, Yn) => re + Yn, 0)]).sort((Y, re) => Y[1] - re[1])[0]) == null ? void 0 : ee[0];\n              ae && (Te = ae);\n              break;\n            }\n            case \"initialPlacement\":\n              Te = a;\n              break;\n          }\n        if (i !== Te)\n          return {\n            reset: {\n              placement: Te\n            }\n          };\n      }\n      return {};\n    }\n  };\n}, lr = /* @__PURE__ */ new Set([\"left\", \"top\"]);\nasync function fr(e, t) {\n  const {\n    placement: n,\n    platform: r,\n    elements: i\n  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = le(n), a = ze(n), c = ie(n) === \"y\", u = lr.has(s) ? -1 : 1, l = o && c ? -1 : 1, f = He(t, e);\n  let {\n    mainAxis: v,\n    crossAxis: d,\n    alignmentAxis: m\n  } = typeof f == \"number\" ? {\n    mainAxis: f,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: f.mainAxis || 0,\n    crossAxis: f.crossAxis || 0,\n    alignmentAxis: f.alignmentAxis\n  };\n  return a && typeof m == \"number\" && (d = a === \"end\" ? m * -1 : m), c ? {\n    x: d * l,\n    y: v * u\n  } : {\n    x: v * u,\n    y: d * l\n  };\n}\nconst dr = function(e) {\n  return e === void 0 && (e = 0), {\n    name: \"offset\",\n    options: e,\n    async fn(t) {\n      var n, r;\n      const {\n        x: i,\n        y: o,\n        placement: s,\n        middlewareData: a\n      } = t, c = await fr(t, e);\n      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {\n        x: i + c.x,\n        y: o + c.y,\n        data: {\n          ...c,\n          placement: s\n        }\n      };\n    }\n  };\n}, pr = function(e) {\n  return e === void 0 && (e = {}), {\n    name: \"shift\",\n    options: e,\n    async fn(t) {\n      const {\n        x: n,\n        y: r,\n        placement: i\n      } = t, {\n        mainAxis: o = !0,\n        crossAxis: s = !1,\n        limiter: a = {\n          fn: (g) => {\n            let {\n              x: h,\n              y: x\n            } = g;\n            return {\n              x: h,\n              y: x\n            };\n          }\n        },\n        ...c\n      } = He(e, t), u = {\n        x: n,\n        y: r\n      }, l = await Zt(t, c), f = ie(le(i)), v = Qt(f);\n      let d = u[v], m = u[f];\n      if (o) {\n        const g = v === \"y\" ? \"top\" : \"left\", h = v === \"y\" ? \"bottom\" : \"right\", x = d + l[g], E = d - l[h];\n        d = Et(x, d, E);\n      }\n      if (s) {\n        const g = f === \"y\" ? \"top\" : \"left\", h = f === \"y\" ? \"bottom\" : \"right\", x = m + l[g], E = m - l[h];\n        m = Et(x, m, E);\n      }\n      const p = a.fn({\n        ...t,\n        [v]: d,\n        [f]: m\n      });\n      return {\n        ...p,\n        data: {\n          x: p.x - n,\n          y: p.y - r,\n          enabled: {\n            [v]: o,\n            [f]: s\n          }\n        }\n      };\n    }\n  };\n};\nfunction Ye() {\n  return typeof window < \"u\";\n}\nfunction ye(e) {\n  return en(e) ? (e.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction j(e) {\n  var t;\n  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction Z(e) {\n  var t;\n  return (t = (en(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;\n}\nfunction en(e) {\n  return Ye() ? e instanceof Node || e instanceof j(e).Node : !1;\n}\nfunction K(e) {\n  return Ye() ? e instanceof Element || e instanceof j(e).Element : !1;\n}\nfunction X(e) {\n  return Ye() ? e instanceof HTMLElement || e instanceof j(e).HTMLElement : !1;\n}\nfunction At(e) {\n  return !Ye() || typeof ShadowRoot > \"u\" ? !1 : e instanceof ShadowRoot || e instanceof j(e).ShadowRoot;\n}\nconst hr = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction Ae(e) {\n  const {\n    overflow: t,\n    overflowX: n,\n    overflowY: r,\n    display: i\n  } = G(e);\n  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !hr.has(i);\n}\nconst vr = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction mr(e) {\n  return vr.has(ye(e));\n}\nconst gr = [\":popover-open\", \":modal\"];\nfunction qe(e) {\n  return gr.some((t) => {\n    try {\n      return e.matches(t);\n    } catch {\n      return !1;\n    }\n  });\n}\nconst br = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"], yr = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"], wr = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction pt(e) {\n  const t = ht(), n = K(e) ? G(e) : e;\n  return br.some((r) => n[r] ? n[r] !== \"none\" : !1) || (n.containerType ? n.containerType !== \"normal\" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !t && (n.filter ? n.filter !== \"none\" : !1) || yr.some((r) => (n.willChange || \"\").includes(r)) || wr.some((r) => (n.contain || \"\").includes(r));\n}\nfunction xr(e) {\n  let t = se(e);\n  for (; X(t) && !me(t); ) {\n    if (pt(t))\n      return t;\n    if (qe(t))\n      return null;\n    t = se(t);\n  }\n  return null;\n}\nfunction ht() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst Sr = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction me(e) {\n  return Sr.has(ye(e));\n}\nfunction G(e) {\n  return j(e).getComputedStyle(e);\n}\nfunction Ke(e) {\n  return K(e) ? {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  } : {\n    scrollLeft: e.scrollX,\n    scrollTop: e.scrollY\n  };\n}\nfunction se(e) {\n  if (ye(e) === \"html\")\n    return e;\n  const t = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    e.assignedSlot || // DOM Element detected.\n    e.parentNode || // ShadowRoot detected.\n    At(e) && e.host || // Fallback.\n    Z(e)\n  );\n  return At(t) ? t.host : t;\n}\nfunction tn(e) {\n  const t = se(e);\n  return me(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : X(t) && Ae(t) ? t : tn(t);\n}\nfunction Ce(e, t, n) {\n  var r;\n  t === void 0 && (t = []), n === void 0 && (n = !0);\n  const i = tn(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = j(i);\n  if (o) {\n    const a = at(s);\n    return t.concat(s, s.visualViewport || [], Ae(i) ? i : [], a && n ? Ce(a) : []);\n  }\n  return t.concat(i, Ce(i, [], n));\n}\nfunction at(e) {\n  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;\n}\nfunction nn(e) {\n  const t = G(e);\n  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;\n  const i = X(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = $e(n) !== o || $e(r) !== s;\n  return a && (n = o, r = s), {\n    width: n,\n    height: r,\n    $: a\n  };\n}\nfunction vt(e) {\n  return K(e) ? e : e.contextElement;\n}\nfunction he(e) {\n  const t = vt(e);\n  if (!X(t))\n    return J(1);\n  const n = t.getBoundingClientRect(), {\n    width: r,\n    height: i,\n    $: o\n  } = nn(t);\n  let s = (o ? $e(n.width) : n.width) / r, a = (o ? $e(n.height) : n.height) / i;\n  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {\n    x: s,\n    y: a\n  };\n}\nconst Tr = /* @__PURE__ */ J(0);\nfunction rn(e) {\n  const t = j(e);\n  return !ht() || !t.visualViewport ? Tr : {\n    x: t.visualViewport.offsetLeft,\n    y: t.visualViewport.offsetTop\n  };\n}\nfunction Er(e, t, n) {\n  return t === void 0 && (t = !1), !n || t && n !== j(e) ? !1 : t;\n}\nfunction fe(e, t, n, r) {\n  t === void 0 && (t = !1), n === void 0 && (n = !1);\n  const i = e.getBoundingClientRect(), o = vt(e);\n  let s = J(1);\n  t && (r ? K(r) && (s = he(r)) : s = he(e));\n  const a = Er(o, n, r) ? rn(o) : J(0);\n  let c = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, l = i.width / s.x, f = i.height / s.y;\n  if (o) {\n    const v = j(o), d = r && K(r) ? j(r) : r;\n    let m = v, p = at(m);\n    for (; p && r && d !== m; ) {\n      const g = he(p), h = p.getBoundingClientRect(), x = G(p), E = h.left + (p.clientLeft + parseFloat(x.paddingLeft)) * g.x, O = h.top + (p.clientTop + parseFloat(x.paddingTop)) * g.y;\n      c *= g.x, u *= g.y, l *= g.x, f *= g.y, c += E, u += O, m = j(p), p = at(m);\n    }\n  }\n  return Fe({\n    width: l,\n    height: f,\n    x: c,\n    y: u\n  });\n}\nfunction Ge(e, t) {\n  const n = Ke(e).scrollLeft;\n  return t ? t.left + n : fe(Z(e)).left + n;\n}\nfunction on(e, t) {\n  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - Ge(e, n), i = n.top + t.scrollTop;\n  return {\n    x: r,\n    y: i\n  };\n}\nfunction Cr(e) {\n  let {\n    elements: t,\n    rect: n,\n    offsetParent: r,\n    strategy: i\n  } = e;\n  const o = i === \"fixed\", s = Z(r), a = t ? qe(t.floating) : !1;\n  if (r === s || a && o)\n    return n;\n  let c = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, u = J(1);\n  const l = J(0), f = X(r);\n  if ((f || !f && !o) && ((ye(r) !== \"body\" || Ae(s)) && (c = Ke(r)), X(r))) {\n    const d = fe(r);\n    u = he(r), l.x = d.x + r.clientLeft, l.y = d.y + r.clientTop;\n  }\n  const v = s && !f && !o ? on(s, c) : J(0);\n  return {\n    width: n.width * u.x,\n    height: n.height * u.y,\n    x: n.x * u.x - c.scrollLeft * u.x + l.x + v.x,\n    y: n.y * u.y - c.scrollTop * u.y + l.y + v.y\n  };\n}\nfunction Pr(e) {\n  return Array.from(e.getClientRects());\n}\nfunction Or(e) {\n  const t = Z(e), n = Ke(e), r = e.ownerDocument.body, i = ue(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = ue(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);\n  let s = -n.scrollLeft + Ge(e);\n  const a = -n.scrollTop;\n  return G(r).direction === \"rtl\" && (s += ue(t.clientWidth, r.clientWidth) - i), {\n    width: i,\n    height: o,\n    x: s,\n    y: a\n  };\n}\nconst kt = 25;\nfunction Ar(e, t) {\n  const n = j(e), r = Z(e), i = n.visualViewport;\n  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;\n  if (i) {\n    o = i.width, s = i.height;\n    const l = ht();\n    (!l || l && t === \"fixed\") && (a = i.offsetLeft, c = i.offsetTop);\n  }\n  const u = Ge(r);\n  if (u <= 0) {\n    const l = r.ownerDocument, f = l.body, v = getComputedStyle(f), d = l.compatMode === \"CSS1Compat\" && parseFloat(v.marginLeft) + parseFloat(v.marginRight) || 0, m = Math.abs(r.clientWidth - f.clientWidth - d);\n    m <= kt && (o -= m);\n  } else u <= kt && (o += u);\n  return {\n    width: o,\n    height: s,\n    x: a,\n    y: c\n  };\n}\nconst kr = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction _r(e, t) {\n  const n = fe(e, !0, t === \"fixed\"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = X(e) ? he(e) : J(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, c = i * o.x, u = r * o.y;\n  return {\n    width: s,\n    height: a,\n    x: c,\n    y: u\n  };\n}\nfunction _t(e, t, n) {\n  let r;\n  if (t === \"viewport\")\n    r = Ar(e, n);\n  else if (t === \"document\")\n    r = Or(Z(e));\n  else if (K(t))\n    r = _r(t, n);\n  else {\n    const i = rn(e);\n    r = {\n      x: t.x - i.x,\n      y: t.y - i.y,\n      width: t.width,\n      height: t.height\n    };\n  }\n  return Fe(r);\n}\nfunction sn(e, t) {\n  const n = se(e);\n  return n === t || !K(n) || me(n) ? !1 : G(n).position === \"fixed\" || sn(n, t);\n}\nfunction Lr(e, t) {\n  const n = t.get(e);\n  if (n)\n    return n;\n  let r = Ce(e, [], !1).filter((a) => K(a) && ye(a) !== \"body\"), i = null;\n  const o = G(e).position === \"fixed\";\n  let s = o ? se(e) : e;\n  for (; K(s) && !me(s); ) {\n    const a = G(s), c = pt(s);\n    !c && a.position === \"fixed\" && (i = null), (o ? !c && !i : !c && a.position === \"static\" && !!i && kr.has(i.position) || Ae(s) && !c && sn(e, s)) ? r = r.filter((l) => l !== s) : i = a, s = se(s);\n  }\n  return t.set(e, r), r;\n}\nfunction Ir(e) {\n  let {\n    element: t,\n    boundary: n,\n    rootBoundary: r,\n    strategy: i\n  } = e;\n  const s = [...n === \"clippingAncestors\" ? qe(t) ? [] : Lr(t, this._c) : [].concat(n), r], a = s[0], c = s.reduce((u, l) => {\n    const f = _t(t, l, i);\n    return u.top = ue(f.top, u.top), u.right = De(f.right, u.right), u.bottom = De(f.bottom, u.bottom), u.left = ue(f.left, u.left), u;\n  }, _t(t, a, i));\n  return {\n    width: c.right - c.left,\n    height: c.bottom - c.top,\n    x: c.left,\n    y: c.top\n  };\n}\nfunction Mr(e) {\n  const {\n    width: t,\n    height: n\n  } = nn(e);\n  return {\n    width: t,\n    height: n\n  };\n}\nfunction Rr(e, t, n) {\n  const r = X(t), i = Z(t), o = n === \"fixed\", s = fe(e, !0, o, t);\n  let a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const c = J(0);\n  function u() {\n    c.x = Ge(i);\n  }\n  if (r || !r && !o)\n    if ((ye(t) !== \"body\" || Ae(i)) && (a = Ke(t)), r) {\n      const d = fe(t, !0, o, t);\n      c.x = d.x + t.clientLeft, c.y = d.y + t.clientTop;\n    } else i && u();\n  o && !r && i && u();\n  const l = i && !r && !o ? on(i, a) : J(0), f = s.left + a.scrollLeft - c.x - l.x, v = s.top + a.scrollTop - c.y - l.y;\n  return {\n    x: f,\n    y: v,\n    width: s.width,\n    height: s.height\n  };\n}\nfunction et(e) {\n  return G(e).position === \"static\";\n}\nfunction Lt(e, t) {\n  if (!X(e) || G(e).position === \"fixed\")\n    return null;\n  if (t)\n    return t(e);\n  let n = e.offsetParent;\n  return Z(e) === n && (n = n.ownerDocument.body), n;\n}\nfunction an(e, t) {\n  const n = j(e);\n  if (qe(e))\n    return n;\n  if (!X(e)) {\n    let i = se(e);\n    for (; i && !me(i); ) {\n      if (K(i) && !et(i))\n        return i;\n      i = se(i);\n    }\n    return n;\n  }\n  let r = Lt(e, t);\n  for (; r && mr(r) && et(r); )\n    r = Lt(r, t);\n  return r && me(r) && et(r) && !pt(r) ? n : r || xr(e) || n;\n}\nconst Dr = async function(e) {\n  const t = this.getOffsetParent || an, n = this.getDimensions, r = await n(e.floating);\n  return {\n    reference: Rr(e.reference, await t(e.floating), e.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: r.width,\n      height: r.height\n    }\n  };\n};\nfunction $r(e) {\n  return G(e).direction === \"rtl\";\n}\nconst Nr = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: Cr,\n  getDocumentElement: Z,\n  getClippingRect: Ir,\n  getOffsetParent: an,\n  getElementRects: Dr,\n  getClientRects: Pr,\n  getDimensions: Mr,\n  getScale: he,\n  isElement: K,\n  isRTL: $r\n};\nfunction cn(e, t) {\n  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;\n}\nfunction Fr(e, t) {\n  let n = null, r;\n  const i = Z(e);\n  function o() {\n    var a;\n    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;\n  }\n  function s(a, c) {\n    a === void 0 && (a = !1), c === void 0 && (c = 1), o();\n    const u = e.getBoundingClientRect(), {\n      left: l,\n      top: f,\n      width: v,\n      height: d\n    } = u;\n    if (a || t(), !v || !d)\n      return;\n    const m = _e(f), p = _e(i.clientWidth - (l + v)), g = _e(i.clientHeight - (f + d)), h = _e(l), E = {\n      rootMargin: -m + \"px \" + -p + \"px \" + -g + \"px \" + -h + \"px\",\n      threshold: ue(0, De(1, c)) || 1\n    };\n    let O = !0;\n    function b(S) {\n      const C = S[0].intersectionRatio;\n      if (C !== c) {\n        if (!O)\n          return s();\n        C ? s(!1, C) : r = setTimeout(() => {\n          s(!1, 1e-7);\n        }, 1e3);\n      }\n      C === 1 && !cn(u, e.getBoundingClientRect()) && s(), O = !1;\n    }\n    try {\n      n = new IntersectionObserver(b, {\n        ...E,\n        // Handle <iframe>s\n        root: i.ownerDocument\n      });\n    } catch {\n      n = new IntersectionObserver(b, E);\n    }\n    n.observe(e);\n  }\n  return s(!0), o;\n}\nfunction Ur(e, t, n, r) {\n  r === void 0 && (r = {});\n  const {\n    ancestorScroll: i = !0,\n    ancestorResize: o = !0,\n    elementResize: s = typeof ResizeObserver == \"function\",\n    layoutShift: a = typeof IntersectionObserver == \"function\",\n    animationFrame: c = !1\n  } = r, u = vt(e), l = i || o ? [...u ? Ce(u) : [], ...Ce(t)] : [];\n  l.forEach((h) => {\n    i && h.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), o && h.addEventListener(\"resize\", n);\n  });\n  const f = u && a ? Fr(u, n) : null;\n  let v = -1, d = null;\n  s && (d = new ResizeObserver((h) => {\n    let [x] = h;\n    x && x.target === u && d && (d.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {\n      var E;\n      (E = d) == null || E.observe(t);\n    })), n();\n  }), u && !c && d.observe(u), d.observe(t));\n  let m, p = c ? fe(e) : null;\n  c && g();\n  function g() {\n    const h = fe(e);\n    p && !cn(p, h) && n(), p = h, m = requestAnimationFrame(g);\n  }\n  return n(), () => {\n    var h;\n    l.forEach((x) => {\n      i && x.removeEventListener(\"scroll\", n), o && x.removeEventListener(\"resize\", n);\n    }), f == null || f(), (h = d) == null || h.disconnect(), d = null, c && cancelAnimationFrame(m);\n  };\n}\nconst Wr = dr, jr = pr, Br = ur, Vr = (e, t, n) => {\n  const r = /* @__PURE__ */ new Map(), i = {\n    platform: Nr,\n    ...n\n  }, o = {\n    ...i.platform,\n    _c: r\n  };\n  return cr(e, t, {\n    ...i,\n    platform: o\n  });\n};\nvar es = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Hr(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar Me = { exports: {} }, zr = Me.exports, It;\nfunction Yr() {\n  return It || (It = 1, (function(e) {\n    (function(t, n) {\n      e.exports ? e.exports = n() : t.log = n();\n    })(zr, function() {\n      var t = function() {\n      }, n = \"undefined\", r = typeof window !== n && typeof window.navigator !== n && /Trident\\/|MSIE /.test(window.navigator.userAgent), i = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n      ], o = {}, s = null;\n      function a(p, g) {\n        var h = p[g];\n        if (typeof h.bind == \"function\")\n          return h.bind(p);\n        try {\n          return Function.prototype.bind.call(h, p);\n        } catch {\n          return function() {\n            return Function.prototype.apply.apply(h, [p, arguments]);\n          };\n        }\n      }\n      function c() {\n        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();\n      }\n      function u(p) {\n        return p === \"debug\" && (p = \"log\"), typeof console === n ? !1 : p === \"trace\" && r ? c : console[p] !== void 0 ? a(console, p) : console.log !== void 0 ? a(console, \"log\") : t;\n      }\n      function l() {\n        for (var p = this.getLevel(), g = 0; g < i.length; g++) {\n          var h = i[g];\n          this[h] = g < p ? t : this.methodFactory(h, p, this.name);\n        }\n        if (this.log = this.debug, typeof console === n && p < this.levels.SILENT)\n          return \"No console available for logging\";\n      }\n      function f(p) {\n        return function() {\n          typeof console !== n && (l.call(this), this[p].apply(this, arguments));\n        };\n      }\n      function v(p, g, h) {\n        return u(p) || f.apply(this, arguments);\n      }\n      function d(p, g) {\n        var h = this, x, E, O, b = \"loglevel\";\n        typeof p == \"string\" ? b += \":\" + p : typeof p == \"symbol\" && (b = void 0);\n        function S(T) {\n          var _ = (i[T] || \"silent\").toUpperCase();\n          if (!(typeof window === n || !b)) {\n            try {\n              window.localStorage[b] = _;\n              return;\n            } catch {\n            }\n            try {\n              window.document.cookie = encodeURIComponent(b) + \"=\" + _ + \";\";\n            } catch {\n            }\n          }\n        }\n        function C() {\n          var T;\n          if (!(typeof window === n || !b)) {\n            try {\n              T = window.localStorage[b];\n            } catch {\n            }\n            if (typeof T === n)\n              try {\n                var _ = window.document.cookie, ee = encodeURIComponent(b), Q = _.indexOf(ee + \"=\");\n                Q !== -1 && (T = /^([^;]+)/.exec(\n                  _.slice(Q + ee.length + 1)\n                )[1]);\n              } catch {\n              }\n            return h.levels[T] === void 0 && (T = void 0), T;\n          }\n        }\n        function $() {\n          if (!(typeof window === n || !b)) {\n            try {\n              window.localStorage.removeItem(b);\n            } catch {\n            }\n            try {\n              window.document.cookie = encodeURIComponent(b) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch {\n            }\n          }\n        }\n        function M(T) {\n          var _ = T;\n          if (typeof _ == \"string\" && h.levels[_.toUpperCase()] !== void 0 && (_ = h.levels[_.toUpperCase()]), typeof _ == \"number\" && _ >= 0 && _ <= h.levels.SILENT)\n            return _;\n          throw new TypeError(\"log.setLevel() called with invalid level: \" + T);\n        }\n        h.name = p, h.levels = {\n          TRACE: 0,\n          DEBUG: 1,\n          INFO: 2,\n          WARN: 3,\n          ERROR: 4,\n          SILENT: 5\n        }, h.methodFactory = g || v, h.getLevel = function() {\n          return O ?? E ?? x;\n        }, h.setLevel = function(T, _) {\n          return O = M(T), _ !== !1 && S(O), l.call(h);\n        }, h.setDefaultLevel = function(T) {\n          E = M(T), C() || h.setLevel(T, !1);\n        }, h.resetLevel = function() {\n          O = null, $(), l.call(h);\n        }, h.enableAll = function(T) {\n          h.setLevel(h.levels.TRACE, T);\n        }, h.disableAll = function(T) {\n          h.setLevel(h.levels.SILENT, T);\n        }, h.rebuild = function() {\n          if (s !== h && (x = M(s.getLevel())), l.call(h), s === h)\n            for (var T in o)\n              o[T].rebuild();\n        }, x = M(\n          s ? s.getLevel() : \"WARN\"\n        );\n        var V = C();\n        V != null && (O = M(V)), l.call(h);\n      }\n      s = new d(), s.getLogger = function(g) {\n        if (typeof g != \"symbol\" && typeof g != \"string\" || g === \"\")\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        var h = o[g];\n        return h || (h = o[g] = new d(\n          g,\n          s.methodFactory\n        )), h;\n      };\n      var m = typeof window !== n ? window.log : void 0;\n      return s.noConflict = function() {\n        return typeof window !== n && window.log === s && (window.log = m), s;\n      }, s.getLoggers = function() {\n        return o;\n      }, s.default = s, s;\n    });\n  })(Me)), Me.exports;\n}\nvar qr = Yr();\nconst Kr = /* @__PURE__ */ Hr(qr);\nvar ct = function(e, t) {\n  return ct = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {\n    n.__proto__ = r;\n  } || function(n, r) {\n    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);\n  }, ct(e, t);\n};\nfunction ne(e, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  ct(e, t);\n  function n() {\n    this.constructor = e;\n  }\n  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\nfunction Gr(e, t, n, r) {\n  function i(o) {\n    return o instanceof n ? o : new n(function(s) {\n      s(o);\n    });\n  }\n  return new (n || (n = Promise))(function(o, s) {\n    function a(l) {\n      try {\n        u(r.next(l));\n      } catch (f) {\n        s(f);\n      }\n    }\n    function c(l) {\n      try {\n        u(r.throw(l));\n      } catch (f) {\n        s(f);\n      }\n    }\n    function u(l) {\n      l.done ? o(l.value) : i(l.value).then(a, c);\n    }\n    u((r = r.apply(e, t || [])).next());\n  });\n}\nfunction un(e, t) {\n  var n = { label: 0, sent: function() {\n    if (o[0] & 1) throw o[1];\n    return o[1];\n  }, trys: [], ops: [] }, r, i, o, s = Object.create((typeof Iterator == \"function\" ? Iterator : Object).prototype);\n  return s.next = a(0), s.throw = a(1), s.return = a(2), typeof Symbol == \"function\" && (s[Symbol.iterator] = function() {\n    return this;\n  }), s;\n  function a(u) {\n    return function(l) {\n      return c([u, l]);\n    };\n  }\n  function c(u) {\n    if (r) throw new TypeError(\"Generator is already executing.\");\n    for (; s && (s = 0, u[0] && (n = 0)), n; ) try {\n      if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done) return o;\n      switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {\n        case 0:\n        case 1:\n          o = u;\n          break;\n        case 4:\n          return n.label++, { value: u[1], done: !1 };\n        case 5:\n          n.label++, i = u[1], u = [0];\n          continue;\n        case 7:\n          u = n.ops.pop(), n.trys.pop();\n          continue;\n        default:\n          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {\n            n = 0;\n            continue;\n          }\n          if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {\n            n.label = u[1];\n            break;\n          }\n          if (u[0] === 6 && n.label < o[1]) {\n            n.label = o[1], o = u;\n            break;\n          }\n          if (o && n.label < o[2]) {\n            n.label = o[2], n.ops.push(u);\n            break;\n          }\n          o[2] && n.ops.pop(), n.trys.pop();\n          continue;\n      }\n      u = t.call(e, n);\n    } catch (l) {\n      u = [6, l], i = 0;\n    } finally {\n      r = o = 0;\n    }\n    if (u[0] & 5) throw u[1];\n    return { value: u[0] ? u[1] : void 0, done: !0 };\n  }\n}\nfunction ge(e) {\n  var t = typeof Symbol == \"function\" && Symbol.iterator, n = t && e[t], r = 0;\n  if (n) return n.call(e);\n  if (e && typeof e.length == \"number\") return {\n    next: function() {\n      return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };\n    }\n  };\n  throw new TypeError(t ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction de(e, t) {\n  var n = typeof Symbol == \"function\" && e[Symbol.iterator];\n  if (!n) return e;\n  var r = n.call(e), i, o = [], s;\n  try {\n    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);\n  } catch (a) {\n    s = { error: a };\n  } finally {\n    try {\n      i && !i.done && (n = r.return) && n.call(r);\n    } finally {\n      if (s) throw s.error;\n    }\n  }\n  return o;\n}\nfunction be(e, t, n) {\n  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)\n    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);\n  return e.concat(o || Array.prototype.slice.call(t));\n}\nfunction ve(e) {\n  return this instanceof ve ? (this.v = e, this) : new ve(e);\n}\nfunction Qr(e, t, n) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var r = n.apply(e, t || []), i, o = [];\n  return i = Object.create((typeof AsyncIterator == \"function\" ? AsyncIterator : Object).prototype), a(\"next\"), a(\"throw\"), a(\"return\", s), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function s(d) {\n    return function(m) {\n      return Promise.resolve(m).then(d, f);\n    };\n  }\n  function a(d, m) {\n    r[d] && (i[d] = function(p) {\n      return new Promise(function(g, h) {\n        o.push([d, p, g, h]) > 1 || c(d, p);\n      });\n    }, m && (i[d] = m(i[d])));\n  }\n  function c(d, m) {\n    try {\n      u(r[d](m));\n    } catch (p) {\n      v(o[0][3], p);\n    }\n  }\n  function u(d) {\n    d.value instanceof ve ? Promise.resolve(d.value.v).then(l, f) : v(o[0][2], d);\n  }\n  function l(d) {\n    c(\"next\", d);\n  }\n  function f(d) {\n    c(\"throw\", d);\n  }\n  function v(d, m) {\n    d(m), o.shift(), o.length && c(o[0][0], o[0][1]);\n  }\n}\nfunction Jr(e) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var t = e[Symbol.asyncIterator], n;\n  return t ? t.call(e) : (e = typeof ge == \"function\" ? ge(e) : e[Symbol.iterator](), n = {}, r(\"next\"), r(\"throw\"), r(\"return\"), n[Symbol.asyncIterator] = function() {\n    return this;\n  }, n);\n  function r(o) {\n    n[o] = e[o] && function(s) {\n      return new Promise(function(a, c) {\n        s = e[o](s), i(a, c, s.done, s.value);\n      });\n    };\n  }\n  function i(o, s, a, c) {\n    Promise.resolve(c).then(function(u) {\n      o({ value: u, done: a });\n    }, s);\n  }\n}\nfunction P(e) {\n  return typeof e == \"function\";\n}\nfunction mt(e) {\n  var t = function(r) {\n    Error.call(r), r.stack = new Error().stack;\n  }, n = e(t);\n  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;\n}\nvar tt = mt(function(e) {\n  return function(n) {\n    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:\n` + n.map(function(r, i) {\n      return i + 1 + \") \" + r.toString();\n    }).join(`\n  `) : \"\", this.name = \"UnsubscriptionError\", this.errors = n;\n  };\n});\nfunction Ue(e, t) {\n  if (e) {\n    var n = e.indexOf(t);\n    0 <= n && e.splice(n, 1);\n  }\n}\nvar ke = (function() {\n  function e(t) {\n    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;\n  }\n  return e.prototype.unsubscribe = function() {\n    var t, n, r, i, o;\n    if (!this.closed) {\n      this.closed = !0;\n      var s = this._parentage;\n      if (s)\n        if (this._parentage = null, Array.isArray(s))\n          try {\n            for (var a = ge(s), c = a.next(); !c.done; c = a.next()) {\n              var u = c.value;\n              u.remove(this);\n            }\n          } catch (p) {\n            t = { error: p };\n          } finally {\n            try {\n              c && !c.done && (n = a.return) && n.call(a);\n            } finally {\n              if (t) throw t.error;\n            }\n          }\n        else\n          s.remove(this);\n      var l = this.initialTeardown;\n      if (P(l))\n        try {\n          l();\n        } catch (p) {\n          o = p instanceof tt ? p.errors : [p];\n        }\n      var f = this._finalizers;\n      if (f) {\n        this._finalizers = null;\n        try {\n          for (var v = ge(f), d = v.next(); !d.done; d = v.next()) {\n            var m = d.value;\n            try {\n              Mt(m);\n            } catch (p) {\n              o = o ?? [], p instanceof tt ? o = be(be([], de(o)), de(p.errors)) : o.push(p);\n            }\n          }\n        } catch (p) {\n          r = { error: p };\n        } finally {\n          try {\n            d && !d.done && (i = v.return) && i.call(v);\n          } finally {\n            if (r) throw r.error;\n          }\n        }\n      }\n      if (o)\n        throw new tt(o);\n    }\n  }, e.prototype.add = function(t) {\n    var n;\n    if (t && t !== this)\n      if (this.closed)\n        Mt(t);\n      else {\n        if (t instanceof e) {\n          if (t.closed || t._hasParent(this))\n            return;\n          t._addParent(this);\n        }\n        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);\n      }\n  }, e.prototype._hasParent = function(t) {\n    var n = this._parentage;\n    return n === t || Array.isArray(n) && n.includes(t);\n  }, e.prototype._addParent = function(t) {\n    var n = this._parentage;\n    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;\n  }, e.prototype._removeParent = function(t) {\n    var n = this._parentage;\n    n === t ? this._parentage = null : Array.isArray(n) && Ue(n, t);\n  }, e.prototype.remove = function(t) {\n    var n = this._finalizers;\n    n && Ue(n, t), t instanceof e && t._removeParent(this);\n  }, e.EMPTY = (function() {\n    var t = new e();\n    return t.closed = !0, t;\n  })(), e;\n})(), ln = ke.EMPTY;\nfunction fn(e) {\n  return e instanceof ke || e && \"closed\" in e && P(e.remove) && P(e.add) && P(e.unsubscribe);\n}\nfunction Mt(e) {\n  P(e) ? e() : e.unsubscribe();\n}\nvar Xr = {\n  Promise: void 0\n}, Zr = {\n  setTimeout: function(e, t) {\n    for (var n = [], r = 2; r < arguments.length; r++)\n      n[r - 2] = arguments[r];\n    return setTimeout.apply(void 0, be([e, t], de(n)));\n  },\n  clearTimeout: function(e) {\n    return clearTimeout(e);\n  },\n  delegate: void 0\n};\nfunction dn(e) {\n  Zr.setTimeout(function() {\n    throw e;\n  });\n}\nfunction We() {\n}\nfunction Re(e) {\n  e();\n}\nvar gt = (function(e) {\n  ne(t, e);\n  function t(n) {\n    var r = e.call(this) || this;\n    return r.isStopped = !1, n ? (r.destination = n, fn(n) && n.add(r)) : r.destination = ni, r;\n  }\n  return t.create = function(n, r, i) {\n    return new Pe(n, r, i);\n  }, t.prototype.next = function(n) {\n    this.isStopped || this._next(n);\n  }, t.prototype.error = function(n) {\n    this.isStopped || (this.isStopped = !0, this._error(n));\n  }, t.prototype.complete = function() {\n    this.isStopped || (this.isStopped = !0, this._complete());\n  }, t.prototype.unsubscribe = function() {\n    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);\n  }, t.prototype._next = function(n) {\n    this.destination.next(n);\n  }, t.prototype._error = function(n) {\n    try {\n      this.destination.error(n);\n    } finally {\n      this.unsubscribe();\n    }\n  }, t.prototype._complete = function() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }, t;\n})(ke), ei = (function() {\n  function e(t) {\n    this.partialObserver = t;\n  }\n  return e.prototype.next = function(t) {\n    var n = this.partialObserver;\n    if (n.next)\n      try {\n        n.next(t);\n      } catch (r) {\n        Le(r);\n      }\n  }, e.prototype.error = function(t) {\n    var n = this.partialObserver;\n    if (n.error)\n      try {\n        n.error(t);\n      } catch (r) {\n        Le(r);\n      }\n    else\n      Le(t);\n  }, e.prototype.complete = function() {\n    var t = this.partialObserver;\n    if (t.complete)\n      try {\n        t.complete();\n      } catch (n) {\n        Le(n);\n      }\n  }, e;\n})(), Pe = (function(e) {\n  ne(t, e);\n  function t(n, r, i) {\n    var o = e.call(this) || this, s;\n    return P(n) || !n ? s = {\n      next: n ?? void 0,\n      error: r ?? void 0,\n      complete: i ?? void 0\n    } : s = n, o.destination = new ei(s), o;\n  }\n  return t;\n})(gt);\nfunction Le(e) {\n  dn(e);\n}\nfunction ti(e) {\n  throw e;\n}\nvar ni = {\n  closed: !0,\n  next: We,\n  error: ti,\n  complete: We\n}, bt = (function() {\n  return typeof Symbol == \"function\" && Symbol.observable || \"@@observable\";\n})();\nfunction Qe(e) {\n  return e;\n}\nfunction ri(e) {\n  return e.length === 0 ? Qe : e.length === 1 ? e[0] : function(n) {\n    return e.reduce(function(r, i) {\n      return i(r);\n    }, n);\n  };\n}\nvar k = (function() {\n  function e(t) {\n    t && (this._subscribe = t);\n  }\n  return e.prototype.lift = function(t) {\n    var n = new e();\n    return n.source = this, n.operator = t, n;\n  }, e.prototype.subscribe = function(t, n, r) {\n    var i = this, o = oi(t) ? t : new Pe(t, n, r);\n    return Re(function() {\n      var s = i, a = s.operator, c = s.source;\n      o.add(a ? a.call(o, c) : c ? i._subscribe(o) : i._trySubscribe(o));\n    }), o;\n  }, e.prototype._trySubscribe = function(t) {\n    try {\n      return this._subscribe(t);\n    } catch (n) {\n      t.error(n);\n    }\n  }, e.prototype.forEach = function(t, n) {\n    var r = this;\n    return n = Rt(n), new n(function(i, o) {\n      var s = new Pe({\n        next: function(a) {\n          try {\n            t(a);\n          } catch (c) {\n            o(c), s.unsubscribe();\n          }\n        },\n        error: o,\n        complete: i\n      });\n      r.subscribe(s);\n    });\n  }, e.prototype._subscribe = function(t) {\n    var n;\n    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);\n  }, e.prototype[bt] = function() {\n    return this;\n  }, e.prototype.pipe = function() {\n    for (var t = [], n = 0; n < arguments.length; n++)\n      t[n] = arguments[n];\n    return ri(t)(this);\n  }, e.prototype.toPromise = function(t) {\n    var n = this;\n    return t = Rt(t), new t(function(r, i) {\n      var o;\n      n.subscribe(function(s) {\n        return o = s;\n      }, function(s) {\n        return i(s);\n      }, function() {\n        return r(o);\n      });\n    });\n  }, e.create = function(t) {\n    return new e(t);\n  }, e;\n})();\nfunction Rt(e) {\n  var t;\n  return (t = e ?? Xr.Promise) !== null && t !== void 0 ? t : Promise;\n}\nfunction ii(e) {\n  return e && P(e.next) && P(e.error) && P(e.complete);\n}\nfunction oi(e) {\n  return e && e instanceof gt || ii(e) && fn(e);\n}\nfunction si(e) {\n  return P(e == null ? void 0 : e.lift);\n}\nfunction W(e) {\n  return function(t) {\n    if (si(t))\n      return t.lift(function(n) {\n        try {\n          return e(n, this);\n        } catch (r) {\n          this.error(r);\n        }\n      });\n    throw new TypeError(\"Unable to lift unknown Observable type\");\n  };\n}\nfunction F(e, t, n, r, i) {\n  return new ai(e, t, n, r, i);\n}\nvar ai = (function(e) {\n  ne(t, e);\n  function t(n, r, i, o, s, a) {\n    var c = e.call(this, n) || this;\n    return c.onFinalize = s, c.shouldUnsubscribe = a, c._next = r ? function(u) {\n      try {\n        r(u);\n      } catch (l) {\n        n.error(l);\n      }\n    } : e.prototype._next, c._error = o ? function(u) {\n      try {\n        o(u);\n      } catch (l) {\n        n.error(l);\n      } finally {\n        this.unsubscribe();\n      }\n    } : e.prototype._error, c._complete = i ? function() {\n      try {\n        i();\n      } catch (u) {\n        n.error(u);\n      } finally {\n        this.unsubscribe();\n      }\n    } : e.prototype._complete, c;\n  }\n  return t.prototype.unsubscribe = function() {\n    var n;\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      var r = this.closed;\n      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));\n    }\n  }, t;\n})(gt), ci = mt(function(e) {\n  return function() {\n    e(this), this.name = \"ObjectUnsubscribedError\", this.message = \"object unsubscribed\";\n  };\n}), te = (function(e) {\n  ne(t, e);\n  function t() {\n    var n = e.call(this) || this;\n    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;\n  }\n  return t.prototype.lift = function(n) {\n    var r = new Dt(this, this);\n    return r.operator = n, r;\n  }, t.prototype._throwIfClosed = function() {\n    if (this.closed)\n      throw new ci();\n  }, t.prototype.next = function(n) {\n    var r = this;\n    Re(function() {\n      var i, o;\n      if (r._throwIfClosed(), !r.isStopped) {\n        r.currentObservers || (r.currentObservers = Array.from(r.observers));\n        try {\n          for (var s = ge(r.currentObservers), a = s.next(); !a.done; a = s.next()) {\n            var c = a.value;\n            c.next(n);\n          }\n        } catch (u) {\n          i = { error: u };\n        } finally {\n          try {\n            a && !a.done && (o = s.return) && o.call(s);\n          } finally {\n            if (i) throw i.error;\n          }\n        }\n      }\n    });\n  }, t.prototype.error = function(n) {\n    var r = this;\n    Re(function() {\n      if (r._throwIfClosed(), !r.isStopped) {\n        r.hasError = r.isStopped = !0, r.thrownError = n;\n        for (var i = r.observers; i.length; )\n          i.shift().error(n);\n      }\n    });\n  }, t.prototype.complete = function() {\n    var n = this;\n    Re(function() {\n      if (n._throwIfClosed(), !n.isStopped) {\n        n.isStopped = !0;\n        for (var r = n.observers; r.length; )\n          r.shift().complete();\n      }\n    });\n  }, t.prototype.unsubscribe = function() {\n    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;\n  }, Object.defineProperty(t.prototype, \"observed\", {\n    get: function() {\n      var n;\n      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._trySubscribe = function(n) {\n    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);\n  }, t.prototype._subscribe = function(n) {\n    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);\n  }, t.prototype._innerSubscribe = function(n) {\n    var r = this, i = this, o = i.hasError, s = i.isStopped, a = i.observers;\n    return o || s ? ln : (this.currentObservers = null, a.push(n), new ke(function() {\n      r.currentObservers = null, Ue(a, n);\n    }));\n  }, t.prototype._checkFinalizedStatuses = function(n) {\n    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;\n    i ? n.error(o) : s && n.complete();\n  }, t.prototype.asObservable = function() {\n    var n = new k();\n    return n.source = this, n;\n  }, t.create = function(n, r) {\n    return new Dt(n, r);\n  }, t;\n})(k), Dt = (function(e) {\n  ne(t, e);\n  function t(n, r) {\n    var i = e.call(this) || this;\n    return i.destination = n, i.source = r, i;\n  }\n  return t.prototype.next = function(n) {\n    var r, i;\n    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);\n  }, t.prototype.error = function(n) {\n    var r, i;\n    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);\n  }, t.prototype.complete = function() {\n    var n, r;\n    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);\n  }, t.prototype._subscribe = function(n) {\n    var r, i;\n    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : ln;\n  }, t;\n})(te), pn = (function(e) {\n  ne(t, e);\n  function t(n) {\n    var r = e.call(this) || this;\n    return r._value = n, r;\n  }\n  return Object.defineProperty(t.prototype, \"value\", {\n    get: function() {\n      return this.getValue();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._subscribe = function(n) {\n    var r = e.prototype._subscribe.call(this, n);\n    return !r.closed && n.next(this._value), r;\n  }, t.prototype.getValue = function() {\n    var n = this, r = n.hasError, i = n.thrownError, o = n._value;\n    if (r)\n      throw i;\n    return this._throwIfClosed(), o;\n  }, t.prototype.next = function(n) {\n    e.prototype.next.call(this, this._value = n);\n  }, t;\n})(te), ui = {\n  now: function() {\n    return Date.now();\n  }\n}, li = (function(e) {\n  ne(t, e);\n  function t(n, r) {\n    return e.call(this) || this;\n  }\n  return t.prototype.schedule = function(n, r) {\n    return this;\n  }, t;\n})(ke), $t = {\n  setInterval: function(e, t) {\n    for (var n = [], r = 2; r < arguments.length; r++)\n      n[r - 2] = arguments[r];\n    return setInterval.apply(void 0, be([e, t], de(n)));\n  },\n  clearInterval: function(e) {\n    return clearInterval(e);\n  },\n  delegate: void 0\n}, fi = (function(e) {\n  ne(t, e);\n  function t(n, r) {\n    var i = e.call(this, n, r) || this;\n    return i.scheduler = n, i.work = r, i.pending = !1, i;\n  }\n  return t.prototype.schedule = function(n, r) {\n    var i;\n    if (r === void 0 && (r = 0), this.closed)\n      return this;\n    this.state = n;\n    var o = this.id, s = this.scheduler;\n    return o != null && (this.id = this.recycleAsyncId(s, o, r)), this.pending = !0, this.delay = r, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(s, this.id, r), this;\n  }, t.prototype.requestAsyncId = function(n, r, i) {\n    return i === void 0 && (i = 0), $t.setInterval(n.flush.bind(n, this), i);\n  }, t.prototype.recycleAsyncId = function(n, r, i) {\n    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)\n      return r;\n    r != null && $t.clearInterval(r);\n  }, t.prototype.execute = function(n, r) {\n    if (this.closed)\n      return new Error(\"executing a cancelled action\");\n    this.pending = !1;\n    var i = this._execute(n, r);\n    if (i)\n      return i;\n    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));\n  }, t.prototype._execute = function(n, r) {\n    var i = !1, o;\n    try {\n      this.work(n);\n    } catch (s) {\n      i = !0, o = s || new Error(\"Scheduled action threw falsy error\");\n    }\n    if (i)\n      return this.unsubscribe(), o;\n  }, t.prototype.unsubscribe = function() {\n    if (!this.closed) {\n      var n = this, r = n.id, i = n.scheduler, o = i.actions;\n      this.work = this.state = this.scheduler = null, this.pending = !1, Ue(o, this), r != null && (this.id = this.recycleAsyncId(i, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);\n    }\n  }, t;\n})(li), Nt = (function() {\n  function e(t, n) {\n    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;\n  }\n  return e.prototype.schedule = function(t, n, r) {\n    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);\n  }, e.now = ui.now, e;\n})(), di = (function(e) {\n  ne(t, e);\n  function t(n, r) {\n    r === void 0 && (r = Nt.now);\n    var i = e.call(this, n, r) || this;\n    return i.actions = [], i._active = !1, i;\n  }\n  return t.prototype.flush = function(n) {\n    var r = this.actions;\n    if (this._active) {\n      r.push(n);\n      return;\n    }\n    var i;\n    this._active = !0;\n    do\n      if (i = n.execute(n.state, n.delay))\n        break;\n    while (n = r.shift());\n    if (this._active = !1, i) {\n      for (; n = r.shift(); )\n        n.unsubscribe();\n      throw i;\n    }\n  }, t;\n})(Nt), pi = new di(fi);\nfunction hi(e) {\n  return e && P(e.schedule);\n}\nfunction vi(e) {\n  return e[e.length - 1];\n}\nfunction yt(e) {\n  return hi(vi(e)) ? e.pop() : void 0;\n}\nvar wt = (function(e) {\n  return e && typeof e.length == \"number\" && typeof e != \"function\";\n});\nfunction hn(e) {\n  return P(e == null ? void 0 : e.then);\n}\nfunction vn(e) {\n  return P(e[bt]);\n}\nfunction mn(e) {\n  return Symbol.asyncIterator && P(e == null ? void 0 : e[Symbol.asyncIterator]);\n}\nfunction gn(e) {\n  return new TypeError(\"You provided \" + (e !== null && typeof e == \"object\" ? \"an invalid object\" : \"'\" + e + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\nfunction mi() {\n  return typeof Symbol != \"function\" || !Symbol.iterator ? \"@@iterator\" : Symbol.iterator;\n}\nvar bn = mi();\nfunction yn(e) {\n  return P(e == null ? void 0 : e[bn]);\n}\nfunction wn(e) {\n  return Qr(this, arguments, function() {\n    var n, r, i, o;\n    return un(this, function(s) {\n      switch (s.label) {\n        case 0:\n          n = e.getReader(), s.label = 1;\n        case 1:\n          s.trys.push([1, , 9, 10]), s.label = 2;\n        case 2:\n          return [4, ve(n.read())];\n        case 3:\n          return r = s.sent(), i = r.value, o = r.done, o ? [4, ve(void 0)] : [3, 5];\n        case 4:\n          return [2, s.sent()];\n        case 5:\n          return [4, ve(i)];\n        case 6:\n          return [4, s.sent()];\n        case 7:\n          return s.sent(), [3, 2];\n        case 8:\n          return [3, 10];\n        case 9:\n          return n.releaseLock(), [7];\n        case 10:\n          return [2];\n      }\n    });\n  });\n}\nfunction xn(e) {\n  return P(e == null ? void 0 : e.getReader);\n}\nfunction z(e) {\n  if (e instanceof k)\n    return e;\n  if (e != null) {\n    if (vn(e))\n      return gi(e);\n    if (wt(e))\n      return bi(e);\n    if (hn(e))\n      return yi(e);\n    if (mn(e))\n      return Sn(e);\n    if (yn(e))\n      return wi(e);\n    if (xn(e))\n      return xi(e);\n  }\n  throw gn(e);\n}\nfunction gi(e) {\n  return new k(function(t) {\n    var n = e[bt]();\n    if (P(n.subscribe))\n      return n.subscribe(t);\n    throw new TypeError(\"Provided object does not correctly implement Symbol.observable\");\n  });\n}\nfunction bi(e) {\n  return new k(function(t) {\n    for (var n = 0; n < e.length && !t.closed; n++)\n      t.next(e[n]);\n    t.complete();\n  });\n}\nfunction yi(e) {\n  return new k(function(t) {\n    e.then(function(n) {\n      t.closed || (t.next(n), t.complete());\n    }, function(n) {\n      return t.error(n);\n    }).then(null, dn);\n  });\n}\nfunction wi(e) {\n  return new k(function(t) {\n    var n, r;\n    try {\n      for (var i = ge(e), o = i.next(); !o.done; o = i.next()) {\n        var s = o.value;\n        if (t.next(s), t.closed)\n          return;\n      }\n    } catch (a) {\n      n = { error: a };\n    } finally {\n      try {\n        o && !o.done && (r = i.return) && r.call(i);\n      } finally {\n        if (n) throw n.error;\n      }\n    }\n    t.complete();\n  });\n}\nfunction Sn(e) {\n  return new k(function(t) {\n    Si(e, t).catch(function(n) {\n      return t.error(n);\n    });\n  });\n}\nfunction xi(e) {\n  return Sn(wn(e));\n}\nfunction Si(e, t) {\n  var n, r, i, o;\n  return Gr(this, void 0, void 0, function() {\n    var s, a;\n    return un(this, function(c) {\n      switch (c.label) {\n        case 0:\n          c.trys.push([0, 5, 6, 11]), n = Jr(e), c.label = 1;\n        case 1:\n          return [4, n.next()];\n        case 2:\n          if (r = c.sent(), !!r.done) return [3, 4];\n          if (s = r.value, t.next(s), t.closed)\n            return [2];\n          c.label = 3;\n        case 3:\n          return [3, 1];\n        case 4:\n          return [3, 11];\n        case 5:\n          return a = c.sent(), i = { error: a }, [3, 11];\n        case 6:\n          return c.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8];\n        case 7:\n          c.sent(), c.label = 8;\n        case 8:\n          return [3, 10];\n        case 9:\n          if (i) throw i.error;\n          return [7];\n        case 10:\n          return [7];\n        case 11:\n          return t.complete(), [2];\n      }\n    });\n  });\n}\nfunction oe(e, t, n, r, i) {\n  r === void 0 && (r = 0), i === void 0 && (i = !1);\n  var o = t.schedule(function() {\n    n(), i ? e.add(this.schedule(null, r)) : this.unsubscribe();\n  }, r);\n  if (e.add(o), !i)\n    return o;\n}\nfunction Tn(e, t) {\n  return t === void 0 && (t = 0), W(function(n, r) {\n    n.subscribe(F(r, function(i) {\n      return oe(r, e, function() {\n        return r.next(i);\n      }, t);\n    }, function() {\n      return oe(r, e, function() {\n        return r.complete();\n      }, t);\n    }, function(i) {\n      return oe(r, e, function() {\n        return r.error(i);\n      }, t);\n    }));\n  });\n}\nfunction En(e, t) {\n  return t === void 0 && (t = 0), W(function(n, r) {\n    r.add(e.schedule(function() {\n      return n.subscribe(r);\n    }, t));\n  });\n}\nfunction Ti(e, t) {\n  return z(e).pipe(En(t), Tn(t));\n}\nfunction Ei(e, t) {\n  return z(e).pipe(En(t), Tn(t));\n}\nfunction Ci(e, t) {\n  return new k(function(n) {\n    var r = 0;\n    return t.schedule(function() {\n      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());\n    });\n  });\n}\nfunction Pi(e, t) {\n  return new k(function(n) {\n    var r;\n    return oe(n, t, function() {\n      r = e[bn](), oe(n, t, function() {\n        var i, o, s;\n        try {\n          i = r.next(), o = i.value, s = i.done;\n        } catch (a) {\n          n.error(a);\n          return;\n        }\n        s ? n.complete() : n.next(o);\n      }, 0, !0);\n    }), function() {\n      return P(r == null ? void 0 : r.return) && r.return();\n    };\n  });\n}\nfunction Cn(e, t) {\n  if (!e)\n    throw new Error(\"Iterable cannot be null\");\n  return new k(function(n) {\n    oe(n, t, function() {\n      var r = e[Symbol.asyncIterator]();\n      oe(n, t, function() {\n        r.next().then(function(i) {\n          i.done ? n.complete() : n.next(i.value);\n        });\n      }, 0, !0);\n    });\n  });\n}\nfunction Oi(e, t) {\n  return Cn(wn(e), t);\n}\nfunction Ai(e, t) {\n  if (e != null) {\n    if (vn(e))\n      return Ti(e, t);\n    if (wt(e))\n      return Ci(e, t);\n    if (hn(e))\n      return Ei(e, t);\n    if (mn(e))\n      return Cn(e, t);\n    if (yn(e))\n      return Pi(e, t);\n    if (xn(e))\n      return Oi(e, t);\n  }\n  throw gn(e);\n}\nfunction Je(e, t) {\n  return t ? Ai(e, t) : z(e);\n}\nfunction Ft() {\n  for (var e = [], t = 0; t < arguments.length; t++)\n    e[t] = arguments[t];\n  var n = yt(e);\n  return Je(e, n);\n}\nfunction ki(e) {\n  return e instanceof Date && !isNaN(e);\n}\nvar _i = mt(function(e) {\n  return function(n) {\n    n === void 0 && (n = null), e(this), this.message = \"Timeout has occurred\", this.name = \"TimeoutError\", this.info = n;\n  };\n});\nfunction Li(e, t) {\n  var n = ki(e) ? { first: e } : typeof e == \"number\" ? { each: e } : e, r = n.first, i = n.each, o = n.with, s = o === void 0 ? Ii : o, a = n.scheduler, c = a === void 0 ? pi : a, u = n.meta, l = u === void 0 ? null : u;\n  if (r == null && i == null)\n    throw new TypeError(\"No timeout provided.\");\n  return W(function(f, v) {\n    var d, m, p = null, g = 0, h = function(x) {\n      m = oe(v, c, function() {\n        try {\n          d.unsubscribe(), z(s({\n            meta: l,\n            lastValue: p,\n            seen: g\n          })).subscribe(v);\n        } catch (E) {\n          v.error(E);\n        }\n      }, x);\n    };\n    d = f.subscribe(F(v, function(x) {\n      m == null || m.unsubscribe(), g++, v.next(p = x), i > 0 && h(i);\n    }, void 0, void 0, function() {\n      m != null && m.closed || m == null || m.unsubscribe(), p = null;\n    })), !g && h(r != null ? typeof r == \"number\" ? r : +r - c.now() : i);\n  });\n}\nfunction Ii(e) {\n  throw new _i(e);\n}\nfunction A(e, t) {\n  return W(function(n, r) {\n    var i = 0;\n    n.subscribe(F(r, function(o) {\n      r.next(e.call(t, o, i++));\n    }));\n  });\n}\nvar Mi = Array.isArray;\nfunction Ri(e, t) {\n  return Mi(t) ? e.apply(void 0, be([], de(t))) : e(t);\n}\nfunction Di(e) {\n  return A(function(t) {\n    return Ri(e, t);\n  });\n}\nfunction $i(e, t, n, r, i, o, s, a) {\n  var c = [], u = 0, l = 0, f = !1, v = function() {\n    f && !c.length && !u && t.complete();\n  }, d = function(p) {\n    return u < r ? m(p) : c.push(p);\n  }, m = function(p) {\n    u++;\n    var g = !1;\n    z(n(p, l++)).subscribe(F(t, function(h) {\n      t.next(h);\n    }, function() {\n      g = !0;\n    }, void 0, function() {\n      if (g)\n        try {\n          u--;\n          for (var h = function() {\n            var x = c.shift();\n            s || m(x);\n          }; c.length && u < r; )\n            h();\n          v();\n        } catch (x) {\n          t.error(x);\n        }\n    }));\n  };\n  return e.subscribe(F(t, d, function() {\n    f = !0, v();\n  })), function() {\n  };\n}\nfunction xt(e, t, n) {\n  return n === void 0 && (n = 1 / 0), P(t) ? xt(function(r, i) {\n    return A(function(o, s) {\n      return t(r, o, i, s);\n    })(z(e(r, i)));\n  }, n) : (typeof t == \"number\" && (n = t), W(function(r, i) {\n    return $i(r, i, e, n);\n  }));\n}\nfunction Ni(e) {\n  return xt(Qe, e);\n}\nfunction Fi() {\n  return Ni(1);\n}\nfunction je() {\n  for (var e = [], t = 0; t < arguments.length; t++)\n    e[t] = arguments[t];\n  return Fi()(Je(e, yt(e)));\n}\nvar Ui = [\"addListener\", \"removeListener\"], Wi = [\"addEventListener\", \"removeEventListener\"], ji = [\"on\", \"off\"];\nfunction ut(e, t, n, r) {\n  if (P(n) && (r = n, n = void 0), r)\n    return ut(e, t, n).pipe(Di(r));\n  var i = de(Hi(e) ? Wi.map(function(a) {\n    return function(c) {\n      return e[a](t, c, n);\n    };\n  }) : Bi(e) ? Ui.map(Ut(e, t)) : Vi(e) ? ji.map(Ut(e, t)) : [], 2), o = i[0], s = i[1];\n  if (!o && wt(e))\n    return xt(function(a) {\n      return ut(a, t, n);\n    })(z(e));\n  if (!o)\n    throw new TypeError(\"Invalid event target\");\n  return new k(function(a) {\n    var c = function() {\n      for (var u = [], l = 0; l < arguments.length; l++)\n        u[l] = arguments[l];\n      return a.next(1 < u.length ? u : u[0]);\n    };\n    return o(c), function() {\n      return s(c);\n    };\n  });\n}\nfunction Ut(e, t) {\n  return function(n) {\n    return function(r) {\n      return e[n](t, r);\n    };\n  };\n}\nfunction Bi(e) {\n  return P(e.addListener) && P(e.removeListener);\n}\nfunction Vi(e) {\n  return P(e.on) && P(e.off);\n}\nfunction Hi(e) {\n  return P(e.addEventListener) && P(e.removeEventListener);\n}\nfunction Xe(e, t) {\n  return W(function(n, r) {\n    var i = 0;\n    n.subscribe(F(r, function(o) {\n      return e.call(t, o, i++) && r.next(o);\n    }));\n  });\n}\nfunction zi(e, t, n, r, i) {\n  return function(o, s) {\n    var a = n, c = t, u = 0;\n    o.subscribe(F(s, function(l) {\n      var f = u++;\n      c = a ? e(c, l, f) : (a = !0, l), s.next(c);\n    }, i));\n  };\n}\nfunction Yi(e, t) {\n  return t === void 0 && (t = Qe), e = e ?? qi, W(function(n, r) {\n    var i, o = !0;\n    n.subscribe(F(r, function(s) {\n      var a = t(s);\n      (o || !e(i, a)) && (o = !1, i = a, r.next(s));\n    }));\n  });\n}\nfunction qi(e, t) {\n  return e === t;\n}\nfunction lt(e, t) {\n  return W(zi(e, t, arguments.length >= 2, !0));\n}\nfunction Ki(e) {\n  e === void 0 && (e = {});\n  var t = e.connector, n = t === void 0 ? function() {\n    return new te();\n  } : t, r = e.resetOnError, i = r === void 0 ? !0 : r, o = e.resetOnComplete, s = o === void 0 ? !0 : o, a = e.resetOnRefCountZero, c = a === void 0 ? !0 : a;\n  return function(u) {\n    var l, f, v, d = 0, m = !1, p = !1, g = function() {\n      f == null || f.unsubscribe(), f = void 0;\n    }, h = function() {\n      g(), l = v = void 0, m = p = !1;\n    }, x = function() {\n      var E = l;\n      h(), E == null || E.unsubscribe();\n    };\n    return W(function(E, O) {\n      d++, !p && !m && g();\n      var b = v = v ?? n();\n      O.add(function() {\n        d--, d === 0 && !p && !m && (f = nt(x, c));\n      }), b.subscribe(O), !l && d > 0 && (l = new Pe({\n        next: function(S) {\n          return b.next(S);\n        },\n        error: function(S) {\n          p = !0, g(), f = nt(h, i, S), b.error(S);\n        },\n        complete: function() {\n          m = !0, g(), f = nt(h, s), b.complete();\n        }\n      }), z(E).subscribe(l));\n    })(u);\n  };\n}\nfunction nt(e, t) {\n  for (var n = [], r = 2; r < arguments.length; r++)\n    n[r - 2] = arguments[r];\n  if (t === !0) {\n    e();\n    return;\n  }\n  if (t !== !1) {\n    var i = new Pe({\n      next: function() {\n        i.unsubscribe(), e();\n      }\n    });\n    return z(t.apply(void 0, be([], de(n)))).subscribe(i);\n  }\n}\nfunction Gi(e) {\n  return W(function(t, n) {\n    var r = !1, i = F(n, function() {\n      i == null || i.unsubscribe(), r = !0;\n    }, We);\n    z(e).subscribe(i), t.subscribe(F(n, function(o) {\n      return r && n.next(o);\n    }));\n  });\n}\nfunction D() {\n  for (var e = [], t = 0; t < arguments.length; t++)\n    e[t] = arguments[t];\n  var n = yt(e);\n  return W(function(r, i) {\n    (n ? je(e, r, n) : je(e, r)).subscribe(i);\n  });\n}\nfunction Pn(e, t) {\n  return W(function(n, r) {\n    var i = null, o = 0, s = !1, a = function() {\n      return s && !i && r.complete();\n    };\n    n.subscribe(F(r, function(c) {\n      i == null || i.unsubscribe();\n      var u = 0, l = o++;\n      z(e(c, l)).subscribe(i = F(r, function(f) {\n        return r.next(t ? t(c, f, l, u++) : f);\n      }, function() {\n        i = null, a();\n      }));\n    }, function() {\n      s = !0, a();\n    }));\n  });\n}\nfunction Wt(e) {\n  return W(function(t, n) {\n    z(e).subscribe(F(n, function() {\n      return n.complete();\n    }, We)), !n.closed && t.subscribe(n);\n  });\n}\nfunction Qi(e, t, n) {\n  var r = P(e) || t || n ? { next: e, error: t, complete: n } : e;\n  return r ? W(function(i, o) {\n    var s;\n    (s = r.subscribe) === null || s === void 0 || s.call(r);\n    var a = !0;\n    i.subscribe(F(o, function(c) {\n      var u;\n      (u = r.next) === null || u === void 0 || u.call(r, c), o.next(c);\n    }, function() {\n      var c;\n      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), o.complete();\n    }, function(c) {\n      var u;\n      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), o.error(c);\n    }, function() {\n      var c, u;\n      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);\n    }));\n  }) : Qe;\n}\nvar Ji = Object.defineProperty, Xi = Object.defineProperties, Zi = Object.getOwnPropertyDescriptors, jt = Object.getOwnPropertySymbols, eo = Object.prototype.hasOwnProperty, to = Object.prototype.propertyIsEnumerable, Bt = (e, t, n) => t in e ? Ji(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, q = (e, t) => {\n  for (var n in t || (t = {}))\n    eo.call(t, n) && Bt(e, n, t[n]);\n  if (jt)\n    for (var n of jt(t))\n      to.call(t, n) && Bt(e, n, t[n]);\n  return e;\n}, ce = (e, t) => Xi(e, Zi(t)), H = (e, t, n) => new Promise((r, i) => {\n  var o = (c) => {\n    try {\n      a(n.next(c));\n    } catch (u) {\n      i(u);\n    }\n  }, s = (c) => {\n    try {\n      a(n.throw(c));\n    } catch (u) {\n      i(u);\n    }\n  }, a = (c) => c.done ? r(c.value) : Promise.resolve(c.value).then(o, s);\n  a((n = n.apply(e, t)).next());\n}), On = \"lk\";\nfunction B(e) {\n  return typeof e > \"u\" ? !1 : no(e) || ro(e);\n}\nfunction no(e) {\n  var t;\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && e.hasOwnProperty(\"track\") && typeof ((t = e.publication) == null ? void 0 : t.track) < \"u\" : !1;\n}\nfunction ro(e) {\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && e.hasOwnProperty(\"publication\") && typeof e.publication < \"u\" : !1;\n}\nfunction Oe(e) {\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && typeof e.publication > \"u\" : !1;\n}\nfunction N(e) {\n  if (typeof e == \"string\" || typeof e == \"number\")\n    return `${e}`;\n  if (Oe(e))\n    return `${e.participant.identity}_${e.source}_placeholder`;\n  if (B(e))\n    return `${e.participant.identity}_${e.publication.source}_${e.publication.trackSid}`;\n  throw new Error(`Can't generate a id for the given track reference: ${e}`);\n}\nfunction ts(e, t) {\n  return e === void 0 || t === void 0 ? !1 : B(e) && B(t) ? e.publication.trackSid === t.publication.trackSid : N(e) === N(t);\n}\nfunction ns(e, t) {\n  return typeof t > \"u\" ? !1 : B(e) ? t.some(\n    (n) => n.participant.identity === e.participant.identity && B(n) && n.publication.trackSid === e.publication.trackSid\n  ) : Oe(e) ? t.some(\n    (n) => n.participant.identity === e.participant.identity && Oe(n) && n.source === e.source\n  ) : !1;\n}\nfunction io(e, t) {\n  return Oe(e) && B(t) && t.participant.identity === e.participant.identity && t.source === e.source;\n}\nfunction rs() {\n  const e = document.createElement(\"p\");\n  e.style.width = \"100%\", e.style.height = \"200px\";\n  const t = document.createElement(\"div\");\n  t.style.position = \"absolute\", t.style.top = \"0px\", t.style.left = \"0px\", t.style.visibility = \"hidden\", t.style.width = \"200px\", t.style.height = \"150px\", t.style.overflow = \"hidden\", t.appendChild(e), document.body.appendChild(t);\n  const n = e.offsetWidth;\n  t.style.overflow = \"scroll\";\n  let r = e.offsetWidth;\n  return n === r && (r = t.clientWidth), document.body.removeChild(t), n - r;\n}\nfunction is() {\n  return typeof document < \"u\";\n}\nfunction oo(e) {\n  e = q({}, e);\n  const t = \"(?:(?:[a-z]+:)?//)?\", n = \"(?:\\\\S+(?::\\\\S*)?@)?\", r = new RegExp(\n    \"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\",\n    \"g\"\n  ).source, u = `(?:${t}|www\\\\.)${n}(?:localhost|${r}|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?)(?::\\\\d{2,5})?(?:[/?#][^\\\\s\"]*)?`;\n  return e.exact ? new RegExp(`(?:^${u}$)`, \"i\") : new RegExp(u, \"ig\");\n}\nvar Vt = \"[^\\\\.\\\\s@:](?:[^\\\\s@:]*[^\\\\s@:\\\\.])?@[^\\\\.\\\\s@]+(?:\\\\.[^\\\\.\\\\s@]+)*\";\nfunction so({ exact: e } = {}) {\n  return e ? new RegExp(`^${Vt}$`) : new RegExp(Vt, \"g\");\n}\nfunction os(e, t, n) {\n  return Ur(e, t, () => H(this, null, function* () {\n    const { x: i, y: o } = yield Vr(e, t, {\n      placement: \"top\",\n      middleware: [Wr(6), Br(), jr({ padding: 5 })]\n    });\n    n == null || n(i, o);\n  }));\n}\nfunction ss(e, t) {\n  return !e.contains(t.target);\n}\nvar as = () => ({\n  email: so(),\n  url: oo({})\n});\nfunction cs(e, t) {\n  const n = Object.entries(t).map(\n    ([o, s], a) => Array.from(e.matchAll(s)).map(({ index: c, 0: u }) => ({\n      type: o,\n      weight: a,\n      content: u,\n      index: c ?? 0\n    }))\n  ).flat().sort((o, s) => {\n    const a = o.index - s.index;\n    return a !== 0 ? a : o.weight - s.weight;\n  }).filter(({ index: o }, s, a) => {\n    if (s === 0) return !0;\n    const c = a[s - 1];\n    return c.index + c.content.length <= o;\n  }), r = [];\n  let i = 0;\n  for (const { type: o, content: s, index: a } of n)\n    a > i && r.push(e.substring(i, a)), r.push({ type: o, content: s }), i = a + s.length;\n  return e.length > i && r.push(e.substring(i)), r;\n}\nvar ao = [\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RoomMetadataChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveSpeakersChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionQualityChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantPermissionsChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantMetadataChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantNameChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantAttributesChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackMuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnmuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnpublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackStreamStateChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionFailed,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionPermissionChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionStatusChanged\n], An = [\n  ...ao,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackUnpublished\n], co = [\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackStreamStateChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscribed,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnsubscribed,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionPermissionChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionFailed,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\n], uo = [\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ConnectionQualityChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.IsSpeakingChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantMetadataChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackStreamStateChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionFailed,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionPermissionChanged,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionStatusChanged\n], kn = [\n  ...uo,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\n], L = Kr.getLogger(\"lk-components-js\");\nL.setDefaultLevel(\"WARN\");\nfunction us(e, t = {}) {\n  var n;\n  L.setLevel(e), (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)((n = t.liveKitClientLogLevel) != null ? n : e);\n}\nfunction ls(e, t = {}) {\n  var n;\n  const r = L.methodFactory;\n  L.methodFactory = (i, o, s) => {\n    const a = r(i, o, s), c = livekit_client__WEBPACK_IMPORTED_MODULE_0__.LogLevel[i], u = c >= o && c < livekit_client__WEBPACK_IMPORTED_MODULE_0__.LogLevel.silent;\n    return (l, f) => {\n      f ? a(l, f) : a(l), u && e(c, l, f);\n    };\n  }, L.setLevel(L.getLevel()), (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.setLogExtension)((n = t.liveKitClientLogExtension) != null ? n : e);\n}\nvar fs = [\n  {\n    columns: 1,\n    rows: 1\n  },\n  {\n    columns: 1,\n    rows: 2,\n    orientation: \"portrait\"\n  },\n  {\n    columns: 2,\n    rows: 1,\n    orientation: \"landscape\"\n  },\n  {\n    columns: 2,\n    rows: 2,\n    minWidth: 560\n  },\n  {\n    columns: 3,\n    rows: 3,\n    minWidth: 700\n  },\n  {\n    columns: 4,\n    rows: 4,\n    minWidth: 960\n  },\n  {\n    columns: 5,\n    rows: 5,\n    minWidth: 1100\n  }\n];\nfunction lo(e, t, n, r) {\n  if (e.length < 1)\n    throw new Error(\"At least one grid layout definition must be provided.\");\n  const i = fo(e);\n  if (n <= 0 || r <= 0)\n    return i[0];\n  let o = 0;\n  const s = n / r > 1 ? \"landscape\" : \"portrait\";\n  let a = i.find((c, u, l) => {\n    o = u;\n    const f = l.findIndex((v, d) => {\n      const m = !v.orientation || v.orientation === s, p = d > u, g = v.maxTiles === c.maxTiles;\n      return p && g && m;\n    }) !== -1;\n    return c.maxTiles >= t && !f;\n  });\n  if (a === void 0)\n    if (a = i[i.length - 1], a)\n      L.warn(\n        `No layout found for: participantCount: ${t}, width/height: ${n}/${r} fallback to biggest available layout (${a}).`\n      );\n    else\n      throw new Error(\"No layout or fallback layout found.\");\n  if ((n < a.minWidth || r < a.minHeight) && o > 0) {\n    const c = i[o - 1];\n    a = lo(\n      i.slice(0, o),\n      c.maxTiles,\n      n,\n      r\n    );\n  }\n  return a;\n}\nfunction fo(e) {\n  return [...e].map((t) => {\n    var n, r;\n    return {\n      name: `${t.columns}x${t.rows}`,\n      columns: t.columns,\n      rows: t.rows,\n      maxTiles: t.columns * t.rows,\n      minWidth: (n = t.minWidth) != null ? n : 0,\n      minHeight: (r = t.minHeight) != null ? r : 0,\n      orientation: t.orientation\n    };\n  }).sort((t, n) => t.maxTiles !== n.maxTiles ? t.maxTiles - n.maxTiles : t.minWidth !== 0 || n.minWidth !== 0 ? t.minWidth - n.minWidth : t.minHeight !== 0 || n.minHeight !== 0 ? t.minHeight - n.minHeight : 0);\n}\nfunction ds() {\n  return typeof navigator < \"u\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\n}\nfunction ps(e, t) {\n  var n;\n  return ce(q({}, e), {\n    receivedAtMediaTimestamp: (n = t.rtpTimestamp) != null ? n : 0,\n    receivedAt: t.timestamp\n  });\n}\nfunction hs(e, t, n) {\n  return [...e, ...t].reduceRight((r, i) => (r.find((o) => o.id === i.id) || r.unshift(i), r), []).slice(0 - n);\n}\nvar po = /* @__PURE__ */ ((e) => (e.AgentState = \"lk.agent.state\", e.PublishOnBehalf = \"lk.publish_on_behalf\", e.TranscriptionFinal = \"lk.transcription_final\", e.TranscriptionSegmentId = \"lk.segment_id\", e.TranscribedTrackId = \"lk.transcribed_track_id\", e))(po || {}), _n = [], Ln = {\n  showChat: !1,\n  unreadMessages: 0,\n  showSettings: !1\n};\nfunction ho(e) {\n  return typeof e == \"object\";\n}\nfunction vs(e) {\n  return Array.isArray(e) && e.filter(ho).length > 0;\n}\nfunction In(e, t) {\n  return t.audioLevel - e.audioLevel;\n}\nfunction Mn(e, t) {\n  return e.isSpeaking === t.isSpeaking ? 0 : e.isSpeaking ? -1 : 1;\n}\nfunction Rn(e, t) {\n  var n, r, i, o;\n  return e.lastSpokeAt !== void 0 || t.lastSpokeAt !== void 0 ? ((r = (n = t.lastSpokeAt) == null ? void 0 : n.getTime()) != null ? r : 0) - ((o = (i = e.lastSpokeAt) == null ? void 0 : i.getTime()) != null ? o : 0) : 0;\n}\nfunction Be(e, t) {\n  var n, r, i, o;\n  return ((r = (n = e.joinedAt) == null ? void 0 : n.getTime()) != null ? r : 0) - ((o = (i = t.joinedAt) == null ? void 0 : i.getTime()) != null ? o : 0);\n}\nfunction vo(e, t) {\n  return B(e) ? B(t) ? 0 : -1 : B(t) ? 1 : 0;\n}\nfunction mo(e, t) {\n  const n = e.participant.isCameraEnabled, r = t.participant.isCameraEnabled;\n  return n !== r ? n ? -1 : 1 : 0;\n}\nfunction ms(e) {\n  const t = [], n = [], r = [], i = [];\n  e.forEach((a) => {\n    a.participant.isLocal && a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera ? t.push(a) : a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare ? n.push(a) : a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera ? r.push(a) : i.push(a);\n  });\n  const o = go(n), s = bo(r);\n  return [...t, ...o, ...s, ...i];\n}\nfunction go(e) {\n  const t = [], n = [];\n  return e.forEach((i) => {\n    i.participant.isLocal ? t.push(i) : n.push(i);\n  }), t.sort((i, o) => Be(i.participant, o.participant)), n.sort((i, o) => Be(i.participant, o.participant)), [...n, ...t];\n}\nfunction bo(e) {\n  const t = [], n = [];\n  return e.forEach((r) => {\n    r.participant.isLocal ? t.push(r) : n.push(r);\n  }), n.sort((r, i) => r.participant.isSpeaking && i.participant.isSpeaking ? In(r.participant, i.participant) : r.participant.isSpeaking !== i.participant.isSpeaking ? Mn(r.participant, i.participant) : r.participant.lastSpokeAt !== i.participant.lastSpokeAt ? Rn(r.participant, i.participant) : B(r) !== B(i) ? vo(r, i) : r.participant.isCameraEnabled !== i.participant.isCameraEnabled ? mo(r, i) : Be(r.participant, i.participant)), [...t, ...n];\n}\nfunction gs(e) {\n  const t = [...e];\n  t.sort((r, i) => {\n    if (r.isSpeaking && i.isSpeaking)\n      return In(r, i);\n    if (r.isSpeaking !== i.isSpeaking)\n      return Mn(r, i);\n    if (r.lastSpokeAt !== i.lastSpokeAt)\n      return Rn(r, i);\n    const o = r.videoTrackPublications.size > 0, s = i.videoTrackPublications.size > 0;\n    return o !== s ? o ? -1 : 1 : Be(r, i);\n  });\n  const n = t.find((r) => r.isLocal);\n  if (n) {\n    const r = t.indexOf(n);\n    r >= 0 && (t.splice(r, 1), t.length > 0 ? t.splice(0, 0, n) : t.push(n));\n  }\n  return t;\n}\nfunction yo(e, t) {\n  return e.reduce(\n    (n, r, i) => i % t === 0 ? [...n, [r]] : [...n.slice(0, -1), [...n.slice(-1)[0], r]],\n    []\n  );\n}\nfunction Ht(e, t) {\n  const n = Math.max(e.length, t.length);\n  return new Array(n).fill([]).map((r, i) => [e[i], t[i]]);\n}\nfunction Ve(e, t, n) {\n  return e.filter((r) => !t.map((i) => n(i)).includes(n(r)));\n}\nfunction ft(e) {\n  return e.map((t) => typeof t == \"string\" || typeof t == \"number\" ? `${t}` : N(t));\n}\nfunction wo(e, t) {\n  return {\n    dropped: Ve(e, t, N),\n    added: Ve(t, e, N)\n  };\n}\nfunction xo(e) {\n  return e.added.length !== 0 || e.dropped.length !== 0;\n}\nfunction dt(e, t) {\n  const n = t.findIndex(\n    (r) => N(r) === N(e)\n  );\n  if (n === -1)\n    throw new Error(\n      `Element not part of the array: ${N(\n        e\n      )} not in ${ft(t)}`\n    );\n  return n;\n}\nfunction So(e, t, n) {\n  const r = dt(e, n), i = dt(t, n);\n  return n.splice(r, 1, t), n.splice(i, 1, e), n;\n}\nfunction To(e, t) {\n  const n = dt(e, t);\n  return t.splice(n, 1), t;\n}\nfunction Eo(e, t) {\n  return [...t, e];\n}\nfunction rt(e, t) {\n  return yo(e, t);\n}\nfunction bs(e, t, n) {\n  let r = Co(e, t);\n  if (r.length < t.length) {\n    const s = Ve(t, r, N);\n    r = [...r, ...s];\n  }\n  const i = rt(r, n), o = rt(t, n);\n  if (Ht(i, o).forEach(([s, a], c) => {\n    if (s && a) {\n      const u = rt(r, n)[c], l = wo(u, a);\n      xo(l) && (L.debug(\n        `Detected visual changes on page: ${c}, current: ${ft(\n          s\n        )}, next: ${ft(a)}`,\n        { changes: l }\n      ), l.added.length === l.dropped.length && Ht(l.added, l.dropped).forEach(([f, v]) => {\n        if (f && v)\n          r = So(f, v, r);\n        else\n          throw new Error(\n            `For a swap action we need a addition and a removal one is missing: ${f}, ${v}`\n          );\n      }), l.added.length === 0 && l.dropped.length > 0 && l.dropped.forEach((f) => {\n        r = To(f, r);\n      }), l.added.length > 0 && l.dropped.length === 0 && l.added.forEach((f) => {\n        r = Eo(f, r);\n      }));\n    }\n  }), r.length > t.length) {\n    const s = Ve(r, t, N);\n    r = r.filter(\n      (a) => !s.map(N).includes(N(a))\n    );\n  }\n  return r;\n}\nfunction Co(e, t) {\n  return e.map((n) => {\n    const r = t.find(\n      (i) => (\n        // If the IDs match or ..\n        N(n) === N(i) || // ... if the current item is a placeholder and the new item is the track reference can replace it.\n        typeof n != \"number\" && Oe(n) && B(i) && io(n, i)\n      )\n    );\n    return r ?? n;\n  });\n}\nfunction U(e) {\n  return `${On}-${e}`;\n}\nfunction ys(e) {\n  const t = zt(e), n = Dn(e.participant).pipe(\n    A(() => zt(e)),\n    D(t)\n  );\n  return { className: U(\n    e.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera || e.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\"\n  ), trackObserver: n };\n}\nfunction zt(e) {\n  if (B(e))\n    return e.publication;\n  {\n    const { source: t, name: n, participant: r } = e;\n    if (t && n)\n      return r.getTrackPublications().find((i) => i.source === t && i.trackName === n);\n    if (n)\n      return r.getTrackPublicationByName(n);\n    if (t)\n      return r.getTrackPublication(t);\n    throw new Error(\"At least one of source and name needs to be defined\");\n  }\n}\nfunction pe(e, ...t) {\n  return new k((r) => {\n    const i = () => {\n      r.next(e);\n    };\n    return t.forEach((s) => {\n      e.on(s, i);\n    }), () => {\n      t.forEach((s) => {\n        e.off(s, i);\n      });\n    };\n  }).pipe(D(e));\n}\nfunction we(e, t) {\n  return new k((r) => {\n    const i = (...s) => {\n      r.next(s);\n    };\n    return e.on(t, i), () => {\n      e.off(t, i);\n    };\n  });\n}\nfunction ws(e) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged).pipe(\n    A(([t]) => t),\n    D(e.state)\n  );\n}\nfunction xs(e) {\n  return pe(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RoomMetadataChanged,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\n  ).pipe(\n    A((n) => ({ name: n.name, metadata: n.metadata }))\n  );\n}\nfunction Ss(e) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveSpeakersChanged).pipe(\n    A(([t]) => t)\n  );\n}\nfunction Ts(e, t, n = !0) {\n  const r = new k((o) => {\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room.getLocalDevices(e, n).then((s) => {\n      o.next(s), o.complete();\n    }).catch((s) => {\n      t == null || t(s), o.next([]), o.complete();\n    });\n  }), i = new k((o) => {\n    var s;\n    const a = () => H(this, null, function* () {\n      try {\n        const c = yield livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room.getLocalDevices(e, n);\n        o.next(c);\n      } catch (c) {\n        t == null || t(c);\n      }\n    });\n    if (typeof window < \"u\") {\n      if (!window.isSecureContext)\n        throw new Error(\n          \"Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices\"\n        );\n      (s = navigator == null ? void 0 : navigator.mediaDevices) == null || s.addEventListener(\"devicechange\", a);\n    }\n    return () => {\n      var c;\n      (c = navigator == null ? void 0 : navigator.mediaDevices) == null || c.removeEventListener(\"devicechange\", a);\n    };\n  });\n  return je(r, i);\n}\nfunction Po(e) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.DataReceived);\n}\nfunction Oo(e) {\n  return pe(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.AudioPlaybackStatusChanged).pipe(\n    A((n) => ({ canPlayAudio: n.canPlaybackAudio }))\n  );\n}\nfunction Ao(e) {\n  return pe(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.VideoPlaybackStatusChanged).pipe(\n    A((n) => ({ canPlayVideo: n.canPlaybackVideo }))\n  );\n}\nfunction ko(e, t) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveDeviceChanged).pipe(\n    Xe(([n]) => n === t),\n    A(([n, r]) => (L.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", { kind: n, deviceId: r }), r))\n  );\n}\nfunction Es(e, t) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantEncryptionStatusChanged).pipe(\n    Xe(\n      ([, n]) => (t == null ? void 0 : t.identity) === (n == null ? void 0 : n.identity) || !n && (t == null ? void 0 : t.identity) === e.localParticipant.identity\n    ),\n    A(([n]) => n),\n    D(\n      t != null && t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)\n    )\n  );\n}\nfunction Cs(e) {\n  return we(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RecordingStatusChanged).pipe(\n    A(([t]) => t),\n    D(e.isRecording)\n  );\n}\nfunction xe(e, ...t) {\n  return new k((r) => {\n    const i = () => {\n      r.next(e);\n    };\n    return t.forEach((s) => {\n      e.on(s, i);\n    }), () => {\n      t.forEach((s) => {\n        e.off(s, i);\n      });\n    };\n  }).pipe(D(e));\n}\nfunction Dn(e) {\n  return xe(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged,\n    // ParticipantEvent.IsSpeakingChanged,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.MediaDevicesError,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionStatusChanged\n    // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    A((n) => {\n      const { isMicrophoneEnabled: r, isCameraEnabled: i, isScreenShareEnabled: o } = n, s = n.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone), a = n.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera);\n      return {\n        isCameraEnabled: i,\n        isMicrophoneEnabled: r,\n        isScreenShareEnabled: o,\n        cameraTrack: a,\n        microphoneTrack: s,\n        participant: n\n      };\n    })\n  );\n}\nfunction _o(e) {\n  return e ? xe(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantMetadataChanged,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantNameChanged\n  ).pipe(\n    A(({ name: n, identity: r, metadata: i }) => ({\n      name: n,\n      identity: r,\n      metadata: i\n    })),\n    D({\n      name: e.name,\n      identity: e.identity,\n      metadata: e.metadata\n    })\n  ) : void 0;\n}\nfunction Lo(e) {\n  return Ze(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ConnectionQualityChanged\n  ).pipe(\n    A(([n]) => n),\n    D(e.connectionQuality)\n  );\n}\nfunction Ze(e, t) {\n  return new k((r) => {\n    const i = (...s) => {\n      r.next(s);\n    };\n    return e.on(t, i), () => {\n      e.off(t, i);\n    };\n  });\n}\nfunction Io(e) {\n  var t, n, r, i;\n  return xe(\n    e.participant,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscribed,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnsubscribed,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\n  ).pipe(\n    A((o) => {\n      var s, a;\n      const c = (s = e.publication) != null ? s : o.getTrackPublication(e.source);\n      return (a = c == null ? void 0 : c.isMuted) != null ? a : !0;\n    }),\n    D(\n      (i = (r = (t = e.publication) == null ? void 0 : t.isMuted) != null ? r : (n = e.participant.getTrackPublication(e.source)) == null ? void 0 : n.isMuted) != null ? i : !0\n    )\n  );\n}\nfunction Ps(e) {\n  return Ze(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.IsSpeakingChanged).pipe(\n    A(([t]) => t)\n  );\n}\nfunction Os(e, t = {}) {\n  var n;\n  let r;\n  const i = new k((c) => (r = c, () => a.unsubscribe())).pipe(D(Array.from(e.remoteParticipants.values()))), o = (n = t.additionalRoomEvents) != null ? n : An, s = Array.from(\n    /* @__PURE__ */ new Set([\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\n      ...o\n    ])\n  ), a = pe(e, ...s).subscribe(\n    (c) => r == null ? void 0 : r.next(Array.from(c.remoteParticipants.values()))\n  );\n  return e.remoteParticipants.size > 0 && (r == null || r.next(Array.from(e.remoteParticipants.values()))), i;\n}\nfunction As(e, t, n = {}) {\n  var r;\n  const i = (r = n.additionalEvents) != null ? r : kn;\n  return pe(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\n  ).pipe(\n    Pn((s) => {\n      const a = s.getParticipantByIdentity(t);\n      return a ? xe(a, ...i) : new k((c) => c.next(void 0));\n    }),\n    D(e.getParticipantByIdentity(t))\n  );\n}\nfunction ks(e) {\n  return Ze(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged\n  ).pipe(\n    A(() => e.permissions),\n    D(e.permissions)\n  );\n}\nfunction _s(e, { kind: t, identity: n }, r = {}) {\n  var i;\n  const o = (i = r.additionalEvents) != null ? i : kn, s = (c) => {\n    let u = !0;\n    return t && (u = u && c.kind === t), n && (u = u && c.identity === n), u;\n  };\n  return pe(\n    e,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\n  ).pipe(\n    Pn((c) => {\n      const u = Array.from(c.remoteParticipants.values()).find(\n        (l) => s(l)\n      );\n      return u ? xe(u, ...o) : new k((l) => l.next(void 0));\n    }),\n    D(Array.from(e.remoteParticipants.values()).find((c) => s(c)))\n  );\n}\nfunction Ls(e) {\n  return typeof e > \"u\" ? new k() : Ze(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.AttributesChanged).pipe(\n    A(([t]) => ({\n      changed: t,\n      attributes: e.attributes\n    })),\n    D({ changed: e.attributes, attributes: e.attributes })\n  );\n}\nfunction Is(e, t, n, r, i) {\n  const { localParticipant: o } = t, s = (f, v) => {\n    let d = !1;\n    switch (f) {\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\n        d = v.isCameraEnabled;\n        break;\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\n        d = v.isMicrophoneEnabled;\n        break;\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare:\n        d = v.isScreenShareEnabled;\n        break;\n    }\n    return d;\n  }, a = Dn(o).pipe(\n    A((f) => s(e, f.participant)),\n    D(s(e, o))\n  ), c = new te(), u = (f, v) => H(this, null, function* () {\n    try {\n      switch (v ?? (v = n), c.next(!0), e) {\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\n          return yield o.setCameraEnabled(\n            f ?? !o.isCameraEnabled,\n            v,\n            r\n          ), o.isCameraEnabled;\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\n          return yield o.setMicrophoneEnabled(\n            f ?? !o.isMicrophoneEnabled,\n            v,\n            r\n          ), o.isMicrophoneEnabled;\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare:\n          return yield o.setScreenShareEnabled(\n            f ?? !o.isScreenShareEnabled,\n            v,\n            r\n          ), o.isScreenShareEnabled;\n        default:\n          throw new TypeError(\"Tried to toggle unsupported source\");\n      }\n    } catch (d) {\n      if (i && d instanceof Error) {\n        i == null || i(d);\n        return;\n      } else\n        throw d;\n    } finally {\n      c.next(!1);\n    }\n  });\n  return {\n    className: U(\"button\"),\n    toggle: u,\n    enabledObserver: a,\n    pendingObserver: c.asObservable()\n  };\n}\nfunction Ms() {\n  let e = !1;\n  const t = new te(), n = new te(), r = (o) => H(this, null, function* () {\n    n.next(!0), e = o ?? !e, t.next(e), n.next(!1);\n  });\n  return {\n    className: U(\"button\"),\n    toggle: r,\n    enabledObserver: t.asObservable(),\n    pendingObserver: n.asObservable()\n  };\n}\nfunction Rs(e, t, n) {\n  const r = new pn(void 0), i = ko(t, e), o = (a, ...c) => H(this, [a, ...c], function* (u, l = {}) {\n    var f, v, d;\n    if (t) {\n      const m = (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.getBrowser)();\n      if (e === \"audiooutput\" && ((m == null ? void 0 : m.name) === \"Safari\" || (m == null ? void 0 : m.os) === \"iOS\")) {\n        L.warn(\"Switching audio output device is not supported on Safari and iOS.\");\n        return;\n      }\n      L.debug(`Switching active device of kind \"${e}\" with id ${u}.`), yield t.switchActiveDevice(e, u, l.exact);\n      const p = (f = t.getActiveDevice(e)) != null ? f : u;\n      p !== u && u !== \"default\" && L.info(\n        `We tried to select the device with id (${u}), but the browser decided to select the device with id (${p}) instead.`\n      );\n      let g;\n      e === \"audioinput\" ? g = (v = t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone)) == null ? void 0 : v.track : e === \"videoinput\" && (g = (d = t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera)) == null ? void 0 : d.track);\n      const h = u === \"default\" && !g || u === \"default\" && (g == null ? void 0 : g.mediaStreamTrack.label.startsWith(\"Default\"));\n      r.next(h ? u : p);\n    }\n  });\n  return {\n    className: U(\"media-device-select\"),\n    activeDeviceObservable: i,\n    setActiveMediaDevice: o\n  };\n}\nfunction Ds(e) {\n  const t = (r) => {\n    e.disconnect(r);\n  };\n  return { className: U(\"disconnect-button\"), disconnect: t };\n}\nfunction $s(e) {\n  const t = U(\"connection-quality\"), n = Lo(e);\n  return { className: t, connectionQualityObserver: n };\n}\nfunction Ns(e) {\n  let t = \"track-muted-indicator-camera\";\n  switch (e.source) {\n    case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\n      t = \"track-muted-indicator-camera\";\n      break;\n    case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\n      t = \"track-muted-indicator-microphone\";\n      break;\n  }\n  const n = U(t), r = Io(e);\n  return { className: n, mediaMutedObserver: r };\n}\nfunction Fs(e) {\n  return { className: \"lk-participant-name\", infoObserver: _o(e) };\n}\nfunction Us() {\n  return {\n    className: U(\"participant-tile\")\n  };\n}\nvar Mo = {\n  CHAT: \"lk.chat\",\n  TRANSCRIPTION: \"lk.transcription\"\n}, Ro = {\n  CHAT: \"lk-chat-topic\"\n};\nfunction $n(e, t) {\n  return H(this, arguments, function* (n, r, i = {}) {\n    const { reliable: o, destinationIdentities: s, topic: a } = i;\n    yield n.publishData(r, {\n      destinationIdentities: s,\n      topic: a,\n      reliable: o\n    });\n  });\n}\nfunction Do(e, t, n) {\n  const r = Array.isArray(t) ? t : [t], i = Po(e).pipe(\n    Xe(\n      ([, , , c]) => t === void 0 || c !== void 0 && r.includes(c)\n    ),\n    A(([c, u, , l]) => {\n      const f = {\n        payload: c,\n        topic: l,\n        from: u\n      };\n      return n == null || n(f), f;\n    })\n  );\n  let o;\n  const s = new k((c) => {\n    o = c;\n  });\n  return { messageObservable: i, isSendingObservable: s, send: (c, ...u) => H(this, [c, ...u], function* (l, f = {}) {\n    o.next(!0);\n    try {\n      yield $n(e.localParticipant, l, q({ topic: r[0] }, f));\n    } finally {\n      o.next(!1);\n    }\n  }) };\n}\nvar Ie = /* @__PURE__ */ new WeakMap();\nfunction $o(e) {\n  return e.ignoreLegacy == !0;\n}\nvar No = (e) => JSON.parse(new TextDecoder().decode(e)), Fo = (e) => new TextEncoder().encode(JSON.stringify(e));\nfunction Ws(e, t) {\n  var n, r, i, o, s, a;\n  const c = () => {\n    var b, S, C;\n    return ((b = e.serverInfo) == null ? void 0 : b.edition) === 1 || !!((S = e.serverInfo) != null && S.version) && (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.compareVersions)((C = e.serverInfo) == null ? void 0 : C.version, \"1.8.2\") > 0;\n  }, u = new te(), l = (n = t == null ? void 0 : t.channelTopic) != null ? n : Mo.CHAT, f = (r = t == null ? void 0 : t.channelTopic) != null ? r : Ro.CHAT;\n  let v = !1;\n  Ie.has(e) || (v = !0);\n  const d = (i = Ie.get(e)) != null ? i : /* @__PURE__ */ new Map(), m = (o = d.get(l)) != null ? o : new te();\n  d.set(l, m), Ie.set(e, d);\n  const p = (s = t == null ? void 0 : t.messageDecoder) != null ? s : No;\n  if (v) {\n    e.registerTextStreamHandler(l, (S, C) => H(this, null, function* () {\n      const { id: $, timestamp: M } = S.info;\n      Je(S).pipe(\n        lt((T, _) => T + _),\n        A((T) => ({\n          id: $,\n          timestamp: M,\n          message: T,\n          from: e.getParticipantByIdentity(C.identity),\n          type: \"chatMessage\"\n          // editTimestamp: type === 'update' ? timestamp : undefined,\n        }))\n      ).subscribe({\n        next: (T) => m.next(T)\n      });\n    }));\n    const { messageObservable: b } = Do(e, [f]);\n    b.pipe(\n      A((S) => {\n        const C = p(S.payload);\n        return $o(C) ? void 0 : ce(q({}, C), {\n          type: \"chatMessage\",\n          from: S.from\n        });\n      }),\n      Xe((S) => !!S),\n      Wt(u)\n    ).subscribe(m);\n  }\n  const g = m.pipe(\n    lt((b, S) => {\n      if (\"id\" in S && b.find((C) => {\n        var $, M;\n        return (($ = C.from) == null ? void 0 : $.identity) === ((M = S.from) == null ? void 0 : M.identity) && C.id === S.id;\n      })) {\n        const C = b.findIndex(($) => $.id === S.id);\n        if (C > -1) {\n          const $ = b[C];\n          b[C] = ce(q({}, S), {\n            timestamp: $.timestamp,\n            editTimestamp: S.timestamp\n          });\n        }\n        return [...b];\n      }\n      return [...b, S];\n    }, []),\n    Wt(u)\n  ), h = new pn(!1), x = (a = t == null ? void 0 : t.messageEncoder) != null ? a : Fo, E = (b, S) => H(this, null, function* () {\n    var C;\n    S || (S = {}), (C = S.topic) != null || (S.topic = l), h.next(!0);\n    try {\n      const M = {\n        id: (yield e.localParticipant.sendText(b, S)).id,\n        timestamp: Date.now(),\n        message: b\n      }, V = ce(q({}, M), {\n        attachedFiles: S.attachments\n      }), T = ce(q({}, V), {\n        type: \"chatMessage\",\n        from: e.localParticipant,\n        attributes: S.attributes\n      });\n      m.next(T);\n      const _ = x(ce(q({}, M), {\n        ignoreLegacy: c()\n      }));\n      try {\n        yield $n(e.localParticipant, _, {\n          reliable: !0,\n          topic: f\n        });\n      } catch (ee) {\n        L.info(\"could not send message in legacy chat format\", ee);\n      }\n      return T;\n    } finally {\n      h.next(!1);\n    }\n  });\n  function O() {\n    u.next(), u.complete(), m.complete(), Ie.delete(e), e.unregisterTextStreamHandler(l);\n  }\n  return e.once(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.Disconnected, O), {\n    messageObservable: g,\n    isSendingObservable: h,\n    send: E\n  };\n}\nfunction js() {\n  const e = (n) => H(this, null, function* () {\n    L.info(\"Start Audio for room: \", n), yield n.startAudio();\n  });\n  return { className: U(\"start-audio-button\"), roomAudioPlaybackAllowedObservable: Oo, handleStartAudioPlayback: e };\n}\nfunction Bs() {\n  const e = (n) => H(this, null, function* () {\n    L.info(\"Start Video for room: \", n), yield n.startVideo();\n  });\n  return { className: U(\"start-audio-button\"), roomVideoPlaybackAllowedObservable: Ao, handleStartVideoPlayback: e };\n}\nfunction Vs() {\n  return { className: [U(\"button\"), U(\"chat-toggle\")].join(\" \") };\n}\nfunction Hs() {\n  return { className: [U(\"button\"), U(\"focus-toggle-button\")].join(\" \") };\n}\nfunction zs() {\n  return { className: \"lk-clear-pin-button lk-button\" };\n}\nfunction Ys() {\n  return { className: \"lk-room-container\" };\n}\nfunction Yt(e, t, n = !0) {\n  const i = [e.localParticipant, ...Array.from(e.remoteParticipants.values())], o = [];\n  return i.forEach((s) => {\n    t.forEach((a) => {\n      const c = Array.from(\n        s.trackPublications.values()\n      ).filter(\n        (u) => u.source === a && // either return all or only the ones that are subscribed\n        (!n || u.track)\n      ).map((u) => ({\n        participant: s,\n        publication: u,\n        source: u.source\n      }));\n      o.push(...c);\n    });\n  }), { trackReferences: o, participants: i };\n}\nfunction qt(e, t, n = !1) {\n  const { sources: r, kind: i, name: o } = t;\n  return Array.from(e.trackPublications.values()).filter(\n    (a) => (!r || r.includes(a.source)) && (!i || a.kind === i) && (!o || a.trackName === o) && // either return all or only the ones that are subscribed\n    (!n || a.track)\n  ).map((a) => ({\n    participant: e,\n    publication: a,\n    source: a.source\n  }));\n}\nfunction qs(e, t, n) {\n  var r, i;\n  const o = (r = n.additionalRoomEvents) != null ? r : An, s = (i = n.onlySubscribed) != null ? i : !0, a = Array.from(\n    (/* @__PURE__ */ new Set([\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackPublished,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackUnpublished,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackPublished,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnpublished,\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionStatusChanged,\n      ...o\n    ])).values()\n  );\n  return pe(e, ...a).pipe(\n    A((u) => {\n      const l = Yt(u, t, s);\n      return L.debug(`TrackReference[] was updated. (length ${l.trackReferences.length})`, l), l;\n    }),\n    D(Yt(e, t, s))\n  );\n}\nfunction Ks(e, t) {\n  return xe(e, ...co).pipe(\n    A((r) => {\n      const i = qt(r, t);\n      return L.debug(`TrackReference[] was updated. (length ${i.length})`, i), i;\n    }),\n    D(qt(e, t))\n  );\n}\nfunction Nn(e, t) {\n  return new k((r) => {\n    const i = (...s) => {\n      r.next(s);\n    };\n    return e.on(t, i), () => {\n      e.off(t, i);\n    };\n  });\n}\nfunction Gs(e) {\n  return Nn(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.TrackEvent.TranscriptionReceived);\n}\nfunction Qs(e) {\n  return Nn(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.TrackEvent.TimeSyncUpdate).pipe(\n    A(([t]) => t)\n  );\n}\nfunction Js(e, t = 1e3) {\n  if (e === null) return Ft(!1);\n  const n = ut(e, \"mousemove\", { passive: !0 }).pipe(A(() => !0)), r = n.pipe(\n    Li({\n      each: t,\n      with: () => je(Ft(!1), r.pipe(Gi(n)))\n    }),\n    Yi()\n  );\n  return r;\n}\nfunction Uo(e, t) {\n  if (typeof localStorage > \"u\") {\n    L.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    if (t) {\n      const n = Object.fromEntries(\n        Object.entries(t).filter(([, r]) => r !== \"\")\n      );\n      localStorage.setItem(e, JSON.stringify(n));\n    }\n  } catch (n) {\n    L.error(`Error setting item to local storage: ${n}`);\n  }\n}\nfunction Wo(e) {\n  if (typeof localStorage > \"u\") {\n    L.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    const t = localStorage.getItem(e);\n    if (!t) {\n      L.warn(`Item with key ${e} does not exist in local storage.`);\n      return;\n    }\n    return JSON.parse(t);\n  } catch (t) {\n    L.error(`Error getting item from local storage: ${t}`);\n    return;\n  }\n}\nfunction jo(e) {\n  return {\n    load: () => Wo(e),\n    save: (t) => Uo(e, t)\n  };\n}\nvar Bo = `${On}-user-choices`, Ee = {\n  videoEnabled: !0,\n  audioEnabled: !0,\n  videoDeviceId: \"default\",\n  audioDeviceId: \"default\",\n  username: \"\"\n}, { load: Vo, save: Ho } = jo(Bo);\nfunction Xs(e, t = !1) {\n  t !== !0 && Ho(e);\n}\nfunction Zs(e, t = !1) {\n  var n, r, i, o, s;\n  const a = {\n    videoEnabled: (n = e == null ? void 0 : e.videoEnabled) != null ? n : Ee.videoEnabled,\n    audioEnabled: (r = e == null ? void 0 : e.audioEnabled) != null ? r : Ee.audioEnabled,\n    videoDeviceId: (i = e == null ? void 0 : e.videoDeviceId) != null ? i : Ee.videoDeviceId,\n    audioDeviceId: (o = e == null ? void 0 : e.audioDeviceId) != null ? o : Ee.audioDeviceId,\n    username: (s = e == null ? void 0 : e.username) != null ? s : Ee.username\n  };\n  if (t)\n    return a;\n  {\n    const c = Vo();\n    return q(q({}, a), c ?? {});\n  }\n}\nvar it = null, ot = null, zo = 0;\nfunction Kt() {\n  return it || (it = /* @__PURE__ */ new Map()), it;\n}\nfunction Yo() {\n  return ot || (ot = /* @__PURE__ */ new WeakMap()), ot;\n}\nfunction qo(e, t) {\n  const n = Yo();\n  let r = n.get(e);\n  return r || (r = `room_${zo++}`, n.set(e, r)), `${r}:${t}`;\n}\nfunction ea(e, t) {\n  const n = qo(e, t), r = Kt(), i = r.get(n);\n  if (i)\n    return i;\n  const o = new te();\n  let s = [];\n  const a = \"lk.segment_id\", c = o.pipe(\n    Qi({\n      subscribe: () => {\n        e.registerTextStreamHandler(t, (u, l) => H(this, null, function* () {\n          var f;\n          const v = Je(u).pipe(\n            lt((m, p) => m + p, \"\")\n          ), d = !!((f = u.info.attributes) != null && f[a]);\n          v.subscribe((m) => {\n            const p = s.findIndex(\n              (g) => {\n                var h, x;\n                return g.streamInfo.id === u.info.id || d && ((h = g.streamInfo.attributes) == null ? void 0 : h[a]) === ((x = u.info.attributes) == null ? void 0 : x[a]);\n              }\n            );\n            p !== -1 ? (s[p] = ce(q({}, s[p]), {\n              text: m\n            }), o.next([...s])) : (s.push({\n              text: m,\n              participantInfo: l,\n              streamInfo: u.info\n            }), o.next([...s]));\n          });\n        }));\n      },\n      finalize: () => {\n        e.unregisterTextStreamHandler(t);\n      }\n    }),\n    Ki()\n  );\n  return r.set(n, c), e.on(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.Disconnected, () => {\n    Kt().delete(n), s = [], o.next([]);\n  }), c;\n}\nfunction Fn(e, t) {\n  if (t.msg === \"show_chat\")\n    return { ...e, showChat: !0, unreadMessages: 0 };\n  if (t.msg === \"hide_chat\")\n    return { ...e, showChat: !1 };\n  if (t.msg === \"toggle_chat\") {\n    const n = { ...e, showChat: !e.showChat };\n    return n.showChat === !0 && (n.unreadMessages = 0), n;\n  } else return t.msg === \"unread_msg\" ? { ...e, unreadMessages: t.count } : t.msg === \"toggle_settings\" ? { ...e, showSettings: !e.showSettings } : { ...e };\n}\nfunction Un(e, t) {\n  return t.msg === \"set_pin\" ? [t.trackReference] : t.msg === \"clear_pin\" ? [] : { ...e };\n}\nconst Wn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction ta() {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Wn);\n  if (!e)\n    throw Error(\"Tried to access LayoutContext context outside a LayoutContextProvider provider.\");\n  return e;\n}\nfunction na(e) {\n  const t = Ko();\n  if (e ?? (e = t), !e)\n    throw Error(\"Tried to access LayoutContext context outside a LayoutContextProvider provider.\");\n  return e;\n}\nfunction ra() {\n  const [e, t] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Un, _n), [n, r] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Fn, Ln);\n  return {\n    pin: { dispatch: t, state: e },\n    widget: { dispatch: r, state: n }\n  };\n}\nfunction ia(e) {\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Un, _n), [r, i] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Fn, Ln);\n  return e ?? {\n    pin: { dispatch: n, state: t },\n    widget: { dispatch: i, state: r }\n  };\n}\nfunction Ko() {\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Wn);\n}\nconst jn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(\n  void 0\n);\nfunction oa() {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(jn);\n  if (!e)\n    throw Error(\"tried to access track context outside of track context provider\");\n  return e;\n}\nfunction Bn() {\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(jn);\n}\nfunction sa(e) {\n  const t = Bn(), n = e ?? t;\n  if (!n)\n    throw new Error(\n      \"No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly\"\n    );\n  return n;\n}\nconst Vn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction aa() {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Vn);\n  if (!e)\n    throw Error(\"tried to access participant context outside of participant context provider\");\n  return e;\n}\nfunction Go() {\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Vn);\n}\nfunction ca(e) {\n  const t = Go(), n = Bn(), r = e ?? t ?? (n == null ? void 0 : n.participant);\n  if (!r)\n    throw new Error(\n      \"No participant provided, make sure you are inside a participant context or pass the participant explicitly\"\n    );\n  return r;\n}\nconst Hn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction ua() {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Hn);\n  if (!e)\n    throw Error(\"tried to access room context outside of livekit room component\");\n  return e;\n}\nfunction Qo() {\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Hn);\n}\nfunction la(e) {\n  const t = Qo(), n = e ?? t;\n  if (!n)\n    throw new Error(\n      \"No room provided, make sure you are inside a Room context or pass the room explicitly\"\n    );\n  return n;\n}\nconst zn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction fa() {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(zn);\n  if (!e)\n    throw Error(\"tried to access session context outside of SessionProvider component\");\n  return e;\n}\nfunction Jo() {\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(zn);\n}\nfunction da(e) {\n  const t = Jo(), n = e ?? t;\n  if (!n)\n    throw new Error(\n      \"No session provided, make sure you are inside a Session context or pass the session explicitly\"\n    );\n  return n;\n}\nconst Xo = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction pa(e) {\n  const t = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Xo);\n  if (e === !0) {\n    if (t)\n      return t;\n    throw Error(\"tried to access feature context, but none is present\");\n  }\n  return t;\n}\n\n//# sourceMappingURL=contexts-CsO1QZ3r.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvY29udGV4dHMtQ3NPMVFaM3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9OO0FBQ3pMO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsR0FBRyxxQkFBcUI7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsSUFBSTtBQUNKLFVBQVU7QUFDVixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQkFBZ0I7QUFDaEIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWTtBQUNaLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLFdBQVcsMkJBQTJCLFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnUUFBZ1EsMERBQTBEO0FBQzFULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxjQUFjLHVCQUF1QixHQUFHLFNBQVM7QUFDakQ7QUFDQSxjQUFjLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QjtBQUN2Rix3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlHQUFpRyxFQUFFO0FBQ25HO0FBQ0Esc0JBQXNCLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSwwSkFBMEosR0FBRyxlQUFlLElBQUk7QUFDck8scUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBLGNBQWMsV0FBVyxJQUFJO0FBQzdCLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pELEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0g7QUFDQTtBQUNBLEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0g7QUFDQSxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNIO0FBQ0EsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0g7QUFDQTtBQUNBLEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQiwyREFBRTtBQUNuQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQUUsdUJBQXVCLG9EQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLCtEQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxHQUFHLHdDQUF3QyxFQUFFO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxHQUFHLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwUUFBMFE7QUFDMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaURBQUMsMENBQTBDLGlEQUFDLCtDQUErQyxpREFBQztBQUN0SSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxTQUFTLFNBQVMsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFLGFBQWE7QUFDM0Q7QUFDQSxVQUFVLFVBQVUsTUFBTTtBQUMxQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixFQUFFLElBQUksRUFBRTtBQUMxRjtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLEdBQUcsR0FBRyxFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxpQkFBaUIsaURBQUMsK0JBQStCLGlEQUFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLHFEQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBQztBQUNMLElBQUkscURBQUM7QUFDTDtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBRTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQUU7QUFDMUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEIsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFDO0FBQ2hCLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBQztBQUNoQjtBQUNBLHVGQUF1RixzQkFBc0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0w7QUFDQSxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNFQUFzRSwrQkFBK0IsaURBQUMsK0NBQStDLGlEQUFDO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0w7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUM7QUFDUCxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBQztBQUNMLElBQUkscURBQUM7QUFDTCxJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFDO0FBQ0wsSUFBSSxxREFBQztBQUNMLElBQUkscURBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNERBQUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsaURBQWlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQSxXQUFXLGlEQUFDO0FBQ1o7QUFDQTtBQUNBLFdBQVcsaURBQUM7QUFDWjtBQUNBO0FBQ0EsV0FBVyxpREFBQztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxZQUFZLEVBQUU7QUFDbEU7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLDJEQUEyRCxFQUFFO0FBQ2pIO0FBQ0E7QUFDQSwyRUFBMkUsaURBQUMseUhBQXlILGlEQUFDO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFDO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsaURBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVcsd0dBQXdHO0FBQ25IO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCwrREFBRTtBQUN2SCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUcsS0FBSztBQUNSO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUCxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUCxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUJBQXlCO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLHNEQUFFO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHNEQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFDO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLElBQUksdUNBQXVDLGdDQUFnQyxrQ0FBa0Msc0NBQXNDLElBQUk7QUFDdko7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQVksbUJBQW1CLDZDQUFZO0FBQzVEO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBWSxtQkFBbUIsNkNBQVk7QUFDNUQ7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBWTtBQUNyQjtBQUNBLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFlO0FBQzFCO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFlO0FBQzFCO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFlO0FBQzFCO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFlO0FBQzFCO0FBQ0EsWUFBWSw2Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQStGRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvY29udGV4dHMtQ3NPMVFaM3IubWpzPzA5MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2V0TG9nTGV2ZWwgYXMgcW4sIExvZ0xldmVsIGFzIFN0LCBzZXRMb2dFeHRlbnNpb24gYXMgS24sIFJvb21FdmVudCBhcyB5LCBQYXJ0aWNpcGFudEV2ZW50IGFzIHcsIFRyYWNrIGFzIFIsIFRyYWNrRXZlbnQgYXMgR3QsIGdldEJyb3dzZXIgYXMgR24sIGNvbXBhcmVWZXJzaW9ucyBhcyBRbiwgUm9vbSBhcyBUdCB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xuaW1wb3J0ICogYXMgSSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IERlID0gTWF0aC5taW4sIHVlID0gTWF0aC5tYXgsICRlID0gTWF0aC5yb3VuZCwgX2UgPSBNYXRoLmZsb29yLCBKID0gKGUpID0+ICh7XG4gIHg6IGUsXG4gIHk6IGVcbn0pLCBKbiA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59LCBYbiA9IHtcbiAgc3RhcnQ6IFwiZW5kXCIsXG4gIGVuZDogXCJzdGFydFwiXG59O1xuZnVuY3Rpb24gRXQoZSwgdCwgbikge1xuICByZXR1cm4gdWUoZSwgRGUodCwgbikpO1xufVxuZnVuY3Rpb24gSGUoZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSh0KSA6IGU7XG59XG5mdW5jdGlvbiBsZShlKSB7XG4gIHJldHVybiBlLnNwbGl0KFwiLVwiKVswXTtcbn1cbmZ1bmN0aW9uIHplKGUpIHtcbiAgcmV0dXJuIGUuc3BsaXQoXCItXCIpWzFdO1xufVxuZnVuY3Rpb24gUXQoZSkge1xuICByZXR1cm4gZSA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gSnQoZSkge1xuICByZXR1cm4gZSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xufVxuY29uc3QgWm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0b3BcIiwgXCJib3R0b21cIl0pO1xuZnVuY3Rpb24gaWUoZSkge1xuICByZXR1cm4gWm4uaGFzKGxlKGUpKSA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiBYdChlKSB7XG4gIHJldHVybiBRdChpZShlKSk7XG59XG5mdW5jdGlvbiBlcihlLCB0LCBuKSB7XG4gIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgY29uc3QgciA9IHplKGUpLCBpID0gWHQoZSksIG8gPSBKdChpKTtcbiAgbGV0IHMgPSBpID09PSBcInhcIiA/IHIgPT09IChuID8gXCJlbmRcIiA6IFwic3RhcnRcIikgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiA6IHIgPT09IFwic3RhcnRcIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICByZXR1cm4gdC5yZWZlcmVuY2Vbb10gPiB0LmZsb2F0aW5nW29dICYmIChzID0gTmUocykpLCBbcywgTmUocyldO1xufVxuZnVuY3Rpb24gdHIoZSkge1xuICBjb25zdCB0ID0gTmUoZSk7XG4gIHJldHVybiBbc3QoZSksIHQsIHN0KHQpXTtcbn1cbmZ1bmN0aW9uIHN0KGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvc3RhcnR8ZW5kL2csICh0KSA9PiBYblt0XSk7XG59XG5jb25zdCBDdCA9IFtcImxlZnRcIiwgXCJyaWdodFwiXSwgUHQgPSBbXCJyaWdodFwiLCBcImxlZnRcIl0sIG5yID0gW1widG9wXCIsIFwiYm90dG9tXCJdLCByciA9IFtcImJvdHRvbVwiLCBcInRvcFwiXTtcbmZ1bmN0aW9uIGlyKGUsIHQsIG4pIHtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHJldHVybiBuID8gdCA/IFB0IDogQ3QgOiB0ID8gQ3QgOiBQdDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIHQgPyBuciA6IHJyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIG9yKGUsIHQsIG4sIHIpIHtcbiAgY29uc3QgaSA9IHplKGUpO1xuICBsZXQgbyA9IGlyKGxlKGUpLCBuID09PSBcInN0YXJ0XCIsIHIpO1xuICByZXR1cm4gaSAmJiAobyA9IG8ubWFwKChzKSA9PiBzICsgXCItXCIgKyBpKSwgdCAmJiAobyA9IG8uY29uY2F0KG8ubWFwKHN0KSkpKSwgbztcbn1cbmZ1bmN0aW9uIE5lKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csICh0KSA9PiBKblt0XSk7XG59XG5mdW5jdGlvbiBzcihlKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLmVcbiAgfTtcbn1cbmZ1bmN0aW9uIGFyKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgPyBzcihlKSA6IHtcbiAgICB0b3A6IGUsXG4gICAgcmlnaHQ6IGUsXG4gICAgYm90dG9tOiBlLFxuICAgIGxlZnQ6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIEZlKGUpIHtcbiAgY29uc3Qge1xuICAgIHg6IHQsXG4gICAgeTogbixcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IGlcbiAgfSA9IGU7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHIsXG4gICAgaGVpZ2h0OiBpLFxuICAgIHRvcDogbixcbiAgICBsZWZ0OiB0LFxuICAgIHJpZ2h0OiB0ICsgcixcbiAgICBib3R0b206IG4gKyBpLFxuICAgIHg6IHQsXG4gICAgeTogblxuICB9O1xufVxuZnVuY3Rpb24gT3QoZSwgdCwgbikge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZTogcixcbiAgICBmbG9hdGluZzogaVxuICB9ID0gZTtcbiAgY29uc3QgbyA9IGllKHQpLCBzID0gWHQodCksIGEgPSBKdChzKSwgYyA9IGxlKHQpLCB1ID0gbyA9PT0gXCJ5XCIsIGwgPSByLnggKyByLndpZHRoIC8gMiAtIGkud2lkdGggLyAyLCBmID0gci55ICsgci5oZWlnaHQgLyAyIC0gaS5oZWlnaHQgLyAyLCB2ID0gclthXSAvIDIgLSBpW2FdIC8gMjtcbiAgbGV0IGQ7XG4gIHN3aXRjaCAoYykge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGQgPSB7XG4gICAgICAgIHg6IGwsXG4gICAgICAgIHk6IHIueSAtIGkuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgZCA9IHtcbiAgICAgICAgeDogbCxcbiAgICAgICAgeTogci55ICsgci5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGQgPSB7XG4gICAgICAgIHg6IHIueCArIHIud2lkdGgsXG4gICAgICAgIHk6IGZcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgZCA9IHtcbiAgICAgICAgeDogci54IC0gaS53aWR0aCxcbiAgICAgICAgeTogZlxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkID0ge1xuICAgICAgICB4OiByLngsXG4gICAgICAgIHk6IHIueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKHplKHQpKSB7XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICBkW3NdIC09IHYgKiAobiAmJiB1ID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGRbc10gKz0gdiAqIChuICYmIHUgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG5jb25zdCBjciA9IGFzeW5jIChlLCB0LCBuKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQ6IHIgPSBcImJvdHRvbVwiLFxuICAgIHN0cmF0ZWd5OiBpID0gXCJhYnNvbHV0ZVwiLFxuICAgIG1pZGRsZXdhcmU6IG8gPSBbXSxcbiAgICBwbGF0Zm9ybTogc1xuICB9ID0gbiwgYSA9IG8uZmlsdGVyKEJvb2xlYW4pLCBjID0gYXdhaXQgKHMuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaXNSVEwodCkpO1xuICBsZXQgdSA9IGF3YWl0IHMuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2U6IGUsXG4gICAgZmxvYXRpbmc6IHQsXG4gICAgc3RyYXRlZ3k6IGlcbiAgfSksIHtcbiAgICB4OiBsLFxuICAgIHk6IGZcbiAgfSA9IE90KHUsIHIsIGMpLCB2ID0gciwgZCA9IHt9LCBtID0gMDtcbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBhLmxlbmd0aDsgcCsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZTogZyxcbiAgICAgIGZuOiBoXG4gICAgfSA9IGFbcF0sIHtcbiAgICAgIHgsXG4gICAgICB5OiBFLFxuICAgICAgZGF0YTogTyxcbiAgICAgIHJlc2V0OiBiXG4gICAgfSA9IGF3YWl0IGgoe1xuICAgICAgeDogbCxcbiAgICAgIHk6IGYsXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiByLFxuICAgICAgcGxhY2VtZW50OiB2LFxuICAgICAgc3RyYXRlZ3k6IGksXG4gICAgICBtaWRkbGV3YXJlRGF0YTogZCxcbiAgICAgIHJlY3RzOiB1LFxuICAgICAgcGxhdGZvcm06IHMsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGUsXG4gICAgICAgIGZsb2F0aW5nOiB0XG4gICAgICB9XG4gICAgfSk7XG4gICAgbCA9IHggPz8gbCwgZiA9IEUgPz8gZiwgZCA9IHtcbiAgICAgIC4uLmQsXG4gICAgICBbZ106IHtcbiAgICAgICAgLi4uZFtnXSxcbiAgICAgICAgLi4uT1xuICAgICAgfVxuICAgIH0sIGIgJiYgbSA8PSA1MCAmJiAobSsrLCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIChiLnBsYWNlbWVudCAmJiAodiA9IGIucGxhY2VtZW50KSwgYi5yZWN0cyAmJiAodSA9IGIucmVjdHMgPT09ICEwID8gYXdhaXQgcy5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgcmVmZXJlbmNlOiBlLFxuICAgICAgZmxvYXRpbmc6IHQsXG4gICAgICBzdHJhdGVneTogaVxuICAgIH0pIDogYi5yZWN0cyksIHtcbiAgICAgIHg6IGwsXG4gICAgICB5OiBmXG4gICAgfSA9IE90KHUsIHYsIGMpKSwgcCA9IC0xKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGwsXG4gICAgeTogZixcbiAgICBwbGFjZW1lbnQ6IHYsXG4gICAgc3RyYXRlZ3k6IGksXG4gICAgbWlkZGxld2FyZURhdGE6IGRcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBadChlLCB0KSB7XG4gIHZhciBuO1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIGNvbnN0IHtcbiAgICB4OiByLFxuICAgIHk6IGksXG4gICAgcGxhdGZvcm06IG8sXG4gICAgcmVjdHM6IHMsXG4gICAgZWxlbWVudHM6IGEsXG4gICAgc3RyYXRlZ3k6IGNcbiAgfSA9IGUsIHtcbiAgICBib3VuZGFyeTogdSA9IFwiY2xpcHBpbmdBbmNlc3RvcnNcIixcbiAgICByb290Qm91bmRhcnk6IGwgPSBcInZpZXdwb3J0XCIsXG4gICAgZWxlbWVudENvbnRleHQ6IGYgPSBcImZsb2F0aW5nXCIsXG4gICAgYWx0Qm91bmRhcnk6IHYgPSAhMSxcbiAgICBwYWRkaW5nOiBkID0gMFxuICB9ID0gSGUodCwgZSksIG0gPSBhcihkKSwgZyA9IGFbdiA/IGYgPT09IFwiZmxvYXRpbmdcIiA/IFwicmVmZXJlbmNlXCIgOiBcImZsb2F0aW5nXCIgOiBmXSwgaCA9IEZlKGF3YWl0IG8uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAobiA9IGF3YWl0IChvLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogby5pc0VsZW1lbnQoZykpKSA9PSBudWxsIHx8IG4gPyBnIDogZy5jb250ZXh0RWxlbWVudCB8fCBhd2FpdCAoby5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0RG9jdW1lbnRFbGVtZW50KGEuZmxvYXRpbmcpKSxcbiAgICBib3VuZGFyeTogdSxcbiAgICByb290Qm91bmRhcnk6IGwsXG4gICAgc3RyYXRlZ3k6IGNcbiAgfSkpLCB4ID0gZiA9PT0gXCJmbG9hdGluZ1wiID8ge1xuICAgIHg6IHIsXG4gICAgeTogaSxcbiAgICB3aWR0aDogcy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiBzLnJlZmVyZW5jZSwgRSA9IGF3YWl0IChvLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogby5nZXRPZmZzZXRQYXJlbnQoYS5mbG9hdGluZykpLCBPID0gYXdhaXQgKG8uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvLmlzRWxlbWVudChFKSkgPyBhd2FpdCAoby5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogby5nZXRTY2FsZShFKSkgfHwge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9IDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9LCBiID0gRmUoby5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IG8uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzOiBhLFxuICAgIHJlY3Q6IHgsXG4gICAgb2Zmc2V0UGFyZW50OiBFLFxuICAgIHN0cmF0ZWd5OiBjXG4gIH0pIDogeCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoaC50b3AgLSBiLnRvcCArIG0udG9wKSAvIE8ueSxcbiAgICBib3R0b206IChiLmJvdHRvbSAtIGguYm90dG9tICsgbS5ib3R0b20pIC8gTy55LFxuICAgIGxlZnQ6IChoLmxlZnQgLSBiLmxlZnQgKyBtLmxlZnQpIC8gTy54LFxuICAgIHJpZ2h0OiAoYi5yaWdodCAtIGgucmlnaHQgKyBtLnJpZ2h0KSAvIE8ueFxuICB9O1xufVxuY29uc3QgdXIgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHtcbiAgICBuYW1lOiBcImZsaXBcIixcbiAgICBvcHRpb25zOiBlLFxuICAgIGFzeW5jIGZuKHQpIHtcbiAgICAgIHZhciBuLCByO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQ6IGksXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhOiBvLFxuICAgICAgICByZWN0czogcyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudDogYSxcbiAgICAgICAgcGxhdGZvcm06IGMsXG4gICAgICAgIGVsZW1lbnRzOiB1XG4gICAgICB9ID0gdCwge1xuICAgICAgICBtYWluQXhpczogbCA9ICEwLFxuICAgICAgICBjcm9zc0F4aXM6IGYgPSAhMCxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB2LFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5OiBkID0gXCJiZXN0Rml0XCIsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb246IG0gPSBcIm5vbmVcIixcbiAgICAgICAgZmxpcEFsaWdubWVudDogcCA9ICEwLFxuICAgICAgICAuLi5nXG4gICAgICB9ID0gSGUoZSwgdCk7XG4gICAgICBpZiAoKG4gPSBvLmFycm93KSAhPSBudWxsICYmIG4uYWxpZ25tZW50T2Zmc2V0KVxuICAgICAgICByZXR1cm4ge307XG4gICAgICBjb25zdCBoID0gbGUoaSksIHggPSBpZShhKSwgRSA9IGxlKGEpID09PSBhLCBPID0gYXdhaXQgKGMuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IGMuaXNSVEwodS5mbG9hdGluZykpLCBiID0gdiB8fCAoRSB8fCAhcCA/IFtOZShhKV0gOiB0cihhKSksIFMgPSBtICE9PSBcIm5vbmVcIjtcbiAgICAgICF2ICYmIFMgJiYgYi5wdXNoKC4uLm9yKGEsIHAsIG0sIE8pKTtcbiAgICAgIGNvbnN0IEMgPSBbYSwgLi4uYl0sICQgPSBhd2FpdCBadCh0LCBnKSwgTSA9IFtdO1xuICAgICAgbGV0IFYgPSAoKHIgPSBvLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiByLm92ZXJmbG93cykgfHwgW107XG4gICAgICBpZiAobCAmJiBNLnB1c2goJFtoXSksIGYpIHtcbiAgICAgICAgY29uc3QgUSA9IGVyKGksIHMsIE8pO1xuICAgICAgICBNLnB1c2goJFtRWzBdXSwgJFtRWzFdXSk7XG4gICAgICB9XG4gICAgICBpZiAoViA9IFsuLi5WLCB7XG4gICAgICAgIHBsYWNlbWVudDogaSxcbiAgICAgICAgb3ZlcmZsb3dzOiBNXG4gICAgICB9XSwgIU0uZXZlcnkoKFEpID0+IFEgPD0gMCkpIHtcbiAgICAgICAgdmFyIFQsIF87XG4gICAgICAgIGNvbnN0IFEgPSAoKChUID0gby5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogVC5pbmRleCkgfHwgMCkgKyAxLCBTZSA9IENbUV07XG4gICAgICAgIGlmIChTZSAmJiAoIShmID09PSBcImFsaWdubWVudFwiID8geCAhPT0gaWUoU2UpIDogITEpIHx8IC8vIFdlIGxlYXZlIHRoZSBjdXJyZW50IG1haW4gYXhpcyBvbmx5IGlmIGV2ZXJ5IHBsYWNlbWVudCBvbiB0aGF0IGF4aXNcbiAgICAgICAgLy8gb3ZlcmZsb3dzIHRoZSBtYWluIGF4aXMuXG4gICAgICAgIFYuZXZlcnkoKFkpID0+IGllKFkucGxhY2VtZW50KSA9PT0geCA/IFkub3ZlcmZsb3dzWzBdID4gMCA6ICEwKSkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IFEsXG4gICAgICAgICAgICAgIG92ZXJmbG93czogVlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogU2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICBsZXQgVGUgPSAoXyA9IFYuZmlsdGVyKChhZSkgPT4gYWUub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGFlLCBZKSA9PiBhZS5vdmVyZmxvd3NbMV0gLSBZLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfLnBsYWNlbWVudDtcbiAgICAgICAgaWYgKCFUZSlcbiAgICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJiZXN0Rml0XCI6IHtcbiAgICAgICAgICAgICAgdmFyIGVlO1xuICAgICAgICAgICAgICBjb25zdCBhZSA9IChlZSA9IFYuZmlsdGVyKChZKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlID0gaWUoWS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlID09PSB4IHx8IC8vIENyZWF0ZSBhIGJpYXMgdG8gdGhlIGB5YCBzaWRlIGF4aXMgZHVlIHRvIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgZGlyZWN0aW9ucyBmYXZvcmluZyBncmVhdGVyIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgcmUgPT09IFwieVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIH0pLm1hcCgoWSkgPT4gW1kucGxhY2VtZW50LCBZLm92ZXJmbG93cy5maWx0ZXIoKHJlKSA9PiByZSA+IDApLnJlZHVjZSgocmUsIFluKSA9PiByZSArIFluLCAwKV0pLnNvcnQoKFksIHJlKSA9PiBZWzFdIC0gcmVbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogZWVbMF07XG4gICAgICAgICAgICAgIGFlICYmIChUZSA9IGFlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW5pdGlhbFBsYWNlbWVudFwiOlxuICAgICAgICAgICAgICBUZSA9IGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT09IFRlKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IFRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59LCBsciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImxlZnRcIiwgXCJ0b3BcIl0pO1xuYXN5bmMgZnVuY3Rpb24gZnIoZSwgdCkge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50OiBuLFxuICAgIHBsYXRmb3JtOiByLFxuICAgIGVsZW1lbnRzOiBpXG4gIH0gPSBlLCBvID0gYXdhaXQgKHIuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaXNSVEwoaS5mbG9hdGluZykpLCBzID0gbGUobiksIGEgPSB6ZShuKSwgYyA9IGllKG4pID09PSBcInlcIiwgdSA9IGxyLmhhcyhzKSA/IC0xIDogMSwgbCA9IG8gJiYgYyA/IC0xIDogMSwgZiA9IEhlKHQsIGUpO1xuICBsZXQge1xuICAgIG1haW5BeGlzOiB2LFxuICAgIGNyb3NzQXhpczogZCxcbiAgICBhbGlnbm1lbnRBeGlzOiBtXG4gIH0gPSB0eXBlb2YgZiA9PSBcIm51bWJlclwiID8ge1xuICAgIG1haW5BeGlzOiBmLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IGYubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IGYuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogZi5hbGlnbm1lbnRBeGlzXG4gIH07XG4gIHJldHVybiBhICYmIHR5cGVvZiBtID09IFwibnVtYmVyXCIgJiYgKGQgPSBhID09PSBcImVuZFwiID8gbSAqIC0xIDogbSksIGMgPyB7XG4gICAgeDogZCAqIGwsXG4gICAgeTogdiAqIHVcbiAgfSA6IHtcbiAgICB4OiB2ICogdSxcbiAgICB5OiBkICogbFxuICB9O1xufVxuY29uc3QgZHIgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwge1xuICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgb3B0aW9uczogZSxcbiAgICBhc3luYyBmbih0KSB7XG4gICAgICB2YXIgbiwgcjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogaSxcbiAgICAgICAgeTogbyxcbiAgICAgICAgcGxhY2VtZW50OiBzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YTogYVxuICAgICAgfSA9IHQsIGMgPSBhd2FpdCBmcih0LCBlKTtcbiAgICAgIHJldHVybiBzID09PSAoKG4gPSBhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4ucGxhY2VtZW50KSAmJiAociA9IGEuYXJyb3cpICE9IG51bGwgJiYgci5hbGlnbm1lbnRPZmZzZXQgPyB7fSA6IHtcbiAgICAgICAgeDogaSArIGMueCxcbiAgICAgICAgeTogbyArIGMueSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgcGxhY2VtZW50OiBzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgcHIgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHtcbiAgICBuYW1lOiBcInNoaWZ0XCIsXG4gICAgb3B0aW9uczogZSxcbiAgICBhc3luYyBmbih0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IG4sXG4gICAgICAgIHk6IHIsXG4gICAgICAgIHBsYWNlbWVudDogaVxuICAgICAgfSA9IHQsIHtcbiAgICAgICAgbWFpbkF4aXM6IG8gPSAhMCxcbiAgICAgICAgY3Jvc3NBeGlzOiBzID0gITEsXG4gICAgICAgIGxpbWl0ZXI6IGEgPSB7XG4gICAgICAgICAgZm46IChnKSA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgICB5OiB4XG4gICAgICAgICAgICB9ID0gZztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICAgIHk6IHhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5jXG4gICAgICB9ID0gSGUoZSwgdCksIHUgPSB7XG4gICAgICAgIHg6IG4sXG4gICAgICAgIHk6IHJcbiAgICAgIH0sIGwgPSBhd2FpdCBadCh0LCBjKSwgZiA9IGllKGxlKGkpKSwgdiA9IFF0KGYpO1xuICAgICAgbGV0IGQgPSB1W3ZdLCBtID0gdVtmXTtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGNvbnN0IGcgPSB2ID09PSBcInlcIiA/IFwidG9wXCIgOiBcImxlZnRcIiwgaCA9IHYgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgeCA9IGQgKyBsW2ddLCBFID0gZCAtIGxbaF07XG4gICAgICAgIGQgPSBFdCh4LCBkLCBFKTtcbiAgICAgIH1cbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGNvbnN0IGcgPSBmID09PSBcInlcIiA/IFwidG9wXCIgOiBcImxlZnRcIiwgaCA9IGYgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgeCA9IG0gKyBsW2ddLCBFID0gbSAtIGxbaF07XG4gICAgICAgIG0gPSBFdCh4LCBtLCBFKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBhLmZuKHtcbiAgICAgICAgLi4udCxcbiAgICAgICAgW3ZdOiBkLFxuICAgICAgICBbZl06IG1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IHAueCAtIG4sXG4gICAgICAgICAgeTogcC55IC0gcixcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbdl06IG8sXG4gICAgICAgICAgICBbZl06IHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIFllKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiO1xufVxuZnVuY3Rpb24geWUoZSkge1xuICByZXR1cm4gZW4oZSkgPyAoZS5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogXCIjZG9jdW1lbnRcIjtcbn1cbmZ1bmN0aW9uIGooZSkge1xuICB2YXIgdDtcbiAgcmV0dXJuIChlID09IG51bGwgfHwgKHQgPSBlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBaKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiAodCA9IChlbihlKSA/IGUub3duZXJEb2N1bWVudCA6IGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gZW4oZSkge1xuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBOb2RlIHx8IGUgaW5zdGFuY2VvZiBqKGUpLk5vZGUgOiAhMTtcbn1cbmZ1bmN0aW9uIEsoZSkge1xuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGUgaW5zdGFuY2VvZiBqKGUpLkVsZW1lbnQgOiAhMTtcbn1cbmZ1bmN0aW9uIFgoZSkge1xuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlIGluc3RhbmNlb2YgaihlKS5IVE1MRWxlbWVudCA6ICExO1xufVxuZnVuY3Rpb24gQXQoZSkge1xuICByZXR1cm4gIVllKCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIiA/ICExIDogZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgZSBpbnN0YW5jZW9mIGooZSkuU2hhZG93Um9vdDtcbn1cbmNvbnN0IGhyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5saW5lXCIsIFwiY29udGVudHNcIl0pO1xuZnVuY3Rpb24gQWUoZSkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3c6IHQsXG4gICAgb3ZlcmZsb3dYOiBuLFxuICAgIG92ZXJmbG93WTogcixcbiAgICBkaXNwbGF5OiBpXG4gIH0gPSBHKGUpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3QodCArIHIgKyBuKSAmJiAhaHIuaGFzKGkpO1xufVxuY29uc3QgdnIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0pO1xuZnVuY3Rpb24gbXIoZSkge1xuICByZXR1cm4gdnIuaGFzKHllKGUpKTtcbn1cbmNvbnN0IGdyID0gW1wiOnBvcG92ZXItb3BlblwiLCBcIjptb2RhbFwiXTtcbmZ1bmN0aW9uIHFlKGUpIHtcbiAgcmV0dXJuIGdyLnNvbWUoKHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUubWF0Y2hlcyh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgYnIgPSBbXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInBlcnNwZWN0aXZlXCJdLCB5ciA9IFtcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZVwiLCBcInNjYWxlXCIsIFwicm90YXRlXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJmaWx0ZXJcIl0sIHdyID0gW1wicGFpbnRcIiwgXCJsYXlvdXRcIiwgXCJzdHJpY3RcIiwgXCJjb250ZW50XCJdO1xuZnVuY3Rpb24gcHQoZSkge1xuICBjb25zdCB0ID0gaHQoKSwgbiA9IEsoZSkgPyBHKGUpIDogZTtcbiAgcmV0dXJuIGJyLnNvbWUoKHIpID0+IG5bcl0gPyBuW3JdICE9PSBcIm5vbmVcIiA6ICExKSB8fCAobi5jb250YWluZXJUeXBlID8gbi5jb250YWluZXJUeXBlICE9PSBcIm5vcm1hbFwiIDogITEpIHx8ICF0ICYmIChuLmJhY2tkcm9wRmlsdGVyID8gbi5iYWNrZHJvcEZpbHRlciAhPT0gXCJub25lXCIgOiAhMSkgfHwgIXQgJiYgKG4uZmlsdGVyID8gbi5maWx0ZXIgIT09IFwibm9uZVwiIDogITEpIHx8IHlyLnNvbWUoKHIpID0+IChuLndpbGxDaGFuZ2UgfHwgXCJcIikuaW5jbHVkZXMocikpIHx8IHdyLnNvbWUoKHIpID0+IChuLmNvbnRhaW4gfHwgXCJcIikuaW5jbHVkZXMocikpO1xufVxuZnVuY3Rpb24geHIoZSkge1xuICBsZXQgdCA9IHNlKGUpO1xuICBmb3IgKDsgWCh0KSAmJiAhbWUodCk7ICkge1xuICAgIGlmIChwdCh0KSlcbiAgICAgIHJldHVybiB0O1xuICAgIGlmIChxZSh0KSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHQgPSBzZSh0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGh0KCkge1xuICByZXR1cm4gdHlwZW9mIENTUyA+IFwidVwiIHx8ICFDU1Muc3VwcG9ydHMgPyAhMSA6IENTUy5zdXBwb3J0cyhcIi13ZWJraXQtYmFja2Ryb3AtZmlsdGVyXCIsIFwibm9uZVwiKTtcbn1cbmNvbnN0IFNyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0pO1xuZnVuY3Rpb24gbWUoZSkge1xuICByZXR1cm4gU3IuaGFzKHllKGUpKTtcbn1cbmZ1bmN0aW9uIEcoZSkge1xuICByZXR1cm4gaihlKS5nZXRDb21wdXRlZFN0eWxlKGUpO1xufVxuZnVuY3Rpb24gS2UoZSkge1xuICByZXR1cm4gSyhlKSA/IHtcbiAgICBzY3JvbGxMZWZ0OiBlLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlLnNjcm9sbFRvcFxuICB9IDoge1xuICAgIHNjcm9sbExlZnQ6IGUuc2Nyb2xsWCxcbiAgICBzY3JvbGxUb3A6IGUuc2Nyb2xsWVxuICB9O1xufVxuZnVuY3Rpb24gc2UoZSkge1xuICBpZiAoeWUoZSkgPT09IFwiaHRtbFwiKVxuICAgIHJldHVybiBlO1xuICBjb25zdCB0ID0gKFxuICAgIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICAgIGUuYXNzaWduZWRTbG90IHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICAgIGUucGFyZW50Tm9kZSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICAgIEF0KGUpICYmIGUuaG9zdCB8fCAvLyBGYWxsYmFjay5cbiAgICBaKGUpXG4gICk7XG4gIHJldHVybiBBdCh0KSA/IHQuaG9zdCA6IHQ7XG59XG5mdW5jdGlvbiB0bihlKSB7XG4gIGNvbnN0IHQgPSBzZShlKTtcbiAgcmV0dXJuIG1lKHQpID8gZS5vd25lckRvY3VtZW50ID8gZS5vd25lckRvY3VtZW50LmJvZHkgOiBlLmJvZHkgOiBYKHQpICYmIEFlKHQpID8gdCA6IHRuKHQpO1xufVxuZnVuY3Rpb24gQ2UoZSwgdCwgbikge1xuICB2YXIgcjtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gW10pLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMCk7XG4gIGNvbnN0IGkgPSB0bihlKSwgbyA9IGkgPT09ICgociA9IGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYm9keSksIHMgPSBqKGkpO1xuICBpZiAobykge1xuICAgIGNvbnN0IGEgPSBhdChzKTtcbiAgICByZXR1cm4gdC5jb25jYXQocywgcy52aXN1YWxWaWV3cG9ydCB8fCBbXSwgQWUoaSkgPyBpIDogW10sIGEgJiYgbiA/IENlKGEpIDogW10pO1xuICB9XG4gIHJldHVybiB0LmNvbmNhdChpLCBDZShpLCBbXSwgbikpO1xufVxuZnVuY3Rpb24gYXQoZSkge1xuICByZXR1cm4gZS5wYXJlbnQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUucGFyZW50KSA/IGUuZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG5uKGUpIHtcbiAgY29uc3QgdCA9IEcoZSk7XG4gIGxldCBuID0gcGFyc2VGbG9hdCh0LndpZHRoKSB8fCAwLCByID0gcGFyc2VGbG9hdCh0LmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaSA9IFgoZSksIG8gPSBpID8gZS5vZmZzZXRXaWR0aCA6IG4sIHMgPSBpID8gZS5vZmZzZXRIZWlnaHQgOiByLCBhID0gJGUobikgIT09IG8gfHwgJGUocikgIT09IHM7XG4gIHJldHVybiBhICYmIChuID0gbywgciA9IHMpLCB7XG4gICAgd2lkdGg6IG4sXG4gICAgaGVpZ2h0OiByLFxuICAgICQ6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHZ0KGUpIHtcbiAgcmV0dXJuIEsoZSkgPyBlIDogZS5jb250ZXh0RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGhlKGUpIHtcbiAgY29uc3QgdCA9IHZ0KGUpO1xuICBpZiAoIVgodCkpXG4gICAgcmV0dXJuIEooMSk7XG4gIGNvbnN0IG4gPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XG4gICAgd2lkdGg6IHIsXG4gICAgaGVpZ2h0OiBpLFxuICAgICQ6IG9cbiAgfSA9IG5uKHQpO1xuICBsZXQgcyA9IChvID8gJGUobi53aWR0aCkgOiBuLndpZHRoKSAvIHIsIGEgPSAobyA/ICRlKG4uaGVpZ2h0KSA6IG4uaGVpZ2h0KSAvIGk7XG4gIHJldHVybiAoIXMgfHwgIU51bWJlci5pc0Zpbml0ZShzKSkgJiYgKHMgPSAxKSwgKCFhIHx8ICFOdW1iZXIuaXNGaW5pdGUoYSkpICYmIChhID0gMSksIHtcbiAgICB4OiBzLFxuICAgIHk6IGFcbiAgfTtcbn1cbmNvbnN0IFRyID0gLyogQF9fUFVSRV9fICovIEooMCk7XG5mdW5jdGlvbiBybihlKSB7XG4gIGNvbnN0IHQgPSBqKGUpO1xuICByZXR1cm4gIWh0KCkgfHwgIXQudmlzdWFsVmlld3BvcnQgPyBUciA6IHtcbiAgICB4OiB0LnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogdC52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIEVyKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgIW4gfHwgdCAmJiBuICE9PSBqKGUpID8gITEgOiB0O1xufVxuZnVuY3Rpb24gZmUoZSwgdCwgbiwgcikge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSAhMSksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgY29uc3QgaSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB2dChlKTtcbiAgbGV0IHMgPSBKKDEpO1xuICB0ICYmIChyID8gSyhyKSAmJiAocyA9IGhlKHIpKSA6IHMgPSBoZShlKSk7XG4gIGNvbnN0IGEgPSBFcihvLCBuLCByKSA/IHJuKG8pIDogSigwKTtcbiAgbGV0IGMgPSAoaS5sZWZ0ICsgYS54KSAvIHMueCwgdSA9IChpLnRvcCArIGEueSkgLyBzLnksIGwgPSBpLndpZHRoIC8gcy54LCBmID0gaS5oZWlnaHQgLyBzLnk7XG4gIGlmIChvKSB7XG4gICAgY29uc3QgdiA9IGoobyksIGQgPSByICYmIEsocikgPyBqKHIpIDogcjtcbiAgICBsZXQgbSA9IHYsIHAgPSBhdChtKTtcbiAgICBmb3IgKDsgcCAmJiByICYmIGQgIT09IG07ICkge1xuICAgICAgY29uc3QgZyA9IGhlKHApLCBoID0gcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeCA9IEcocCksIEUgPSBoLmxlZnQgKyAocC5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdCh4LnBhZGRpbmdMZWZ0KSkgKiBnLngsIE8gPSBoLnRvcCArIChwLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoeC5wYWRkaW5nVG9wKSkgKiBnLnk7XG4gICAgICBjICo9IGcueCwgdSAqPSBnLnksIGwgKj0gZy54LCBmICo9IGcueSwgYyArPSBFLCB1ICs9IE8sIG0gPSBqKHApLCBwID0gYXQobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBGZSh7XG4gICAgd2lkdGg6IGwsXG4gICAgaGVpZ2h0OiBmLFxuICAgIHg6IGMsXG4gICAgeTogdVxuICB9KTtcbn1cbmZ1bmN0aW9uIEdlKGUsIHQpIHtcbiAgY29uc3QgbiA9IEtlKGUpLnNjcm9sbExlZnQ7XG4gIHJldHVybiB0ID8gdC5sZWZ0ICsgbiA6IGZlKFooZSkpLmxlZnQgKyBuO1xufVxuZnVuY3Rpb24gb24oZSwgdCkge1xuICBjb25zdCBuID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IG4ubGVmdCArIHQuc2Nyb2xsTGVmdCAtIEdlKGUsIG4pLCBpID0gbi50b3AgKyB0LnNjcm9sbFRvcDtcbiAgcmV0dXJuIHtcbiAgICB4OiByLFxuICAgIHk6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIENyKGUpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50czogdCxcbiAgICByZWN0OiBuLFxuICAgIG9mZnNldFBhcmVudDogcixcbiAgICBzdHJhdGVneTogaVxuICB9ID0gZTtcbiAgY29uc3QgbyA9IGkgPT09IFwiZml4ZWRcIiwgcyA9IFoociksIGEgPSB0ID8gcWUodC5mbG9hdGluZykgOiAhMTtcbiAgaWYgKHIgPT09IHMgfHwgYSAmJiBvKVxuICAgIHJldHVybiBuO1xuICBsZXQgYyA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9LCB1ID0gSigxKTtcbiAgY29uc3QgbCA9IEooMCksIGYgPSBYKHIpO1xuICBpZiAoKGYgfHwgIWYgJiYgIW8pICYmICgoeWUocikgIT09IFwiYm9keVwiIHx8IEFlKHMpKSAmJiAoYyA9IEtlKHIpKSwgWChyKSkpIHtcbiAgICBjb25zdCBkID0gZmUocik7XG4gICAgdSA9IGhlKHIpLCBsLnggPSBkLnggKyByLmNsaWVudExlZnQsIGwueSA9IGQueSArIHIuY2xpZW50VG9wO1xuICB9XG4gIGNvbnN0IHYgPSBzICYmICFmICYmICFvID8gb24ocywgYykgOiBKKDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBuLndpZHRoICogdS54LFxuICAgIGhlaWdodDogbi5oZWlnaHQgKiB1LnksXG4gICAgeDogbi54ICogdS54IC0gYy5zY3JvbGxMZWZ0ICogdS54ICsgbC54ICsgdi54LFxuICAgIHk6IG4ueSAqIHUueSAtIGMuc2Nyb2xsVG9wICogdS55ICsgbC55ICsgdi55XG4gIH07XG59XG5mdW5jdGlvbiBQcihlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGUuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5mdW5jdGlvbiBPcihlKSB7XG4gIGNvbnN0IHQgPSBaKGUpLCBuID0gS2UoZSksIHIgPSBlLm93bmVyRG9jdW1lbnQuYm9keSwgaSA9IHVlKHQuc2Nyb2xsV2lkdGgsIHQuY2xpZW50V2lkdGgsIHIuc2Nyb2xsV2lkdGgsIHIuY2xpZW50V2lkdGgpLCBvID0gdWUodC5zY3JvbGxIZWlnaHQsIHQuY2xpZW50SGVpZ2h0LCByLnNjcm9sbEhlaWdodCwgci5jbGllbnRIZWlnaHQpO1xuICBsZXQgcyA9IC1uLnNjcm9sbExlZnQgKyBHZShlKTtcbiAgY29uc3QgYSA9IC1uLnNjcm9sbFRvcDtcbiAgcmV0dXJuIEcocikuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChzICs9IHVlKHQuY2xpZW50V2lkdGgsIHIuY2xpZW50V2lkdGgpIC0gaSksIHtcbiAgICB3aWR0aDogaSxcbiAgICBoZWlnaHQ6IG8sXG4gICAgeDogcyxcbiAgICB5OiBhXG4gIH07XG59XG5jb25zdCBrdCA9IDI1O1xuZnVuY3Rpb24gQXIoZSwgdCkge1xuICBjb25zdCBuID0gaihlKSwgciA9IFooZSksIGkgPSBuLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgbyA9IHIuY2xpZW50V2lkdGgsIHMgPSByLmNsaWVudEhlaWdodCwgYSA9IDAsIGMgPSAwO1xuICBpZiAoaSkge1xuICAgIG8gPSBpLndpZHRoLCBzID0gaS5oZWlnaHQ7XG4gICAgY29uc3QgbCA9IGh0KCk7XG4gICAgKCFsIHx8IGwgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAoYSA9IGkub2Zmc2V0TGVmdCwgYyA9IGkub2Zmc2V0VG9wKTtcbiAgfVxuICBjb25zdCB1ID0gR2Uocik7XG4gIGlmICh1IDw9IDApIHtcbiAgICBjb25zdCBsID0gci5vd25lckRvY3VtZW50LCBmID0gbC5ib2R5LCB2ID0gZ2V0Q29tcHV0ZWRTdHlsZShmKSwgZCA9IGwuY29tcGF0TW9kZSA9PT0gXCJDU1MxQ29tcGF0XCIgJiYgcGFyc2VGbG9hdCh2Lm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdCh2Lm1hcmdpblJpZ2h0KSB8fCAwLCBtID0gTWF0aC5hYnMoci5jbGllbnRXaWR0aCAtIGYuY2xpZW50V2lkdGggLSBkKTtcbiAgICBtIDw9IGt0ICYmIChvIC09IG0pO1xuICB9IGVsc2UgdSA8PSBrdCAmJiAobyArPSB1KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHMsXG4gICAgeDogYSxcbiAgICB5OiBjXG4gIH07XG59XG5jb25zdCBrciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0pO1xuZnVuY3Rpb24gX3IoZSwgdCkge1xuICBjb25zdCBuID0gZmUoZSwgITAsIHQgPT09IFwiZml4ZWRcIiksIHIgPSBuLnRvcCArIGUuY2xpZW50VG9wLCBpID0gbi5sZWZ0ICsgZS5jbGllbnRMZWZ0LCBvID0gWChlKSA/IGhlKGUpIDogSigxKSwgcyA9IGUuY2xpZW50V2lkdGggKiBvLngsIGEgPSBlLmNsaWVudEhlaWdodCAqIG8ueSwgYyA9IGkgKiBvLngsIHUgPSByICogby55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogYSxcbiAgICB4OiBjLFxuICAgIHk6IHVcbiAgfTtcbn1cbmZ1bmN0aW9uIF90KGUsIHQsIG4pIHtcbiAgbGV0IHI7XG4gIGlmICh0ID09PSBcInZpZXdwb3J0XCIpXG4gICAgciA9IEFyKGUsIG4pO1xuICBlbHNlIGlmICh0ID09PSBcImRvY3VtZW50XCIpXG4gICAgciA9IE9yKFooZSkpO1xuICBlbHNlIGlmIChLKHQpKVxuICAgIHIgPSBfcih0LCBuKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgaSA9IHJuKGUpO1xuICAgIHIgPSB7XG4gICAgICB4OiB0LnggLSBpLngsXG4gICAgICB5OiB0LnkgLSBpLnksXG4gICAgICB3aWR0aDogdC53aWR0aCxcbiAgICAgIGhlaWdodDogdC5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiBGZShyKTtcbn1cbmZ1bmN0aW9uIHNuKGUsIHQpIHtcbiAgY29uc3QgbiA9IHNlKGUpO1xuICByZXR1cm4gbiA9PT0gdCB8fCAhSyhuKSB8fCBtZShuKSA/ICExIDogRyhuKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiIHx8IHNuKG4sIHQpO1xufVxuZnVuY3Rpb24gTHIoZSwgdCkge1xuICBjb25zdCBuID0gdC5nZXQoZSk7XG4gIGlmIChuKVxuICAgIHJldHVybiBuO1xuICBsZXQgciA9IENlKGUsIFtdLCAhMSkuZmlsdGVyKChhKSA9PiBLKGEpICYmIHllKGEpICE9PSBcImJvZHlcIiksIGkgPSBudWxsO1xuICBjb25zdCBvID0gRyhlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiO1xuICBsZXQgcyA9IG8gPyBzZShlKSA6IGU7XG4gIGZvciAoOyBLKHMpICYmICFtZShzKTsgKSB7XG4gICAgY29uc3QgYSA9IEcocyksIGMgPSBwdChzKTtcbiAgICAhYyAmJiBhLnBvc2l0aW9uID09PSBcImZpeGVkXCIgJiYgKGkgPSBudWxsKSwgKG8gPyAhYyAmJiAhaSA6ICFjICYmIGEucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgISFpICYmIGtyLmhhcyhpLnBvc2l0aW9uKSB8fCBBZShzKSAmJiAhYyAmJiBzbihlLCBzKSkgPyByID0gci5maWx0ZXIoKGwpID0+IGwgIT09IHMpIDogaSA9IGEsIHMgPSBzZShzKTtcbiAgfVxuICByZXR1cm4gdC5zZXQoZSwgciksIHI7XG59XG5mdW5jdGlvbiBJcihlKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudDogdCxcbiAgICBib3VuZGFyeTogbixcbiAgICByb290Qm91bmRhcnk6IHIsXG4gICAgc3RyYXRlZ3k6IGlcbiAgfSA9IGU7XG4gIGNvbnN0IHMgPSBbLi4ubiA9PT0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiID8gcWUodCkgPyBbXSA6IExyKHQsIHRoaXMuX2MpIDogW10uY29uY2F0KG4pLCByXSwgYSA9IHNbMF0sIGMgPSBzLnJlZHVjZSgodSwgbCkgPT4ge1xuICAgIGNvbnN0IGYgPSBfdCh0LCBsLCBpKTtcbiAgICByZXR1cm4gdS50b3AgPSB1ZShmLnRvcCwgdS50b3ApLCB1LnJpZ2h0ID0gRGUoZi5yaWdodCwgdS5yaWdodCksIHUuYm90dG9tID0gRGUoZi5ib3R0b20sIHUuYm90dG9tKSwgdS5sZWZ0ID0gdWUoZi5sZWZ0LCB1LmxlZnQpLCB1O1xuICB9LCBfdCh0LCBhLCBpKSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGMucmlnaHQgLSBjLmxlZnQsXG4gICAgaGVpZ2h0OiBjLmJvdHRvbSAtIGMudG9wLFxuICAgIHg6IGMubGVmdCxcbiAgICB5OiBjLnRvcFxuICB9O1xufVxuZnVuY3Rpb24gTXIoZSkge1xuICBjb25zdCB7XG4gICAgd2lkdGg6IHQsXG4gICAgaGVpZ2h0OiBuXG4gIH0gPSBubihlKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdCxcbiAgICBoZWlnaHQ6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFJyKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IFgodCksIGkgPSBaKHQpLCBvID0gbiA9PT0gXCJmaXhlZFwiLCBzID0gZmUoZSwgITAsIG8sIHQpO1xuICBsZXQgYSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBjID0gSigwKTtcbiAgZnVuY3Rpb24gdSgpIHtcbiAgICBjLnggPSBHZShpKTtcbiAgfVxuICBpZiAociB8fCAhciAmJiAhbylcbiAgICBpZiAoKHllKHQpICE9PSBcImJvZHlcIiB8fCBBZShpKSkgJiYgKGEgPSBLZSh0KSksIHIpIHtcbiAgICAgIGNvbnN0IGQgPSBmZSh0LCAhMCwgbywgdCk7XG4gICAgICBjLnggPSBkLnggKyB0LmNsaWVudExlZnQsIGMueSA9IGQueSArIHQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpICYmIHUoKTtcbiAgbyAmJiAhciAmJiBpICYmIHUoKTtcbiAgY29uc3QgbCA9IGkgJiYgIXIgJiYgIW8gPyBvbihpLCBhKSA6IEooMCksIGYgPSBzLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBjLnggLSBsLngsIHYgPSBzLnRvcCArIGEuc2Nyb2xsVG9wIC0gYy55IC0gbC55O1xuICByZXR1cm4ge1xuICAgIHg6IGYsXG4gICAgeTogdixcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBldChlKSB7XG4gIHJldHVybiBHKGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiO1xufVxuZnVuY3Rpb24gTHQoZSwgdCkge1xuICBpZiAoIVgoZSkgfHwgRyhlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodClcbiAgICByZXR1cm4gdChlKTtcbiAgbGV0IG4gPSBlLm9mZnNldFBhcmVudDtcbiAgcmV0dXJuIFooZSkgPT09IG4gJiYgKG4gPSBuLm93bmVyRG9jdW1lbnQuYm9keSksIG47XG59XG5mdW5jdGlvbiBhbihlLCB0KSB7XG4gIGNvbnN0IG4gPSBqKGUpO1xuICBpZiAocWUoZSkpXG4gICAgcmV0dXJuIG47XG4gIGlmICghWChlKSkge1xuICAgIGxldCBpID0gc2UoZSk7XG4gICAgZm9yICg7IGkgJiYgIW1lKGkpOyApIHtcbiAgICAgIGlmIChLKGkpICYmICFldChpKSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICBpID0gc2UoaSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGxldCByID0gTHQoZSwgdCk7XG4gIGZvciAoOyByICYmIG1yKHIpICYmIGV0KHIpOyApXG4gICAgciA9IEx0KHIsIHQpO1xuICByZXR1cm4gciAmJiBtZShyKSAmJiBldChyKSAmJiAhcHQocikgPyBuIDogciB8fCB4cihlKSB8fCBuO1xufVxuY29uc3QgRHIgPSBhc3luYyBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBhbiwgbiA9IHRoaXMuZ2V0RGltZW5zaW9ucywgciA9IGF3YWl0IG4oZS5mbG9hdGluZyk7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBScihlLnJlZmVyZW5jZSwgYXdhaXQgdChlLmZsb2F0aW5nKSwgZS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHIud2lkdGgsXG4gICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uICRyKGUpIHtcbiAgcmV0dXJuIEcoZSkuZGlyZWN0aW9uID09PSBcInJ0bFwiO1xufVxuY29uc3QgTnIgPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0OiBDcixcbiAgZ2V0RG9jdW1lbnRFbGVtZW50OiBaLFxuICBnZXRDbGlwcGluZ1JlY3Q6IElyLFxuICBnZXRPZmZzZXRQYXJlbnQ6IGFuLFxuICBnZXRFbGVtZW50UmVjdHM6IERyLFxuICBnZXRDbGllbnRSZWN0czogUHIsXG4gIGdldERpbWVuc2lvbnM6IE1yLFxuICBnZXRTY2FsZTogaGUsXG4gIGlzRWxlbWVudDogSyxcbiAgaXNSVEw6ICRyXG59O1xuZnVuY3Rpb24gY24oZSwgdCkge1xuICByZXR1cm4gZS54ID09PSB0LnggJiYgZS55ID09PSB0LnkgJiYgZS53aWR0aCA9PT0gdC53aWR0aCAmJiBlLmhlaWdodCA9PT0gdC5oZWlnaHQ7XG59XG5mdW5jdGlvbiBGcihlLCB0KSB7XG4gIGxldCBuID0gbnVsbCwgcjtcbiAgY29uc3QgaSA9IFooZSk7XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgdmFyIGE7XG4gICAgY2xlYXJUaW1lb3V0KHIpLCAoYSA9IG4pID09IG51bGwgfHwgYS5kaXNjb25uZWN0KCksIG4gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHMoYSwgYykge1xuICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9ICExKSwgYyA9PT0gdm9pZCAwICYmIChjID0gMSksIG8oKTtcbiAgICBjb25zdCB1ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwge1xuICAgICAgbGVmdDogbCxcbiAgICAgIHRvcDogZixcbiAgICAgIHdpZHRoOiB2LFxuICAgICAgaGVpZ2h0OiBkXG4gICAgfSA9IHU7XG4gICAgaWYgKGEgfHwgdCgpLCAhdiB8fCAhZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBtID0gX2UoZiksIHAgPSBfZShpLmNsaWVudFdpZHRoIC0gKGwgKyB2KSksIGcgPSBfZShpLmNsaWVudEhlaWdodCAtIChmICsgZCkpLCBoID0gX2UobCksIEUgPSB7XG4gICAgICByb290TWFyZ2luOiAtbSArIFwicHggXCIgKyAtcCArIFwicHggXCIgKyAtZyArIFwicHggXCIgKyAtaCArIFwicHhcIixcbiAgICAgIHRocmVzaG9sZDogdWUoMCwgRGUoMSwgYykpIHx8IDFcbiAgICB9O1xuICAgIGxldCBPID0gITA7XG4gICAgZnVuY3Rpb24gYihTKSB7XG4gICAgICBjb25zdCBDID0gU1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChDICE9PSBjKSB7XG4gICAgICAgIGlmICghTylcbiAgICAgICAgICByZXR1cm4gcygpO1xuICAgICAgICBDID8gcyghMSwgQykgOiByID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcyghMSwgMWUtNyk7XG4gICAgICAgIH0sIDFlMyk7XG4gICAgICB9XG4gICAgICBDID09PSAxICYmICFjbih1LCBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSAmJiBzKCksIE8gPSAhMTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG4gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoYiwge1xuICAgICAgICAuLi5FLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IGkub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBuID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGIsIEUpO1xuICAgIH1cbiAgICBuLm9ic2VydmUoZSk7XG4gIH1cbiAgcmV0dXJuIHMoITApLCBvO1xufVxuZnVuY3Rpb24gVXIoZSwgdCwgbiwgcikge1xuICByID09PSB2b2lkIDAgJiYgKHIgPSB7fSk7XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbDogaSA9ICEwLFxuICAgIGFuY2VzdG9yUmVzaXplOiBvID0gITAsXG4gICAgZWxlbWVudFJlc2l6ZTogcyA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIsXG4gICAgbGF5b3V0U2hpZnQ6IGEgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiLFxuICAgIGFuaW1hdGlvbkZyYW1lOiBjID0gITFcbiAgfSA9IHIsIHUgPSB2dChlKSwgbCA9IGkgfHwgbyA/IFsuLi51ID8gQ2UodSkgOiBbXSwgLi4uQ2UodCldIDogW107XG4gIGwuZm9yRWFjaCgoaCkgPT4ge1xuICAgIGkgJiYgaC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG4sIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIG8gJiYgaC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG4pO1xuICB9KTtcbiAgY29uc3QgZiA9IHUgJiYgYSA/IEZyKHUsIG4pIDogbnVsbDtcbiAgbGV0IHYgPSAtMSwgZCA9IG51bGw7XG4gIHMgJiYgKGQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGgpID0+IHtcbiAgICBsZXQgW3hdID0gaDtcbiAgICB4ICYmIHgudGFyZ2V0ID09PSB1ICYmIGQgJiYgKGQudW5vYnNlcnZlKHQpLCBjYW5jZWxBbmltYXRpb25GcmFtZSh2KSwgdiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB2YXIgRTtcbiAgICAgIChFID0gZCkgPT0gbnVsbCB8fCBFLm9ic2VydmUodCk7XG4gICAgfSkpLCBuKCk7XG4gIH0pLCB1ICYmICFjICYmIGQub2JzZXJ2ZSh1KSwgZC5vYnNlcnZlKHQpKTtcbiAgbGV0IG0sIHAgPSBjID8gZmUoZSkgOiBudWxsO1xuICBjICYmIGcoKTtcbiAgZnVuY3Rpb24gZygpIHtcbiAgICBjb25zdCBoID0gZmUoZSk7XG4gICAgcCAmJiAhY24ocCwgaCkgJiYgbigpLCBwID0gaCwgbSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShnKTtcbiAgfVxuICByZXR1cm4gbigpLCAoKSA9PiB7XG4gICAgdmFyIGg7XG4gICAgbC5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICBpICYmIHgucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBuKSwgbyAmJiB4LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbik7XG4gICAgfSksIGYgPT0gbnVsbCB8fCBmKCksIChoID0gZCkgPT0gbnVsbCB8fCBoLmRpc2Nvbm5lY3QoKSwgZCA9IG51bGwsIGMgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUobSk7XG4gIH07XG59XG5jb25zdCBXciA9IGRyLCBqciA9IHByLCBCciA9IHVyLCBWciA9IChlLCB0LCBuKSA9PiB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBpID0ge1xuICAgIHBsYXRmb3JtOiBOcixcbiAgICAuLi5uXG4gIH0sIG8gPSB7XG4gICAgLi4uaS5wbGF0Zm9ybSxcbiAgICBfYzogclxuICB9O1xuICByZXR1cm4gY3IoZSwgdCwge1xuICAgIC4uLmksXG4gICAgcGxhdGZvcm06IG9cbiAgfSk7XG59O1xudmFyIGVzID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gSHIoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiZGVmYXVsdFwiKSA/IGUuZGVmYXVsdCA6IGU7XG59XG52YXIgTWUgPSB7IGV4cG9ydHM6IHt9IH0sIHpyID0gTWUuZXhwb3J0cywgSXQ7XG5mdW5jdGlvbiBZcigpIHtcbiAgcmV0dXJuIEl0IHx8IChJdCA9IDEsIChmdW5jdGlvbihlKSB7XG4gICAgKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgIGUuZXhwb3J0cyA/IGUuZXhwb3J0cyA9IG4oKSA6IHQubG9nID0gbigpO1xuICAgIH0pKHpyLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB9LCBuID0gXCJ1bmRlZmluZWRcIiwgciA9IHR5cGVvZiB3aW5kb3cgIT09IG4gJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IG4gJiYgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLCBpID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICAgIF0sIG8gPSB7fSwgcyA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBhKHAsIGcpIHtcbiAgICAgICAgdmFyIGggPSBwW2ddO1xuICAgICAgICBpZiAodHlwZW9mIGguYmluZCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGguYmluZChwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChoLCBwKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShoLCBbcCwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgY29uc29sZS5sb2cgJiYgKGNvbnNvbGUubG9nLmFwcGx5ID8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKSA6IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pKSwgY29uc29sZS50cmFjZSAmJiBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KHApIHtcbiAgICAgICAgcmV0dXJuIHAgPT09IFwiZGVidWdcIiAmJiAocCA9IFwibG9nXCIpLCB0eXBlb2YgY29uc29sZSA9PT0gbiA/ICExIDogcCA9PT0gXCJ0cmFjZVwiICYmIHIgPyBjIDogY29uc29sZVtwXSAhPT0gdm9pZCAwID8gYShjb25zb2xlLCBwKSA6IGNvbnNvbGUubG9nICE9PSB2b2lkIDAgPyBhKGNvbnNvbGUsIFwibG9nXCIpIDogdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSB0aGlzLmdldExldmVsKCksIGcgPSAwOyBnIDwgaS5sZW5ndGg7IGcrKykge1xuICAgICAgICAgIHZhciBoID0gaVtnXTtcbiAgICAgICAgICB0aGlzW2hdID0gZyA8IHAgPyB0IDogdGhpcy5tZXRob2RGYWN0b3J5KGgsIHAsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9nID0gdGhpcy5kZWJ1ZywgdHlwZW9mIGNvbnNvbGUgPT09IG4gJiYgcCA8IHRoaXMubGV2ZWxzLlNJTEVOVClcbiAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gbiAmJiAobC5jYWxsKHRoaXMpLCB0aGlzW3BdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdihwLCBnLCBoKSB7XG4gICAgICAgIHJldHVybiB1KHApIHx8IGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGQocCwgZykge1xuICAgICAgICB2YXIgaCA9IHRoaXMsIHgsIEUsIE8sIGIgPSBcImxvZ2xldmVsXCI7XG4gICAgICAgIHR5cGVvZiBwID09IFwic3RyaW5nXCIgPyBiICs9IFwiOlwiICsgcCA6IHR5cGVvZiBwID09IFwic3ltYm9sXCIgJiYgKGIgPSB2b2lkIDApO1xuICAgICAgICBmdW5jdGlvbiBTKFQpIHtcbiAgICAgICAgICB2YXIgXyA9IChpW1RdIHx8IFwic2lsZW50XCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gbiB8fCAhYikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbYl0gPSBfO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoYikgKyBcIj1cIiArIF8gKyBcIjtcIjtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDKCkge1xuICAgICAgICAgIHZhciBUO1xuICAgICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT09IG4gfHwgIWIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBUID0gd2luZG93LmxvY2FsU3RvcmFnZVtiXTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSBuKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBfID0gd2luZG93LmRvY3VtZW50LmNvb2tpZSwgZWUgPSBlbmNvZGVVUklDb21wb25lbnQoYiksIFEgPSBfLmluZGV4T2YoZWUgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgUSAhPT0gLTEgJiYgKFQgPSAvXihbXjtdKykvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICBfLnNsaWNlKFEgKyBlZS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgIClbMV0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGgubGV2ZWxzW1RdID09PSB2b2lkIDAgJiYgKFQgPSB2b2lkIDApLCBUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiAkKCkge1xuICAgICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT09IG4gfHwgIWIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYik7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoYikgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBNKFQpIHtcbiAgICAgICAgICB2YXIgXyA9IFQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfID09IFwic3RyaW5nXCIgJiYgaC5sZXZlbHNbXy50b1VwcGVyQ2FzZSgpXSAhPT0gdm9pZCAwICYmIChfID0gaC5sZXZlbHNbXy50b1VwcGVyQ2FzZSgpXSksIHR5cGVvZiBfID09IFwibnVtYmVyXCIgJiYgXyA+PSAwICYmIF8gPD0gaC5sZXZlbHMuU0lMRU5UKVxuICAgICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgVCk7XG4gICAgICAgIH1cbiAgICAgICAgaC5uYW1lID0gcCwgaC5sZXZlbHMgPSB7XG4gICAgICAgICAgVFJBQ0U6IDAsXG4gICAgICAgICAgREVCVUc6IDEsXG4gICAgICAgICAgSU5GTzogMixcbiAgICAgICAgICBXQVJOOiAzLFxuICAgICAgICAgIEVSUk9SOiA0LFxuICAgICAgICAgIFNJTEVOVDogNVxuICAgICAgICB9LCBoLm1ldGhvZEZhY3RvcnkgPSBnIHx8IHYsIGguZ2V0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTyA/PyBFID8/IHg7XG4gICAgICAgIH0sIGguc2V0TGV2ZWwgPSBmdW5jdGlvbihULCBfKSB7XG4gICAgICAgICAgcmV0dXJuIE8gPSBNKFQpLCBfICE9PSAhMSAmJiBTKE8pLCBsLmNhbGwoaCk7XG4gICAgICAgIH0sIGguc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24oVCkge1xuICAgICAgICAgIEUgPSBNKFQpLCBDKCkgfHwgaC5zZXRMZXZlbChULCAhMSk7XG4gICAgICAgIH0sIGgucmVzZXRMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIE8gPSBudWxsLCAkKCksIGwuY2FsbChoKTtcbiAgICAgICAgfSwgaC5lbmFibGVBbGwgPSBmdW5jdGlvbihUKSB7XG4gICAgICAgICAgaC5zZXRMZXZlbChoLmxldmVscy5UUkFDRSwgVCk7XG4gICAgICAgIH0sIGguZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICBoLnNldExldmVsKGgubGV2ZWxzLlNJTEVOVCwgVCk7XG4gICAgICAgIH0sIGgucmVidWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChzICE9PSBoICYmICh4ID0gTShzLmdldExldmVsKCkpKSwgbC5jYWxsKGgpLCBzID09PSBoKVxuICAgICAgICAgICAgZm9yICh2YXIgVCBpbiBvKVxuICAgICAgICAgICAgICBvW1RdLnJlYnVpbGQoKTtcbiAgICAgICAgfSwgeCA9IE0oXG4gICAgICAgICAgcyA/IHMuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiXG4gICAgICAgICk7XG4gICAgICAgIHZhciBWID0gQygpO1xuICAgICAgICBWICE9IG51bGwgJiYgKE8gPSBNKFYpKSwgbC5jYWxsKGgpO1xuICAgICAgfVxuICAgICAgcyA9IG5ldyBkKCksIHMuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oZykge1xuICAgICAgICBpZiAodHlwZW9mIGcgIT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgZyAhPSBcInN0cmluZ1wiIHx8IGcgPT09IFwiXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIHZhciBoID0gb1tnXTtcbiAgICAgICAgcmV0dXJuIGggfHwgKGggPSBvW2ddID0gbmV3IGQoXG4gICAgICAgICAgZyxcbiAgICAgICAgICBzLm1ldGhvZEZhY3RvcnlcbiAgICAgICAgKSksIGg7XG4gICAgICB9O1xuICAgICAgdmFyIG0gPSB0eXBlb2Ygd2luZG93ICE9PSBuID8gd2luZG93LmxvZyA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IG4gJiYgd2luZG93LmxvZyA9PT0gcyAmJiAod2luZG93LmxvZyA9IG0pLCBzO1xuICAgICAgfSwgcy5nZXRMb2dnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSwgcy5kZWZhdWx0ID0gcywgcztcbiAgICB9KTtcbiAgfSkoTWUpKSwgTWUuZXhwb3J0cztcbn1cbnZhciBxciA9IFlyKCk7XG5jb25zdCBLciA9IC8qIEBfX1BVUkVfXyAqLyBIcihxcik7XG52YXIgY3QgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBjdCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBuLl9fcHJvdG9fXyA9IHI7XG4gIH0gfHwgZnVuY3Rpb24obiwgcikge1xuICAgIGZvciAodmFyIGkgaW4gcikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIGkpICYmIChuW2ldID0gcltpXSk7XG4gIH0sIGN0KGUsIHQpO1xufTtcbmZ1bmN0aW9uIG5lKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiB0ICE9PSBudWxsKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHQpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgY3QoZSwgdCk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGU7XG4gIH1cbiAgZS5wcm90b3R5cGUgPSB0ID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZSh0KSA6IChuLnByb3RvdHlwZSA9IHQucHJvdG90eXBlLCBuZXcgbigpKTtcbn1cbmZ1bmN0aW9uIEdyKGUsIHQsIG4sIHIpIHtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBuID8gbyA6IG5ldyBuKGZ1bmN0aW9uKHMpIHtcbiAgICAgIHMobyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAobiB8fCAobiA9IFByb21pc2UpKShmdW5jdGlvbihvLCBzKSB7XG4gICAgZnVuY3Rpb24gYShsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB1KHIubmV4dChsKSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIHMoZik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGMobCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdShyLnRocm93KGwpKTtcbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgcyhmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdShsKSB7XG4gICAgICBsLmRvbmUgPyBvKGwudmFsdWUpIDogaShsLnZhbHVlKS50aGVuKGEsIGMpO1xuICAgIH1cbiAgICB1KChyID0gci5hcHBseShlLCB0IHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bihlLCB0KSB7XG4gIHZhciBuID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKG9bMF0gJiAxKSB0aHJvdyBvWzFdO1xuICAgIHJldHVybiBvWzFdO1xuICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCByLCBpLCBvLCBzID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gcy5uZXh0ID0gYSgwKSwgcy50aHJvdyA9IGEoMSksIHMucmV0dXJuID0gYSgyKSwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgKHNbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgcztcbiAgZnVuY3Rpb24gYSh1KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBjKFt1LCBsXSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjKHUpIHtcbiAgICBpZiAocikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgZm9yICg7IHMgJiYgKHMgPSAwLCB1WzBdICYmIChuID0gMCkpLCBuOyApIHRyeSB7XG4gICAgICBpZiAociA9IDEsIGkgJiYgKG8gPSB1WzBdICYgMiA/IGkucmV0dXJuIDogdVswXSA/IGkudGhyb3cgfHwgKChvID0gaS5yZXR1cm4pICYmIG8uY2FsbChpKSwgMCkgOiBpLm5leHQpICYmICEobyA9IG8uY2FsbChpLCB1WzFdKSkuZG9uZSkgcmV0dXJuIG87XG4gICAgICBzd2l0Y2ggKGkgPSAwLCBvICYmICh1ID0gW3VbMF0gJiAyLCBvLnZhbHVlXSksIHVbMF0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbyA9IHU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gbi5sYWJlbCsrLCB7IHZhbHVlOiB1WzFdLCBkb25lOiAhMSB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgbi5sYWJlbCsrLCBpID0gdVsxXSwgdSA9IFswXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHUgPSBuLm9wcy5wb3AoKSwgbi50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChvID0gbi50cnlzLCAhKG8gPSBvLmxlbmd0aCA+IDAgJiYgb1tvLmxlbmd0aCAtIDFdKSAmJiAodVswXSA9PT0gNiB8fCB1WzBdID09PSAyKSkge1xuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVbMF0gPT09IDMgJiYgKCFvIHx8IHVbMV0gPiBvWzBdICYmIHVbMV0gPCBvWzNdKSkge1xuICAgICAgICAgICAgbi5sYWJlbCA9IHVbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVbMF0gPT09IDYgJiYgbi5sYWJlbCA8IG9bMV0pIHtcbiAgICAgICAgICAgIG4ubGFiZWwgPSBvWzFdLCBvID0gdTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobyAmJiBuLmxhYmVsIDwgb1syXSkge1xuICAgICAgICAgICAgbi5sYWJlbCA9IG9bMl0sIG4ub3BzLnB1c2godSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgb1syXSAmJiBuLm9wcy5wb3AoKSwgbi50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IHQuY2FsbChlLCBuKTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICB1ID0gWzYsIGxdLCBpID0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgciA9IG8gPSAwO1xuICAgIH1cbiAgICBpZiAodVswXSAmIDUpIHRocm93IHVbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVbMF0gPyB1WzFdIDogdm9pZCAwLCBkb25lOiAhMCB9O1xuICB9XG59XG5mdW5jdGlvbiBnZShlKSB7XG4gIHZhciB0ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBuID0gdCAmJiBlW3RdLCByID0gMDtcbiAgaWYgKG4pIHJldHVybiBuLmNhbGwoZSk7XG4gIGlmIChlICYmIHR5cGVvZiBlLmxlbmd0aCA9PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUgJiYgciA+PSBlLmxlbmd0aCAmJiAoZSA9IHZvaWQgMCksIHsgdmFsdWU6IGUgJiYgZVtyKytdLCBkb25lOiAhZSB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcih0ID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gZGUoZSwgdCkge1xuICB2YXIgbiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFuKSByZXR1cm4gZTtcbiAgdmFyIHIgPSBuLmNhbGwoZSksIGksIG8gPSBbXSwgcztcbiAgdHJ5IHtcbiAgICBmb3IgKDsgKHQgPT09IHZvaWQgMCB8fCB0LS0gPiAwKSAmJiAhKGkgPSByLm5leHQoKSkuZG9uZTsgKSBvLnB1c2goaS52YWx1ZSk7XG4gIH0gY2F0Y2ggKGEpIHtcbiAgICBzID0geyBlcnJvcjogYSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpICYmICFpLmRvbmUgJiYgKG4gPSByLnJldHVybikgJiYgbi5jYWxsKHIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocykgdGhyb3cgcy5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBiZShlLCB0LCBuKSB7XG4gIGlmIChuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGgsIG87IHIgPCBpOyByKyspXG4gICAgKG8gfHwgIShyIGluIHQpKSAmJiAobyB8fCAobyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsIDAsIHIpKSwgb1tyXSA9IHRbcl0pO1xuICByZXR1cm4gZS5jb25jYXQobyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KSk7XG59XG5mdW5jdGlvbiB2ZShlKSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgdmUgPyAodGhpcy52ID0gZSwgdGhpcykgOiBuZXcgdmUoZSk7XG59XG5mdW5jdGlvbiBRcihlLCB0LCBuKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciByID0gbi5hcHBseShlLCB0IHx8IFtdKSwgaSwgbyA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIGEoXCJuZXh0XCIpLCBhKFwidGhyb3dcIiksIGEoXCJyZXR1cm5cIiwgcyksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIGk7XG4gIGZ1bmN0aW9uIHMoZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG0pLnRoZW4oZCwgZik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhKGQsIG0pIHtcbiAgICByW2RdICYmIChpW2RdID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGcsIGgpIHtcbiAgICAgICAgby5wdXNoKFtkLCBwLCBnLCBoXSkgPiAxIHx8IGMoZCwgcCk7XG4gICAgICB9KTtcbiAgICB9LCBtICYmIChpW2RdID0gbShpW2RdKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGMoZCwgbSkge1xuICAgIHRyeSB7XG4gICAgICB1KHJbZF0obSkpO1xuICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgIHYob1swXVszXSwgcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHUoZCkge1xuICAgIGQudmFsdWUgaW5zdGFuY2VvZiB2ZSA/IFByb21pc2UucmVzb2x2ZShkLnZhbHVlLnYpLnRoZW4obCwgZikgOiB2KG9bMF1bMl0sIGQpO1xuICB9XG4gIGZ1bmN0aW9uIGwoZCkge1xuICAgIGMoXCJuZXh0XCIsIGQpO1xuICB9XG4gIGZ1bmN0aW9uIGYoZCkge1xuICAgIGMoXCJ0aHJvd1wiLCBkKTtcbiAgfVxuICBmdW5jdGlvbiB2KGQsIG0pIHtcbiAgICBkKG0pLCBvLnNoaWZ0KCksIG8ubGVuZ3RoICYmIGMob1swXVswXSwgb1swXVsxXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEpyKGUpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIHQgPSBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgbjtcbiAgcmV0dXJuIHQgPyB0LmNhbGwoZSkgOiAoZSA9IHR5cGVvZiBnZSA9PSBcImZ1bmN0aW9uXCIgPyBnZShlKSA6IGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBuID0ge30sIHIoXCJuZXh0XCIpLCByKFwidGhyb3dcIiksIHIoXCJyZXR1cm5cIiksIG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIG4pO1xuICBmdW5jdGlvbiByKG8pIHtcbiAgICBuW29dID0gZVtvXSAmJiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYSwgYykge1xuICAgICAgICBzID0gZVtvXShzKSwgaShhLCBjLCBzLmRvbmUsIHMudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpKG8sIHMsIGEsIGMpIHtcbiAgICBQcm9taXNlLnJlc29sdmUoYykudGhlbihmdW5jdGlvbih1KSB7XG4gICAgICBvKHsgdmFsdWU6IHUsIGRvbmU6IGEgfSk7XG4gICAgfSwgcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFAoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gbXQoZSkge1xuICB2YXIgdCA9IGZ1bmN0aW9uKHIpIHtcbiAgICBFcnJvci5jYWxsKHIpLCByLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH0sIG4gPSBlKHQpO1xuICByZXR1cm4gbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSksIG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbiwgbjtcbn1cbnZhciB0dCA9IG10KGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICBlKHRoaXMpLCB0aGlzLm1lc3NhZ2UgPSBuID8gbi5sZW5ndGggKyBgIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XG5gICsgbi5tYXAoZnVuY3Rpb24ociwgaSkge1xuICAgICAgcmV0dXJuIGkgKyAxICsgXCIpIFwiICsgci50b1N0cmluZygpO1xuICAgIH0pLmpvaW4oYFxuICBgKSA6IFwiXCIsIHRoaXMubmFtZSA9IFwiVW5zdWJzY3JpcHRpb25FcnJvclwiLCB0aGlzLmVycm9ycyA9IG47XG4gIH07XG59KTtcbmZ1bmN0aW9uIFVlKGUsIHQpIHtcbiAgaWYgKGUpIHtcbiAgICB2YXIgbiA9IGUuaW5kZXhPZih0KTtcbiAgICAwIDw9IG4gJiYgZS5zcGxpY2UobiwgMSk7XG4gIH1cbn1cbnZhciBrZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSB0LCB0aGlzLmNsb3NlZCA9ICExLCB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsLCB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgfVxuICByZXR1cm4gZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCwgbiwgciwgaSwgbztcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9ICEwO1xuICAgICAgdmFyIHMgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICBpZiAocylcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudGFnZSA9IG51bGwsIEFycmF5LmlzQXJyYXkocykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBnZShzKSwgYyA9IGEubmV4dCgpOyAhYy5kb25lOyBjID0gYS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBjLnZhbHVlO1xuICAgICAgICAgICAgICB1LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICB0ID0geyBlcnJvcjogcCB9O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjICYmICFjLmRvbmUgJiYgKG4gPSBhLnJldHVybikgJiYgbi5jYWxsKGEpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKHQpIHRocm93IHQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcy5yZW1vdmUodGhpcyk7XG4gICAgICB2YXIgbCA9IHRoaXMuaW5pdGlhbFRlYXJkb3duO1xuICAgICAgaWYgKFAobCkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbCgpO1xuICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgbyA9IHAgaW5zdGFuY2VvZiB0dCA/IHAuZXJyb3JzIDogW3BdO1xuICAgICAgICB9XG4gICAgICB2YXIgZiA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgICBpZiAoZikge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciB2ID0gZ2UoZiksIGQgPSB2Lm5leHQoKTsgIWQuZG9uZTsgZCA9IHYubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGQudmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBNdChtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgICAgICAgbyA9IG8gPz8gW10sIHAgaW5zdGFuY2VvZiB0dCA/IG8gPSBiZShiZShbXSwgZGUobykpLCBkZShwLmVycm9ycykpIDogby5wdXNoKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICAgIHIgPSB7IGVycm9yOiBwIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGQgJiYgIWQuZG9uZSAmJiAoaSA9IHYucmV0dXJuKSAmJiBpLmNhbGwodik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChyKSB0aHJvdyByLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG8pXG4gICAgICAgIHRocm93IG5ldyB0dChvKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbjtcbiAgICBpZiAodCAmJiB0ICE9PSB0aGlzKVxuICAgICAgaWYgKHRoaXMuY2xvc2VkKVxuICAgICAgICBNdCh0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGUpIHtcbiAgICAgICAgICBpZiAodC5jbG9zZWQgfHwgdC5faGFzUGFyZW50KHRoaXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHQuX2FkZFBhcmVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAodGhpcy5fZmluYWxpemVycyA9IChuID0gdGhpcy5fZmluYWxpemVycykgIT09IG51bGwgJiYgbiAhPT0gdm9pZCAwID8gbiA6IFtdKS5wdXNoKHQpO1xuICAgICAgfVxuICB9LCBlLnByb3RvdHlwZS5faGFzUGFyZW50ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBuID0gdGhpcy5fcGFyZW50YWdlO1xuICAgIHJldHVybiBuID09PSB0IHx8IEFycmF5LmlzQXJyYXkobikgJiYgbi5pbmNsdWRlcyh0KTtcbiAgfSwgZS5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICB0aGlzLl9wYXJlbnRhZ2UgPSBBcnJheS5pc0FycmF5KG4pID8gKG4ucHVzaCh0KSwgbikgOiBuID8gW24sIHRdIDogdDtcbiAgfSwgZS5wcm90b3R5cGUuX3JlbW92ZVBhcmVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICBuID09PSB0ID8gdGhpcy5fcGFyZW50YWdlID0gbnVsbCA6IEFycmF5LmlzQXJyYXkobikgJiYgVWUobiwgdCk7XG4gIH0sIGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgbiAmJiBVZShuLCB0KSwgdCBpbnN0YW5jZW9mIGUgJiYgdC5fcmVtb3ZlUGFyZW50KHRoaXMpO1xuICB9LCBlLkVNUFRZID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbmV3IGUoKTtcbiAgICByZXR1cm4gdC5jbG9zZWQgPSAhMCwgdDtcbiAgfSkoKSwgZTtcbn0pKCksIGxuID0ga2UuRU1QVFk7XG5mdW5jdGlvbiBmbihlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2Yga2UgfHwgZSAmJiBcImNsb3NlZFwiIGluIGUgJiYgUChlLnJlbW92ZSkgJiYgUChlLmFkZCkgJiYgUChlLnVuc3Vic2NyaWJlKTtcbn1cbmZ1bmN0aW9uIE10KGUpIHtcbiAgUChlKSA/IGUoKSA6IGUudW5zdWJzY3JpYmUoKTtcbn1cbnZhciBYciA9IHtcbiAgUHJvbWlzZTogdm9pZCAwXG59LCBaciA9IHtcbiAgc2V0VGltZW91dDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgciA9IDI7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspXG4gICAgICBuW3IgLSAyXSA9IGFyZ3VtZW50c1tyXTtcbiAgICByZXR1cm4gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIGJlKFtlLCB0XSwgZGUobikpKTtcbiAgfSxcbiAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChlKTtcbiAgfSxcbiAgZGVsZWdhdGU6IHZvaWQgMFxufTtcbmZ1bmN0aW9uIGRuKGUpIHtcbiAgWnIuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFdlKCkge1xufVxuZnVuY3Rpb24gUmUoZSkge1xuICBlKCk7XG59XG52YXIgZ3QgPSAoZnVuY3Rpb24oZSkge1xuICBuZSh0LCBlKTtcbiAgZnVuY3Rpb24gdChuKSB7XG4gICAgdmFyIHIgPSBlLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXR1cm4gci5pc1N0b3BwZWQgPSAhMSwgbiA/IChyLmRlc3RpbmF0aW9uID0gbiwgZm4obikgJiYgbi5hZGQocikpIDogci5kZXN0aW5hdGlvbiA9IG5pLCByO1xuICB9XG4gIHJldHVybiB0LmNyZWF0ZSA9IGZ1bmN0aW9uKG4sIHIsIGkpIHtcbiAgICByZXR1cm4gbmV3IFBlKG4sIHIsIGkpO1xuICB9LCB0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuX25leHQobik7XG4gIH0sIHQucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuaXNTdG9wcGVkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCB0aGlzLl9lcnJvcihuKSk7XG4gIH0sIHQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgfHwgKHRoaXMuaXNTdG9wcGVkID0gITAsIHRoaXMuX2NvbXBsZXRlKCkpO1xuICB9LCB0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xvc2VkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCBlLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpLCB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbCk7XG4gIH0sIHQucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuKTtcbiAgfSwgdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24obikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKG4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LCB0LnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LCB0O1xufSkoa2UpLCBlaSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdGhpcy5wYXJ0aWFsT2JzZXJ2ZXIgPSB0O1xuICB9XG4gIHJldHVybiBlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBuID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgaWYgKG4ubmV4dClcbiAgICAgIHRyeSB7XG4gICAgICAgIG4ubmV4dCh0KTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgTGUocik7XG4gICAgICB9XG4gIH0sIGUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBuID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgaWYgKG4uZXJyb3IpXG4gICAgICB0cnkge1xuICAgICAgICBuLmVycm9yKHQpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICBMZShyKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBMZSh0KTtcbiAgfSwgZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xuICAgIGlmICh0LmNvbXBsZXRlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdC5jb21wbGV0ZSgpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBMZShuKTtcbiAgICAgIH1cbiAgfSwgZTtcbn0pKCksIFBlID0gKGZ1bmN0aW9uKGUpIHtcbiAgbmUodCwgZSk7XG4gIGZ1bmN0aW9uIHQobiwgciwgaSkge1xuICAgIHZhciBvID0gZS5jYWxsKHRoaXMpIHx8IHRoaXMsIHM7XG4gICAgcmV0dXJuIFAobikgfHwgIW4gPyBzID0ge1xuICAgICAgbmV4dDogbiA/PyB2b2lkIDAsXG4gICAgICBlcnJvcjogciA/PyB2b2lkIDAsXG4gICAgICBjb21wbGV0ZTogaSA/PyB2b2lkIDBcbiAgICB9IDogcyA9IG4sIG8uZGVzdGluYXRpb24gPSBuZXcgZWkocyksIG87XG4gIH1cbiAgcmV0dXJuIHQ7XG59KShndCk7XG5mdW5jdGlvbiBMZShlKSB7XG4gIGRuKGUpO1xufVxuZnVuY3Rpb24gdGkoZSkge1xuICB0aHJvdyBlO1xufVxudmFyIG5pID0ge1xuICBjbG9zZWQ6ICEwLFxuICBuZXh0OiBXZSxcbiAgZXJyb3I6IHRpLFxuICBjb21wbGV0ZTogV2Vcbn0sIGJ0ID0gKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgXCJAQG9ic2VydmFibGVcIjtcbn0pKCk7XG5mdW5jdGlvbiBRZShlKSB7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcmkoZSkge1xuICByZXR1cm4gZS5sZW5ndGggPT09IDAgPyBRZSA6IGUubGVuZ3RoID09PSAxID8gZVswXSA6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24ociwgaSkge1xuICAgICAgcmV0dXJuIGkocik7XG4gICAgfSwgbik7XG4gIH07XG59XG52YXIgayA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgdCAmJiAodGhpcy5fc3Vic2NyaWJlID0gdCk7XG4gIH1cbiAgcmV0dXJuIGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG4gPSBuZXcgZSgpO1xuICAgIHJldHVybiBuLnNvdXJjZSA9IHRoaXMsIG4ub3BlcmF0b3IgPSB0LCBuO1xuICB9LCBlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbih0LCBuLCByKSB7XG4gICAgdmFyIGkgPSB0aGlzLCBvID0gb2kodCkgPyB0IDogbmV3IFBlKHQsIG4sIHIpO1xuICAgIHJldHVybiBSZShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gaSwgYSA9IHMub3BlcmF0b3IsIGMgPSBzLnNvdXJjZTtcbiAgICAgIG8uYWRkKGEgPyBhLmNhbGwobywgYykgOiBjID8gaS5fc3Vic2NyaWJlKG8pIDogaS5fdHJ5U3Vic2NyaWJlKG8pKTtcbiAgICB9KSwgbztcbiAgfSwgZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZSh0KTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICB0LmVycm9yKG4pO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgcmV0dXJuIG4gPSBSdChuKSwgbmV3IG4oZnVuY3Rpb24oaSwgbykge1xuICAgICAgdmFyIHMgPSBuZXcgUGUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQoYSk7XG4gICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgbyhjKSwgcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG8sXG4gICAgICAgIGNvbXBsZXRlOiBpXG4gICAgICB9KTtcbiAgICAgIHIuc3Vic2NyaWJlKHMpO1xuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBuO1xuICAgIHJldHVybiAobiA9IHRoaXMuc291cmNlKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnN1YnNjcmliZSh0KTtcbiAgfSwgZS5wcm90b3R5cGVbYnRdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciB0ID0gW10sIG4gPSAwOyBuIDwgYXJndW1lbnRzLmxlbmd0aDsgbisrKVxuICAgICAgdFtuXSA9IGFyZ3VtZW50c1tuXTtcbiAgICByZXR1cm4gcmkodCkodGhpcyk7XG4gIH0sIGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPSBSdCh0KSwgbmV3IHQoZnVuY3Rpb24ociwgaSkge1xuICAgICAgdmFyIG87XG4gICAgICBuLnN1YnNjcmliZShmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBvID0gcztcbiAgICAgIH0sIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIGkocyk7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIobyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgZS5jcmVhdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIG5ldyBlKHQpO1xuICB9LCBlO1xufSkoKTtcbmZ1bmN0aW9uIFJ0KGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiAodCA9IGUgPz8gWHIuUHJvbWlzZSkgIT09IG51bGwgJiYgdCAhPT0gdm9pZCAwID8gdCA6IFByb21pc2U7XG59XG5mdW5jdGlvbiBpaShlKSB7XG4gIHJldHVybiBlICYmIFAoZS5uZXh0KSAmJiBQKGUuZXJyb3IpICYmIFAoZS5jb21wbGV0ZSk7XG59XG5mdW5jdGlvbiBvaShlKSB7XG4gIHJldHVybiBlICYmIGUgaW5zdGFuY2VvZiBndCB8fCBpaShlKSAmJiBmbihlKTtcbn1cbmZ1bmN0aW9uIHNpKGUpIHtcbiAgcmV0dXJuIFAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5saWZ0KTtcbn1cbmZ1bmN0aW9uIFcoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGlmIChzaSh0KSlcbiAgICAgIHJldHVybiB0LmxpZnQoZnVuY3Rpb24obikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBlKG4sIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYWJsZSB0byBsaWZ0IHVua25vd24gT2JzZXJ2YWJsZSB0eXBlXCIpO1xuICB9O1xufVxuZnVuY3Rpb24gRihlLCB0LCBuLCByLCBpKSB7XG4gIHJldHVybiBuZXcgYWkoZSwgdCwgbiwgciwgaSk7XG59XG52YXIgYWkgPSAoZnVuY3Rpb24oZSkge1xuICBuZSh0LCBlKTtcbiAgZnVuY3Rpb24gdChuLCByLCBpLCBvLCBzLCBhKSB7XG4gICAgdmFyIGMgPSBlLmNhbGwodGhpcywgbikgfHwgdGhpcztcbiAgICByZXR1cm4gYy5vbkZpbmFsaXplID0gcywgYy5zaG91bGRVbnN1YnNjcmliZSA9IGEsIGMuX25leHQgPSByID8gZnVuY3Rpb24odSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcih1KTtcbiAgICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgICAgbi5lcnJvcihsKTtcbiAgICAgIH1cbiAgICB9IDogZS5wcm90b3R5cGUuX25leHQsIGMuX2Vycm9yID0gbyA/IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG8odSk7XG4gICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgIG4uZXJyb3IobCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSA6IGUucHJvdG90eXBlLl9lcnJvciwgYy5fY29tcGxldGUgPSBpID8gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpKCk7XG4gICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgIG4uZXJyb3IodSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSA6IGUucHJvdG90eXBlLl9jb21wbGV0ZSwgYztcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbjtcbiAgICBpZiAoIXRoaXMuc2hvdWxkVW5zdWJzY3JpYmUgfHwgdGhpcy5zaG91bGRVbnN1YnNjcmliZSgpKSB7XG4gICAgICB2YXIgciA9IHRoaXMuY2xvc2VkO1xuICAgICAgZS5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKSwgIXIgJiYgKChuID0gdGhpcy5vbkZpbmFsaXplKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgfHwgbi5jYWxsKHRoaXMpKTtcbiAgICB9XG4gIH0sIHQ7XG59KShndCksIGNpID0gbXQoZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZSh0aGlzKSwgdGhpcy5uYW1lID0gXCJPYmplY3RVbnN1YnNjcmliZWRFcnJvclwiLCB0aGlzLm1lc3NhZ2UgPSBcIm9iamVjdCB1bnN1YnNjcmliZWRcIjtcbiAgfTtcbn0pLCB0ZSA9IChmdW5jdGlvbihlKSB7XG4gIG5lKHQsIGUpO1xuICBmdW5jdGlvbiB0KCkge1xuICAgIHZhciBuID0gZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIG4uY2xvc2VkID0gITEsIG4uY3VycmVudE9ic2VydmVycyA9IG51bGwsIG4ub2JzZXJ2ZXJzID0gW10sIG4uaXNTdG9wcGVkID0gITEsIG4uaGFzRXJyb3IgPSAhMSwgbi50aHJvd25FcnJvciA9IG51bGwsIG47XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIgPSBuZXcgRHQodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHIub3BlcmF0b3IgPSBuLCByO1xuICB9LCB0LnByb3RvdHlwZS5fdGhyb3dJZkNsb3NlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgIHRocm93IG5ldyBjaSgpO1xuICB9LCB0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24obikge1xuICAgIHZhciByID0gdGhpcztcbiAgICBSZShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBvO1xuICAgICAgaWYgKHIuX3Rocm93SWZDbG9zZWQoKSwgIXIuaXNTdG9wcGVkKSB7XG4gICAgICAgIHIuY3VycmVudE9ic2VydmVycyB8fCAoci5jdXJyZW50T2JzZXJ2ZXJzID0gQXJyYXkuZnJvbShyLm9ic2VydmVycykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIHMgPSBnZShyLmN1cnJlbnRPYnNlcnZlcnMpLCBhID0gcy5uZXh0KCk7ICFhLmRvbmU7IGEgPSBzLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLnZhbHVlO1xuICAgICAgICAgICAgYy5uZXh0KG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgIGkgPSB7IGVycm9yOiB1IH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGEgJiYgIWEuZG9uZSAmJiAobyA9IHMucmV0dXJuKSAmJiBvLmNhbGwocyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChpKSB0aHJvdyBpLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LCB0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgUmUoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoci5fdGhyb3dJZkNsb3NlZCgpLCAhci5pc1N0b3BwZWQpIHtcbiAgICAgICAgci5oYXNFcnJvciA9IHIuaXNTdG9wcGVkID0gITAsIHIudGhyb3duRXJyb3IgPSBuO1xuICAgICAgICBmb3IgKHZhciBpID0gci5vYnNlcnZlcnM7IGkubGVuZ3RoOyApXG4gICAgICAgICAgaS5zaGlmdCgpLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCB0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gdGhpcztcbiAgICBSZShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChuLl90aHJvd0lmQ2xvc2VkKCksICFuLmlzU3RvcHBlZCkge1xuICAgICAgICBuLmlzU3RvcHBlZCA9ICEwO1xuICAgICAgICBmb3IgKHZhciByID0gbi5vYnNlcnZlcnM7IHIubGVuZ3RoOyApXG4gICAgICAgICAgci5zaGlmdCgpLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0aGlzLmNsb3NlZCA9ICEwLCB0aGlzLm9ic2VydmVycyA9IHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGw7XG4gIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSwgXCJvYnNlcnZlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuO1xuICAgICAgcmV0dXJuICgobiA9IHRoaXMub2JzZXJ2ZXJzKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmxlbmd0aCkgPiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fdGhyb3dJZkNsb3NlZCgpLCBlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgbik7XG4gIH0sIHQucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rocm93SWZDbG9zZWQoKSwgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhuKSwgdGhpcy5faW5uZXJTdWJzY3JpYmUobik7XG4gIH0sIHQucHJvdG90eXBlLl9pbm5lclN1YnNjcmliZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IHRoaXMsIGkgPSB0aGlzLCBvID0gaS5oYXNFcnJvciwgcyA9IGkuaXNTdG9wcGVkLCBhID0gaS5vYnNlcnZlcnM7XG4gICAgcmV0dXJuIG8gfHwgcyA/IGxuIDogKHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGwsIGEucHVzaChuKSwgbmV3IGtlKGZ1bmN0aW9uKCkge1xuICAgICAgci5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbCwgVWUoYSwgbik7XG4gICAgfSkpO1xuICB9LCB0LnByb3RvdHlwZS5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IHRoaXMsIGkgPSByLmhhc0Vycm9yLCBvID0gci50aHJvd25FcnJvciwgcyA9IHIuaXNTdG9wcGVkO1xuICAgIGkgPyBuLmVycm9yKG8pIDogcyAmJiBuLmNvbXBsZXRlKCk7XG4gIH0sIHQucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gbmV3IGsoKTtcbiAgICByZXR1cm4gbi5zb3VyY2UgPSB0aGlzLCBuO1xuICB9LCB0LmNyZWF0ZSA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICByZXR1cm4gbmV3IER0KG4sIHIpO1xuICB9LCB0O1xufSkoayksIER0ID0gKGZ1bmN0aW9uKGUpIHtcbiAgbmUodCwgZSk7XG4gIGZ1bmN0aW9uIHQobiwgcikge1xuICAgIHZhciBpID0gZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmV0dXJuIGkuZGVzdGluYXRpb24gPSBuLCBpLnNvdXJjZSA9IHIsIGk7XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIsIGk7XG4gICAgKGkgPSAociA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIubmV4dCkgPT09IG51bGwgfHwgaSA9PT0gdm9pZCAwIHx8IGkuY2FsbChyLCBuKTtcbiAgfSwgdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIsIGk7XG4gICAgKGkgPSAociA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIuZXJyb3IpID09PSBudWxsIHx8IGkgPT09IHZvaWQgMCB8fCBpLmNhbGwociwgbik7XG4gIH0sIHQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4sIHI7XG4gICAgKHIgPSAobiA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uY29tcGxldGUpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCB8fCByLmNhbGwobik7XG4gIH0sIHQucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIsIGk7XG4gICAgcmV0dXJuIChpID0gKHIgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5zdWJzY3JpYmUobikpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiBsbjtcbiAgfSwgdDtcbn0pKHRlKSwgcG4gPSAoZnVuY3Rpb24oZSkge1xuICBuZSh0LCBlKTtcbiAgZnVuY3Rpb24gdChuKSB7XG4gICAgdmFyIHIgPSBlLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXR1cm4gci5fdmFsdWUgPSBuLCByO1xuICB9XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgciA9IGUucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBuKTtcbiAgICByZXR1cm4gIXIuY2xvc2VkICYmIG4ubmV4dCh0aGlzLl92YWx1ZSksIHI7XG4gIH0sIHQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSB0aGlzLCByID0gbi5oYXNFcnJvciwgaSA9IG4udGhyb3duRXJyb3IsIG8gPSBuLl92YWx1ZTtcbiAgICBpZiAocilcbiAgICAgIHRocm93IGk7XG4gICAgcmV0dXJuIHRoaXMuX3Rocm93SWZDbG9zZWQoKSwgbztcbiAgfSwgdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBlLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdGhpcy5fdmFsdWUgPSBuKTtcbiAgfSwgdDtcbn0pKHRlKSwgdWkgPSB7XG4gIG5vdzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cbn0sIGxpID0gKGZ1bmN0aW9uKGUpIHtcbiAgbmUodCwgZSk7XG4gIGZ1bmN0aW9uIHQobiwgcikge1xuICAgIHJldHVybiBlLmNhbGwodGhpcykgfHwgdGhpcztcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIHQ7XG59KShrZSksICR0ID0ge1xuICBzZXRJbnRlcnZhbDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgciA9IDI7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspXG4gICAgICBuW3IgLSAyXSA9IGFyZ3VtZW50c1tyXTtcbiAgICByZXR1cm4gc2V0SW50ZXJ2YWwuYXBwbHkodm9pZCAwLCBiZShbZSwgdF0sIGRlKG4pKSk7XG4gIH0sXG4gIGNsZWFySW50ZXJ2YWw6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChlKTtcbiAgfSxcbiAgZGVsZWdhdGU6IHZvaWQgMFxufSwgZmkgPSAoZnVuY3Rpb24oZSkge1xuICBuZSh0LCBlKTtcbiAgZnVuY3Rpb24gdChuLCByKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodGhpcywgbiwgcikgfHwgdGhpcztcbiAgICByZXR1cm4gaS5zY2hlZHVsZXIgPSBuLCBpLndvcmsgPSByLCBpLnBlbmRpbmcgPSAhMSwgaTtcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKHIgPT09IHZvaWQgMCAmJiAociA9IDApLCB0aGlzLmNsb3NlZClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIHRoaXMuc3RhdGUgPSBuO1xuICAgIHZhciBvID0gdGhpcy5pZCwgcyA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIHJldHVybiBvICE9IG51bGwgJiYgKHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHMsIG8sIHIpKSwgdGhpcy5wZW5kaW5nID0gITAsIHRoaXMuZGVsYXkgPSByLCB0aGlzLmlkID0gKGkgPSB0aGlzLmlkKSAhPT0gbnVsbCAmJiBpICE9PSB2b2lkIDAgPyBpIDogdGhpcy5yZXF1ZXN0QXN5bmNJZChzLCB0aGlzLmlkLCByKSwgdGhpcztcbiAgfSwgdC5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbihuLCByLCBpKSB7XG4gICAgcmV0dXJuIGkgPT09IHZvaWQgMCAmJiAoaSA9IDApLCAkdC5zZXRJbnRlcnZhbChuLmZsdXNoLmJpbmQobiwgdGhpcyksIGkpO1xuICB9LCB0LnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uKG4sIHIsIGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwICYmIChpID0gMCksIGkgIT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBpICYmIHRoaXMucGVuZGluZyA9PT0gITEpXG4gICAgICByZXR1cm4gcjtcbiAgICByICE9IG51bGwgJiYgJHQuY2xlYXJJbnRlcnZhbChyKTtcbiAgfSwgdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpXG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiZXhlY3V0aW5nIGEgY2FuY2VsbGVkIGFjdGlvblwiKTtcbiAgICB0aGlzLnBlbmRpbmcgPSAhMTtcbiAgICB2YXIgaSA9IHRoaXMuX2V4ZWN1dGUobiwgcik7XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gaTtcbiAgICB0aGlzLnBlbmRpbmcgPT09ICExICYmIHRoaXMuaWQgIT0gbnVsbCAmJiAodGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpKTtcbiAgfSwgdC5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIGkgPSAhMSwgbztcbiAgICB0cnkge1xuICAgICAgdGhpcy53b3JrKG4pO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGkgPSAhMCwgbyA9IHMgfHwgbmV3IEVycm9yKFwiU2NoZWR1bGVkIGFjdGlvbiB0aHJldyBmYWxzeSBlcnJvclwiKTtcbiAgICB9XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gdGhpcy51bnN1YnNjcmliZSgpLCBvO1xuICB9LCB0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgIHZhciBuID0gdGhpcywgciA9IG4uaWQsIGkgPSBuLnNjaGVkdWxlciwgbyA9IGkuYWN0aW9ucztcbiAgICAgIHRoaXMud29yayA9IHRoaXMuc3RhdGUgPSB0aGlzLnNjaGVkdWxlciA9IG51bGwsIHRoaXMucGVuZGluZyA9ICExLCBVZShvLCB0aGlzKSwgciAhPSBudWxsICYmICh0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChpLCByLCBudWxsKSksIHRoaXMuZGVsYXkgPSBudWxsLCBlLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwgdDtcbn0pKGxpKSwgTnQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUodCwgbikge1xuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IGUubm93KSwgdGhpcy5zY2hlZHVsZXJBY3Rpb25DdG9yID0gdCwgdGhpcy5ub3cgPSBuO1xuICB9XG4gIHJldHVybiBlLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uKHQsIG4sIHIpIHtcbiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gMCksIG5ldyB0aGlzLnNjaGVkdWxlckFjdGlvbkN0b3IodGhpcywgdCkuc2NoZWR1bGUociwgbik7XG4gIH0sIGUubm93ID0gdWkubm93LCBlO1xufSkoKSwgZGkgPSAoZnVuY3Rpb24oZSkge1xuICBuZSh0LCBlKTtcbiAgZnVuY3Rpb24gdChuLCByKSB7XG4gICAgciA9PT0gdm9pZCAwICYmIChyID0gTnQubm93KTtcbiAgICB2YXIgaSA9IGUuY2FsbCh0aGlzLCBuLCByKSB8fCB0aGlzO1xuICAgIHJldHVybiBpLmFjdGlvbnMgPSBbXSwgaS5fYWN0aXZlID0gITEsIGk7XG4gIH1cbiAgcmV0dXJuIHQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24obikge1xuICAgIHZhciByID0gdGhpcy5hY3Rpb25zO1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHIucHVzaChuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdGhpcy5fYWN0aXZlID0gITA7XG4gICAgZG9cbiAgICAgIGlmIChpID0gbi5leGVjdXRlKG4uc3RhdGUsIG4uZGVsYXkpKVxuICAgICAgICBicmVhaztcbiAgICB3aGlsZSAobiA9IHIuc2hpZnQoKSk7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSA9ICExLCBpKSB7XG4gICAgICBmb3IgKDsgbiA9IHIuc2hpZnQoKTsgKVxuICAgICAgICBuLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aHJvdyBpO1xuICAgIH1cbiAgfSwgdDtcbn0pKE50KSwgcGkgPSBuZXcgZGkoZmkpO1xuZnVuY3Rpb24gaGkoZSkge1xuICByZXR1cm4gZSAmJiBQKGUuc2NoZWR1bGUpO1xufVxuZnVuY3Rpb24gdmkoZSkge1xuICByZXR1cm4gZVtlLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24geXQoZSkge1xuICByZXR1cm4gaGkodmkoZSkpID8gZS5wb3AoKSA6IHZvaWQgMDtcbn1cbnZhciB3dCA9IChmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICYmIHR5cGVvZiBlLmxlbmd0aCA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIjtcbn0pO1xuZnVuY3Rpb24gaG4oZSkge1xuICByZXR1cm4gUChlID09IG51bGwgPyB2b2lkIDAgOiBlLnRoZW4pO1xufVxuZnVuY3Rpb24gdm4oZSkge1xuICByZXR1cm4gUChlW2J0XSk7XG59XG5mdW5jdGlvbiBtbihlKSB7XG4gIHJldHVybiBTeW1ib2wuYXN5bmNJdGVyYXRvciAmJiBQKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcbn1cbmZ1bmN0aW9uIGduKGUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgcHJvdmlkZWQgXCIgKyAoZSAhPT0gbnVsbCAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gXCJhbiBpbnZhbGlkIG9iamVjdFwiIDogXCInXCIgKyBlICsgXCInXCIpICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLiBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgUmVhZGFibGVTdHJlYW0sIEFycmF5LCBBc3luY0l0ZXJhYmxlLCBvciBJdGVyYWJsZS5cIik7XG59XG5mdW5jdGlvbiBtaSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT0gXCJmdW5jdGlvblwiIHx8ICFTeW1ib2wuaXRlcmF0b3IgPyBcIkBAaXRlcmF0b3JcIiA6IFN5bWJvbC5pdGVyYXRvcjtcbn1cbnZhciBibiA9IG1pKCk7XG5mdW5jdGlvbiB5bihlKSB7XG4gIHJldHVybiBQKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGVbYm5dKTtcbn1cbmZ1bmN0aW9uIHduKGUpIHtcbiAgcmV0dXJuIFFyKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4sIHIsIGksIG87XG4gICAgcmV0dXJuIHVuKHRoaXMsIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHN3aXRjaCAocy5sYWJlbCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgbiA9IGUuZ2V0UmVhZGVyKCksIHMubGFiZWwgPSAxO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcy50cnlzLnB1c2goWzEsICwgOSwgMTBdKSwgcy5sYWJlbCA9IDI7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gWzQsIHZlKG4ucmVhZCgpKV07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gciA9IHMuc2VudCgpLCBpID0gci52YWx1ZSwgbyA9IHIuZG9uZSwgbyA/IFs0LCB2ZSh2b2lkIDApXSA6IFszLCA1XTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBbMiwgcy5zZW50KCldO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIFs0LCB2ZShpKV07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gWzQsIHMuc2VudCgpXTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBzLnNlbnQoKSwgWzMsIDJdO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIFszLCAxMF07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gbi5yZWxlYXNlTG9jaygpLCBbN107XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB4bihlKSB7XG4gIHJldHVybiBQKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZ2V0UmVhZGVyKTtcbn1cbmZ1bmN0aW9uIHooZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIGspXG4gICAgcmV0dXJuIGU7XG4gIGlmIChlICE9IG51bGwpIHtcbiAgICBpZiAodm4oZSkpXG4gICAgICByZXR1cm4gZ2koZSk7XG4gICAgaWYgKHd0KGUpKVxuICAgICAgcmV0dXJuIGJpKGUpO1xuICAgIGlmIChobihlKSlcbiAgICAgIHJldHVybiB5aShlKTtcbiAgICBpZiAobW4oZSkpXG4gICAgICByZXR1cm4gU24oZSk7XG4gICAgaWYgKHluKGUpKVxuICAgICAgcmV0dXJuIHdpKGUpO1xuICAgIGlmICh4bihlKSlcbiAgICAgIHJldHVybiB4aShlKTtcbiAgfVxuICB0aHJvdyBnbihlKTtcbn1cbmZ1bmN0aW9uIGdpKGUpIHtcbiAgcmV0dXJuIG5ldyBrKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiA9IGVbYnRdKCk7XG4gICAgaWYgKFAobi5zdWJzY3JpYmUpKVxuICAgICAgcmV0dXJuIG4uc3Vic2NyaWJlKHQpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZVwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBiaShlKSB7XG4gIHJldHVybiBuZXcgayhmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aCAmJiAhdC5jbG9zZWQ7IG4rKylcbiAgICAgIHQubmV4dChlW25dKTtcbiAgICB0LmNvbXBsZXRlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24geWkoZSkge1xuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24odCkge1xuICAgIGUudGhlbihmdW5jdGlvbihuKSB7XG4gICAgICB0LmNsb3NlZCB8fCAodC5uZXh0KG4pLCB0LmNvbXBsZXRlKCkpO1xuICAgIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB0LmVycm9yKG4pO1xuICAgIH0pLnRoZW4obnVsbCwgZG4pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdpKGUpIHtcbiAgcmV0dXJuIG5ldyBrKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbiwgcjtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaSA9IGdlKGUpLCBvID0gaS5uZXh0KCk7ICFvLmRvbmU7IG8gPSBpLm5leHQoKSkge1xuICAgICAgICB2YXIgcyA9IG8udmFsdWU7XG4gICAgICAgIGlmICh0Lm5leHQocyksIHQuY2xvc2VkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBuID0geyBlcnJvcjogYSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBvICYmICFvLmRvbmUgJiYgKHIgPSBpLnJldHVybikgJiYgci5jYWxsKGkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG4pIHRocm93IG4uZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHQuY29tcGxldGUoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBTbihlKSB7XG4gIHJldHVybiBuZXcgayhmdW5jdGlvbih0KSB7XG4gICAgU2koZSwgdCkuY2F0Y2goZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHQuZXJyb3Iobik7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24geGkoZSkge1xuICByZXR1cm4gU24od24oZSkpO1xufVxuZnVuY3Rpb24gU2koZSwgdCkge1xuICB2YXIgbiwgciwgaSwgbztcbiAgcmV0dXJuIEdyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcywgYTtcbiAgICByZXR1cm4gdW4odGhpcywgZnVuY3Rpb24oYykge1xuICAgICAgc3dpdGNoIChjLmxhYmVsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjLnRyeXMucHVzaChbMCwgNSwgNiwgMTFdKSwgbiA9IEpyKGUpLCBjLmxhYmVsID0gMTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBbNCwgbi5uZXh0KCldO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKHIgPSBjLnNlbnQoKSwgISFyLmRvbmUpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgaWYgKHMgPSByLnZhbHVlLCB0Lm5leHQocyksIHQuY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICBjLmxhYmVsID0gMztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gWzMsIDExXTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBhID0gYy5zZW50KCksIGkgPSB7IGVycm9yOiBhIH0sIFszLCAxMV07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gYy50cnlzLnB1c2goWzYsICwgOSwgMTBdKSwgciAmJiAhci5kb25lICYmIChvID0gbi5yZXR1cm4pID8gWzQsIG8uY2FsbChuKV0gOiBbMywgOF07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjLnNlbnQoKSwgYy5sYWJlbCA9IDg7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gWzMsIDEwXTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmIChpKSB0aHJvdyBpLmVycm9yO1xuICAgICAgICAgIHJldHVybiBbN107XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIFs3XTtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gdC5jb21wbGV0ZSgpLCBbMl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gb2UoZSwgdCwgbiwgciwgaSkge1xuICByID09PSB2b2lkIDAgJiYgKHIgPSAwKSwgaSA9PT0gdm9pZCAwICYmIChpID0gITEpO1xuICB2YXIgbyA9IHQuc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgbigpLCBpID8gZS5hZGQodGhpcy5zY2hlZHVsZShudWxsLCByKSkgOiB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH0sIHIpO1xuICBpZiAoZS5hZGQobyksICFpKVxuICAgIHJldHVybiBvO1xufVxuZnVuY3Rpb24gVG4oZSwgdCkge1xuICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIFcoZnVuY3Rpb24obiwgcikge1xuICAgIG4uc3Vic2NyaWJlKEYociwgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG9lKHIsIGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gci5uZXh0KGkpO1xuICAgICAgfSwgdCk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb2UociwgZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByLmNvbXBsZXRlKCk7XG4gICAgICB9LCB0KTtcbiAgICB9LCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gb2UociwgZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByLmVycm9yKGkpO1xuICAgICAgfSwgdCk7XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEVuKGUsIHQpIHtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBXKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICByLmFkZChlLnNjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG4uc3Vic2NyaWJlKHIpO1xuICAgIH0sIHQpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBUaShlLCB0KSB7XG4gIHJldHVybiB6KGUpLnBpcGUoRW4odCksIFRuKHQpKTtcbn1cbmZ1bmN0aW9uIEVpKGUsIHQpIHtcbiAgcmV0dXJuIHooZSkucGlwZShFbih0KSwgVG4odCkpO1xufVxuZnVuY3Rpb24gQ2koZSwgdCkge1xuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24obikge1xuICAgIHZhciByID0gMDtcbiAgICByZXR1cm4gdC5zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgIHIgPT09IGUubGVuZ3RoID8gbi5jb21wbGV0ZSgpIDogKG4ubmV4dChlW3IrK10pLCBuLmNsb3NlZCB8fCB0aGlzLnNjaGVkdWxlKCkpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFBpKGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBrKGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgcjtcbiAgICByZXR1cm4gb2UobiwgdCwgZnVuY3Rpb24oKSB7XG4gICAgICByID0gZVtibl0oKSwgb2UobiwgdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBvLCBzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGkgPSByLm5leHQoKSwgbyA9IGkudmFsdWUsIHMgPSBpLmRvbmU7XG4gICAgICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgICAgICBuLmVycm9yKGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzID8gbi5jb21wbGV0ZSgpIDogbi5uZXh0KG8pO1xuICAgICAgfSwgMCwgITApO1xuICAgIH0pLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBQKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucmV0dXJuKSAmJiByLnJldHVybigpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gQ24oZSwgdCkge1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSXRlcmFibGUgY2Fubm90IGJlIG51bGxcIik7XG4gIHJldHVybiBuZXcgayhmdW5jdGlvbihuKSB7XG4gICAgb2UobiwgdCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICBvZShuLCB0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgci5uZXh0KCkudGhlbihmdW5jdGlvbihpKSB7XG4gICAgICAgICAgaS5kb25lID8gbi5jb21wbGV0ZSgpIDogbi5uZXh0KGkudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDAsICEwKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPaShlLCB0KSB7XG4gIHJldHVybiBDbih3bihlKSwgdCk7XG59XG5mdW5jdGlvbiBBaShlLCB0KSB7XG4gIGlmIChlICE9IG51bGwpIHtcbiAgICBpZiAodm4oZSkpXG4gICAgICByZXR1cm4gVGkoZSwgdCk7XG4gICAgaWYgKHd0KGUpKVxuICAgICAgcmV0dXJuIENpKGUsIHQpO1xuICAgIGlmIChobihlKSlcbiAgICAgIHJldHVybiBFaShlLCB0KTtcbiAgICBpZiAobW4oZSkpXG4gICAgICByZXR1cm4gQ24oZSwgdCk7XG4gICAgaWYgKHluKGUpKVxuICAgICAgcmV0dXJuIFBpKGUsIHQpO1xuICAgIGlmICh4bihlKSlcbiAgICAgIHJldHVybiBPaShlLCB0KTtcbiAgfVxuICB0aHJvdyBnbihlKTtcbn1cbmZ1bmN0aW9uIEplKGUsIHQpIHtcbiAgcmV0dXJuIHQgPyBBaShlLCB0KSA6IHooZSk7XG59XG5mdW5jdGlvbiBGdCgpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCB0ID0gMDsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKylcbiAgICBlW3RdID0gYXJndW1lbnRzW3RdO1xuICB2YXIgbiA9IHl0KGUpO1xuICByZXR1cm4gSmUoZSwgbik7XG59XG5mdW5jdGlvbiBraShlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oZSk7XG59XG52YXIgX2kgPSBtdChmdW5jdGlvbihlKSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgbiA9PT0gdm9pZCAwICYmIChuID0gbnVsbCksIGUodGhpcyksIHRoaXMubWVzc2FnZSA9IFwiVGltZW91dCBoYXMgb2NjdXJyZWRcIiwgdGhpcy5uYW1lID0gXCJUaW1lb3V0RXJyb3JcIiwgdGhpcy5pbmZvID0gbjtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gTGkoZSwgdCkge1xuICB2YXIgbiA9IGtpKGUpID8geyBmaXJzdDogZSB9IDogdHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IHsgZWFjaDogZSB9IDogZSwgciA9IG4uZmlyc3QsIGkgPSBuLmVhY2gsIG8gPSBuLndpdGgsIHMgPSBvID09PSB2b2lkIDAgPyBJaSA6IG8sIGEgPSBuLnNjaGVkdWxlciwgYyA9IGEgPT09IHZvaWQgMCA/IHBpIDogYSwgdSA9IG4ubWV0YSwgbCA9IHUgPT09IHZvaWQgMCA/IG51bGwgOiB1O1xuICBpZiAociA9PSBudWxsICYmIGkgPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gdGltZW91dCBwcm92aWRlZC5cIik7XG4gIHJldHVybiBXKGZ1bmN0aW9uKGYsIHYpIHtcbiAgICB2YXIgZCwgbSwgcCA9IG51bGwsIGcgPSAwLCBoID0gZnVuY3Rpb24oeCkge1xuICAgICAgbSA9IG9lKHYsIGMsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQudW5zdWJzY3JpYmUoKSwgeihzKHtcbiAgICAgICAgICAgIG1ldGE6IGwsXG4gICAgICAgICAgICBsYXN0VmFsdWU6IHAsXG4gICAgICAgICAgICBzZWVuOiBnXG4gICAgICAgICAgfSkpLnN1YnNjcmliZSh2KTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgIHYuZXJyb3IoRSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHgpO1xuICAgIH07XG4gICAgZCA9IGYuc3Vic2NyaWJlKEYodiwgZnVuY3Rpb24oeCkge1xuICAgICAgbSA9PSBudWxsIHx8IG0udW5zdWJzY3JpYmUoKSwgZysrLCB2Lm5leHQocCA9IHgpLCBpID4gMCAmJiBoKGkpO1xuICAgIH0sIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIG0gIT0gbnVsbCAmJiBtLmNsb3NlZCB8fCBtID09IG51bGwgfHwgbS51bnN1YnNjcmliZSgpLCBwID0gbnVsbDtcbiAgICB9KSksICFnICYmIGgociAhPSBudWxsID8gdHlwZW9mIHIgPT0gXCJudW1iZXJcIiA/IHIgOiArciAtIGMubm93KCkgOiBpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBJaShlKSB7XG4gIHRocm93IG5ldyBfaShlKTtcbn1cbmZ1bmN0aW9uIEEoZSwgdCkge1xuICByZXR1cm4gVyhmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIG4uc3Vic2NyaWJlKEYociwgZnVuY3Rpb24obykge1xuICAgICAgci5uZXh0KGUuY2FsbCh0LCBvLCBpKyspKTtcbiAgICB9KSk7XG4gIH0pO1xufVxudmFyIE1pID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIFJpKGUsIHQpIHtcbiAgcmV0dXJuIE1pKHQpID8gZS5hcHBseSh2b2lkIDAsIGJlKFtdLCBkZSh0KSkpIDogZSh0KTtcbn1cbmZ1bmN0aW9uIERpKGUpIHtcbiAgcmV0dXJuIEEoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBSaShlLCB0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkaShlLCB0LCBuLCByLCBpLCBvLCBzLCBhKSB7XG4gIHZhciBjID0gW10sIHUgPSAwLCBsID0gMCwgZiA9ICExLCB2ID0gZnVuY3Rpb24oKSB7XG4gICAgZiAmJiAhYy5sZW5ndGggJiYgIXUgJiYgdC5jb21wbGV0ZSgpO1xuICB9LCBkID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiB1IDwgciA/IG0ocCkgOiBjLnB1c2gocCk7XG4gIH0sIG0gPSBmdW5jdGlvbihwKSB7XG4gICAgdSsrO1xuICAgIHZhciBnID0gITE7XG4gICAgeihuKHAsIGwrKykpLnN1YnNjcmliZShGKHQsIGZ1bmN0aW9uKGgpIHtcbiAgICAgIHQubmV4dChoKTtcbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgIGcgPSAhMDtcbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGcpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdS0tO1xuICAgICAgICAgIGZvciAodmFyIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4ID0gYy5zaGlmdCgpO1xuICAgICAgICAgICAgcyB8fCBtKHgpO1xuICAgICAgICAgIH07IGMubGVuZ3RoICYmIHUgPCByOyApXG4gICAgICAgICAgICBoKCk7XG4gICAgICAgICAgdigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdC5lcnJvcih4KTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIGUuc3Vic2NyaWJlKEYodCwgZCwgZnVuY3Rpb24oKSB7XG4gICAgZiA9ICEwLCB2KCk7XG4gIH0pKSwgZnVuY3Rpb24oKSB7XG4gIH07XG59XG5mdW5jdGlvbiB4dChlLCB0LCBuKSB7XG4gIHJldHVybiBuID09PSB2b2lkIDAgJiYgKG4gPSAxIC8gMCksIFAodCkgPyB4dChmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuIEEoZnVuY3Rpb24obywgcykge1xuICAgICAgcmV0dXJuIHQociwgbywgaSwgcyk7XG4gICAgfSkoeihlKHIsIGkpKSk7XG4gIH0sIG4pIDogKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgJiYgKG4gPSB0KSwgVyhmdW5jdGlvbihyLCBpKSB7XG4gICAgcmV0dXJuICRpKHIsIGksIGUsIG4pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBOaShlKSB7XG4gIHJldHVybiB4dChRZSwgZSk7XG59XG5mdW5jdGlvbiBGaSgpIHtcbiAgcmV0dXJuIE5pKDEpO1xufVxuZnVuY3Rpb24gamUoKSB7XG4gIGZvciAodmFyIGUgPSBbXSwgdCA9IDA7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IGFyZ3VtZW50c1t0XTtcbiAgcmV0dXJuIEZpKCkoSmUoZSwgeXQoZSkpKTtcbn1cbnZhciBVaSA9IFtcImFkZExpc3RlbmVyXCIsIFwicmVtb3ZlTGlzdGVuZXJcIl0sIFdpID0gW1wiYWRkRXZlbnRMaXN0ZW5lclwiLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIl0sIGppID0gW1wib25cIiwgXCJvZmZcIl07XG5mdW5jdGlvbiB1dChlLCB0LCBuLCByKSB7XG4gIGlmIChQKG4pICYmIChyID0gbiwgbiA9IHZvaWQgMCksIHIpXG4gICAgcmV0dXJuIHV0KGUsIHQsIG4pLnBpcGUoRGkocikpO1xuICB2YXIgaSA9IGRlKEhpKGUpID8gV2kubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGVbYV0odCwgYywgbik7XG4gICAgfTtcbiAgfSkgOiBCaShlKSA/IFVpLm1hcChVdChlLCB0KSkgOiBWaShlKSA/IGppLm1hcChVdChlLCB0KSkgOiBbXSwgMiksIG8gPSBpWzBdLCBzID0gaVsxXTtcbiAgaWYgKCFvICYmIHd0KGUpKVxuICAgIHJldHVybiB4dChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gdXQoYSwgdCwgbik7XG4gICAgfSkoeihlKSk7XG4gIGlmICghbylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBldmVudCB0YXJnZXRcIik7XG4gIHJldHVybiBuZXcgayhmdW5jdGlvbihhKSB7XG4gICAgdmFyIGMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHUgPSBbXSwgbCA9IDA7IGwgPCBhcmd1bWVudHMubGVuZ3RoOyBsKyspXG4gICAgICAgIHVbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICByZXR1cm4gYS5uZXh0KDEgPCB1Lmxlbmd0aCA/IHUgOiB1WzBdKTtcbiAgICB9O1xuICAgIHJldHVybiBvKGMpLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzKGMpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gVXQoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gZVtuXSh0LCByKTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gQmkoZSkge1xuICByZXR1cm4gUChlLmFkZExpc3RlbmVyKSAmJiBQKGUucmVtb3ZlTGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gVmkoZSkge1xuICByZXR1cm4gUChlLm9uKSAmJiBQKGUub2ZmKTtcbn1cbmZ1bmN0aW9uIEhpKGUpIHtcbiAgcmV0dXJuIFAoZS5hZGRFdmVudExpc3RlbmVyKSAmJiBQKGUucmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBYZShlLCB0KSB7XG4gIHJldHVybiBXKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgbi5zdWJzY3JpYmUoRihyLCBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gZS5jYWxsKHQsIG8sIGkrKykgJiYgci5uZXh0KG8pO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB6aShlLCB0LCBuLCByLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbihvLCBzKSB7XG4gICAgdmFyIGEgPSBuLCBjID0gdCwgdSA9IDA7XG4gICAgby5zdWJzY3JpYmUoRihzLCBmdW5jdGlvbihsKSB7XG4gICAgICB2YXIgZiA9IHUrKztcbiAgICAgIGMgPSBhID8gZShjLCBsLCBmKSA6IChhID0gITAsIGwpLCBzLm5leHQoYyk7XG4gICAgfSwgaSkpO1xuICB9O1xufVxuZnVuY3Rpb24gWWkoZSwgdCkge1xuICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gUWUpLCBlID0gZSA/PyBxaSwgVyhmdW5jdGlvbihuLCByKSB7XG4gICAgdmFyIGksIG8gPSAhMDtcbiAgICBuLnN1YnNjcmliZShGKHIsIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBhID0gdChzKTtcbiAgICAgIChvIHx8ICFlKGksIGEpKSAmJiAobyA9ICExLCBpID0gYSwgci5uZXh0KHMpKTtcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcWkoZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdDtcbn1cbmZ1bmN0aW9uIGx0KGUsIHQpIHtcbiAgcmV0dXJuIFcoemkoZSwgdCwgYXJndW1lbnRzLmxlbmd0aCA+PSAyLCAhMCkpO1xufVxuZnVuY3Rpb24gS2koZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSk7XG4gIHZhciB0ID0gZS5jb25uZWN0b3IsIG4gPSB0ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IHRlKCk7XG4gIH0gOiB0LCByID0gZS5yZXNldE9uRXJyb3IsIGkgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIG8gPSBlLnJlc2V0T25Db21wbGV0ZSwgcyA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgYSA9IGUucmVzZXRPblJlZkNvdW50WmVybywgYyA9IGEgPT09IHZvaWQgMCA/ICEwIDogYTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHUpIHtcbiAgICB2YXIgbCwgZiwgdiwgZCA9IDAsIG0gPSAhMSwgcCA9ICExLCBnID0gZnVuY3Rpb24oKSB7XG4gICAgICBmID09IG51bGwgfHwgZi51bnN1YnNjcmliZSgpLCBmID0gdm9pZCAwO1xuICAgIH0sIGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGcoKSwgbCA9IHYgPSB2b2lkIDAsIG0gPSBwID0gITE7XG4gICAgfSwgeCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEUgPSBsO1xuICAgICAgaCgpLCBFID09IG51bGwgfHwgRS51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFcoZnVuY3Rpb24oRSwgTykge1xuICAgICAgZCsrLCAhcCAmJiAhbSAmJiBnKCk7XG4gICAgICB2YXIgYiA9IHYgPSB2ID8/IG4oKTtcbiAgICAgIE8uYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICBkLS0sIGQgPT09IDAgJiYgIXAgJiYgIW0gJiYgKGYgPSBudCh4LCBjKSk7XG4gICAgICB9KSwgYi5zdWJzY3JpYmUoTyksICFsICYmIGQgPiAwICYmIChsID0gbmV3IFBlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oUykge1xuICAgICAgICAgIHJldHVybiBiLm5leHQoUyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihTKSB7XG4gICAgICAgICAgcCA9ICEwLCBnKCksIGYgPSBudChoLCBpLCBTKSwgYi5lcnJvcihTKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG0gPSAhMCwgZygpLCBmID0gbnQoaCwgcyksIGIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSksIHooRSkuc3Vic2NyaWJlKGwpKTtcbiAgICB9KSh1KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG50KGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IFtdLCByID0gMjsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKylcbiAgICBuW3IgLSAyXSA9IGFyZ3VtZW50c1tyXTtcbiAgaWYgKHQgPT09ICEwKSB7XG4gICAgZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodCAhPT0gITEpIHtcbiAgICB2YXIgaSA9IG5ldyBQZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaS51bnN1YnNjcmliZSgpLCBlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHoodC5hcHBseSh2b2lkIDAsIGJlKFtdLCBkZShuKSkpKS5zdWJzY3JpYmUoaSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdpKGUpIHtcbiAgcmV0dXJuIFcoZnVuY3Rpb24odCwgbikge1xuICAgIHZhciByID0gITEsIGkgPSBGKG4sIGZ1bmN0aW9uKCkge1xuICAgICAgaSA9PSBudWxsIHx8IGkudW5zdWJzY3JpYmUoKSwgciA9ICEwO1xuICAgIH0sIFdlKTtcbiAgICB6KGUpLnN1YnNjcmliZShpKSwgdC5zdWJzY3JpYmUoRihuLCBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gciAmJiBuLm5leHQobyk7XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEQoKSB7XG4gIGZvciAodmFyIGUgPSBbXSwgdCA9IDA7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IGFyZ3VtZW50c1t0XTtcbiAgdmFyIG4gPSB5dChlKTtcbiAgcmV0dXJuIFcoZnVuY3Rpb24ociwgaSkge1xuICAgIChuID8gamUoZSwgciwgbikgOiBqZShlLCByKSkuc3Vic2NyaWJlKGkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFBuKGUsIHQpIHtcbiAgcmV0dXJuIFcoZnVuY3Rpb24obiwgcikge1xuICAgIHZhciBpID0gbnVsbCwgbyA9IDAsIHMgPSAhMSwgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHMgJiYgIWkgJiYgci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgbi5zdWJzY3JpYmUoRihyLCBmdW5jdGlvbihjKSB7XG4gICAgICBpID09IG51bGwgfHwgaS51bnN1YnNjcmliZSgpO1xuICAgICAgdmFyIHUgPSAwLCBsID0gbysrO1xuICAgICAgeihlKGMsIGwpKS5zdWJzY3JpYmUoaSA9IEYociwgZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gci5uZXh0KHQgPyB0KGMsIGYsIGwsIHUrKykgOiBmKTtcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICBpID0gbnVsbCwgYSgpO1xuICAgICAgfSkpO1xuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgcyA9ICEwLCBhKCk7XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFd0KGUpIHtcbiAgcmV0dXJuIFcoZnVuY3Rpb24odCwgbikge1xuICAgIHooZSkuc3Vic2NyaWJlKEYobiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbi5jb21wbGV0ZSgpO1xuICAgIH0sIFdlKSksICFuLmNsb3NlZCAmJiB0LnN1YnNjcmliZShuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBRaShlLCB0LCBuKSB7XG4gIHZhciByID0gUChlKSB8fCB0IHx8IG4gPyB7IG5leHQ6IGUsIGVycm9yOiB0LCBjb21wbGV0ZTogbiB9IDogZTtcbiAgcmV0dXJuIHIgPyBXKGZ1bmN0aW9uKGksIG8pIHtcbiAgICB2YXIgcztcbiAgICAocyA9IHIuc3Vic2NyaWJlKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgfHwgcy5jYWxsKHIpO1xuICAgIHZhciBhID0gITA7XG4gICAgaS5zdWJzY3JpYmUoRihvLCBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgdTtcbiAgICAgICh1ID0gci5uZXh0KSA9PT0gbnVsbCB8fCB1ID09PSB2b2lkIDAgfHwgdS5jYWxsKHIsIGMpLCBvLm5leHQoYyk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGEgPSAhMSwgKGMgPSByLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBjID09PSB2b2lkIDAgfHwgYy5jYWxsKHIpLCBvLmNvbXBsZXRlKCk7XG4gICAgfSwgZnVuY3Rpb24oYykge1xuICAgICAgdmFyIHU7XG4gICAgICBhID0gITEsICh1ID0gci5lcnJvcikgPT09IG51bGwgfHwgdSA9PT0gdm9pZCAwIHx8IHUuY2FsbChyLCBjKSwgby5lcnJvcihjKTtcbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjLCB1O1xuICAgICAgYSAmJiAoKGMgPSByLnVuc3Vic2NyaWJlKSA9PT0gbnVsbCB8fCBjID09PSB2b2lkIDAgfHwgYy5jYWxsKHIpKSwgKHUgPSByLmZpbmFsaXplKSA9PT0gbnVsbCB8fCB1ID09PSB2b2lkIDAgfHwgdS5jYWxsKHIpO1xuICAgIH0pKTtcbiAgfSkgOiBRZTtcbn1cbnZhciBKaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgWGkgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgWmkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywganQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBlbyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHRvID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgQnQgPSAoZSwgdCwgbikgPT4gdCBpbiBlID8gSmkoZSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogbiB9KSA6IGVbdF0gPSBuLCBxID0gKGUsIHQpID0+IHtcbiAgZm9yICh2YXIgbiBpbiB0IHx8ICh0ID0ge30pKVxuICAgIGVvLmNhbGwodCwgbikgJiYgQnQoZSwgbiwgdFtuXSk7XG4gIGlmIChqdClcbiAgICBmb3IgKHZhciBuIG9mIGp0KHQpKVxuICAgICAgdG8uY2FsbCh0LCBuKSAmJiBCdChlLCBuLCB0W25dKTtcbiAgcmV0dXJuIGU7XG59LCBjZSA9IChlLCB0KSA9PiBYaShlLCBaaSh0KSksIEggPSAoZSwgdCwgbikgPT4gbmV3IFByb21pc2UoKHIsIGkpID0+IHtcbiAgdmFyIG8gPSAoYykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhKG4ubmV4dChjKSk7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaSh1KTtcbiAgICB9XG4gIH0sIHMgPSAoYykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhKG4udGhyb3coYykpO1xuICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgIGkodSk7XG4gICAgfVxuICB9LCBhID0gKGMpID0+IGMuZG9uZSA/IHIoYy52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoYy52YWx1ZSkudGhlbihvLCBzKTtcbiAgYSgobiA9IG4uYXBwbHkoZSwgdCkpLm5leHQoKSk7XG59KSwgT24gPSBcImxrXCI7XG5mdW5jdGlvbiBCKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID4gXCJ1XCIgPyAhMSA6IG5vKGUpIHx8IHJvKGUpO1xufVxuZnVuY3Rpb24gbm8oZSkge1xuICB2YXIgdDtcbiAgcmV0dXJuIGUgPyBlLmhhc093blByb3BlcnR5KFwicGFydGljaXBhbnRcIikgJiYgZS5oYXNPd25Qcm9wZXJ0eShcInNvdXJjZVwiKSAmJiBlLmhhc093blByb3BlcnR5KFwidHJhY2tcIikgJiYgdHlwZW9mICgodCA9IGUucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiB0LnRyYWNrKSA8IFwidVwiIDogITE7XG59XG5mdW5jdGlvbiBybyhlKSB7XG4gIHJldHVybiBlID8gZS5oYXNPd25Qcm9wZXJ0eShcInBhcnRpY2lwYW50XCIpICYmIGUuaGFzT3duUHJvcGVydHkoXCJzb3VyY2VcIikgJiYgZS5oYXNPd25Qcm9wZXJ0eShcInB1YmxpY2F0aW9uXCIpICYmIHR5cGVvZiBlLnB1YmxpY2F0aW9uIDwgXCJ1XCIgOiAhMTtcbn1cbmZ1bmN0aW9uIE9lKGUpIHtcbiAgcmV0dXJuIGUgPyBlLmhhc093blByb3BlcnR5KFwicGFydGljaXBhbnRcIikgJiYgZS5oYXNPd25Qcm9wZXJ0eShcInNvdXJjZVwiKSAmJiB0eXBlb2YgZS5wdWJsaWNhdGlvbiA+IFwidVwiIDogITE7XG59XG5mdW5jdGlvbiBOKGUpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gYCR7ZX1gO1xuICBpZiAoT2UoZSkpXG4gICAgcmV0dXJuIGAke2UucGFydGljaXBhbnQuaWRlbnRpdHl9XyR7ZS5zb3VyY2V9X3BsYWNlaG9sZGVyYDtcbiAgaWYgKEIoZSkpXG4gICAgcmV0dXJuIGAke2UucGFydGljaXBhbnQuaWRlbnRpdHl9XyR7ZS5wdWJsaWNhdGlvbi5zb3VyY2V9XyR7ZS5wdWJsaWNhdGlvbi50cmFja1NpZH1gO1xuICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGdlbmVyYXRlIGEgaWQgZm9yIHRoZSBnaXZlbiB0cmFjayByZWZlcmVuY2U6ICR7ZX1gKTtcbn1cbmZ1bmN0aW9uIHRzKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCB8fCB0ID09PSB2b2lkIDAgPyAhMSA6IEIoZSkgJiYgQih0KSA/IGUucHVibGljYXRpb24udHJhY2tTaWQgPT09IHQucHVibGljYXRpb24udHJhY2tTaWQgOiBOKGUpID09PSBOKHQpO1xufVxuZnVuY3Rpb24gbnMoZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIHQgPiBcInVcIiA/ICExIDogQihlKSA/IHQuc29tZShcbiAgICAobikgPT4gbi5wYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gZS5wYXJ0aWNpcGFudC5pZGVudGl0eSAmJiBCKG4pICYmIG4ucHVibGljYXRpb24udHJhY2tTaWQgPT09IGUucHVibGljYXRpb24udHJhY2tTaWRcbiAgKSA6IE9lKGUpID8gdC5zb21lKFxuICAgIChuKSA9PiBuLnBhcnRpY2lwYW50LmlkZW50aXR5ID09PSBlLnBhcnRpY2lwYW50LmlkZW50aXR5ICYmIE9lKG4pICYmIG4uc291cmNlID09PSBlLnNvdXJjZVxuICApIDogITE7XG59XG5mdW5jdGlvbiBpbyhlLCB0KSB7XG4gIHJldHVybiBPZShlKSAmJiBCKHQpICYmIHQucGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGUucGFydGljaXBhbnQuaWRlbnRpdHkgJiYgdC5zb3VyY2UgPT09IGUuc291cmNlO1xufVxuZnVuY3Rpb24gcnMoKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiLCBlLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcbiAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIHQuc3R5bGUudG9wID0gXCIwcHhcIiwgdC5zdHlsZS5sZWZ0ID0gXCIwcHhcIiwgdC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdC5zdHlsZS53aWR0aCA9IFwiMjAwcHhcIiwgdC5zdHlsZS5oZWlnaHQgPSBcIjE1MHB4XCIsIHQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCB0LmFwcGVuZENoaWxkKGUpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO1xuICBjb25zdCBuID0gZS5vZmZzZXRXaWR0aDtcbiAgdC5zdHlsZS5vdmVyZmxvdyA9IFwic2Nyb2xsXCI7XG4gIGxldCByID0gZS5vZmZzZXRXaWR0aDtcbiAgcmV0dXJuIG4gPT09IHIgJiYgKHIgPSB0LmNsaWVudFdpZHRoKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgbiAtIHI7XG59XG5mdW5jdGlvbiBpcygpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCA8IFwidVwiO1xufVxuZnVuY3Rpb24gb28oZSkge1xuICBlID0gcSh7fSwgZSk7XG4gIGNvbnN0IHQgPSBcIig/Oig/OlthLXpdKzopPy8vKT9cIiwgbiA9IFwiKD86XFxcXFMrKD86OlxcXFxTKik/QCk/XCIsIHIgPSBuZXcgUmVnRXhwKFxuICAgIFwiKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M31cIixcbiAgICBcImdcIlxuICApLnNvdXJjZSwgdSA9IGAoPzoke3R9fHd3d1xcXFwuKSR7bn0oPzpsb2NhbGhvc3R8JHtyfXwoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV1bLV9dKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKSooPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmXXsyLH0pKVxcXFwuPykoPzo6XFxcXGR7Miw1fSk/KD86Wy8/I11bXlxcXFxzXCJdKik/YDtcbiAgcmV0dXJuIGUuZXhhY3QgPyBuZXcgUmVnRXhwKGAoPzpeJHt1fSQpYCwgXCJpXCIpIDogbmV3IFJlZ0V4cCh1LCBcImlnXCIpO1xufVxudmFyIFZ0ID0gXCJbXlxcXFwuXFxcXHNAOl0oPzpbXlxcXFxzQDpdKlteXFxcXHNAOlxcXFwuXSk/QFteXFxcXC5cXFxcc0BdKyg/OlxcXFwuW15cXFxcLlxcXFxzQF0rKSpcIjtcbmZ1bmN0aW9uIHNvKHsgZXhhY3Q6IGUgfSA9IHt9KSB7XG4gIHJldHVybiBlID8gbmV3IFJlZ0V4cChgXiR7VnR9JGApIDogbmV3IFJlZ0V4cChWdCwgXCJnXCIpO1xufVxuZnVuY3Rpb24gb3MoZSwgdCwgbikge1xuICByZXR1cm4gVXIoZSwgdCwgKCkgPT4gSCh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHsgeDogaSwgeTogbyB9ID0geWllbGQgVnIoZSwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcInRvcFwiLFxuICAgICAgbWlkZGxld2FyZTogW1dyKDYpLCBCcigpLCBqcih7IHBhZGRpbmc6IDUgfSldXG4gICAgfSk7XG4gICAgbiA9PSBudWxsIHx8IG4oaSwgbyk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHNzKGUsIHQpIHtcbiAgcmV0dXJuICFlLmNvbnRhaW5zKHQudGFyZ2V0KTtcbn1cbnZhciBhcyA9ICgpID0+ICh7XG4gIGVtYWlsOiBzbygpLFxuICB1cmw6IG9vKHt9KVxufSk7XG5mdW5jdGlvbiBjcyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBPYmplY3QuZW50cmllcyh0KS5tYXAoXG4gICAgKFtvLCBzXSwgYSkgPT4gQXJyYXkuZnJvbShlLm1hdGNoQWxsKHMpKS5tYXAoKHsgaW5kZXg6IGMsIDA6IHUgfSkgPT4gKHtcbiAgICAgIHR5cGU6IG8sXG4gICAgICB3ZWlnaHQ6IGEsXG4gICAgICBjb250ZW50OiB1LFxuICAgICAgaW5kZXg6IGMgPz8gMFxuICAgIH0pKVxuICApLmZsYXQoKS5zb3J0KChvLCBzKSA9PiB7XG4gICAgY29uc3QgYSA9IG8uaW5kZXggLSBzLmluZGV4O1xuICAgIHJldHVybiBhICE9PSAwID8gYSA6IG8ud2VpZ2h0IC0gcy53ZWlnaHQ7XG4gIH0pLmZpbHRlcigoeyBpbmRleDogbyB9LCBzLCBhKSA9PiB7XG4gICAgaWYgKHMgPT09IDApIHJldHVybiAhMDtcbiAgICBjb25zdCBjID0gYVtzIC0gMV07XG4gICAgcmV0dXJuIGMuaW5kZXggKyBjLmNvbnRlbnQubGVuZ3RoIDw9IG87XG4gIH0pLCByID0gW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCB7IHR5cGU6IG8sIGNvbnRlbnQ6IHMsIGluZGV4OiBhIH0gb2YgbilcbiAgICBhID4gaSAmJiByLnB1c2goZS5zdWJzdHJpbmcoaSwgYSkpLCByLnB1c2goeyB0eXBlOiBvLCBjb250ZW50OiBzIH0pLCBpID0gYSArIHMubGVuZ3RoO1xuICByZXR1cm4gZS5sZW5ndGggPiBpICYmIHIucHVzaChlLnN1YnN0cmluZyhpKSksIHI7XG59XG52YXIgYW8gPSBbXG4gIHkuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCxcbiAgeS5Sb29tTWV0YWRhdGFDaGFuZ2VkLFxuICB5LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCxcbiAgeS5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXG4gIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXG4gIHkuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsXG4gIHkuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gIHkuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsXG4gIHkuUGFydGljaXBhbnROYW1lQ2hhbmdlZCxcbiAgeS5QYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkLFxuICB5LlRyYWNrTXV0ZWQsXG4gIHkuVHJhY2tVbm11dGVkLFxuICB5LlRyYWNrUHVibGlzaGVkLFxuICB5LlRyYWNrVW5wdWJsaXNoZWQsXG4gIHkuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsXG4gIHkuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsXG4gIHkuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgeS5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcbl0sIEFuID0gW1xuICAuLi5hbyxcbiAgeS5Mb2NhbFRyYWNrUHVibGlzaGVkLFxuICB5LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFxuXSwgY28gPSBbXG4gIHcuVHJhY2tQdWJsaXNoZWQsXG4gIHcuVHJhY2tVbnB1Ymxpc2hlZCxcbiAgdy5UcmFja011dGVkLFxuICB3LlRyYWNrVW5tdXRlZCxcbiAgdy5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCxcbiAgdy5UcmFja1N1YnNjcmliZWQsXG4gIHcuVHJhY2tVbnN1YnNjcmliZWQsXG4gIHcuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgdy5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCxcbiAgdy5Mb2NhbFRyYWNrUHVibGlzaGVkLFxuICB3LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFxuXSwgdW8gPSBbXG4gIHcuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxuICB3LklzU3BlYWtpbmdDaGFuZ2VkLFxuICB3LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLFxuICB3LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICB3LlRyYWNrTXV0ZWQsXG4gIHcuVHJhY2tVbm11dGVkLFxuICB3LlRyYWNrUHVibGlzaGVkLFxuICB3LlRyYWNrVW5wdWJsaXNoZWQsXG4gIHcuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsXG4gIHcuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsXG4gIHcuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgdy5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcbl0sIGtuID0gW1xuICAuLi51byxcbiAgdy5Mb2NhbFRyYWNrUHVibGlzaGVkLFxuICB3LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFxuXSwgTCA9IEtyLmdldExvZ2dlcihcImxrLWNvbXBvbmVudHMtanNcIik7XG5MLnNldERlZmF1bHRMZXZlbChcIldBUk5cIik7XG5mdW5jdGlvbiB1cyhlLCB0ID0ge30pIHtcbiAgdmFyIG47XG4gIEwuc2V0TGV2ZWwoZSksIHFuKChuID0gdC5saXZlS2l0Q2xpZW50TG9nTGV2ZWwpICE9IG51bGwgPyBuIDogZSk7XG59XG5mdW5jdGlvbiBscyhlLCB0ID0ge30pIHtcbiAgdmFyIG47XG4gIGNvbnN0IHIgPSBMLm1ldGhvZEZhY3Rvcnk7XG4gIEwubWV0aG9kRmFjdG9yeSA9IChpLCBvLCBzKSA9PiB7XG4gICAgY29uc3QgYSA9IHIoaSwgbywgcyksIGMgPSBTdFtpXSwgdSA9IGMgPj0gbyAmJiBjIDwgU3Quc2lsZW50O1xuICAgIHJldHVybiAobCwgZikgPT4ge1xuICAgICAgZiA/IGEobCwgZikgOiBhKGwpLCB1ICYmIGUoYywgbCwgZik7XG4gICAgfTtcbiAgfSwgTC5zZXRMZXZlbChMLmdldExldmVsKCkpLCBLbigobiA9IHQubGl2ZUtpdENsaWVudExvZ0V4dGVuc2lvbikgIT0gbnVsbCA/IG4gOiBlKTtcbn1cbnZhciBmcyA9IFtcbiAge1xuICAgIGNvbHVtbnM6IDEsXG4gICAgcm93czogMVxuICB9LFxuICB7XG4gICAgY29sdW1uczogMSxcbiAgICByb3dzOiAyLFxuICAgIG9yaWVudGF0aW9uOiBcInBvcnRyYWl0XCJcbiAgfSxcbiAge1xuICAgIGNvbHVtbnM6IDIsXG4gICAgcm93czogMSxcbiAgICBvcmllbnRhdGlvbjogXCJsYW5kc2NhcGVcIlxuICB9LFxuICB7XG4gICAgY29sdW1uczogMixcbiAgICByb3dzOiAyLFxuICAgIG1pbldpZHRoOiA1NjBcbiAgfSxcbiAge1xuICAgIGNvbHVtbnM6IDMsXG4gICAgcm93czogMyxcbiAgICBtaW5XaWR0aDogNzAwXG4gIH0sXG4gIHtcbiAgICBjb2x1bW5zOiA0LFxuICAgIHJvd3M6IDQsXG4gICAgbWluV2lkdGg6IDk2MFxuICB9LFxuICB7XG4gICAgY29sdW1uczogNSxcbiAgICByb3dzOiA1LFxuICAgIG1pbldpZHRoOiAxMTAwXG4gIH1cbl07XG5mdW5jdGlvbiBsbyhlLCB0LCBuLCByKSB7XG4gIGlmIChlLmxlbmd0aCA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGdyaWQgbGF5b3V0IGRlZmluaXRpb24gbXVzdCBiZSBwcm92aWRlZC5cIik7XG4gIGNvbnN0IGkgPSBmbyhlKTtcbiAgaWYgKG4gPD0gMCB8fCByIDw9IDApXG4gICAgcmV0dXJuIGlbMF07XG4gIGxldCBvID0gMDtcbiAgY29uc3QgcyA9IG4gLyByID4gMSA/IFwibGFuZHNjYXBlXCIgOiBcInBvcnRyYWl0XCI7XG4gIGxldCBhID0gaS5maW5kKChjLCB1LCBsKSA9PiB7XG4gICAgbyA9IHU7XG4gICAgY29uc3QgZiA9IGwuZmluZEluZGV4KCh2LCBkKSA9PiB7XG4gICAgICBjb25zdCBtID0gIXYub3JpZW50YXRpb24gfHwgdi5vcmllbnRhdGlvbiA9PT0gcywgcCA9IGQgPiB1LCBnID0gdi5tYXhUaWxlcyA9PT0gYy5tYXhUaWxlcztcbiAgICAgIHJldHVybiBwICYmIGcgJiYgbTtcbiAgICB9KSAhPT0gLTE7XG4gICAgcmV0dXJuIGMubWF4VGlsZXMgPj0gdCAmJiAhZjtcbiAgfSk7XG4gIGlmIChhID09PSB2b2lkIDApXG4gICAgaWYgKGEgPSBpW2kubGVuZ3RoIC0gMV0sIGEpXG4gICAgICBMLndhcm4oXG4gICAgICAgIGBObyBsYXlvdXQgZm91bmQgZm9yOiBwYXJ0aWNpcGFudENvdW50OiAke3R9LCB3aWR0aC9oZWlnaHQ6ICR7bn0vJHtyfSBmYWxsYmFjayB0byBiaWdnZXN0IGF2YWlsYWJsZSBsYXlvdXQgKCR7YX0pLmBcbiAgICAgICk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbGF5b3V0IG9yIGZhbGxiYWNrIGxheW91dCBmb3VuZC5cIik7XG4gIGlmICgobiA8IGEubWluV2lkdGggfHwgciA8IGEubWluSGVpZ2h0KSAmJiBvID4gMCkge1xuICAgIGNvbnN0IGMgPSBpW28gLSAxXTtcbiAgICBhID0gbG8oXG4gICAgICBpLnNsaWNlKDAsIG8pLFxuICAgICAgYy5tYXhUaWxlcyxcbiAgICAgIG4sXG4gICAgICByXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGZvKGUpIHtcbiAgcmV0dXJuIFsuLi5lXS5tYXAoKHQpID0+IHtcbiAgICB2YXIgbiwgcjtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYCR7dC5jb2x1bW5zfXgke3Qucm93c31gLFxuICAgICAgY29sdW1uczogdC5jb2x1bW5zLFxuICAgICAgcm93czogdC5yb3dzLFxuICAgICAgbWF4VGlsZXM6IHQuY29sdW1ucyAqIHQucm93cyxcbiAgICAgIG1pbldpZHRoOiAobiA9IHQubWluV2lkdGgpICE9IG51bGwgPyBuIDogMCxcbiAgICAgIG1pbkhlaWdodDogKHIgPSB0Lm1pbkhlaWdodCkgIT0gbnVsbCA/IHIgOiAwLFxuICAgICAgb3JpZW50YXRpb246IHQub3JpZW50YXRpb25cbiAgICB9O1xuICB9KS5zb3J0KCh0LCBuKSA9PiB0Lm1heFRpbGVzICE9PSBuLm1heFRpbGVzID8gdC5tYXhUaWxlcyAtIG4ubWF4VGlsZXMgOiB0Lm1pbldpZHRoICE9PSAwIHx8IG4ubWluV2lkdGggIT09IDAgPyB0Lm1pbldpZHRoIC0gbi5taW5XaWR0aCA6IHQubWluSGVpZ2h0ICE9PSAwIHx8IG4ubWluSGVpZ2h0ICE9PSAwID8gdC5taW5IZWlnaHQgLSBuLm1pbkhlaWdodCA6IDApO1xufVxuZnVuY3Rpb24gZHMoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAhIW5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhO1xufVxuZnVuY3Rpb24gcHMoZSwgdCkge1xuICB2YXIgbjtcbiAgcmV0dXJuIGNlKHEoe30sIGUpLCB7XG4gICAgcmVjZWl2ZWRBdE1lZGlhVGltZXN0YW1wOiAobiA9IHQucnRwVGltZXN0YW1wKSAhPSBudWxsID8gbiA6IDAsXG4gICAgcmVjZWl2ZWRBdDogdC50aW1lc3RhbXBcbiAgfSk7XG59XG5mdW5jdGlvbiBocyhlLCB0LCBuKSB7XG4gIHJldHVybiBbLi4uZSwgLi4udF0ucmVkdWNlUmlnaHQoKHIsIGkpID0+IChyLmZpbmQoKG8pID0+IG8uaWQgPT09IGkuaWQpIHx8IHIudW5zaGlmdChpKSwgciksIFtdKS5zbGljZSgwIC0gbik7XG59XG52YXIgcG8gPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5BZ2VudFN0YXRlID0gXCJsay5hZ2VudC5zdGF0ZVwiLCBlLlB1Ymxpc2hPbkJlaGFsZiA9IFwibGsucHVibGlzaF9vbl9iZWhhbGZcIiwgZS5UcmFuc2NyaXB0aW9uRmluYWwgPSBcImxrLnRyYW5zY3JpcHRpb25fZmluYWxcIiwgZS5UcmFuc2NyaXB0aW9uU2VnbWVudElkID0gXCJsay5zZWdtZW50X2lkXCIsIGUuVHJhbnNjcmliZWRUcmFja0lkID0gXCJsay50cmFuc2NyaWJlZF90cmFja19pZFwiLCBlKSkocG8gfHwge30pLCBfbiA9IFtdLCBMbiA9IHtcbiAgc2hvd0NoYXQ6ICExLFxuICB1bnJlYWRNZXNzYWdlczogMCxcbiAgc2hvd1NldHRpbmdzOiAhMVxufTtcbmZ1bmN0aW9uIGhvKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiB2cyhlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGUpICYmIGUuZmlsdGVyKGhvKS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gSW4oZSwgdCkge1xuICByZXR1cm4gdC5hdWRpb0xldmVsIC0gZS5hdWRpb0xldmVsO1xufVxuZnVuY3Rpb24gTW4oZSwgdCkge1xuICByZXR1cm4gZS5pc1NwZWFraW5nID09PSB0LmlzU3BlYWtpbmcgPyAwIDogZS5pc1NwZWFraW5nID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gUm4oZSwgdCkge1xuICB2YXIgbiwgciwgaSwgbztcbiAgcmV0dXJuIGUubGFzdFNwb2tlQXQgIT09IHZvaWQgMCB8fCB0Lmxhc3RTcG9rZUF0ICE9PSB2b2lkIDAgPyAoKHIgPSAobiA9IHQubGFzdFNwb2tlQXQpID09IG51bGwgPyB2b2lkIDAgOiBuLmdldFRpbWUoKSkgIT0gbnVsbCA/IHIgOiAwKSAtICgobyA9IChpID0gZS5sYXN0U3Bva2VBdCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZ2V0VGltZSgpKSAhPSBudWxsID8gbyA6IDApIDogMDtcbn1cbmZ1bmN0aW9uIEJlKGUsIHQpIHtcbiAgdmFyIG4sIHIsIGksIG87XG4gIHJldHVybiAoKHIgPSAobiA9IGUuam9pbmVkQXQpID09IG51bGwgPyB2b2lkIDAgOiBuLmdldFRpbWUoKSkgIT0gbnVsbCA/IHIgOiAwKSAtICgobyA9IChpID0gdC5qb2luZWRBdCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZ2V0VGltZSgpKSAhPSBudWxsID8gbyA6IDApO1xufVxuZnVuY3Rpb24gdm8oZSwgdCkge1xuICByZXR1cm4gQihlKSA/IEIodCkgPyAwIDogLTEgOiBCKHQpID8gMSA6IDA7XG59XG5mdW5jdGlvbiBtbyhlLCB0KSB7XG4gIGNvbnN0IG4gPSBlLnBhcnRpY2lwYW50LmlzQ2FtZXJhRW5hYmxlZCwgciA9IHQucGFydGljaXBhbnQuaXNDYW1lcmFFbmFibGVkO1xuICByZXR1cm4gbiAhPT0gciA/IG4gPyAtMSA6IDEgOiAwO1xufVxuZnVuY3Rpb24gbXMoZSkge1xuICBjb25zdCB0ID0gW10sIG4gPSBbXSwgciA9IFtdLCBpID0gW107XG4gIGUuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGEucGFydGljaXBhbnQuaXNMb2NhbCAmJiBhLnNvdXJjZSA9PT0gUi5Tb3VyY2UuQ2FtZXJhID8gdC5wdXNoKGEpIDogYS5zb3VyY2UgPT09IFIuU291cmNlLlNjcmVlblNoYXJlID8gbi5wdXNoKGEpIDogYS5zb3VyY2UgPT09IFIuU291cmNlLkNhbWVyYSA/IHIucHVzaChhKSA6IGkucHVzaChhKTtcbiAgfSk7XG4gIGNvbnN0IG8gPSBnbyhuKSwgcyA9IGJvKHIpO1xuICByZXR1cm4gWy4uLnQsIC4uLm8sIC4uLnMsIC4uLmldO1xufVxuZnVuY3Rpb24gZ28oZSkge1xuICBjb25zdCB0ID0gW10sIG4gPSBbXTtcbiAgcmV0dXJuIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGkucGFydGljaXBhbnQuaXNMb2NhbCA/IHQucHVzaChpKSA6IG4ucHVzaChpKTtcbiAgfSksIHQuc29ydCgoaSwgbykgPT4gQmUoaS5wYXJ0aWNpcGFudCwgby5wYXJ0aWNpcGFudCkpLCBuLnNvcnQoKGksIG8pID0+IEJlKGkucGFydGljaXBhbnQsIG8ucGFydGljaXBhbnQpKSwgWy4uLm4sIC4uLnRdO1xufVxuZnVuY3Rpb24gYm8oZSkge1xuICBjb25zdCB0ID0gW10sIG4gPSBbXTtcbiAgcmV0dXJuIGUuZm9yRWFjaCgocikgPT4ge1xuICAgIHIucGFydGljaXBhbnQuaXNMb2NhbCA/IHQucHVzaChyKSA6IG4ucHVzaChyKTtcbiAgfSksIG4uc29ydCgociwgaSkgPT4gci5wYXJ0aWNpcGFudC5pc1NwZWFraW5nICYmIGkucGFydGljaXBhbnQuaXNTcGVha2luZyA/IEluKHIucGFydGljaXBhbnQsIGkucGFydGljaXBhbnQpIDogci5wYXJ0aWNpcGFudC5pc1NwZWFraW5nICE9PSBpLnBhcnRpY2lwYW50LmlzU3BlYWtpbmcgPyBNbihyLnBhcnRpY2lwYW50LCBpLnBhcnRpY2lwYW50KSA6IHIucGFydGljaXBhbnQubGFzdFNwb2tlQXQgIT09IGkucGFydGljaXBhbnQubGFzdFNwb2tlQXQgPyBSbihyLnBhcnRpY2lwYW50LCBpLnBhcnRpY2lwYW50KSA6IEIocikgIT09IEIoaSkgPyB2byhyLCBpKSA6IHIucGFydGljaXBhbnQuaXNDYW1lcmFFbmFibGVkICE9PSBpLnBhcnRpY2lwYW50LmlzQ2FtZXJhRW5hYmxlZCA/IG1vKHIsIGkpIDogQmUoci5wYXJ0aWNpcGFudCwgaS5wYXJ0aWNpcGFudCkpLCBbLi4udCwgLi4ubl07XG59XG5mdW5jdGlvbiBncyhlKSB7XG4gIGNvbnN0IHQgPSBbLi4uZV07XG4gIHQuc29ydCgociwgaSkgPT4ge1xuICAgIGlmIChyLmlzU3BlYWtpbmcgJiYgaS5pc1NwZWFraW5nKVxuICAgICAgcmV0dXJuIEluKHIsIGkpO1xuICAgIGlmIChyLmlzU3BlYWtpbmcgIT09IGkuaXNTcGVha2luZylcbiAgICAgIHJldHVybiBNbihyLCBpKTtcbiAgICBpZiAoci5sYXN0U3Bva2VBdCAhPT0gaS5sYXN0U3Bva2VBdClcbiAgICAgIHJldHVybiBSbihyLCBpKTtcbiAgICBjb25zdCBvID0gci52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPiAwLCBzID0gaS52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPiAwO1xuICAgIHJldHVybiBvICE9PSBzID8gbyA/IC0xIDogMSA6IEJlKHIsIGkpO1xuICB9KTtcbiAgY29uc3QgbiA9IHQuZmluZCgocikgPT4gci5pc0xvY2FsKTtcbiAgaWYgKG4pIHtcbiAgICBjb25zdCByID0gdC5pbmRleE9mKG4pO1xuICAgIHIgPj0gMCAmJiAodC5zcGxpY2UociwgMSksIHQubGVuZ3RoID4gMCA/IHQuc3BsaWNlKDAsIDAsIG4pIDogdC5wdXNoKG4pKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHlvKGUsIHQpIHtcbiAgcmV0dXJuIGUucmVkdWNlKFxuICAgIChuLCByLCBpKSA9PiBpICUgdCA9PT0gMCA/IFsuLi5uLCBbcl1dIDogWy4uLm4uc2xpY2UoMCwgLTEpLCBbLi4ubi5zbGljZSgtMSlbMF0sIHJdXSxcbiAgICBbXVxuICApO1xufVxuZnVuY3Rpb24gSHQoZSwgdCkge1xuICBjb25zdCBuID0gTWF0aC5tYXgoZS5sZW5ndGgsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBBcnJheShuKS5maWxsKFtdKS5tYXAoKHIsIGkpID0+IFtlW2ldLCB0W2ldXSk7XG59XG5mdW5jdGlvbiBWZShlLCB0LCBuKSB7XG4gIHJldHVybiBlLmZpbHRlcigocikgPT4gIXQubWFwKChpKSA9PiBuKGkpKS5pbmNsdWRlcyhuKHIpKSk7XG59XG5mdW5jdGlvbiBmdChlKSB7XG4gIHJldHVybiBlLm1hcCgodCkgPT4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gYCR7dH1gIDogTih0KSk7XG59XG5mdW5jdGlvbiB3byhlLCB0KSB7XG4gIHJldHVybiB7XG4gICAgZHJvcHBlZDogVmUoZSwgdCwgTiksXG4gICAgYWRkZWQ6IFZlKHQsIGUsIE4pXG4gIH07XG59XG5mdW5jdGlvbiB4byhlKSB7XG4gIHJldHVybiBlLmFkZGVkLmxlbmd0aCAhPT0gMCB8fCBlLmRyb3BwZWQubGVuZ3RoICE9PSAwO1xufVxuZnVuY3Rpb24gZHQoZSwgdCkge1xuICBjb25zdCBuID0gdC5maW5kSW5kZXgoXG4gICAgKHIpID0+IE4ocikgPT09IE4oZSlcbiAgKTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFbGVtZW50IG5vdCBwYXJ0IG9mIHRoZSBhcnJheTogJHtOKFxuICAgICAgICBlXG4gICAgICApfSBub3QgaW4gJHtmdCh0KX1gXG4gICAgKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBTbyhlLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBkdChlLCBuKSwgaSA9IGR0KHQsIG4pO1xuICByZXR1cm4gbi5zcGxpY2UociwgMSwgdCksIG4uc3BsaWNlKGksIDEsIGUpLCBuO1xufVxuZnVuY3Rpb24gVG8oZSwgdCkge1xuICBjb25zdCBuID0gZHQoZSwgdCk7XG4gIHJldHVybiB0LnNwbGljZShuLCAxKSwgdDtcbn1cbmZ1bmN0aW9uIEVvKGUsIHQpIHtcbiAgcmV0dXJuIFsuLi50LCBlXTtcbn1cbmZ1bmN0aW9uIHJ0KGUsIHQpIHtcbiAgcmV0dXJuIHlvKGUsIHQpO1xufVxuZnVuY3Rpb24gYnMoZSwgdCwgbikge1xuICBsZXQgciA9IENvKGUsIHQpO1xuICBpZiAoci5sZW5ndGggPCB0Lmxlbmd0aCkge1xuICAgIGNvbnN0IHMgPSBWZSh0LCByLCBOKTtcbiAgICByID0gWy4uLnIsIC4uLnNdO1xuICB9XG4gIGNvbnN0IGkgPSBydChyLCBuKSwgbyA9IHJ0KHQsIG4pO1xuICBpZiAoSHQoaSwgbykuZm9yRWFjaCgoW3MsIGFdLCBjKSA9PiB7XG4gICAgaWYgKHMgJiYgYSkge1xuICAgICAgY29uc3QgdSA9IHJ0KHIsIG4pW2NdLCBsID0gd28odSwgYSk7XG4gICAgICB4byhsKSAmJiAoTC5kZWJ1ZyhcbiAgICAgICAgYERldGVjdGVkIHZpc3VhbCBjaGFuZ2VzIG9uIHBhZ2U6ICR7Y30sIGN1cnJlbnQ6ICR7ZnQoXG4gICAgICAgICAgc1xuICAgICAgICApfSwgbmV4dDogJHtmdChhKX1gLFxuICAgICAgICB7IGNoYW5nZXM6IGwgfVxuICAgICAgKSwgbC5hZGRlZC5sZW5ndGggPT09IGwuZHJvcHBlZC5sZW5ndGggJiYgSHQobC5hZGRlZCwgbC5kcm9wcGVkKS5mb3JFYWNoKChbZiwgdl0pID0+IHtcbiAgICAgICAgaWYgKGYgJiYgdilcbiAgICAgICAgICByID0gU28oZiwgdiwgcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRm9yIGEgc3dhcCBhY3Rpb24gd2UgbmVlZCBhIGFkZGl0aW9uIGFuZCBhIHJlbW92YWwgb25lIGlzIG1pc3Npbmc6ICR7Zn0sICR7dn1gXG4gICAgICAgICAgKTtcbiAgICAgIH0pLCBsLmFkZGVkLmxlbmd0aCA9PT0gMCAmJiBsLmRyb3BwZWQubGVuZ3RoID4gMCAmJiBsLmRyb3BwZWQuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgICByID0gVG8oZiwgcik7XG4gICAgICB9KSwgbC5hZGRlZC5sZW5ndGggPiAwICYmIGwuZHJvcHBlZC5sZW5ndGggPT09IDAgJiYgbC5hZGRlZC5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgIHIgPSBFbyhmLCByKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pLCByLmxlbmd0aCA+IHQubGVuZ3RoKSB7XG4gICAgY29uc3QgcyA9IFZlKHIsIHQsIE4pO1xuICAgIHIgPSByLmZpbHRlcihcbiAgICAgIChhKSA9PiAhcy5tYXAoTikuaW5jbHVkZXMoTihhKSlcbiAgICApO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ28oZSwgdCkge1xuICByZXR1cm4gZS5tYXAoKG4pID0+IHtcbiAgICBjb25zdCByID0gdC5maW5kKFxuICAgICAgKGkpID0+IChcbiAgICAgICAgLy8gSWYgdGhlIElEcyBtYXRjaCBvciAuLlxuICAgICAgICBOKG4pID09PSBOKGkpIHx8IC8vIC4uLiBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgcGxhY2Vob2xkZXIgYW5kIHRoZSBuZXcgaXRlbSBpcyB0aGUgdHJhY2sgcmVmZXJlbmNlIGNhbiByZXBsYWNlIGl0LlxuICAgICAgICB0eXBlb2YgbiAhPSBcIm51bWJlclwiICYmIE9lKG4pICYmIEIoaSkgJiYgaW8obiwgaSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiByID8/IG47XG4gIH0pO1xufVxuZnVuY3Rpb24gVShlKSB7XG4gIHJldHVybiBgJHtPbn0tJHtlfWA7XG59XG5mdW5jdGlvbiB5cyhlKSB7XG4gIGNvbnN0IHQgPSB6dChlKSwgbiA9IERuKGUucGFydGljaXBhbnQpLnBpcGUoXG4gICAgQSgoKSA9PiB6dChlKSksXG4gICAgRCh0KVxuICApO1xuICByZXR1cm4geyBjbGFzc05hbWU6IFUoXG4gICAgZS5zb3VyY2UgPT09IFIuU291cmNlLkNhbWVyYSB8fCBlLnNvdXJjZSA9PT0gUi5Tb3VyY2UuU2NyZWVuU2hhcmUgPyBcInBhcnRpY2lwYW50LW1lZGlhLXZpZGVvXCIgOiBcInBhcnRpY2lwYW50LW1lZGlhLWF1ZGlvXCJcbiAgKSwgdHJhY2tPYnNlcnZlcjogbiB9O1xufVxuZnVuY3Rpb24genQoZSkge1xuICBpZiAoQihlKSlcbiAgICByZXR1cm4gZS5wdWJsaWNhdGlvbjtcbiAge1xuICAgIGNvbnN0IHsgc291cmNlOiB0LCBuYW1lOiBuLCBwYXJ0aWNpcGFudDogciB9ID0gZTtcbiAgICBpZiAodCAmJiBuKVxuICAgICAgcmV0dXJuIHIuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKS5maW5kKChpKSA9PiBpLnNvdXJjZSA9PT0gdCAmJiBpLnRyYWNrTmFtZSA9PT0gbik7XG4gICAgaWYgKG4pXG4gICAgICByZXR1cm4gci5nZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG4pO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuIHIuZ2V0VHJhY2tQdWJsaWNhdGlvbih0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgb2Ygc291cmNlIGFuZCBuYW1lIG5lZWRzIHRvIGJlIGRlZmluZWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHBlKGUsIC4uLnQpIHtcbiAgcmV0dXJuIG5ldyBrKChyKSA9PiB7XG4gICAgY29uc3QgaSA9ICgpID0+IHtcbiAgICAgIHIubmV4dChlKTtcbiAgICB9O1xuICAgIHJldHVybiB0LmZvckVhY2goKHMpID0+IHtcbiAgICAgIGUub24ocywgaSk7XG4gICAgfSksICgpID0+IHtcbiAgICAgIHQuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBlLm9mZihzLCBpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pLnBpcGUoRChlKSk7XG59XG5mdW5jdGlvbiB3ZShlLCB0KSB7XG4gIHJldHVybiBuZXcgaygocikgPT4ge1xuICAgIGNvbnN0IGkgPSAoLi4ucykgPT4ge1xuICAgICAgci5uZXh0KHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGUub24odCwgaSksICgpID0+IHtcbiAgICAgIGUub2ZmKHQsIGkpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gd3MoZSkge1xuICByZXR1cm4gd2UoZSwgeS5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKS5waXBlKFxuICAgIEEoKFt0XSkgPT4gdCksXG4gICAgRChlLnN0YXRlKVxuICApO1xufVxuZnVuY3Rpb24geHMoZSkge1xuICByZXR1cm4gcGUoXG4gICAgZSxcbiAgICB5LlJvb21NZXRhZGF0YUNoYW5nZWQsXG4gICAgeS5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gICkucGlwZShcbiAgICBBKChuKSA9PiAoeyBuYW1lOiBuLm5hbWUsIG1ldGFkYXRhOiBuLm1ldGFkYXRhIH0pKVxuICApO1xufVxuZnVuY3Rpb24gU3MoZSkge1xuICByZXR1cm4gd2UoZSwgeS5BY3RpdmVTcGVha2Vyc0NoYW5nZWQpLnBpcGUoXG4gICAgQSgoW3RdKSA9PiB0KVxuICApO1xufVxuZnVuY3Rpb24gVHMoZSwgdCwgbiA9ICEwKSB7XG4gIGNvbnN0IHIgPSBuZXcgaygobykgPT4ge1xuICAgIFR0LmdldExvY2FsRGV2aWNlcyhlLCBuKS50aGVuKChzKSA9PiB7XG4gICAgICBvLm5leHQocyksIG8uY29tcGxldGUoKTtcbiAgICB9KS5jYXRjaCgocykgPT4ge1xuICAgICAgdCA9PSBudWxsIHx8IHQocyksIG8ubmV4dChbXSksIG8uY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfSksIGkgPSBuZXcgaygobykgPT4ge1xuICAgIHZhciBzO1xuICAgIGNvbnN0IGEgPSAoKSA9PiBIKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjID0geWllbGQgVHQuZ2V0TG9jYWxEZXZpY2VzKGUsIG4pO1xuICAgICAgICBvLm5leHQoYyk7XG4gICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgIHQgPT0gbnVsbCB8fCB0KGMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpIHtcbiAgICAgIGlmICghd2luZG93LmlzU2VjdXJlQ29udGV4dClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIG1lZGlhIGRldmljZXMgaXMgYXZhaWxhYmxlIG9ubHkgaW4gc2VjdXJlIGNvbnRleHRzIChIVFRQUyBhbmQgbG9jYWxob3N0KSwgaW4gc29tZSBvciBhbGwgc3VwcG9ydGluZyBicm93c2Vycy4gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL21lZGlhRGV2aWNlc1wiXG4gICAgICAgICk7XG4gICAgICAocyA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCB8fCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VjaGFuZ2VcIiwgYSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgYztcbiAgICAgIChjID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PSBudWxsIHx8IGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZWNoYW5nZVwiLCBhKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGplKHIsIGkpO1xufVxuZnVuY3Rpb24gUG8oZSkge1xuICByZXR1cm4gd2UoZSwgeS5EYXRhUmVjZWl2ZWQpO1xufVxuZnVuY3Rpb24gT28oZSkge1xuICByZXR1cm4gcGUoZSwgeS5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCkucGlwZShcbiAgICBBKChuKSA9PiAoeyBjYW5QbGF5QXVkaW86IG4uY2FuUGxheWJhY2tBdWRpbyB9KSlcbiAgKTtcbn1cbmZ1bmN0aW9uIEFvKGUpIHtcbiAgcmV0dXJuIHBlKGUsIHkuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQpLnBpcGUoXG4gICAgQSgobikgPT4gKHsgY2FuUGxheVZpZGVvOiBuLmNhblBsYXliYWNrVmlkZW8gfSkpXG4gICk7XG59XG5mdW5jdGlvbiBrbyhlLCB0KSB7XG4gIHJldHVybiB3ZShlLCB5LkFjdGl2ZURldmljZUNoYW5nZWQpLnBpcGUoXG4gICAgWGUoKFtuXSkgPT4gbiA9PT0gdCksXG4gICAgQSgoW24sIHJdKSA9PiAoTC5kZWJ1ZyhcImFjdGl2ZURldmljZU9ic2VydmFibGUgfCBSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZFwiLCB7IGtpbmQ6IG4sIGRldmljZUlkOiByIH0pLCByKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIEVzKGUsIHQpIHtcbiAgcmV0dXJuIHdlKGUsIHkuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCkucGlwZShcbiAgICBYZShcbiAgICAgIChbLCBuXSkgPT4gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaWRlbnRpdHkpID09PSAobiA9PSBudWxsID8gdm9pZCAwIDogbi5pZGVudGl0eSkgfHwgIW4gJiYgKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaWRlbnRpdHkpID09PSBlLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICApLFxuICAgIEEoKFtuXSkgPT4gbiksXG4gICAgRChcbiAgICAgIHQgIT0gbnVsbCAmJiB0LmlzTG9jYWwgPyB0LmlzRTJFRUVuYWJsZWQgOiAhISh0ICE9IG51bGwgJiYgdC5pc0VuY3J5cHRlZClcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBDcyhlKSB7XG4gIHJldHVybiB3ZShlLCB5LlJlY29yZGluZ1N0YXR1c0NoYW5nZWQpLnBpcGUoXG4gICAgQSgoW3RdKSA9PiB0KSxcbiAgICBEKGUuaXNSZWNvcmRpbmcpXG4gICk7XG59XG5mdW5jdGlvbiB4ZShlLCAuLi50KSB7XG4gIHJldHVybiBuZXcgaygocikgPT4ge1xuICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICByLm5leHQoZSk7XG4gICAgfTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBlLm9uKHMsIGkpO1xuICAgIH0pLCAoKSA9PiB7XG4gICAgICB0LmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgZS5vZmYocywgaSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KS5waXBlKEQoZSkpO1xufVxuZnVuY3Rpb24gRG4oZSkge1xuICByZXR1cm4geGUoXG4gICAgZSxcbiAgICB3LlRyYWNrTXV0ZWQsXG4gICAgdy5UcmFja1VubXV0ZWQsXG4gICAgdy5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAvLyBQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLFxuICAgIHcuVHJhY2tQdWJsaXNoZWQsXG4gICAgdy5UcmFja1VucHVibGlzaGVkLFxuICAgIHcuTG9jYWxUcmFja1B1Ymxpc2hlZCxcbiAgICB3LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCxcbiAgICB3Lk1lZGlhRGV2aWNlc0Vycm9yLFxuICAgIHcuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXG4gICAgLy8gUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXG4gICkucGlwZShcbiAgICBBKChuKSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWljcm9waG9uZUVuYWJsZWQ6IHIsIGlzQ2FtZXJhRW5hYmxlZDogaSwgaXNTY3JlZW5TaGFyZUVuYWJsZWQ6IG8gfSA9IG4sIHMgPSBuLmdldFRyYWNrUHVibGljYXRpb24oUi5Tb3VyY2UuTWljcm9waG9uZSksIGEgPSBuLmdldFRyYWNrUHVibGljYXRpb24oUi5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQ2FtZXJhRW5hYmxlZDogaSxcbiAgICAgICAgaXNNaWNyb3Bob25lRW5hYmxlZDogcixcbiAgICAgICAgaXNTY3JlZW5TaGFyZUVuYWJsZWQ6IG8sXG4gICAgICAgIGNhbWVyYVRyYWNrOiBhLFxuICAgICAgICBtaWNyb3Bob25lVHJhY2s6IHMsXG4gICAgICAgIHBhcnRpY2lwYW50OiBuXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBfbyhlKSB7XG4gIHJldHVybiBlID8geGUoXG4gICAgZSxcbiAgICB3LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLFxuICAgIHcuUGFydGljaXBhbnROYW1lQ2hhbmdlZFxuICApLnBpcGUoXG4gICAgQSgoeyBuYW1lOiBuLCBpZGVudGl0eTogciwgbWV0YWRhdGE6IGkgfSkgPT4gKHtcbiAgICAgIG5hbWU6IG4sXG4gICAgICBpZGVudGl0eTogcixcbiAgICAgIG1ldGFkYXRhOiBpXG4gICAgfSkpLFxuICAgIEQoe1xuICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgaWRlbnRpdHk6IGUuaWRlbnRpdHksXG4gICAgICBtZXRhZGF0YTogZS5tZXRhZGF0YVxuICAgIH0pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBMbyhlKSB7XG4gIHJldHVybiBaZShcbiAgICBlLFxuICAgIHcuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXG4gICkucGlwZShcbiAgICBBKChbbl0pID0+IG4pLFxuICAgIEQoZS5jb25uZWN0aW9uUXVhbGl0eSlcbiAgKTtcbn1cbmZ1bmN0aW9uIFplKGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBrKChyKSA9PiB7XG4gICAgY29uc3QgaSA9ICguLi5zKSA9PiB7XG4gICAgICByLm5leHQocyk7XG4gICAgfTtcbiAgICByZXR1cm4gZS5vbih0LCBpKSwgKCkgPT4ge1xuICAgICAgZS5vZmYodCwgaSk7XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBJbyhlKSB7XG4gIHZhciB0LCBuLCByLCBpO1xuICByZXR1cm4geGUoXG4gICAgZS5wYXJ0aWNpcGFudCxcbiAgICB3LlRyYWNrTXV0ZWQsXG4gICAgdy5UcmFja1VubXV0ZWQsXG4gICAgdy5UcmFja1N1YnNjcmliZWQsXG4gICAgdy5UcmFja1Vuc3Vic2NyaWJlZCxcbiAgICB3LkxvY2FsVHJhY2tQdWJsaXNoZWQsXG4gICAgdy5Mb2NhbFRyYWNrVW5wdWJsaXNoZWRcbiAgKS5waXBlKFxuICAgIEEoKG8pID0+IHtcbiAgICAgIHZhciBzLCBhO1xuICAgICAgY29uc3QgYyA9IChzID0gZS5wdWJsaWNhdGlvbikgIT0gbnVsbCA/IHMgOiBvLmdldFRyYWNrUHVibGljYXRpb24oZS5zb3VyY2UpO1xuICAgICAgcmV0dXJuIChhID0gYyA9PSBudWxsID8gdm9pZCAwIDogYy5pc011dGVkKSAhPSBudWxsID8gYSA6ICEwO1xuICAgIH0pLFxuICAgIEQoXG4gICAgICAoaSA9IChyID0gKHQgPSBlLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC5pc011dGVkKSAhPSBudWxsID8gciA6IChuID0gZS5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKGUuc291cmNlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uaXNNdXRlZCkgIT0gbnVsbCA/IGkgOiAhMFxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIFBzKGUpIHtcbiAgcmV0dXJuIFplKGUsIHcuSXNTcGVha2luZ0NoYW5nZWQpLnBpcGUoXG4gICAgQSgoW3RdKSA9PiB0KVxuICApO1xufVxuZnVuY3Rpb24gT3MoZSwgdCA9IHt9KSB7XG4gIHZhciBuO1xuICBsZXQgcjtcbiAgY29uc3QgaSA9IG5ldyBrKChjKSA9PiAociA9IGMsICgpID0+IGEudW5zdWJzY3JpYmUoKSkpLnBpcGUoRChBcnJheS5mcm9tKGUucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSkpLCBvID0gKG4gPSB0LmFkZGl0aW9uYWxSb29tRXZlbnRzKSAhPSBudWxsID8gbiA6IEFuLCBzID0gQXJyYXkuZnJvbShcbiAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICB5LlBhcnRpY2lwYW50Q29ubmVjdGVkLFxuICAgICAgeS5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCxcbiAgICAgIHkuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCxcbiAgICAgIC4uLm9cbiAgICBdKVxuICApLCBhID0gcGUoZSwgLi4ucykuc3Vic2NyaWJlKFxuICAgIChjKSA9PiByID09IG51bGwgPyB2b2lkIDAgOiByLm5leHQoQXJyYXkuZnJvbShjLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkpXG4gICk7XG4gIHJldHVybiBlLnJlbW90ZVBhcnRpY2lwYW50cy5zaXplID4gMCAmJiAociA9PSBudWxsIHx8IHIubmV4dChBcnJheS5mcm9tKGUucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSkpLCBpO1xufVxuZnVuY3Rpb24gQXMoZSwgdCwgbiA9IHt9KSB7XG4gIHZhciByO1xuICBjb25zdCBpID0gKHIgPSBuLmFkZGl0aW9uYWxFdmVudHMpICE9IG51bGwgPyByIDoga247XG4gIHJldHVybiBwZShcbiAgICBlLFxuICAgIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXG4gICAgeS5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCxcbiAgICB5LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAgKS5waXBlKFxuICAgIFBuKChzKSA9PiB7XG4gICAgICBjb25zdCBhID0gcy5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkodCk7XG4gICAgICByZXR1cm4gYSA/IHhlKGEsIC4uLmkpIDogbmV3IGsoKGMpID0+IGMubmV4dCh2b2lkIDApKTtcbiAgICB9KSxcbiAgICBEKGUuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHQpKVxuICApO1xufVxuZnVuY3Rpb24ga3MoZSkge1xuICByZXR1cm4gWmUoXG4gICAgZSxcbiAgICB3LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXG4gICkucGlwZShcbiAgICBBKCgpID0+IGUucGVybWlzc2lvbnMpLFxuICAgIEQoZS5wZXJtaXNzaW9ucylcbiAgKTtcbn1cbmZ1bmN0aW9uIF9zKGUsIHsga2luZDogdCwgaWRlbnRpdHk6IG4gfSwgciA9IHt9KSB7XG4gIHZhciBpO1xuICBjb25zdCBvID0gKGkgPSByLmFkZGl0aW9uYWxFdmVudHMpICE9IG51bGwgPyBpIDoga24sIHMgPSAoYykgPT4ge1xuICAgIGxldCB1ID0gITA7XG4gICAgcmV0dXJuIHQgJiYgKHUgPSB1ICYmIGMua2luZCA9PT0gdCksIG4gJiYgKHUgPSB1ICYmIGMuaWRlbnRpdHkgPT09IG4pLCB1O1xuICB9O1xuICByZXR1cm4gcGUoXG4gICAgZSxcbiAgICB5LlBhcnRpY2lwYW50Q29ubmVjdGVkLFxuICAgIHkuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsXG4gICAgeS5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gICkucGlwZShcbiAgICBQbigoYykgPT4ge1xuICAgICAgY29uc3QgdSA9IEFycmF5LmZyb20oYy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQoXG4gICAgICAgIChsKSA9PiBzKGwpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHUgPyB4ZSh1LCAuLi5vKSA6IG5ldyBrKChsKSA9PiBsLm5leHQodm9pZCAwKSk7XG4gICAgfSksXG4gICAgRChBcnJheS5mcm9tKGUucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5maW5kKChjKSA9PiBzKGMpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIExzKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID4gXCJ1XCIgPyBuZXcgaygpIDogWmUoZSwgdy5BdHRyaWJ1dGVzQ2hhbmdlZCkucGlwZShcbiAgICBBKChbdF0pID0+ICh7XG4gICAgICBjaGFuZ2VkOiB0LFxuICAgICAgYXR0cmlidXRlczogZS5hdHRyaWJ1dGVzXG4gICAgfSkpLFxuICAgIEQoeyBjaGFuZ2VkOiBlLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXM6IGUuYXR0cmlidXRlcyB9KVxuICApO1xufVxuZnVuY3Rpb24gSXMoZSwgdCwgbiwgciwgaSkge1xuICBjb25zdCB7IGxvY2FsUGFydGljaXBhbnQ6IG8gfSA9IHQsIHMgPSAoZiwgdikgPT4ge1xuICAgIGxldCBkID0gITE7XG4gICAgc3dpdGNoIChmKSB7XG4gICAgICBjYXNlIFIuU291cmNlLkNhbWVyYTpcbiAgICAgICAgZCA9IHYuaXNDYW1lcmFFbmFibGVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUi5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgZCA9IHYuaXNNaWNyb3Bob25lRW5hYmxlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFIuU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICBkID0gdi5pc1NjcmVlblNoYXJlRW5hYmxlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9LCBhID0gRG4obykucGlwZShcbiAgICBBKChmKSA9PiBzKGUsIGYucGFydGljaXBhbnQpKSxcbiAgICBEKHMoZSwgbykpXG4gICksIGMgPSBuZXcgdGUoKSwgdSA9IChmLCB2KSA9PiBIKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodiA/PyAodiA9IG4pLCBjLm5leHQoITApLCBlKSB7XG4gICAgICAgIGNhc2UgUi5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgIHJldHVybiB5aWVsZCBvLnNldENhbWVyYUVuYWJsZWQoXG4gICAgICAgICAgICBmID8/ICFvLmlzQ2FtZXJhRW5hYmxlZCxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICByXG4gICAgICAgICAgKSwgby5pc0NhbWVyYUVuYWJsZWQ7XG4gICAgICAgIGNhc2UgUi5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICByZXR1cm4geWllbGQgby5zZXRNaWNyb3Bob25lRW5hYmxlZChcbiAgICAgICAgICAgIGYgPz8gIW8uaXNNaWNyb3Bob25lRW5hYmxlZCxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICByXG4gICAgICAgICAgKSwgby5pc01pY3JvcGhvbmVFbmFibGVkO1xuICAgICAgICBjYXNlIFIuU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICAgIHJldHVybiB5aWVsZCBvLnNldFNjcmVlblNoYXJlRW5hYmxlZChcbiAgICAgICAgICAgIGYgPz8gIW8uaXNTY3JlZW5TaGFyZUVuYWJsZWQsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgclxuICAgICAgICAgICksIG8uaXNTY3JlZW5TaGFyZUVuYWJsZWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRyaWVkIHRvIHRvZ2dsZSB1bnN1cHBvcnRlZCBzb3VyY2VcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaWYgKGkgJiYgZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGkgPT0gbnVsbCB8fCBpKGQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgZDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYy5uZXh0KCExKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsYXNzTmFtZTogVShcImJ1dHRvblwiKSxcbiAgICB0b2dnbGU6IHUsXG4gICAgZW5hYmxlZE9ic2VydmVyOiBhLFxuICAgIHBlbmRpbmdPYnNlcnZlcjogYy5hc09ic2VydmFibGUoKVxuICB9O1xufVxuZnVuY3Rpb24gTXMoKSB7XG4gIGxldCBlID0gITE7XG4gIGNvbnN0IHQgPSBuZXcgdGUoKSwgbiA9IG5ldyB0ZSgpLCByID0gKG8pID0+IEgodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBuLm5leHQoITApLCBlID0gbyA/PyAhZSwgdC5uZXh0KGUpLCBuLm5leHQoITEpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGFzc05hbWU6IFUoXCJidXR0b25cIiksXG4gICAgdG9nZ2xlOiByLFxuICAgIGVuYWJsZWRPYnNlcnZlcjogdC5hc09ic2VydmFibGUoKSxcbiAgICBwZW5kaW5nT2JzZXJ2ZXI6IG4uYXNPYnNlcnZhYmxlKClcbiAgfTtcbn1cbmZ1bmN0aW9uIFJzKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IG5ldyBwbih2b2lkIDApLCBpID0ga28odCwgZSksIG8gPSAoYSwgLi4uYykgPT4gSCh0aGlzLCBbYSwgLi4uY10sIGZ1bmN0aW9uKiAodSwgbCA9IHt9KSB7XG4gICAgdmFyIGYsIHYsIGQ7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IG0gPSBHbigpO1xuICAgICAgaWYgKGUgPT09IFwiYXVkaW9vdXRwdXRcIiAmJiAoKG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0ubmFtZSkgPT09IFwiU2FmYXJpXCIgfHwgKG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0ub3MpID09PSBcImlPU1wiKSkge1xuICAgICAgICBMLndhcm4oXCJTd2l0Y2hpbmcgYXVkaW8gb3V0cHV0IGRldmljZSBpcyBub3Qgc3VwcG9ydGVkIG9uIFNhZmFyaSBhbmQgaU9TLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgTC5kZWJ1ZyhgU3dpdGNoaW5nIGFjdGl2ZSBkZXZpY2Ugb2Yga2luZCBcIiR7ZX1cIiB3aXRoIGlkICR7dX0uYCksIHlpZWxkIHQuc3dpdGNoQWN0aXZlRGV2aWNlKGUsIHUsIGwuZXhhY3QpO1xuICAgICAgY29uc3QgcCA9IChmID0gdC5nZXRBY3RpdmVEZXZpY2UoZSkpICE9IG51bGwgPyBmIDogdTtcbiAgICAgIHAgIT09IHUgJiYgdSAhPT0gXCJkZWZhdWx0XCIgJiYgTC5pbmZvKFxuICAgICAgICBgV2UgdHJpZWQgdG8gc2VsZWN0IHRoZSBkZXZpY2Ugd2l0aCBpZCAoJHt1fSksIGJ1dCB0aGUgYnJvd3NlciBkZWNpZGVkIHRvIHNlbGVjdCB0aGUgZGV2aWNlIHdpdGggaWQgKCR7cH0pIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIGxldCBnO1xuICAgICAgZSA9PT0gXCJhdWRpb2lucHV0XCIgPyBnID0gKHYgPSB0LmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbihSLlNvdXJjZS5NaWNyb3Bob25lKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHYudHJhY2sgOiBlID09PSBcInZpZGVvaW5wdXRcIiAmJiAoZyA9IChkID0gdC5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24oUi5Tb3VyY2UuQ2FtZXJhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQudHJhY2spO1xuICAgICAgY29uc3QgaCA9IHUgPT09IFwiZGVmYXVsdFwiICYmICFnIHx8IHUgPT09IFwiZGVmYXVsdFwiICYmIChnID09IG51bGwgPyB2b2lkIDAgOiBnLm1lZGlhU3RyZWFtVHJhY2subGFiZWwuc3RhcnRzV2l0aChcIkRlZmF1bHRcIikpO1xuICAgICAgci5uZXh0KGggPyB1IDogcCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGFzc05hbWU6IFUoXCJtZWRpYS1kZXZpY2Utc2VsZWN0XCIpLFxuICAgIGFjdGl2ZURldmljZU9ic2VydmFibGU6IGksXG4gICAgc2V0QWN0aXZlTWVkaWFEZXZpY2U6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIERzKGUpIHtcbiAgY29uc3QgdCA9IChyKSA9PiB7XG4gICAgZS5kaXNjb25uZWN0KHIpO1xuICB9O1xuICByZXR1cm4geyBjbGFzc05hbWU6IFUoXCJkaXNjb25uZWN0LWJ1dHRvblwiKSwgZGlzY29ubmVjdDogdCB9O1xufVxuZnVuY3Rpb24gJHMoZSkge1xuICBjb25zdCB0ID0gVShcImNvbm5lY3Rpb24tcXVhbGl0eVwiKSwgbiA9IExvKGUpO1xuICByZXR1cm4geyBjbGFzc05hbWU6IHQsIGNvbm5lY3Rpb25RdWFsaXR5T2JzZXJ2ZXI6IG4gfTtcbn1cbmZ1bmN0aW9uIE5zKGUpIHtcbiAgbGV0IHQgPSBcInRyYWNrLW11dGVkLWluZGljYXRvci1jYW1lcmFcIjtcbiAgc3dpdGNoIChlLnNvdXJjZSkge1xuICAgIGNhc2UgUi5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgdCA9IFwidHJhY2stbXV0ZWQtaW5kaWNhdG9yLWNhbWVyYVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgdCA9IFwidHJhY2stbXV0ZWQtaW5kaWNhdG9yLW1pY3JvcGhvbmVcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IG4gPSBVKHQpLCByID0gSW8oZSk7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogbiwgbWVkaWFNdXRlZE9ic2VydmVyOiByIH07XG59XG5mdW5jdGlvbiBGcyhlKSB7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1uYW1lXCIsIGluZm9PYnNlcnZlcjogX28oZSkgfTtcbn1cbmZ1bmN0aW9uIFVzKCkge1xuICByZXR1cm4ge1xuICAgIGNsYXNzTmFtZTogVShcInBhcnRpY2lwYW50LXRpbGVcIilcbiAgfTtcbn1cbnZhciBNbyA9IHtcbiAgQ0hBVDogXCJsay5jaGF0XCIsXG4gIFRSQU5TQ1JJUFRJT046IFwibGsudHJhbnNjcmlwdGlvblwiXG59LCBSbyA9IHtcbiAgQ0hBVDogXCJsay1jaGF0LXRvcGljXCJcbn07XG5mdW5jdGlvbiAkbihlLCB0KSB7XG4gIHJldHVybiBIKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChuLCByLCBpID0ge30pIHtcbiAgICBjb25zdCB7IHJlbGlhYmxlOiBvLCBkZXN0aW5hdGlvbklkZW50aXRpZXM6IHMsIHRvcGljOiBhIH0gPSBpO1xuICAgIHlpZWxkIG4ucHVibGlzaERhdGEociwge1xuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBzLFxuICAgICAgdG9waWM6IGEsXG4gICAgICByZWxpYWJsZTogb1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIERvKGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdLCBpID0gUG8oZSkucGlwZShcbiAgICBYZShcbiAgICAgIChbLCAsICwgY10pID0+IHQgPT09IHZvaWQgMCB8fCBjICE9PSB2b2lkIDAgJiYgci5pbmNsdWRlcyhjKVxuICAgICksXG4gICAgQSgoW2MsIHUsICwgbF0pID0+IHtcbiAgICAgIGNvbnN0IGYgPSB7XG4gICAgICAgIHBheWxvYWQ6IGMsXG4gICAgICAgIHRvcGljOiBsLFxuICAgICAgICBmcm9tOiB1XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCB8fCBuKGYpLCBmO1xuICAgIH0pXG4gICk7XG4gIGxldCBvO1xuICBjb25zdCBzID0gbmV3IGsoKGMpID0+IHtcbiAgICBvID0gYztcbiAgfSk7XG4gIHJldHVybiB7IG1lc3NhZ2VPYnNlcnZhYmxlOiBpLCBpc1NlbmRpbmdPYnNlcnZhYmxlOiBzLCBzZW5kOiAoYywgLi4udSkgPT4gSCh0aGlzLCBbYywgLi4udV0sIGZ1bmN0aW9uKiAobCwgZiA9IHt9KSB7XG4gICAgby5uZXh0KCEwKTtcbiAgICB0cnkge1xuICAgICAgeWllbGQgJG4oZS5sb2NhbFBhcnRpY2lwYW50LCBsLCBxKHsgdG9waWM6IHJbMF0gfSwgZikpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBvLm5leHQoITEpO1xuICAgIH1cbiAgfSkgfTtcbn1cbnZhciBJZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJG8oZSkge1xuICByZXR1cm4gZS5pZ25vcmVMZWdhY3kgPT0gITA7XG59XG52YXIgTm8gPSAoZSkgPT4gSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZSkpLCBGbyA9IChlKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoZSkpO1xuZnVuY3Rpb24gV3MoZSwgdCkge1xuICB2YXIgbiwgciwgaSwgbywgcywgYTtcbiAgY29uc3QgYyA9ICgpID0+IHtcbiAgICB2YXIgYiwgUywgQztcbiAgICByZXR1cm4gKChiID0gZS5zZXJ2ZXJJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogYi5lZGl0aW9uKSA9PT0gMSB8fCAhISgoUyA9IGUuc2VydmVySW5mbykgIT0gbnVsbCAmJiBTLnZlcnNpb24pICYmIFFuKChDID0gZS5zZXJ2ZXJJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogQy52ZXJzaW9uLCBcIjEuOC4yXCIpID4gMDtcbiAgfSwgdSA9IG5ldyB0ZSgpLCBsID0gKG4gPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNoYW5uZWxUb3BpYykgIT0gbnVsbCA/IG4gOiBNby5DSEFULCBmID0gKHIgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNoYW5uZWxUb3BpYykgIT0gbnVsbCA/IHIgOiBSby5DSEFUO1xuICBsZXQgdiA9ICExO1xuICBJZS5oYXMoZSkgfHwgKHYgPSAhMCk7XG4gIGNvbnN0IGQgPSAoaSA9IEllLmdldChlKSkgIT0gbnVsbCA/IGkgOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBtID0gKG8gPSBkLmdldChsKSkgIT0gbnVsbCA/IG8gOiBuZXcgdGUoKTtcbiAgZC5zZXQobCwgbSksIEllLnNldChlLCBkKTtcbiAgY29uc3QgcCA9IChzID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5tZXNzYWdlRGVjb2RlcikgIT0gbnVsbCA/IHMgOiBObztcbiAgaWYgKHYpIHtcbiAgICBlLnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIobCwgKFMsIEMpID0+IEgodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHsgaWQ6ICQsIHRpbWVzdGFtcDogTSB9ID0gUy5pbmZvO1xuICAgICAgSmUoUykucGlwZShcbiAgICAgICAgbHQoKFQsIF8pID0+IFQgKyBfKSxcbiAgICAgICAgQSgoVCkgPT4gKHtcbiAgICAgICAgICBpZDogJCxcbiAgICAgICAgICB0aW1lc3RhbXA6IE0sXG4gICAgICAgICAgbWVzc2FnZTogVCxcbiAgICAgICAgICBmcm9tOiBlLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShDLmlkZW50aXR5KSxcbiAgICAgICAgICB0eXBlOiBcImNoYXRNZXNzYWdlXCJcbiAgICAgICAgICAvLyBlZGl0VGltZXN0YW1wOiB0eXBlID09PSAndXBkYXRlJyA/IHRpbWVzdGFtcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkpXG4gICAgICApLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChUKSA9PiBtLm5leHQoVClcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBjb25zdCB7IG1lc3NhZ2VPYnNlcnZhYmxlOiBiIH0gPSBEbyhlLCBbZl0pO1xuICAgIGIucGlwZShcbiAgICAgIEEoKFMpID0+IHtcbiAgICAgICAgY29uc3QgQyA9IHAoUy5wYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuICRvKEMpID8gdm9pZCAwIDogY2UocSh7fSwgQyksIHtcbiAgICAgICAgICB0eXBlOiBcImNoYXRNZXNzYWdlXCIsXG4gICAgICAgICAgZnJvbTogUy5mcm9tXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBYZSgoUykgPT4gISFTKSxcbiAgICAgIFd0KHUpXG4gICAgKS5zdWJzY3JpYmUobSk7XG4gIH1cbiAgY29uc3QgZyA9IG0ucGlwZShcbiAgICBsdCgoYiwgUykgPT4ge1xuICAgICAgaWYgKFwiaWRcIiBpbiBTICYmIGIuZmluZCgoQykgPT4ge1xuICAgICAgICB2YXIgJCwgTTtcbiAgICAgICAgcmV0dXJuICgoJCA9IEMuZnJvbSkgPT0gbnVsbCA/IHZvaWQgMCA6ICQuaWRlbnRpdHkpID09PSAoKE0gPSBTLmZyb20pID09IG51bGwgPyB2b2lkIDAgOiBNLmlkZW50aXR5KSAmJiBDLmlkID09PSBTLmlkO1xuICAgICAgfSkpIHtcbiAgICAgICAgY29uc3QgQyA9IGIuZmluZEluZGV4KCgkKSA9PiAkLmlkID09PSBTLmlkKTtcbiAgICAgICAgaWYgKEMgPiAtMSkge1xuICAgICAgICAgIGNvbnN0ICQgPSBiW0NdO1xuICAgICAgICAgIGJbQ10gPSBjZShxKHt9LCBTKSwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiAkLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGVkaXRUaW1lc3RhbXA6IFMudGltZXN0YW1wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5iXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLi4uYiwgU107XG4gICAgfSwgW10pLFxuICAgIFd0KHUpXG4gICksIGggPSBuZXcgcG4oITEpLCB4ID0gKGEgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1lc3NhZ2VFbmNvZGVyKSAhPSBudWxsID8gYSA6IEZvLCBFID0gKGIsIFMpID0+IEgodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgQztcbiAgICBTIHx8IChTID0ge30pLCAoQyA9IFMudG9waWMpICE9IG51bGwgfHwgKFMudG9waWMgPSBsKSwgaC5uZXh0KCEwKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgTSA9IHtcbiAgICAgICAgaWQ6ICh5aWVsZCBlLmxvY2FsUGFydGljaXBhbnQuc2VuZFRleHQoYiwgUykpLmlkLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIG1lc3NhZ2U6IGJcbiAgICAgIH0sIFYgPSBjZShxKHt9LCBNKSwge1xuICAgICAgICBhdHRhY2hlZEZpbGVzOiBTLmF0dGFjaG1lbnRzXG4gICAgICB9KSwgVCA9IGNlKHEoe30sIFYpLCB7XG4gICAgICAgIHR5cGU6IFwiY2hhdE1lc3NhZ2VcIixcbiAgICAgICAgZnJvbTogZS5sb2NhbFBhcnRpY2lwYW50LFxuICAgICAgICBhdHRyaWJ1dGVzOiBTLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgICAgbS5uZXh0KFQpO1xuICAgICAgY29uc3QgXyA9IHgoY2UocSh7fSwgTSksIHtcbiAgICAgICAgaWdub3JlTGVnYWN5OiBjKClcbiAgICAgIH0pKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkICRuKGUubG9jYWxQYXJ0aWNpcGFudCwgXywge1xuICAgICAgICAgIHJlbGlhYmxlOiAhMCxcbiAgICAgICAgICB0b3BpYzogZlxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVlKSB7XG4gICAgICAgIEwuaW5mbyhcImNvdWxkIG5vdCBzZW5kIG1lc3NhZ2UgaW4gbGVnYWN5IGNoYXQgZm9ybWF0XCIsIGVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBoLm5leHQoITEpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIE8oKSB7XG4gICAgdS5uZXh0KCksIHUuY29tcGxldGUoKSwgbS5jb21wbGV0ZSgpLCBJZS5kZWxldGUoZSksIGUudW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKGwpO1xuICB9XG4gIHJldHVybiBlLm9uY2UoeS5EaXNjb25uZWN0ZWQsIE8pLCB7XG4gICAgbWVzc2FnZU9ic2VydmFibGU6IGcsXG4gICAgaXNTZW5kaW5nT2JzZXJ2YWJsZTogaCxcbiAgICBzZW5kOiBFXG4gIH07XG59XG5mdW5jdGlvbiBqcygpIHtcbiAgY29uc3QgZSA9IChuKSA9PiBIKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgTC5pbmZvKFwiU3RhcnQgQXVkaW8gZm9yIHJvb206IFwiLCBuKSwgeWllbGQgbi5zdGFydEF1ZGlvKCk7XG4gIH0pO1xuICByZXR1cm4geyBjbGFzc05hbWU6IFUoXCJzdGFydC1hdWRpby1idXR0b25cIiksIHJvb21BdWRpb1BsYXliYWNrQWxsb3dlZE9ic2VydmFibGU6IE9vLCBoYW5kbGVTdGFydEF1ZGlvUGxheWJhY2s6IGUgfTtcbn1cbmZ1bmN0aW9uIEJzKCkge1xuICBjb25zdCBlID0gKG4pID0+IEgodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBMLmluZm8oXCJTdGFydCBWaWRlbyBmb3Igcm9vbTogXCIsIG4pLCB5aWVsZCBuLnN0YXJ0VmlkZW8oKTtcbiAgfSk7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogVShcInN0YXJ0LWF1ZGlvLWJ1dHRvblwiKSwgcm9vbVZpZGVvUGxheWJhY2tBbGxvd2VkT2JzZXJ2YWJsZTogQW8sIGhhbmRsZVN0YXJ0VmlkZW9QbGF5YmFjazogZSB9O1xufVxuZnVuY3Rpb24gVnMoKSB7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogW1UoXCJidXR0b25cIiksIFUoXCJjaGF0LXRvZ2dsZVwiKV0uam9pbihcIiBcIikgfTtcbn1cbmZ1bmN0aW9uIEhzKCkge1xuICByZXR1cm4geyBjbGFzc05hbWU6IFtVKFwiYnV0dG9uXCIpLCBVKFwiZm9jdXMtdG9nZ2xlLWJ1dHRvblwiKV0uam9pbihcIiBcIikgfTtcbn1cbmZ1bmN0aW9uIHpzKCkge1xuICByZXR1cm4geyBjbGFzc05hbWU6IFwibGstY2xlYXItcGluLWJ1dHRvbiBsay1idXR0b25cIiB9O1xufVxuZnVuY3Rpb24gWXMoKSB7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogXCJsay1yb29tLWNvbnRhaW5lclwiIH07XG59XG5mdW5jdGlvbiBZdChlLCB0LCBuID0gITApIHtcbiAgY29uc3QgaSA9IFtlLmxvY2FsUGFydGljaXBhbnQsIC4uLkFycmF5LmZyb20oZS5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpXSwgbyA9IFtdO1xuICByZXR1cm4gaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgdC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBjID0gQXJyYXkuZnJvbShcbiAgICAgICAgcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKVxuICAgICAgKS5maWx0ZXIoXG4gICAgICAgICh1KSA9PiB1LnNvdXJjZSA9PT0gYSAmJiAvLyBlaXRoZXIgcmV0dXJuIGFsbCBvciBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIHN1YnNjcmliZWRcbiAgICAgICAgKCFuIHx8IHUudHJhY2spXG4gICAgICApLm1hcCgodSkgPT4gKHtcbiAgICAgICAgcGFydGljaXBhbnQ6IHMsXG4gICAgICAgIHB1YmxpY2F0aW9uOiB1LFxuICAgICAgICBzb3VyY2U6IHUuc291cmNlXG4gICAgICB9KSk7XG4gICAgICBvLnB1c2goLi4uYyk7XG4gICAgfSk7XG4gIH0pLCB7IHRyYWNrUmVmZXJlbmNlczogbywgcGFydGljaXBhbnRzOiBpIH07XG59XG5mdW5jdGlvbiBxdChlLCB0LCBuID0gITEpIHtcbiAgY29uc3QgeyBzb3VyY2VzOiByLCBraW5kOiBpLCBuYW1lOiBvIH0gPSB0O1xuICByZXR1cm4gQXJyYXkuZnJvbShlLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maWx0ZXIoXG4gICAgKGEpID0+ICghciB8fCByLmluY2x1ZGVzKGEuc291cmNlKSkgJiYgKCFpIHx8IGEua2luZCA9PT0gaSkgJiYgKCFvIHx8IGEudHJhY2tOYW1lID09PSBvKSAmJiAvLyBlaXRoZXIgcmV0dXJuIGFsbCBvciBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIHN1YnNjcmliZWRcbiAgICAoIW4gfHwgYS50cmFjaylcbiAgKS5tYXAoKGEpID0+ICh7XG4gICAgcGFydGljaXBhbnQ6IGUsXG4gICAgcHVibGljYXRpb246IGEsXG4gICAgc291cmNlOiBhLnNvdXJjZVxuICB9KSk7XG59XG5mdW5jdGlvbiBxcyhlLCB0LCBuKSB7XG4gIHZhciByLCBpO1xuICBjb25zdCBvID0gKHIgPSBuLmFkZGl0aW9uYWxSb29tRXZlbnRzKSAhPSBudWxsID8gciA6IEFuLCBzID0gKGkgPSBuLm9ubHlTdWJzY3JpYmVkKSAhPSBudWxsID8gaSA6ICEwLCBhID0gQXJyYXkuZnJvbShcbiAgICAoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgeS5QYXJ0aWNpcGFudENvbm5lY3RlZCxcbiAgICAgIHkuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsXG4gICAgICB5LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsXG4gICAgICB5LkxvY2FsVHJhY2tQdWJsaXNoZWQsXG4gICAgICB5LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCxcbiAgICAgIHkuVHJhY2tQdWJsaXNoZWQsXG4gICAgICB5LlRyYWNrVW5wdWJsaXNoZWQsXG4gICAgICB5LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgIC4uLm9cbiAgICBdKSkudmFsdWVzKClcbiAgKTtcbiAgcmV0dXJuIHBlKGUsIC4uLmEpLnBpcGUoXG4gICAgQSgodSkgPT4ge1xuICAgICAgY29uc3QgbCA9IFl0KHUsIHQsIHMpO1xuICAgICAgcmV0dXJuIEwuZGVidWcoYFRyYWNrUmVmZXJlbmNlW10gd2FzIHVwZGF0ZWQuIChsZW5ndGggJHtsLnRyYWNrUmVmZXJlbmNlcy5sZW5ndGh9KWAsIGwpLCBsO1xuICAgIH0pLFxuICAgIEQoWXQoZSwgdCwgcykpXG4gICk7XG59XG5mdW5jdGlvbiBLcyhlLCB0KSB7XG4gIHJldHVybiB4ZShlLCAuLi5jbykucGlwZShcbiAgICBBKChyKSA9PiB7XG4gICAgICBjb25zdCBpID0gcXQociwgdCk7XG4gICAgICByZXR1cm4gTC5kZWJ1ZyhgVHJhY2tSZWZlcmVuY2VbXSB3YXMgdXBkYXRlZC4gKGxlbmd0aCAke2kubGVuZ3RofSlgLCBpKSwgaTtcbiAgICB9KSxcbiAgICBEKHF0KGUsIHQpKVxuICApO1xufVxuZnVuY3Rpb24gTm4oZSwgdCkge1xuICByZXR1cm4gbmV3IGsoKHIpID0+IHtcbiAgICBjb25zdCBpID0gKC4uLnMpID0+IHtcbiAgICAgIHIubmV4dChzKTtcbiAgICB9O1xuICAgIHJldHVybiBlLm9uKHQsIGkpLCAoKSA9PiB7XG4gICAgICBlLm9mZih0LCBpKTtcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIEdzKGUpIHtcbiAgcmV0dXJuIE5uKGUsIEd0LlRyYW5zY3JpcHRpb25SZWNlaXZlZCk7XG59XG5mdW5jdGlvbiBRcyhlKSB7XG4gIHJldHVybiBObihlLCBHdC5UaW1lU3luY1VwZGF0ZSkucGlwZShcbiAgICBBKChbdF0pID0+IHQpXG4gICk7XG59XG5mdW5jdGlvbiBKcyhlLCB0ID0gMWUzKSB7XG4gIGlmIChlID09PSBudWxsKSByZXR1cm4gRnQoITEpO1xuICBjb25zdCBuID0gdXQoZSwgXCJtb3VzZW1vdmVcIiwgeyBwYXNzaXZlOiAhMCB9KS5waXBlKEEoKCkgPT4gITApKSwgciA9IG4ucGlwZShcbiAgICBMaSh7XG4gICAgICBlYWNoOiB0LFxuICAgICAgd2l0aDogKCkgPT4gamUoRnQoITEpLCByLnBpcGUoR2kobikpKVxuICAgIH0pLFxuICAgIFlpKClcbiAgKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBVbyhlLCB0KSB7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID4gXCJ1XCIpIHtcbiAgICBMLmVycm9yKFwiTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgbiA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXModCkuZmlsdGVyKChbLCByXSkgPT4gciAhPT0gXCJcIilcbiAgICAgICk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCBKU09OLnN0cmluZ2lmeShuKSk7XG4gICAgfVxuICB9IGNhdGNoIChuKSB7XG4gICAgTC5lcnJvcihgRXJyb3Igc2V0dGluZyBpdGVtIHRvIGxvY2FsIHN0b3JhZ2U6ICR7bn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gV28oZSkge1xuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA+IFwidVwiKSB7XG4gICAgTC5lcnJvcihcIkxvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpO1xuICAgIGlmICghdCkge1xuICAgICAgTC53YXJuKGBJdGVtIHdpdGgga2V5ICR7ZX0gZG9lcyBub3QgZXhpc3QgaW4gbG9jYWwgc3RvcmFnZS5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodCk7XG4gIH0gY2F0Y2ggKHQpIHtcbiAgICBMLmVycm9yKGBFcnJvciBnZXR0aW5nIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlOiAke3R9YCk7XG4gICAgcmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBqbyhlKSB7XG4gIHJldHVybiB7XG4gICAgbG9hZDogKCkgPT4gV28oZSksXG4gICAgc2F2ZTogKHQpID0+IFVvKGUsIHQpXG4gIH07XG59XG52YXIgQm8gPSBgJHtPbn0tdXNlci1jaG9pY2VzYCwgRWUgPSB7XG4gIHZpZGVvRW5hYmxlZDogITAsXG4gIGF1ZGlvRW5hYmxlZDogITAsXG4gIHZpZGVvRGV2aWNlSWQ6IFwiZGVmYXVsdFwiLFxuICBhdWRpb0RldmljZUlkOiBcImRlZmF1bHRcIixcbiAgdXNlcm5hbWU6IFwiXCJcbn0sIHsgbG9hZDogVm8sIHNhdmU6IEhvIH0gPSBqbyhCbyk7XG5mdW5jdGlvbiBYcyhlLCB0ID0gITEpIHtcbiAgdCAhPT0gITAgJiYgSG8oZSk7XG59XG5mdW5jdGlvbiBacyhlLCB0ID0gITEpIHtcbiAgdmFyIG4sIHIsIGksIG8sIHM7XG4gIGNvbnN0IGEgPSB7XG4gICAgdmlkZW9FbmFibGVkOiAobiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudmlkZW9FbmFibGVkKSAhPSBudWxsID8gbiA6IEVlLnZpZGVvRW5hYmxlZCxcbiAgICBhdWRpb0VuYWJsZWQ6IChyID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5hdWRpb0VuYWJsZWQpICE9IG51bGwgPyByIDogRWUuYXVkaW9FbmFibGVkLFxuICAgIHZpZGVvRGV2aWNlSWQ6IChpID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS52aWRlb0RldmljZUlkKSAhPSBudWxsID8gaSA6IEVlLnZpZGVvRGV2aWNlSWQsXG4gICAgYXVkaW9EZXZpY2VJZDogKG8gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1ZGlvRGV2aWNlSWQpICE9IG51bGwgPyBvIDogRWUuYXVkaW9EZXZpY2VJZCxcbiAgICB1c2VybmFtZTogKHMgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnVzZXJuYW1lKSAhPSBudWxsID8gcyA6IEVlLnVzZXJuYW1lXG4gIH07XG4gIGlmICh0KVxuICAgIHJldHVybiBhO1xuICB7XG4gICAgY29uc3QgYyA9IFZvKCk7XG4gICAgcmV0dXJuIHEocSh7fSwgYSksIGMgPz8ge30pO1xuICB9XG59XG52YXIgaXQgPSBudWxsLCBvdCA9IG51bGwsIHpvID0gMDtcbmZ1bmN0aW9uIEt0KCkge1xuICByZXR1cm4gaXQgfHwgKGl0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIGl0O1xufVxuZnVuY3Rpb24gWW8oKSB7XG4gIHJldHVybiBvdCB8fCAob3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSksIG90O1xufVxuZnVuY3Rpb24gcW8oZSwgdCkge1xuICBjb25zdCBuID0gWW8oKTtcbiAgbGV0IHIgPSBuLmdldChlKTtcbiAgcmV0dXJuIHIgfHwgKHIgPSBgcm9vbV8ke3pvKyt9YCwgbi5zZXQoZSwgcikpLCBgJHtyfToke3R9YDtcbn1cbmZ1bmN0aW9uIGVhKGUsIHQpIHtcbiAgY29uc3QgbiA9IHFvKGUsIHQpLCByID0gS3QoKSwgaSA9IHIuZ2V0KG4pO1xuICBpZiAoaSlcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgbyA9IG5ldyB0ZSgpO1xuICBsZXQgcyA9IFtdO1xuICBjb25zdCBhID0gXCJsay5zZWdtZW50X2lkXCIsIGMgPSBvLnBpcGUoXG4gICAgUWkoe1xuICAgICAgc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGUucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0LCAodSwgbCkgPT4gSCh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIGNvbnN0IHYgPSBKZSh1KS5waXBlKFxuICAgICAgICAgICAgbHQoKG0sIHApID0+IG0gKyBwLCBcIlwiKVxuICAgICAgICAgICksIGQgPSAhISgoZiA9IHUuaW5mby5hdHRyaWJ1dGVzKSAhPSBudWxsICYmIGZbYV0pO1xuICAgICAgICAgIHYuc3Vic2NyaWJlKChtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwID0gcy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgIChnKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGgsIHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGcuc3RyZWFtSW5mby5pZCA9PT0gdS5pbmZvLmlkIHx8IGQgJiYgKChoID0gZy5zdHJlYW1JbmZvLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBoW2FdKSA9PT0gKCh4ID0gdS5pbmZvLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiB4W2FdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHAgIT09IC0xID8gKHNbcF0gPSBjZShxKHt9LCBzW3BdKSwge1xuICAgICAgICAgICAgICB0ZXh0OiBtXG4gICAgICAgICAgICB9KSwgby5uZXh0KFsuLi5zXSkpIDogKHMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IG0sXG4gICAgICAgICAgICAgIHBhcnRpY2lwYW50SW5mbzogbCxcbiAgICAgICAgICAgICAgc3RyZWFtSW5mbzogdS5pbmZvXG4gICAgICAgICAgICB9KSwgby5uZXh0KFsuLi5zXSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgZmluYWxpemU6ICgpID0+IHtcbiAgICAgICAgZS51bnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIodCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgS2koKVxuICApO1xuICByZXR1cm4gci5zZXQobiwgYyksIGUub24oeS5EaXNjb25uZWN0ZWQsICgpID0+IHtcbiAgICBLdCgpLmRlbGV0ZShuKSwgcyA9IFtdLCBvLm5leHQoW10pO1xuICB9KSwgYztcbn1cbmZ1bmN0aW9uIEZuKGUsIHQpIHtcbiAgaWYgKHQubXNnID09PSBcInNob3dfY2hhdFwiKVxuICAgIHJldHVybiB7IC4uLmUsIHNob3dDaGF0OiAhMCwgdW5yZWFkTWVzc2FnZXM6IDAgfTtcbiAgaWYgKHQubXNnID09PSBcImhpZGVfY2hhdFwiKVxuICAgIHJldHVybiB7IC4uLmUsIHNob3dDaGF0OiAhMSB9O1xuICBpZiAodC5tc2cgPT09IFwidG9nZ2xlX2NoYXRcIikge1xuICAgIGNvbnN0IG4gPSB7IC4uLmUsIHNob3dDaGF0OiAhZS5zaG93Q2hhdCB9O1xuICAgIHJldHVybiBuLnNob3dDaGF0ID09PSAhMCAmJiAobi51bnJlYWRNZXNzYWdlcyA9IDApLCBuO1xuICB9IGVsc2UgcmV0dXJuIHQubXNnID09PSBcInVucmVhZF9tc2dcIiA/IHsgLi4uZSwgdW5yZWFkTWVzc2FnZXM6IHQuY291bnQgfSA6IHQubXNnID09PSBcInRvZ2dsZV9zZXR0aW5nc1wiID8geyAuLi5lLCBzaG93U2V0dGluZ3M6ICFlLnNob3dTZXR0aW5ncyB9IDogeyAuLi5lIH07XG59XG5mdW5jdGlvbiBVbihlLCB0KSB7XG4gIHJldHVybiB0Lm1zZyA9PT0gXCJzZXRfcGluXCIgPyBbdC50cmFja1JlZmVyZW5jZV0gOiB0Lm1zZyA9PT0gXCJjbGVhcl9waW5cIiA/IFtdIDogeyAuLi5lIH07XG59XG5jb25zdCBXbiA9IEkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gdGEoKSB7XG4gIGNvbnN0IGUgPSBJLnVzZUNvbnRleHQoV24pO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgRXJyb3IoXCJUcmllZCB0byBhY2Nlc3MgTGF5b3V0Q29udGV4dCBjb250ZXh0IG91dHNpZGUgYSBMYXlvdXRDb250ZXh0UHJvdmlkZXIgcHJvdmlkZXIuXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG5hKGUpIHtcbiAgY29uc3QgdCA9IEtvKCk7XG4gIGlmIChlID8/IChlID0gdCksICFlKVxuICAgIHRocm93IEVycm9yKFwiVHJpZWQgdG8gYWNjZXNzIExheW91dENvbnRleHQgY29udGV4dCBvdXRzaWRlIGEgTGF5b3V0Q29udGV4dFByb3ZpZGVyIHByb3ZpZGVyLlwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiByYSgpIHtcbiAgY29uc3QgW2UsIHRdID0gSS51c2VSZWR1Y2VyKFVuLCBfbiksIFtuLCByXSA9IEkudXNlUmVkdWNlcihGbiwgTG4pO1xuICByZXR1cm4ge1xuICAgIHBpbjogeyBkaXNwYXRjaDogdCwgc3RhdGU6IGUgfSxcbiAgICB3aWRnZXQ6IHsgZGlzcGF0Y2g6IHIsIHN0YXRlOiBuIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlhKGUpIHtcbiAgY29uc3QgW3QsIG5dID0gSS51c2VSZWR1Y2VyKFVuLCBfbiksIFtyLCBpXSA9IEkudXNlUmVkdWNlcihGbiwgTG4pO1xuICByZXR1cm4gZSA/PyB7XG4gICAgcGluOiB7IGRpc3BhdGNoOiBuLCBzdGF0ZTogdCB9LFxuICAgIHdpZGdldDogeyBkaXNwYXRjaDogaSwgc3RhdGU6IHIgfVxuICB9O1xufVxuZnVuY3Rpb24gS28oKSB7XG4gIHJldHVybiBJLnVzZUNvbnRleHQoV24pO1xufVxuY29uc3Qgam4gPSBJLmNyZWF0ZUNvbnRleHQoXG4gIHZvaWQgMFxuKTtcbmZ1bmN0aW9uIG9hKCkge1xuICBjb25zdCBlID0gSS51c2VDb250ZXh0KGpuKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IEVycm9yKFwidHJpZWQgdG8gYWNjZXNzIHRyYWNrIGNvbnRleHQgb3V0c2lkZSBvZiB0cmFjayBjb250ZXh0IHByb3ZpZGVyXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEJuKCkge1xuICByZXR1cm4gSS51c2VDb250ZXh0KGpuKTtcbn1cbmZ1bmN0aW9uIHNhKGUpIHtcbiAgY29uc3QgdCA9IEJuKCksIG4gPSBlID8/IHQ7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIk5vIFRyYWNrUmVmLCBtYWtlIHN1cmUgeW91IGFyZSBpbnNpZGUgYSBUcmFja1JlZkNvbnRleHQgb3IgcGFzcyB0aGUgVHJhY2tSZWYgZXhwbGljaXRseVwiXG4gICAgKTtcbiAgcmV0dXJuIG47XG59XG5jb25zdCBWbiA9IEkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gYWEoKSB7XG4gIGNvbnN0IGUgPSBJLnVzZUNvbnRleHQoVm4pO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgRXJyb3IoXCJ0cmllZCB0byBhY2Nlc3MgcGFydGljaXBhbnQgY29udGV4dCBvdXRzaWRlIG9mIHBhcnRpY2lwYW50IGNvbnRleHQgcHJvdmlkZXJcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gR28oKSB7XG4gIHJldHVybiBJLnVzZUNvbnRleHQoVm4pO1xufVxuZnVuY3Rpb24gY2EoZSkge1xuICBjb25zdCB0ID0gR28oKSwgbiA9IEJuKCksIHIgPSBlID8/IHQgPz8gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ucGFydGljaXBhbnQpO1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJObyBwYXJ0aWNpcGFudCBwcm92aWRlZCwgbWFrZSBzdXJlIHlvdSBhcmUgaW5zaWRlIGEgcGFydGljaXBhbnQgY29udGV4dCBvciBwYXNzIHRoZSBwYXJ0aWNpcGFudCBleHBsaWNpdGx5XCJcbiAgICApO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IEhuID0gSS5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiB1YSgpIHtcbiAgY29uc3QgZSA9IEkudXNlQ29udGV4dChIbik7XG4gIGlmICghZSlcbiAgICB0aHJvdyBFcnJvcihcInRyaWVkIHRvIGFjY2VzcyByb29tIGNvbnRleHQgb3V0c2lkZSBvZiBsaXZla2l0IHJvb20gY29tcG9uZW50XCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFFvKCkge1xuICByZXR1cm4gSS51c2VDb250ZXh0KEhuKTtcbn1cbmZ1bmN0aW9uIGxhKGUpIHtcbiAgY29uc3QgdCA9IFFvKCksIG4gPSBlID8/IHQ7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIk5vIHJvb20gcHJvdmlkZWQsIG1ha2Ugc3VyZSB5b3UgYXJlIGluc2lkZSBhIFJvb20gY29udGV4dCBvciBwYXNzIHRoZSByb29tIGV4cGxpY2l0bHlcIlxuICAgICk7XG4gIHJldHVybiBuO1xufVxuY29uc3Qgem4gPSBJLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIGZhKCkge1xuICBjb25zdCBlID0gSS51c2VDb250ZXh0KHpuKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IEVycm9yKFwidHJpZWQgdG8gYWNjZXNzIHNlc3Npb24gY29udGV4dCBvdXRzaWRlIG9mIFNlc3Npb25Qcm92aWRlciBjb21wb25lbnRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gSm8oKSB7XG4gIHJldHVybiBJLnVzZUNvbnRleHQoem4pO1xufVxuZnVuY3Rpb24gZGEoZSkge1xuICBjb25zdCB0ID0gSm8oKSwgbiA9IGUgPz8gdDtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTm8gc2Vzc2lvbiBwcm92aWRlZCwgbWFrZSBzdXJlIHlvdSBhcmUgaW5zaWRlIGEgU2Vzc2lvbiBjb250ZXh0IG9yIHBhc3MgdGhlIHNlc3Npb24gZXhwbGljaXRseVwiXG4gICAgKTtcbiAgcmV0dXJuIG47XG59XG5jb25zdCBYbyA9IEkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gcGEoZSkge1xuICBjb25zdCB0ID0gSS51c2VDb250ZXh0KFhvKTtcbiAgaWYgKGUgPT09ICEwKSB7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm4gdDtcbiAgICB0aHJvdyBFcnJvcihcInRyaWVkIHRvIGFjY2VzcyBmZWF0dXJlIGNvbnRleHQsIGJ1dCBub25lIGlzIHByZXNlbnRcIik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5leHBvcnQge1xuICBYcyBhcyAkLFxuICBicyBhcyBBLFxuICBHbyBhcyBCLFxuICBfbyBhcyBDLFxuICBVcyBhcyBELFxuICBPcyBhcyBFLFxuICBuYSBhcyBGLFxuICBmcyBhcyBHLFxuICBBcyBhcyBILFxuICBfcyBhcyBJLFxuICB4cyBhcyBKLFxuICBTcyBhcyBLLFxuICBYbyBhcyBMLFxuICBncyBhcyBNLFxuICBqcyBhcyBOLFxuICBCcyBhcyBPLFxuICBWcyBhcyBQLFxuICBOcyBhcyBRLFxuICBIbiBhcyBSLFxuICBJcyBhcyBTLFxuICBNcyBhcyBULFxuICBobyBhcyBVLFxuICBxcyBhcyBWLFxuICB2cyBhcyBXLFxuICB6dCBhcyBYLFxuICB5cyBhcyBZLFxuICBXcyBhcyBaLFxuICBacyBhcyBfLFxuICB0YSBhcyBhLFxuICBFcyBhcyBhMCxcbiAgQiBhcyBhMSxcbiAgS3MgYXMgYTIsXG4gIFFzIGFzIGEzLFxuICBHcyBhcyBhNCxcbiAgaHMgYXMgYTUsXG4gIHBzIGFzIGE2LFxuICBMcyBhcyBhNyxcbiAgcG8gYXMgYTgsXG4gIENzIGFzIGE5LFxuICBhYSBhcyBhQSxcbiAgZmEgYXMgYUIsXG4gIG9hIGFzIGFDLFxuICBlYSBhcyBhYSxcbiAgTW8gYXMgYWIsXG4gIEpvIGFzIGFjLFxuICBkYSBhcyBhZCxcbiAgQm4gYXMgYWUsXG4gIFduIGFzIGFmLFxuICBGcyBhcyBhZyxcbiAgZXMgYXMgYWgsXG4gIEhyIGFzIGFpLFxuICBWbiBhcyBhaixcbiAgam4gYXMgYWssXG4gIHBhIGFzIGFsLFxuICBKcyBhcyBhbSxcbiAgcnMgYXMgYW4sXG4gIGlhIGFzIGFvLFxuICBjcyBhcyBhcCxcbiAgYXMgYXMgYXEsXG4gIHpuIGFzIGFyLFxuICBvcyBhcyBhcyxcbiAgc3MgYXMgYXQsXG4gIGRzIGFzIGF1LFxuICByYSBhcyBhdixcbiAgdHMgYXMgYXcsXG4gIGlzIGFzIGF4LFxuICB1cyBhcyBheSxcbiAgbHMgYXMgYXosXG4gIHpzIGFzIGIsXG4gIGNhIGFzIGMsXG4gICRzIGFzIGQsXG4gIHdzIGFzIGUsXG4gIHVhIGFzIGYsXG4gIERvIGFzIGcsXG4gIERzIGFzIGgsXG4gIHNhIGFzIGksXG4gIEtvIGFzIGosXG4gIEhzIGFzIGssXG4gIEwgYXMgbCxcbiAgbnMgYXMgbSxcbiAgbG8gYXMgbixcbiAgSW8gYXMgbyxcbiAgTiBhcyBwLFxuICBQcyBhcyBxLFxuICBPbyBhcyByLFxuICBZcyBhcyBzLFxuICBEbiBhcyB0LFxuICBsYSBhcyB1LFxuICBrcyBhcyB2LFxuICBRbyBhcyB3LFxuICBUcyBhcyB4LFxuICBScyBhcyB5LFxuICBtcyBhcyB6XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dHMtQ3NPMVFaM3IubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-yU-srrIO.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/hooks-yU-srrIO.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ an; },\n/* harmony export */   A: function() { return /* binding */ In; },\n/* harmony export */   B: function() { return /* binding */ Vn; },\n/* harmony export */   C: function() { return /* binding */ Oe; },\n/* harmony export */   D: function() { return /* binding */ wn; },\n/* harmony export */   E: function() { return /* binding */ An; },\n/* harmony export */   F: function() { return /* binding */ Bt; },\n/* harmony export */   G: function() { return /* binding */ Se; },\n/* harmony export */   H: function() { return /* binding */ jt; },\n/* harmony export */   I: function() { return /* binding */ xn; },\n/* harmony export */   J: function() { return /* binding */ Un; },\n/* harmony export */   K: function() { return /* binding */ Wt; },\n/* harmony export */   L: function() { return /* binding */ qn; },\n/* harmony export */   M: function() { return /* binding */ pe; },\n/* harmony export */   N: function() { return /* binding */ jn; },\n/* harmony export */   O: function() { return /* binding */ Gt; },\n/* harmony export */   P: function() { return /* binding */ $n; },\n/* harmony export */   Q: function() { return /* binding */ Xn; },\n/* harmony export */   R: function() { return /* binding */ dn; },\n/* harmony export */   S: function() { return /* binding */ Ie; },\n/* harmony export */   T: function() { return /* binding */ ts; },\n/* harmony export */   U: function() { return /* binding */ ss; },\n/* harmony export */   V: function() { return /* binding */ re; },\n/* harmony export */   W: function() { return /* binding */ rn; },\n/* harmony export */   X: function() { return /* binding */ os; },\n/* harmony export */   Y: function() { return /* binding */ on; },\n/* harmony export */   Z: function() { return /* binding */ rs; },\n/* harmony export */   _: function() { return /* binding */ as; },\n/* harmony export */   a: function() { return /* binding */ te; },\n/* harmony export */   a0: function() { return /* binding */ cn; },\n/* harmony export */   a1: function() { return /* binding */ cs; },\n/* harmony export */   a2: function() { return /* binding */ pn; },\n/* harmony export */   a3: function() { return /* binding */ is; },\n/* harmony export */   a4: function() { return /* binding */ us; },\n/* harmony export */   a5: function() { return /* binding */ vn; },\n/* harmony export */   a6: function() { return /* binding */ ls; },\n/* harmony export */   b: function() { return /* binding */ Jn; },\n/* harmony export */   c: function() { return /* binding */ Rn; },\n/* harmony export */   d: function() { return /* binding */ Dn; },\n/* harmony export */   e: function() { return /* binding */ Nn; },\n/* harmony export */   f: function() { return /* binding */ zn; },\n/* harmony export */   g: function() { return /* binding */ Wn; },\n/* harmony export */   h: function() { return /* binding */ Kn; },\n/* harmony export */   i: function() { return /* binding */ Ln; },\n/* harmony export */   j: function() { return /* binding */ D; },\n/* harmony export */   k: function() { return /* binding */ Qn; },\n/* harmony export */   l: function() { return /* binding */ Hn; },\n/* harmony export */   m: function() { return /* binding */ es; },\n/* harmony export */   n: function() { return /* binding */ On; },\n/* harmony export */   o: function() { return /* binding */ Fn; },\n/* harmony export */   p: function() { return /* binding */ Gn; },\n/* harmony export */   q: function() { return /* binding */ qt; },\n/* harmony export */   r: function() { return /* binding */ zt; },\n/* harmony export */   s: function() { return /* binding */ ns; },\n/* harmony export */   t: function() { return /* binding */ Yn; },\n/* harmony export */   u: function() { return /* binding */ Pn; },\n/* harmony export */   v: function() { return /* binding */ Bn; },\n/* harmony export */   w: function() { return /* binding */ Kt; },\n/* harmony export */   x: function() { return /* binding */ Zn; },\n/* harmony export */   y: function() { return /* binding */ _n; },\n/* harmony export */   z: function() { return /* binding */ kn; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contexts-CsO1QZ3r.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs\");\n/* harmony import */ var _room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./room-Bb6uLxS5.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n\n\n\n\n\nconst xt = (e) => {\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    n.current = e;\n  }), n;\n};\nfunction Ut(e, n) {\n  const t = Vt(), r = xt(n);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    let o = !1;\n    const c = e.current;\n    if (!c) return;\n    function a(i, u) {\n      o || r.current(i, u);\n    }\n    return t == null || t.subscribe(c, a), () => {\n      o = !0, t == null || t.unsubscribe(c, a);\n    };\n  }, [e.current, t, r]), t == null ? void 0 : t.observer;\n}\nfunction Ht() {\n  let e = !1, n = [];\n  const t = /* @__PURE__ */ new Map();\n  if (typeof window > \"u\")\n    return;\n  const r = new ResizeObserver((o, c) => {\n    n = n.concat(o), e || window.requestAnimationFrame(() => {\n      const a = /* @__PURE__ */ new Set();\n      for (let i = 0; i < n.length; i++) {\n        if (a.has(n[i].target)) continue;\n        a.add(n[i].target);\n        const u = t.get(n[i].target);\n        u == null || u.forEach((p) => p(n[i], c));\n      }\n      n = [], e = !1;\n    }), e = !0;\n  });\n  return {\n    observer: r,\n    subscribe(o, c) {\n      r.observe(o);\n      const a = t.get(o) ?? [];\n      a.push(c), t.set(o, a);\n    },\n    unsubscribe(o, c) {\n      const a = t.get(o) ?? [];\n      if (a.length === 1) {\n        r.unobserve(o), t.delete(o);\n        return;\n      }\n      const i = a.indexOf(c);\n      i !== -1 && a.splice(i, 1), t.set(o, a);\n    }\n  };\n}\nlet ce;\nconst Vt = () => ce || (ce = Ht()), qt = (e) => {\n  const [n, t] = react__WEBPACK_IMPORTED_MODULE_0__.useState({ width: 0, height: 0 });\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    if (e.current) {\n      const { width: o, height: c } = e.current.getBoundingClientRect();\n      t({ width: o, height: c });\n    }\n  }, [e.current]);\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (o) => t(o.contentRect),\n    []\n  );\n  return Ut(e, r), n;\n};\nfunction D(e, n, t = !0) {\n  const [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (t && o(n), typeof window > \"u\" || !e) return;\n    const c = e.subscribe(o);\n    return () => c.unsubscribe();\n  }, [e, t]), r;\n}\nfunction kn(e) {\n  const n = (c) => typeof window < \"u\" ? window.matchMedia(c).matches : !1, [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n(e));\n  function o() {\n    r(n(e));\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const c = window.matchMedia(e);\n    return o(), c.addListener ? c.addListener(o) : c.addEventListener(\"change\", o), () => {\n      c.removeListener ? c.removeListener(o) : c.removeEventListener(\"change\", o);\n    };\n  }, [e]), t;\n}\nfunction wn(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), t = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    await n.startAudio();\n  }, [n]), r = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(n),\n    [n]\n  ), { canPlayAudio: o } = D(r, {\n    canPlayAudio: n.canPlaybackAudio\n  });\n  return { canPlayAudio: o, startAudio: t };\n}\nfunction Pn(e) {\n  const { state: n, dispatch: t } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a)().pin;\n  return { buttonProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const { className: o } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.b)();\n    return (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\n      className: o,\n      disabled: !(n != null && n.length),\n      onClick: () => {\n        t && t({ msg: \"clear_pin\" });\n      }\n    });\n  }, [e, t, n]) };\n}\nfunction Ln(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e.participant), { className: t, connectionQualityObserver: r } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.d)(n),\n    [n]\n  ), o = D(r, n.connectionQuality);\n  return { className: t, quality: o };\n}\nfunction te(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(n), [n]);\n  return D(t, n.state);\n}\nfunction An(e, n) {\n  const t = typeof e == \"function\" ? e : n, r = typeof e == \"string\" ? e : void 0, o = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), { send: c, messageObservable: a, isSendingObservable: i } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(o, r, t),\n    [o, r, t]\n  ), u = D(a, void 0), p = D(i, !1);\n  return {\n    message: u,\n    send: c,\n    isSending: p\n  };\n}\nfunction Rn(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), t = te(n);\n  return { buttonProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const { className: o, disconnect: c } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(n);\n    return (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\n      className: o,\n      onClick: () => c(e.stopTracks ?? !0),\n      disabled: t === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected\n    });\n  }, [n, e, t]) };\n}\nfunction Bt(e) {\n  if (e.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.LocalTrackPublication) {\n    const n = e.publication.track;\n    if (n) {\n      const { facingMode: t } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.facingModeFromLocalTrack)(n);\n      return t;\n    }\n  }\n  return \"undefined\";\n}\nfunction Dn({ trackRef: e, props: n }) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.j)(), { className: o } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.k)(), []), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(t, r == null ? void 0 : r.pin.state), [t, r == null ? void 0 : r.pin.state]);\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(n, {\n      className: o,\n      onClick: (i) => {\n        var u, p, h, d, l;\n        (u = n.onClick) == null || u.call(n, i), c ? (h = r == null ? void 0 : (p = r.pin).dispatch) == null || h.call(p, {\n          msg: \"clear_pin\"\n        }) : (l = r == null ? void 0 : (d = r.pin).dispatch) == null || l.call(d, {\n          msg: \"set_pin\",\n          trackReference: t\n        });\n      }\n    }),\n    [n, o, t, c, r == null ? void 0 : r.pin]\n  ), inFocus: c };\n}\nfunction On(e, n, t = {}) {\n  const r = t.gridLayouts ?? _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.G, { width: o, height: c } = qt(e), a = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.n)(r, n, o, c);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    e.current && a && (e.current.style.setProperty(\"--lk-col-count\", a == null ? void 0 : a.columns.toString()), e.current.style.setProperty(\"--lk-row-count\", a == null ? void 0 : a.rows.toString()));\n  }, [e, a]), {\n    layout: a,\n    containerWidth: o,\n    containerHeight: c\n  };\n}\nfunction Se(e, n = {}) {\n  var i, u;\n  const t = typeof e == \"string\" ? n.participant : e.participant, r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(t), o = typeof e == \"string\" ? { participant: r, source: e } : e, [c, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    !!((i = o.publication) != null && i.isMuted || (u = r.getTrackPublication(o.source)) != null && u.isMuted)\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const p = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.o)(o).subscribe(a);\n    return () => p.unsubscribe();\n  }, [(0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(o)]), c;\n}\nfunction jt(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(n), [n]);\n  return D(t, n.isSpeaking);\n}\nfunction Oe(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n.localParticipant), [o, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    t.isMicrophoneEnabled\n  ), [a, i] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.isCameraEnabled), [u, p] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    t.isScreenShareEnabled\n  ), [h, d] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    t.lastMicrophoneError\n  ), [l, v] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.lastCameraError), [C, k] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    void 0\n  ), [A, w] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0), O = (R) => {\n    i(R.isCameraEnabled), c(R.isMicrophoneEnabled), p(R.isScreenShareEnabled), w(R.cameraTrack), k(R.microphoneTrack), d(R.participant.lastMicrophoneError), v(R.participant.lastCameraError), r(R.participant);\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const R = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(n.localParticipant).subscribe(O);\n    return () => R.unsubscribe();\n  }, [n]), {\n    isMicrophoneEnabled: o,\n    isScreenShareEnabled: u,\n    isCameraEnabled: a,\n    microphoneTrack: C,\n    cameraTrack: A,\n    lastMicrophoneError: h,\n    lastCameraError: l,\n    localParticipant: t\n  };\n}\nfunction In() {\n  const e = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.v)(e.localParticipant),\n    [e]\n  );\n  return D(n, e.localParticipant.permissions);\n}\nfunction Nn({\n  kind: e,\n  room: n,\n  track: t,\n  requestPermissions: r,\n  onError: o\n}) {\n  const c = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => n ?? c ?? new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Room(), [n, c]), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.x)(e, o, r),\n    [e, r, o]\n  ), u = D(i, []), [p, h] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    (a == null ? void 0 : a.getActiveDevice(e)) ?? \"default\"\n  ), { className: d, activeDeviceObservable: l, setActiveMediaDevice: v } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.y)(e, a),\n    [e, a, t]\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const C = l.subscribe((k) => {\n      k && (_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.info(\"setCurrentDeviceId\", k), h(k));\n    });\n    return () => {\n      C == null || C.unsubscribe();\n    };\n  }, [l]), { devices: u, className: d, activeDeviceId: p, setActiveMediaDevice: v };\n}\nfunction _n({\n  kind: e,\n  onError: n\n}) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.x)(e, n),\n    [e, n]\n  );\n  return D(t, []);\n}\nfunction zt(e, n, t = {}) {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]), o = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1), c = n !== o.current, a = typeof t.customSortFunction == \"function\" ? t.customSortFunction(e) : (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.z)(e);\n  let i = [...a];\n  if (c === !1)\n    try {\n      i = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.A)(r.current, a, n);\n    } catch (u) {\n      _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.error(\"Error while running updatePages(): \", u);\n    }\n  return c ? r.current = a : r.current = i, o.current = n, i;\n}\nfunction Fn(e, n) {\n  const [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(1), o = Math.max(Math.ceil(n.length / e), 1);\n  t > o && r(o);\n  const c = t * e, a = c - e, i = (d) => {\n    r((l) => d === \"next\" ? l === o ? l : l + 1 : l === 1 ? l : l - 1);\n  }, u = (d) => {\n    d > o ? r(o) : d < 1 ? r(1) : r(d);\n  }, h = zt(n, e).slice(a, c);\n  return {\n    totalPageCount: o,\n    nextPage: () => i(\"next\"),\n    prevPage: () => i(\"previous\"),\n    setPage: u,\n    firstItemIndex: a,\n    lastItemIndex: c,\n    tracks: h,\n    currentPage: t\n  };\n}\nfunction xn(e = {}) {\n  let n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.B)();\n  e.participant && (n = e.participant);\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.C)(n), [n]), { identity: r, name: o, metadata: c } = D(t, {\n    name: n == null ? void 0 : n.name,\n    identity: n == null ? void 0 : n.identity,\n    metadata: n == null ? void 0 : n.metadata\n  });\n  return { identity: r, name: o, metadata: c };\n}\nfunction Un(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e.participant), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.v)(n), [n]);\n  return D(t, n.permissions);\n}\nfunction Hn({\n  trackRef: e,\n  onParticipantClick: n,\n  disableSpeakingIndicator: t,\n  htmlProps: r\n}) {\n  const o = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const { className: l } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.D)();\n    return (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(r, {\n      className: l,\n      onClick: (v) => {\n        var C;\n        if ((C = r.onClick) == null || C.call(r, v), typeof n == \"function\") {\n          const k = o.publication ?? o.participant.getTrackPublication(o.source);\n          n({ participant: o.participant, track: k });\n        }\n      }\n    });\n  }, [\n    r,\n    n,\n    o.publication,\n    o.source,\n    o.participant\n  ]), a = o.participant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    participant: o.participant,\n    source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone,\n    publication: a\n  }), [a, o.participant]), u = Se(o), p = Se(i), h = jt(o.participant), d = Bt(o);\n  return {\n    elementProps: {\n      \"data-lk-audio-muted\": p,\n      \"data-lk-video-muted\": u,\n      \"data-lk-speaking\": t === !0 ? !1 : h,\n      \"data-lk-local-participant\": o.participant.isLocal,\n      \"data-lk-source\": o.source,\n      \"data-lk-facing-mode\": d,\n      ...c\n    }\n  };\n}\nfunction pe(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const o = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(n, {\n      additionalRoomEvents: e.updateOnlyOn\n    }).subscribe(r);\n    return () => o.unsubscribe();\n  }, [n, JSON.stringify(e.updateOnlyOn)]), t;\n}\nfunction Wt(e = {}) {\n  const n = pe(e), { localParticipant: t } = Oe(e);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => [t, ...n],\n    [t, n]\n  );\n}\nfunction Vn(e) {\n  return e = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.F)(e), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);\n}\nfunction qn(e, n = {}) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), [r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n.updateOnlyOn), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => typeof e == \"string\" ? (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.H)(t, e, {\n    additionalEvents: r\n  }) : (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.I)(t, e, {\n    additionalEvents: r\n  }), [t, JSON.stringify(e), r]), [c, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    p: void 0\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const i = o.subscribe((u) => a({ p: u }));\n    return () => i.unsubscribe();\n  }, [o]), c.p;\n}\nfunction Bn(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.J)(n), [n]), { name: r, metadata: o } = D(t, {\n    name: n.name,\n    metadata: n.metadata\n  });\n  return { name: r, metadata: o };\n}\nfunction Gt(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e == null ? void 0 : e.room), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.K)(n), [n]);\n  return D(t, n.activeSpeakers);\n}\nfunction jn(e) {\n  const [n, t] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(e)\n  ), r = Gt();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t((0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(e));\n  }, [r, e]), n;\n}\nfunction zn({ room: e, props: n }) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), { className: r, roomAudioPlaybackAllowedObservable: o, handleStartAudioPlayback: c } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.N)(),\n    []\n  ), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => o(t),\n    [t, o]\n  ), { canPlayAudio: i } = D(a, {\n    canPlayAudio: t.canPlaybackAudio\n  });\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(n, {\n      className: r,\n      onClick: () => {\n        c(t);\n      },\n      style: { display: i ? \"none\" : \"block\" }\n    }),\n    [n, r, i, c, t]\n  ), canPlayAudio: i };\n}\nfunction Wn({ room: e, props: n }) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), { className: r, roomVideoPlaybackAllowedObservable: o, handleStartVideoPlayback: c } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.O)(),\n    []\n  ), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => o(t),\n    [t, o]\n  ), { canPlayVideo: i } = D(a, {\n    canPlayVideo: t.canPlaybackVideo\n  });\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(n, {\n      className: r,\n      onClick: () => {\n        c(t);\n      },\n      style: { display: i ? \"none\" : \"block\" }\n    }),\n    [n, r, i, c, t]\n  ), canPlayVideo: i };\n}\nfunction Gn(e, n = {}) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), o = n.minSwipeDistance ?? 50, c = (u) => {\n    r.current = null, t.current = u.targetTouches[0].clientX;\n  }, a = (u) => {\n    r.current = u.targetTouches[0].clientX;\n  }, i = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (!t.current || !r.current)\n      return;\n    const u = t.current - r.current, p = u > o, h = u < -o;\n    p && n.onLeftSwipe && n.onLeftSwipe(), h && n.onRightSwipe && n.onRightSwipe();\n  }, [o, n]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const u = e.current;\n    return u && (u.addEventListener(\"touchstart\", c, { passive: !0 }), u.addEventListener(\"touchmove\", a, { passive: !0 }), u.addEventListener(\"touchend\", i, { passive: !0 })), () => {\n      u && (u.removeEventListener(\"touchstart\", c), u.removeEventListener(\"touchmove\", a), u.removeEventListener(\"touchend\", i));\n    };\n  }, [e, i]);\n}\nfunction Jn({ props: e }) {\n  const { dispatch: n, state: t } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a)().widget, { className: r } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.P)(), []);\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\n    className: r,\n    onClick: () => {\n      n && n({ msg: \"toggle_chat\" });\n    },\n    \"aria-pressed\": t != null && t.showChat ? \"true\" : \"false\",\n    \"data-lk-unread-msgs\": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : \"9+\" : \"0\"\n  }), [e, r, n, t]) };\n}\nfunction $n(e, n, t = {}) {\n  const [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var a;\n    if (e === void 0)\n      throw Error(\"token endpoint needs to be defined\");\n    if (((a = t.userInfo) == null ? void 0 : a.identity) === void 0)\n      return;\n    (async () => {\n      _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"fetching token\");\n      const i = new URLSearchParams({ ...t.userInfo, roomName: n }), u = await fetch(`${e}?${i.toString()}`);\n      if (!u.ok) {\n        _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.error(\n          `Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`\n        );\n        return;\n      }\n      const { accessToken: p } = await u.json();\n      o(p);\n    })();\n  }, [e, n, JSON.stringify(t)]), r;\n}\nfunction Qn(e) {\n  var c, a;\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), { className: t, mediaMutedObserver: r } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.Q)(n),\n    [(0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(n)]\n  );\n  return { isMuted: D(\n    r,\n    !!((c = n.publication) != null && c.isMuted || (a = n.participant.getTrackPublication(n.source)) != null && a.isMuted)\n  ), className: t };\n}\nfunction Kn({\n  source: e,\n  onChange: n,\n  initialState: t,\n  captureOptions: r,\n  publishOptions: o,\n  onDeviceError: c,\n  room: a,\n  ...i\n}) {\n  var m;\n  const u = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(), p = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => a ?? u, [a, u]), h = (m = p == null ? void 0 : p.localParticipant) == null ? void 0 : m.getTrackPublication(e), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), { toggle: l, className: v, pendingObserver: C, enabledObserver: k } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => p ? (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.S)(e, p, r, o, c) : (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.T)(),\n    [p, e, JSON.stringify(r), o]\n  ), A = D(C, !1), w = D(k, t ?? !!(h != null && h.isEnabled));\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    n == null || n(w, d.current), d.current = !1;\n  }, [w, n]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t !== void 0 && (_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"forcing initial toggle state\", e, t), l(t));\n  }, []);\n  const O = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_Bb6uLxS5_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(i, { className: v }), [i, v]), R = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (f) => {\n      var b;\n      d.current = !0, l().catch(() => d.current = !1), (b = i.onClick) == null || b.call(i, f);\n    },\n    [i, l]\n  );\n  return {\n    toggle: l,\n    enabled: w,\n    pending: A,\n    track: h,\n    buttonProps: {\n      ...O,\n      \"aria-pressed\": w,\n      \"data-lk-source\": e,\n      \"data-lk-enabled\": w,\n      disabled: A,\n      onClick: R\n    }\n  };\n}\nfunction Yn(e = [\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera,\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone,\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare,\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShareAudio,\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown\n], n = {}) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(n.room), [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), [c, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => e.map((p) => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.U)(p) ? p.source : p), [JSON.stringify(e)]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const p = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.V)(t, i, {\n      additionalRoomEvents: n.updateOnlyOn,\n      onlySubscribed: n.onlySubscribed\n    }).subscribe(({ trackReferences: h, participants: d }) => {\n      _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"setting track bundles\", h, d), o(h), a(d);\n    });\n    return () => p.unsubscribe();\n  }, [\n    t,\n    JSON.stringify(n.onlySubscribed),\n    JSON.stringify(n.updateOnlyOn),\n    JSON.stringify(e)\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if ((0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.W)(e)) {\n      const p = $t(e, c), h = Array.from(r);\n      return c.forEach((d) => {\n        p.has(d.identity) && (p.get(d.identity) ?? []).forEach((v) => {\n          if (r.find(\n            ({ participant: k, publication: A }) => d.identity === k.identity && A.source === v\n          ))\n            return;\n          _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\n            `Add ${v} placeholder for participant ${d.identity}.`\n          );\n          const C = {\n            participant: d,\n            source: v\n          };\n          h.push(C);\n        });\n      }), h;\n    } else\n      return r;\n  }, [r, c, e]);\n}\nfunction Jt(e, n) {\n  const t = new Set(e);\n  for (const r of n)\n    t.delete(r);\n  return t;\n}\nfunction $t(e, n) {\n  const t = /* @__PURE__ */ new Map();\n  if ((0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.W)(e)) {\n    const r = e.filter((o) => o.withPlaceholder).map((o) => o.source);\n    n.forEach((o) => {\n      const c = o.getTrackPublications().map((i) => {\n        var u;\n        return (u = i.track) == null ? void 0 : u.source;\n      }).filter((i) => i !== void 0), a = Array.from(\n        Jt(new Set(r), new Set(c))\n      );\n      a.length > 0 && t.set(o.identity, a);\n    });\n  }\n  return t;\n}\nfunction Qt(e) {\n  const [n, t] = react__WEBPACK_IMPORTED_MODULE_0__.useState((0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.X)(e)), { trackObserver: r } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(e), [e.participant.sid ?? e.participant.identity, e.source]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const o = r.subscribe((c) => {\n      t(c);\n    });\n    return () => o == null ? void 0 : o.unsubscribe();\n  }, [r]), {\n    participant: e.participant,\n    source: e.source ?? livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown,\n    publication: n\n  };\n}\nfunction Xn(e, n) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(n);\n  return Qt({ name: e, participant: t });\n}\nfunction Kt(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e == null ? void 0 : e.room), t = te(n), r = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => t === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected,\n    [t]\n  ), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.Z)(n, e),\n    [n, e, r]\n  ), c = D(o.isSendingObservable, !1), a = D(o.messageObservable, []);\n  return { send: o.send, chatMessages: a, isSending: c };\n}\nfunction Zn(e = {}) {\n  const [n, t] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__._)(e.defaults, e.preventLoad ?? !1)\n  ), r = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    t((p) => ({ ...p, audioEnabled: u }));\n  }, []), o = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    t((p) => ({ ...p, videoEnabled: u }));\n  }, []), c = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    t((p) => ({ ...p, audioDeviceId: u }));\n  }, []), a = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    t((p) => ({ ...p, videoDeviceId: u }));\n  }, []), i = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    t((p) => ({ ...p, username: u }));\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.$)(n, e.preventSave ?? !1);\n  }, [n, e.preventSave]), {\n    userChoices: n,\n    saveAudioInputEnabled: r,\n    saveVideoInputEnabled: o,\n    saveAudioInputDeviceId: c,\n    saveVideoInputDeviceId: a,\n    saveUsername: i\n  };\n}\nfunction es(e, n = {}) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e), r = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(n.room), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a0)(r, t), [r, t]);\n  return D(\n    o,\n    t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)\n  );\n}\nfunction ts(e, n = { fftSize: 32, smoothingTimeConstant: 0 }) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a1)(e) ? e.publication.track : e, [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!t || !t.mediaStream)\n      return;\n    const { cleanup: c, analyser: a } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(t, n), i = a.frequencyBinCount, u = new Uint8Array(i), h = setInterval(() => {\n      a.getByteFrequencyData(u);\n      let d = 0;\n      for (let l = 0; l < u.length; l++) {\n        const v = u[l];\n        d += v * v;\n      }\n      o(Math.sqrt(d / u.length) / 255);\n    }, 1e3 / 30);\n    return () => {\n      c(), clearInterval(h);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), r;\n}\nconst Yt = (e) => {\n  const n = (t) => {\n    let c = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;\n    return c = Math.sqrt(c), c;\n  };\n  return e.map((t) => t === -1 / 0 ? 0 : n(t));\n}, Xt = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 }\n};\nfunction ns(e, n = {}) {\n  var a;\n  const t = e instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track ? e : (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track, r = { ...Xt, ...n }, [o, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    new Array(r.bands).fill(0)\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!t || !(t != null && t.mediaStream)) {\n      c((v) => v.slice().fill(0));\n      return;\n    }\n    const { analyser: i, cleanup: u } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(t, r.analyserOptions), p = i.frequencyBinCount, h = new Float32Array(p), l = setInterval(() => {\n      i.getFloatFrequencyData(h);\n      let v = new Float32Array(h.length);\n      for (let w = 0; w < h.length; w++)\n        v[w] = h[w];\n      v = v.slice(n.loPass, n.hiPass);\n      const C = Yt(v), k = Math.ceil(C.length / r.bands), A = [];\n      for (let w = 0; w < r.bands; w++) {\n        const O = C.slice(w * k, (w + 1) * k).reduce((R, m) => R += m, 0);\n        A.push(O / k);\n      }\n      c(A);\n    }, r.updateInterval);\n    return () => {\n      u(), clearInterval(l);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), o;\n}\nconst Zt = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20\n};\nfunction ss(e, n = {}) {\n  var h;\n  const t = e instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track ? e : (h = e == null ? void 0 : e.publication) == null ? void 0 : h.track, r = { ...Zt, ...n }, o = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Float32Array()), c = react__WEBPACK_IMPORTED_MODULE_0__.useRef(performance.now()), a = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0), [i, u] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), p = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((d) => {\n    u(\n      Array.from(\n        tn(d, r.barCount).map((l) => Math.sqrt(l) * r.volMultiplier)\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      )\n    );\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!t || !(t != null && t.mediaStream))\n      return;\n    const { analyser: d, cleanup: l } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(t, {\n      fftSize: ye(r.barCount)\n    }), v = ye(r.barCount), C = new Float32Array(v), k = () => {\n      if (A = requestAnimationFrame(k), d.getFloatTimeDomainData(C), o.current.map((w, O) => w + C[O]), a.current += 1, performance.now() - c.current >= r.updateInterval) {\n        const w = C.map((O) => O / a.current);\n        p(w), c.current = performance.now(), a.current = 0;\n      }\n    };\n    let A = requestAnimationFrame(k);\n    return () => {\n      l(), cancelAnimationFrame(A);\n    };\n  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), p]), {\n    bars: i\n  };\n}\nfunction ye(e) {\n  return e < 32 ? 32 : en(e);\n}\nfunction en(e) {\n  let n = 2;\n  for (; e >>= 1; )\n    n <<= 1;\n  return n;\n}\nfunction tn(e, n) {\n  const t = Math.floor(e.length / n), r = new Float32Array(n);\n  for (let o = 0; o < n; o++) {\n    const c = t * o;\n    let a = 0;\n    for (let i = 0; i < t; i++)\n      a = a + Math.abs(e[c + i]);\n    r[o] = a / t;\n  }\n  return r;\n}\nfunction re(e, n = {}) {\n  let t, r;\n  typeof n == \"string\" ? t = n : (t = n == null ? void 0 : n.participantIdentity, r = n == null ? void 0 : n.room);\n  const o = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.B)(), c = Wt({ room: r, updateOnlyOn: [] }), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => t ? c.find((p) => p.identity === t) : o, [t, c, o]), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (a)\n      return (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a2)(a, { sources: e });\n  }, [a, JSON.stringify(e)]);\n  return D(i, []);\n}\nfunction nn(e) {\n  var t, r, o;\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      var c;\n      return (c = e == null ? void 0 : e.publication) != null && c.track ? (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a3)(e == null ? void 0 : e.publication.track) : void 0;\n    },\n    [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]\n  );\n  return D(n, {\n    timestamp: Date.now(),\n    rtpTimestamp: (o = (r = e == null ? void 0 : e.publication) == null ? void 0 : r.track) == null ? void 0 : o.rtpTimestamp\n  });\n}\nconst sn = {\n  bufferSize: 100\n  // maxAge: 2_000,\n};\nfunction rn(e, n) {\n  const t = { ...sn, ...n }, [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), c = nn(e), a = (i) => {\n    var u;\n    (u = t.onTranscription) == null || u.call(t, i), o(\n      (p) => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a5)(\n        p,\n        // when first receiving a segment, add the current media timestamp to it\n        i.map((h) => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a6)(h, c)),\n        t.bufferSize\n      )\n    );\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!(e != null && e.publication))\n      return;\n    const i = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a4)(e.publication).subscribe((u) => {\n      a(...u);\n    });\n    return () => {\n      i.unsubscribe();\n    };\n  }, [e && (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(e), a]), { segments: r };\n}\nfunction on(e = {}) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.B)(), t = e.participant ?? n, r = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    // weird typescript constraint\n    () => t ? (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(t) : (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(t),\n    [t]\n  );\n  return D(r, {\n    attributes: t == null ? void 0 : t.attributes\n  });\n}\nfunction rs(e, n = {}) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(n.participant), [r, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.attributes[e]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!t)\n      return;\n    const c = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(t).subscribe((a) => {\n      a.changed[e] !== void 0 && o(a.attributes[e]);\n    });\n    return () => {\n      c.unsubscribe();\n    };\n  }, [t, e]), r;\n}\nconst Ce = _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.AgentState;\nfunction os() {\n  const e = pe(), n = e.find(\n    (d) => d.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && !(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.PublishOnBehalf in d.attributes)\n  ), t = e.find(\n    (d) => d.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && d.attributes[_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.PublishOnBehalf] === (n == null ? void 0 : n.identity)\n  ), r = re(\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera],\n    n == null ? void 0 : n.identity\n  ), o = re(\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera],\n    t == null ? void 0 : t.identity\n  ), c = r.find((d) => d.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone) ?? o.find((d) => d.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone), a = r.find((d) => d.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera) ?? o.find((d) => d.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera), { segments: i } = rn(c), u = te(), { attributes: p } = on({ participant: n }), h = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => u === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected ? \"disconnected\" : u === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting || !n || !(p != null && p[Ce]) ? \"connecting\" : p[Ce], [p, n, u]);\n  return {\n    agent: n,\n    state: h,\n    audioTrack: c,\n    videoTrack: a,\n    agentTranscriptions: i,\n    agentAttributes: p\n  };\n}\nfunction as(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), t = te(n), r = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a9)(n), [n, t]);\n  return D(r, n.isRecording);\n}\nfunction an(e, n) {\n  const t = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(n == null ? void 0 : n.room), o = te(t) === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected, c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.aa)(t, e), [t, e]);\n  return { textStreams: D(o ? void 0 : c, []) };\n}\nfunction cn(e) {\n  const { participantIdentities: n, trackSids: t } = e ?? {}, { textStreams: r } = an(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.ab.TRANSCRIPTION, { room: e == null ? void 0 : e.room });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => r.filter(\n      (c) => n ? n.includes(c.participantInfo.identity) : !0\n    ).filter(\n      (c) => {\n        var a;\n        return t ? t.includes(\n          ((a = c.streamInfo.attributes) == null ? void 0 : a[_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.TranscribedTrackId]) ?? \"\"\n        ) : !0;\n      }\n    ),\n    [r, n, t]\n  );\n}\nconst Me = 2, Te = 400, Ee = 3, ke = 1e3;\nfunction cs(e) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]), t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Mutex(), []), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => t.lock().then(async (h) => {\n    for (; ; ) {\n      const d = n.current.pop();\n      if (!d) {\n        h();\n        break;\n      }\n      switch (d.type) {\n        case \"connect\":\n          await d.room.connect(...d.args).then(d.resolve).catch(d.reject);\n          break;\n        case \"disconnect\":\n          await d.room.disconnect(...d.args).then(d.resolve).catch(d.reject);\n          break;\n      }\n    }\n  }), []), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((h) => {\n    let d = 0;\n    o.current = o.current.filter((l) => {\n      const v = h.getTime() - l.getTime() < ke;\n      return v && (d += 1), v;\n    }), d > Ee && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\n      `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${Ee}x in ${ke}ms). This is not recommended.`\n    );\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n.current = [];\n    const h = /* @__PURE__ */ new Date();\n    o.current.push(h), c(h);\n  }, [e, c]);\n  const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((h) => {\n    let d = 0;\n    a.current = a.current.filter((l) => {\n      const v = h.getTime() - l.getTime() < Te;\n      return v && (d += 1), v;\n    }), d > Me && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\n      `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${Me}x in ${Te}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`\n    );\n  }, []), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (...h) => new Promise((d, l) => {\n      if (!e)\n        throw new Error(\"Called connect(), but room was unset\");\n      const v = /* @__PURE__ */ new Date();\n      i(v), n.current.push({ type: \"connect\", room: e, args: h, resolve: d, reject: l }), a.current.push(v), r();\n    }),\n    [e, i, r]\n  ), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (...h) => new Promise((d, l) => {\n      if (!e)\n        throw new Error(\"Called discconnect(), but room was unset\");\n      const v = /* @__PURE__ */ new Date();\n      i(v), n.current.push({ type: \"disconnect\", room: e, args: h, resolve: d, reject: l }), a.current.push(v), r();\n    }),\n    [e, i, r]\n  );\n  return {\n    connect: e ? u : null,\n    disconnect: e ? p : null\n  };\n}\nvar ne = { exports: {} }, we;\nfunction un() {\n  if (we) return ne.exports;\n  we = 1;\n  var e = typeof Reflect == \"object\" ? Reflect : null, n = e && typeof e.apply == \"function\" ? e.apply : function(f, b, g) {\n    return Function.prototype.apply.call(f, b, g);\n  }, t;\n  e && typeof e.ownKeys == \"function\" ? t = e.ownKeys : Object.getOwnPropertySymbols ? t = function(f) {\n    return Object.getOwnPropertyNames(f).concat(Object.getOwnPropertySymbols(f));\n  } : t = function(f) {\n    return Object.getOwnPropertyNames(f);\n  };\n  function r(m) {\n    console && console.warn && console.warn(m);\n  }\n  var o = Number.isNaN || function(f) {\n    return f !== f;\n  };\n  function c() {\n    c.init.call(this);\n  }\n  ne.exports = c, ne.exports.once = w, c.EventEmitter = c, c.prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;\n  var a = 10;\n  function i(m) {\n    if (typeof m != \"function\")\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof m);\n  }\n  Object.defineProperty(c, \"defaultMaxListeners\", {\n    enumerable: !0,\n    get: function() {\n      return a;\n    },\n    set: function(m) {\n      if (typeof m != \"number\" || m < 0 || o(m))\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + m + \".\");\n      a = m;\n    }\n  }), c.init = function() {\n    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n  }, c.prototype.setMaxListeners = function(f) {\n    if (typeof f != \"number\" || f < 0 || o(f))\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + f + \".\");\n    return this._maxListeners = f, this;\n  };\n  function u(m) {\n    return m._maxListeners === void 0 ? c.defaultMaxListeners : m._maxListeners;\n  }\n  c.prototype.getMaxListeners = function() {\n    return u(this);\n  }, c.prototype.emit = function(f) {\n    for (var b = [], g = 1; g < arguments.length; g++) b.push(arguments[g]);\n    var y = f === \"error\", T = this._events;\n    if (T !== void 0)\n      y = y && T.error === void 0;\n    else if (!y)\n      return !1;\n    if (y) {\n      var M;\n      if (b.length > 0 && (M = b[0]), M instanceof Error)\n        throw M;\n      var P = new Error(\"Unhandled error.\" + (M ? \" (\" + M.message + \")\" : \"\"));\n      throw P.context = M, P;\n    }\n    var F = T[f];\n    if (F === void 0)\n      return !1;\n    if (typeof F == \"function\")\n      n(F, this, b);\n    else\n      for (var q = F.length, J = C(F, q), g = 0; g < q; ++g)\n        n(J[g], this, b);\n    return !0;\n  };\n  function p(m, f, b, g) {\n    var y, T, M;\n    if (i(b), T = m._events, T === void 0 ? (T = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (T.newListener !== void 0 && (m.emit(\n      \"newListener\",\n      f,\n      b.listener ? b.listener : b\n    ), T = m._events), M = T[f]), M === void 0)\n      M = T[f] = b, ++m._eventsCount;\n    else if (typeof M == \"function\" ? M = T[f] = g ? [b, M] : [M, b] : g ? M.unshift(b) : M.push(b), y = u(m), y > 0 && M.length > y && !M.warned) {\n      M.warned = !0;\n      var P = new Error(\"Possible EventEmitter memory leak detected. \" + M.length + \" \" + String(f) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      P.name = \"MaxListenersExceededWarning\", P.emitter = m, P.type = f, P.count = M.length, r(P);\n    }\n    return m;\n  }\n  c.prototype.addListener = function(f, b) {\n    return p(this, f, b, !1);\n  }, c.prototype.on = c.prototype.addListener, c.prototype.prependListener = function(f, b) {\n    return p(this, f, b, !0);\n  };\n  function h() {\n    if (!this.fired)\n      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n  }\n  function d(m, f, b) {\n    var g = { fired: !1, wrapFn: void 0, target: m, type: f, listener: b }, y = h.bind(g);\n    return y.listener = b, g.wrapFn = y, y;\n  }\n  c.prototype.once = function(f, b) {\n    return i(b), this.on(f, d(this, f, b)), this;\n  }, c.prototype.prependOnceListener = function(f, b) {\n    return i(b), this.prependListener(f, d(this, f, b)), this;\n  }, c.prototype.removeListener = function(f, b) {\n    var g, y, T, M, P;\n    if (i(b), y = this._events, y === void 0)\n      return this;\n    if (g = y[f], g === void 0)\n      return this;\n    if (g === b || g.listener === b)\n      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete y[f], y.removeListener && this.emit(\"removeListener\", f, g.listener || b));\n    else if (typeof g != \"function\") {\n      for (T = -1, M = g.length - 1; M >= 0; M--)\n        if (g[M] === b || g[M].listener === b) {\n          P = g[M].listener, T = M;\n          break;\n        }\n      if (T < 0)\n        return this;\n      T === 0 ? g.shift() : k(g, T), g.length === 1 && (y[f] = g[0]), y.removeListener !== void 0 && this.emit(\"removeListener\", f, P || b);\n    }\n    return this;\n  }, c.prototype.off = c.prototype.removeListener, c.prototype.removeAllListeners = function(f) {\n    var b, g, y;\n    if (g = this._events, g === void 0)\n      return this;\n    if (g.removeListener === void 0)\n      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : g[f] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete g[f]), this;\n    if (arguments.length === 0) {\n      var T = Object.keys(g), M;\n      for (y = 0; y < T.length; ++y)\n        M = T[y], M !== \"removeListener\" && this.removeAllListeners(M);\n      return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;\n    }\n    if (b = g[f], typeof b == \"function\")\n      this.removeListener(f, b);\n    else if (b !== void 0)\n      for (y = b.length - 1; y >= 0; y--)\n        this.removeListener(f, b[y]);\n    return this;\n  };\n  function l(m, f, b) {\n    var g = m._events;\n    if (g === void 0)\n      return [];\n    var y = g[f];\n    return y === void 0 ? [] : typeof y == \"function\" ? b ? [y.listener || y] : [y] : b ? A(y) : C(y, y.length);\n  }\n  c.prototype.listeners = function(f) {\n    return l(this, f, !0);\n  }, c.prototype.rawListeners = function(f) {\n    return l(this, f, !1);\n  }, c.listenerCount = function(m, f) {\n    return typeof m.listenerCount == \"function\" ? m.listenerCount(f) : v.call(m, f);\n  }, c.prototype.listenerCount = v;\n  function v(m) {\n    var f = this._events;\n    if (f !== void 0) {\n      var b = f[m];\n      if (typeof b == \"function\")\n        return 1;\n      if (b !== void 0)\n        return b.length;\n    }\n    return 0;\n  }\n  c.prototype.eventNames = function() {\n    return this._eventsCount > 0 ? t(this._events) : [];\n  };\n  function C(m, f) {\n    for (var b = new Array(f), g = 0; g < f; ++g)\n      b[g] = m[g];\n    return b;\n  }\n  function k(m, f) {\n    for (; f + 1 < m.length; f++)\n      m[f] = m[f + 1];\n    m.pop();\n  }\n  function A(m) {\n    for (var f = new Array(m.length), b = 0; b < f.length; ++b)\n      f[b] = m[b].listener || m[b];\n    return f;\n  }\n  function w(m, f) {\n    return new Promise(function(b, g) {\n      function y(M) {\n        m.removeListener(f, T), g(M);\n      }\n      function T() {\n        typeof m.removeListener == \"function\" && m.removeListener(\"error\", y), b([].slice.call(arguments));\n      }\n      R(m, f, T, { once: !0 }), f !== \"error\" && O(m, y, { once: !0 });\n    });\n  }\n  function O(m, f, b) {\n    typeof m.on == \"function\" && R(m, \"error\", f, b);\n  }\n  function R(m, f, b, g) {\n    if (typeof m.on == \"function\")\n      g.once ? m.once(f, b) : m.on(f, b);\n    else if (typeof m.addEventListener == \"function\")\n      m.addEventListener(f, function y(T) {\n        g.once && m.removeEventListener(f, y), b(T);\n      });\n    else\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof m);\n  }\n  return ne.exports;\n}\nvar he = un();\nconst ln = 2e4;\nvar dn = /* @__PURE__ */ ((e) => (e.CameraChanged = \"cameraChanged\", e.MicrophoneChanged = \"microphoneChanged\", e.StateChanged = \"stateChanged\", e))(dn || {});\nconst x = (e) => ({\n  isConnected: e === \"listening\" || e === \"thinking\" || e === \"speaking\",\n  canListen: e === \"pre-connect-buffering\" || e === \"listening\" || e === \"thinking\" || e === \"speaking\",\n  isFinished: e === \"disconnected\" || e === \"failed\",\n  isPending: e === \"connecting\" || e === \"initializing\" || e === \"idle\"\n}), fn = () => {\n  const [e, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    null\n  ), [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    null\n  ), o = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"connecting\"), c = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), a = (i) => setTimeout(() => {\n    if (!c.current) {\n      n(\"Agent did not join the room.\");\n      return;\n    }\n    const { isConnected: u } = x(o.current);\n    if (!u) {\n      n(\"Agent joined the room but did not complete initializing.\");\n      return;\n    }\n  }, i ?? ln);\n  return {\n    agentTimeoutFailureReason: e,\n    startAgentTimeout: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      (i) => {\n        t && clearTimeout(t), n(null), r(a(i)), o.current = \"connecting\", c.current = !1;\n      },\n      [t]\n    ),\n    clearAgentTimeout: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n      t && clearTimeout(t), n(null), r(null), o.current = \"connecting\", c.current = !1;\n    }, [t]),\n    clearAgentTimeoutFailureReason: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n      n(null);\n    }, []),\n    updateAgentTimeoutState: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\n      o.current = i;\n    }, []),\n    updateAgentTimeoutParticipantExists: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\n      c.current = i;\n    }, [])\n  };\n};\nfunction mn(e, n) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(n);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t.current = n;\n  }, [n]);\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (a) => {\n      const { isConnected: i } = x(t.current);\n      if (!i)\n        return new Promise((u, p) => {\n          const h = (v) => {\n            const { isConnected: C } = x(v);\n            C && (l(), u());\n          }, d = () => {\n            l(), p(new Error(\"useAgent(/* ... */).waitUntilConnected - signal aborted\"));\n          }, l = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", d);\n          };\n          e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", d);\n        });\n    },\n    [e]\n  ), o = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (a) => {\n      const { canListen: i } = x(t.current);\n      if (!i)\n        return new Promise((u, p) => {\n          const h = (v) => {\n            const { canListen: C } = x(v);\n            C && (l(), u());\n          }, d = () => {\n            l(), p(new Error(\"useAgent(/* ... */).waitUntilCouldBeListening - signal aborted\"));\n          }, l = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", d);\n          };\n          e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", d);\n        });\n    },\n    [e]\n  ), c = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (a) => {\n      const { isFinished: i } = x(t.current);\n      if (!i)\n        return new Promise((u, p) => {\n          const h = (v) => {\n            const { isFinished: C } = x(v);\n            C && (l(), u());\n          }, d = () => {\n            l(), p(new Error(\"useAgent(/* ... */).waitUntilFinished - signal aborted\"));\n          }, l = () => {\n            e.off(\"stateChanged\", h), a == null || a.removeEventListener(\"abort\", d);\n          };\n          e.on(\"stateChanged\", h), a == null || a.addEventListener(\"abort\", d);\n        });\n    },\n    [e]\n  );\n  return { waitUntilConnected: r, waitUntilCouldBeListening: o, waitUntilFinished: c };\n}\nfunction Ie(e) {\n  const n = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.ac)();\n  if (e = e ?? n, !e)\n    throw new Error(\n      \"No session provided, make sure you are inside a Session context or pass the session explicitly\"\n    );\n  const {\n    room: t,\n    internal: {\n      agentConnectTimeoutMilliseconds: r,\n      agentTimeoutFailureReason: o,\n      startAgentTimeout: c,\n      clearAgentTimeout: a,\n      clearAgentTimeoutFailureReason: i,\n      updateAgentTimeoutState: u,\n      updateAgentTimeoutParticipantExists: p\n    }\n  } = e, h = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new he.EventEmitter(), []), d = pe({ room: t }), l = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => d.find(\n    (S) => S.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && !(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.PublishOnBehalf in S.attributes)\n  ) ?? null, [d]), v = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => l ? d.find(\n    (S) => S.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && S.attributes[_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.PublishOnBehalf] === l.identity\n  ) ?? null : null, [l, d]), [C, k] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!l)\n      return;\n    const S = (_) => {\n      k(_);\n    };\n    return l.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.AttributesChanged, S), () => {\n      l.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.AttributesChanged, S);\n    };\n  }, [l, h]);\n  const A = re([livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone], {\n    room: t,\n    participantIdentity: l == null ? void 0 : l.identity\n  }), w = re([livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone], {\n    room: t,\n    participantIdentity: v == null ? void 0 : v.identity\n  }), O = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => A.find((S) => S.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera) ?? w.find((S) => S.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera),\n    [A, w]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    h.emit(\"cameraChanged\", O);\n  }, [h, O]);\n  const R = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => A.find((S) => S.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone) ?? w.find((S) => S.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone),\n    [A, w]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    h.emit(\"microphoneChanged\", R);\n  }, [h, R]);\n  const [m, f] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.state);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const S = (_) => {\n      f(_);\n    };\n    return t.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ConnectionStateChanged, S), () => {\n      t.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ConnectionStateChanged, S);\n    };\n  }, [t]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    l && i();\n  }, [l]);\n  const [b, g] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!l)\n      return;\n    const S = (_) => {\n      _.identity === (l == null ? void 0 : l.identity) && g(\"Agent left the room unexpectedly.\");\n    };\n    return t.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ParticipantDisconnected, S), () => {\n      t.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ParticipantDisconnected, S);\n    };\n  }, [l, t]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    m === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected && g(null);\n  }, [m]);\n  const [y, T] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone) ?? null\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const S = () => {\n      T(t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone) ?? null);\n    }, _ = () => {\n      T(null);\n    };\n    return t.localParticipant.on(\n      livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.LocalTrackPublished,\n      S\n    ), t.localParticipant.on(\n      livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.LocalTrackUnpublished,\n      _\n    ), () => {\n      t.localParticipant.off(\n        livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.LocalTrackPublished,\n        S\n      ), t.localParticipant.off(\n        livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantEvent.LocalTrackUnpublished,\n        _\n      );\n    };\n  }, [t.localParticipant]);\n  const M = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const S = [];\n    return o && S.push(o), b && S.push(b), S;\n  }, [o, b]), P = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (M.length > 0)\n      return \"failed\";\n    let S = \"disconnected\";\n    return m !== livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected && (S = \"connecting\"), y && (S = \"pre-connect-buffering\"), l && C[_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.AgentState] && (S = C[_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.a8.AgentState]), S;\n  }, [\n    M,\n    m,\n    y,\n    l,\n    C\n  ]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    h.emit(\"stateChanged\", P), u(P);\n  }, [h, P]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    p(l !== null);\n  }, [l]);\n  const F = e.connectionState === \"disconnected\";\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!F)\n      return c(r), () => {\n        a();\n      };\n  }, [F, r]);\n  const q = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const S = {\n      attributes: C,\n      internal: {\n        agentParticipant: l,\n        workerParticipant: v,\n        emitter: h\n      }\n    };\n    switch (P) {\n      case \"disconnected\":\n        return {\n          ...S,\n          state: P,\n          ...x(P),\n          failureReasons: null,\n          // Clear inner values if no longer connected\n          cameraTrack: void 0,\n          microphoneTrack: void 0\n        };\n      case \"connecting\":\n        return {\n          ...S,\n          state: P,\n          ...x(P),\n          failureReasons: null,\n          // Clear inner values if no longer connected\n          cameraTrack: void 0,\n          microphoneTrack: void 0\n        };\n      case \"initializing\":\n      case \"idle\":\n        return {\n          ...S,\n          state: P,\n          ...x(P),\n          failureReasons: null,\n          cameraTrack: O,\n          microphoneTrack: R\n        };\n      case \"pre-connect-buffering\":\n        return {\n          ...S,\n          state: P,\n          ...x(P),\n          failureReasons: null,\n          cameraTrack: O,\n          microphoneTrack: R\n        };\n      case \"listening\":\n      case \"thinking\":\n      case \"speaking\":\n        return {\n          ...S,\n          state: P,\n          ...x(P),\n          failureReasons: null,\n          cameraTrack: O,\n          microphoneTrack: R\n        };\n      case \"failed\":\n        return {\n          ...S,\n          state: \"failed\",\n          ...x(\"failed\"),\n          failureReasons: M,\n          // Clear inner values if no longer connected\n          cameraTrack: void 0,\n          microphoneTrack: void 0\n        };\n    }\n  }, [C, h, l, P, O, R]), { waitUntilConnected: J, waitUntilCouldBeListening: K, waitUntilFinished: L } = mn(h, P), N = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (S) => new Promise((_, Y) => {\n      const B = (z) => {\n        z && ($(), _(z));\n      }, j = () => {\n        $(), Y(new Error(\"useAgent(/* ... */).waitUntilCamera - signal aborted\"));\n      }, $ = () => {\n        h.off(\"cameraChanged\", B), S == null || S.removeEventListener(\"abort\", j);\n      };\n      h.on(\"cameraChanged\", B), S == null || S.addEventListener(\"abort\", j);\n    }),\n    [h]\n  ), Z = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (S) => new Promise((_, Y) => {\n      const B = (z) => {\n        z && ($(), _(z));\n      }, j = () => {\n        $(), Y(new Error(\"useAgent(/* ... */).waitUntilMicrophone - signal aborted\"));\n      }, $ = () => {\n        h.off(\"microphoneChanged\", B), S == null || S.removeEventListener(\"abort\", j);\n      };\n      h.on(\"microphoneChanged\", B), S == null || S.addEventListener(\"abort\", j);\n    }),\n    [h]\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...q,\n    waitUntilConnected: J,\n    waitUntilCouldBeListening: K,\n    waitUntilFinished: L,\n    waitUntilCamera: N,\n    waitUntilMicrophone: Z\n  }), [\n    q,\n    J,\n    K,\n    L,\n    N,\n    Z\n  ]);\n}\nvar pn = /* @__PURE__ */ ((e) => (e.ConnectionStateChanged = \"connectionStateChanged\", e.MediaDevicesError = \"mediaDevicesError\", e.EncryptionError = \"encryptionError\", e))(pn || {});\nfunction hn(e, n) {\n  const t = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(n)]);\n  for (const r of t)\n    switch (r) {\n      case \"roomName\":\n      case \"participantName\":\n      case \"participantIdentity\":\n      case \"participantMetadata\":\n      case \"participantAttributes\":\n      case \"agentName\":\n      case \"agentMetadata\":\n        if (e[r] !== n[r])\n          return !1;\n        break;\n      default:\n        const o = r;\n        throw new Error(`Options key ${o} not being checked for equality!`);\n    }\n  return !0;\n}\nfunction bn(e, n) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(n);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t.current = n;\n  }, [n]), react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (o, c) => {\n      if (t.current !== o)\n        return new Promise((a, i) => {\n          const u = (d) => {\n            d === o && (h(), a());\n          }, p = () => {\n            h(), i(\n              new Error(\n                `useSession(/* ... */).waitUntilConnectionState(${o}, /* signal */) - signal aborted`\n              )\n            );\n          }, h = () => {\n            e.off(\"connectionStateChanged\", u), c == null || c.removeEventListener(\"abort\", p);\n          };\n          e.on(\"connectionStateChanged\", u), c == null || c.addEventListener(\"abort\", p);\n        });\n    },\n    [e]\n  );\n}\nfunction gn(e, n) {\n  const t = e instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.TokenSourceConfigurable, r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\n    t ? n : null\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!t) {\n      r.current = null;\n      return;\n    }\n    r.current !== null && hn(r.current, n) || (r.current = n);\n  }, [t, n]), react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    if (t) {\n      if (!r.current)\n        throw new Error(\n          \"AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!\"\n        );\n      return e.fetch(r.current);\n    } else\n      return e.fetch();\n  }, [t, e]);\n}\nfunction is(e, n = {}) {\n  const { room: t, agentConnectTimeoutMilliseconds: r, ...o } = n, c = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => c ?? t ?? new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Room(),\n    [c, t]\n  ), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => new he.EventEmitter(),\n    []\n  ), u = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (L) => ({\n      isConnected: L === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected || L === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Reconnecting || L === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.SignalReconnecting\n    }),\n    []\n  ), [p, h] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a.state);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const L = (N) => {\n      h(N);\n    };\n    return a.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ConnectionStateChanged, L), () => {\n      a.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.ConnectionStateChanged, L);\n    };\n  }, [a]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const L = async (N) => {\n      i.emit(\"mediaDevicesError\", N);\n    };\n    return a.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, L), () => {\n      a.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, L);\n    };\n  }, [a, i]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const L = async (N) => {\n      i.emit(\"encryptionError\", N);\n    };\n    return a.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, L), () => {\n      a.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, L);\n    };\n  }, [a, i]);\n  const { localParticipant: d } = Oe({ room: a }), l = d.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera), v = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => !l || l.isMuted ? null : {\n    source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera,\n    participant: d,\n    publication: l\n  }, [d, l, l == null ? void 0 : l.isMuted]), C = d.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone), k = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => !C || C.isMuted ? null : {\n    source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone,\n    participant: d,\n    publication: C\n  }, [d, C, C == null ? void 0 : C.isMuted]), {\n    agentTimeoutFailureReason: A,\n    startAgentTimeout: w,\n    clearAgentTimeout: O,\n    clearAgentTimeoutFailureReason: R,\n    updateAgentTimeoutState: m,\n    updateAgentTimeoutParticipantExists: f\n  } = fn(), b = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      emitter: i,\n      tokenSource: e,\n      agentConnectTimeoutMilliseconds: r,\n      agentTimeoutFailureReason: A,\n      startAgentTimeout: w,\n      clearAgentTimeout: O,\n      clearAgentTimeoutFailureReason: R,\n      updateAgentTimeoutState: m,\n      updateAgentTimeoutParticipantExists: f\n    }),\n    [\n      i,\n      r,\n      e,\n      A,\n      w,\n      O,\n      R,\n      m,\n      f\n    ]\n  ), g = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const L = {\n      room: a,\n      internal: b\n    };\n    switch (p) {\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting:\n        return {\n          ...L,\n          connectionState: livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting,\n          ...u(livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting),\n          local: {\n            cameraTrack: null,\n            microphoneTrack: null\n          }\n        };\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected:\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Reconnecting:\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.SignalReconnecting:\n        return {\n          ...L,\n          connectionState: p,\n          ...u(p),\n          local: {\n            cameraTrack: v,\n            microphoneTrack: k\n          }\n        };\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected:\n        return {\n          ...L,\n          connectionState: livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected,\n          ...u(livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected),\n          local: {\n            cameraTrack: null,\n            microphoneTrack: null\n          }\n        };\n    }\n  }, [\n    b,\n    a,\n    p,\n    v,\n    k,\n    u\n  ]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    i.emit(\"connectionStateChanged\", g.connectionState);\n  }, [i, g.connectionState]);\n  const y = bn(\n    i,\n    g.connectionState\n  ), T = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (L) => y(\n      livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connected,\n      L\n    ),\n    [y]\n  ), M = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (L) => y(livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected, L),\n    [y]\n  ), P = Ie(\n    react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n      () => ({\n        connectionState: g.connectionState,\n        room: a,\n        internal: b\n      }),\n      [g, a, b]\n    )\n  ), F = gn(e, o), q = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (L = {}) => {\n      var B, j;\n      const {\n        signal: N,\n        tracks: Z = { microphone: { enabled: !0, publishOptions: { preConnectBuffer: !0 } } },\n        roomConnectOptions: S\n      } = L;\n      await M(N);\n      const _ = () => {\n        a.disconnect();\n      };\n      N == null || N.addEventListener(\"abort\", _);\n      let Y = !1;\n      await Promise.all([\n        F().then(({ serverUrl: $, participantToken: z }) => {\n          var be, ge;\n          return Y = (((ge = (be = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.decodeTokenPayload)(z).roomConfig) == null ? void 0 : be.agents) == null ? void 0 : ge.length) ?? 0) > 0, a.connect($, z, S);\n        }),\n        // Start microphone (with preconnect buffer) by default\n        (B = Z.microphone) != null && B.enabled ? a.localParticipant.setMicrophoneEnabled(\n          !0,\n          void 0,\n          ((j = Z.microphone) == null ? void 0 : j.publishOptions) ?? {}\n        ) : Promise.resolve()\n      ]), await T(N), Y && await P.waitUntilConnected(N), N == null || N.removeEventListener(\"abort\", _);\n    },\n    [a, M, F, T, P.waitUntilConnected]\n  ), J = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    await a.disconnect();\n  }, [a]), K = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    const L = await F();\n    await a.prepareConnection(L.serverUrl, L.participantToken);\n  }, [F, a]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      K().catch((L) => {\n        console.warn(\"WARNING: Room.prepareConnection failed:\", L);\n      });\n    },\n    [\n      /* note: no prepareConnection here, this effect should only ever run once! */\n    ]\n  ), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      ...g,\n      waitUntilConnected: T,\n      waitUntilDisconnected: M,\n      prepareConnection: K,\n      start: q,\n      end: J\n    }),\n    [g, T, M, K, q, J]\n  );\n}\nfunction us(e, n, t, r) {\n  const o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => () => {\n  }, []), c = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(t ?? o, r ?? []), a = r ? c : t, i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => e ? \"internal\" in e ? e.internal.emitter : e : null, [e]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!(!i || !a))\n      return i.on(n, a), () => {\n        i.off(n, a);\n      };\n  }, [i, n, a]);\n}\nvar vn = /* @__PURE__ */ ((e) => (e.MessageReceived = \"messageReceived\", e))(vn || {});\nfunction ls(e) {\n  const { room: n } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.ad)(e), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => new he.EventEmitter(),\n    []\n  ), r = Ie(e), o = cn({ room: n }), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({ room: n }), [n]), a = Kt(c), i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => o.map((l) => {\n    var v, C, k;\n    switch (l.participantInfo.identity) {\n      case n.localParticipant.identity:\n        return {\n          type: \"userTranscript\",\n          message: l.text,\n          id: l.streamInfo.id,\n          timestamp: l.streamInfo.timestamp,\n          from: n.localParticipant\n        };\n      case ((v = r.internal.agentParticipant) == null ? void 0 : v.identity):\n      case ((C = r.internal.workerParticipant) == null ? void 0 : C.identity):\n        return {\n          type: \"agentTranscript\",\n          message: l.text,\n          id: l.streamInfo.id,\n          timestamp: l.streamInfo.timestamp,\n          from: ((k = r.internal.agentParticipant) == null ? void 0 : k.identity) === l.participantInfo.identity ? r.internal.agentParticipant : r.internal.workerParticipant\n        };\n      default:\n        return {\n          type: \"agentTranscript\",\n          message: l.text,\n          id: l.streamInfo.id,\n          timestamp: l.streamInfo.timestamp,\n          from: Array.from(n.remoteParticipants.values()).find(\n            (A) => A.identity === l.participantInfo.identity\n          )\n        };\n    }\n  }), [o, n]), u = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => [...i, ...a.chatMessages], [i, a.chatMessages]), p = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map()), h = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const l = /* @__PURE__ */ new Date();\n    for (const v of u)\n      p.current.has(v.id) || p.current.set(v.id, l);\n    return u.sort((v, C) => {\n      const k = p.current.get(v.id), A = p.current.get(C.id);\n      return typeof k > \"u\" || typeof A > \"u\" ? 0 : k.getTime() - A.getTime();\n    });\n  }, [u]), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Set());\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    for (const l of h)\n      d.current.has(l.id) || (d.current.add(l.id), t.emit(\"messageReceived\", l));\n  }, [h]), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      messages: h,\n      send: a.send,\n      isSending: a.isSending,\n      internal: { emitter: t }\n    }),\n    [h, a.send, a.isSending]\n  );\n}\n\n//# sourceMappingURL=hooks-yU-srrIO.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvaG9va3MteVUtc3JySU8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQzZEO0FBQ29pQjtBQUMva0I7QUFDNlA7QUFDMVM7QUFDQSxZQUFZLHlDQUFRO0FBQ3BCLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVLEdBQUcscUJBQXFCO0FBQ25ELEVBQUUsa0RBQWlCO0FBQ25CO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEMsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQSxHQUFHO0FBQ0gsWUFBWSw4Q0FBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVU7QUFDM0IsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFGQUFxRiwyQ0FBVTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLHlEQUFDLFNBQVMsOENBQWE7QUFDbkM7QUFDQSxHQUFHLFlBQVksMENBQVM7QUFDeEIsVUFBVSx5REFBRTtBQUNaO0FBQ0EsT0FBTyxrQkFBa0I7QUFDekI7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QixFQUFFLHlEQUFFO0FBQ3RDLFdBQVcsYUFBYSwwQ0FBUztBQUNqQyxZQUFZLGVBQWUsRUFBRSx5REFBRTtBQUMvQixXQUFXLHFEQUFDO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEIsWUFBWSx5REFBQyxtQkFBbUIsNkNBQTZDLEVBQUUsMENBQVM7QUFDeEYsVUFBVSx5REFBRTtBQUNaO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVkseURBQUMsU0FBUywwQ0FBUyxPQUFPLHlEQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Rix5REFBRSxNQUFNLHdEQUF3RCxFQUFFLDBDQUFTO0FBQ2xLLFVBQVUseURBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFFO0FBQ2QsV0FBVyxhQUFhLDBDQUFTO0FBQ2pDLFlBQVksOEJBQThCLEVBQUUseURBQUU7QUFDOUMsV0FBVyxxREFBQztBQUNaO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQUM7QUFDdkIsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLGlFQUFFO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixFQUFFLHdFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxZQUFZLHlEQUFFLFNBQVMseURBQUUsTUFBTSxlQUFlLEVBQUUsMENBQVMsT0FBTyx5REFBRSxhQUFhLDBDQUFTLE9BQU8seURBQUU7QUFDakcsV0FBVyxhQUFhLDBDQUFTO0FBQ2pDLFVBQVUscURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDZCQUE2QixxREFBRSxJQUFJLHNCQUFzQixhQUFhLHlEQUFFO0FBQ3hFLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNFQUFzRSx5REFBQyxrQ0FBa0MsNEJBQTRCLGNBQWMsMkNBQVU7QUFDN0o7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEIsY0FBYyx5REFBRTtBQUNoQjtBQUNBLEdBQUcsR0FBRyx5REFBRTtBQUNSO0FBQ0E7QUFDQSxZQUFZLHlEQUFDLFNBQVMsMENBQVMsT0FBTyx5REFBRTtBQUN4QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVkseURBQUMsbUJBQW1CLDJDQUFVLCtCQUErQiwyQ0FBVTtBQUNuRjtBQUNBLGNBQWMsMkNBQVUsOEJBQThCLDJDQUFVO0FBQ2hFO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBLGNBQWMsMkNBQVUsOEJBQThCLDJDQUFVO0FBQ2hFO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQixjQUFjLHlEQUFFO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFFLFFBQVEsMENBQVM7QUFDL0IsVUFBVSx5REFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVkseURBQUUsUUFBUSwwQ0FBUyxxQkFBcUIsZ0RBQUUsaUJBQWlCLDBDQUFTO0FBQ2hGLFVBQVUseURBQUU7QUFDWjtBQUNBLDRCQUE0QiwyQ0FBVTtBQUN0QztBQUNBLE9BQU8sbUVBQW1FLEVBQUUsMENBQVM7QUFDckYsVUFBVSx5REFBRTtBQUNaO0FBQ0E7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsWUFBWSxxREFBQztBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLDBDQUFTO0FBQ3JCLFVBQVUseURBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixZQUFZLHlDQUFRLFVBQVUseUNBQVEscUdBQXFHLHlEQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQUU7QUFDWixNQUFNO0FBQ04sTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFVBQVUseURBQUU7QUFDWjtBQUNBLFlBQVksMENBQVMsT0FBTyx5REFBRSxhQUFhLG9DQUFvQztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVkseURBQUMscUJBQXFCLDBDQUFTLE9BQU8seURBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWSx5REFBRSxTQUFTLDBDQUFTO0FBQ2hDLFlBQVksZUFBZSxFQUFFLHlEQUFFO0FBQy9CLFdBQVcscURBQUM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBQyx5QkFBeUIsMENBQVM7QUFDL0U7QUFDQSxZQUFZLGlEQUFDO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVkseURBQUMsbUJBQW1CLDJDQUFVO0FBQzFDLFNBQVMsNENBQVc7QUFDcEIsY0FBYyx5REFBRTtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQjtBQUNsQixxQkFBcUIsc0JBQXNCO0FBQzNDLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQUUsS0FBSywwQ0FBUztBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQixZQUFZLHlEQUFFLFVBQVUsMkNBQVUsc0JBQXNCLDBDQUFTLDhCQUE4Qix5REFBRTtBQUNqRztBQUNBLEdBQUcsSUFBSSx5REFBRTtBQUNUO0FBQ0EsR0FBRyx3Q0FBd0MsMkNBQVU7QUFDckQ7QUFDQSxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQixxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQjtBQUNsQixZQUFZLHlEQUFDLGNBQWMsMENBQVMsT0FBTyx5REFBRSxhQUFhLHVCQUF1QjtBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWSx5REFBQyxtQ0FBbUMsMENBQVMsT0FBTyx5REFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVU7QUFDM0IsSUFBSSx5REFBRTtBQUNOO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQixNQUFNLHlEQUFFO0FBQ1IsR0FBRztBQUNIO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsWUFBWSx5REFBQyxPQUFPLG1GQUFtRixFQUFFLDBDQUFTO0FBQ2xILFVBQVUseURBQUU7QUFDWjtBQUNBLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0EsR0FBRztBQUNILFdBQVcsYUFBYSwwQ0FBUztBQUNqQyxVQUFVLHFEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsWUFBWSx5REFBQyxPQUFPLG1GQUFtRixFQUFFLDBDQUFTO0FBQ2xILFVBQVUseURBQUU7QUFDWjtBQUNBLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0EsR0FBRztBQUNILFdBQVcsYUFBYSwwQ0FBUztBQUNqQyxVQUFVLHFEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVkseUNBQVEsWUFBWSx5Q0FBUTtBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUcsTUFBTSw4Q0FBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFXO0FBQ2I7QUFDQSx1REFBdUQsYUFBYSx3Q0FBd0MsYUFBYSx1Q0FBdUMsYUFBYTtBQUM3SztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLFVBQVUsd0JBQXdCLEVBQUUseURBQUUsYUFBYSxlQUFlLEVBQUUsMENBQVMsT0FBTyx5REFBRTtBQUN0RixXQUFXLGFBQWEsMENBQVMsT0FBTyxxREFBQztBQUN6QztBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0I7QUFDeEIsaUJBQWlCLDJDQUFVO0FBQzNCLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQLHNDQUFzQyw0QkFBNEIsc0JBQXNCLEVBQUUsR0FBRyxhQUFhO0FBQzFHO0FBQ0EsUUFBUSxxREFBQztBQUNULGlFQUFpRSxTQUFTLElBQUksYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBRSxPQUFPLHNDQUFzQyxFQUFFLDBDQUFTO0FBQ3RFLFVBQVUseURBQUU7QUFDWixLQUFLLHlEQUFFO0FBQ1A7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLHlEQUFFLFFBQVEsMENBQVMsMkhBQTJILHlDQUFRLFFBQVEsa0VBQWtFLEVBQUUsMENBQVM7QUFDdlAsY0FBYyx5REFBRSxrQkFBa0IseURBQUU7QUFDcEM7QUFDQTtBQUNBLEVBQUUsNENBQVc7QUFDYjtBQUNBLEdBQUcsV0FBVyw0Q0FBVztBQUN6QixxQkFBcUIscURBQUM7QUFDdEIsR0FBRztBQUNILFlBQVksMENBQVMsT0FBTyxxREFBQyxNQUFNLGNBQWMsZ0JBQWdCLDhDQUFhO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlEQUFDO0FBQ0gsRUFBRSxpREFBQztBQUNILEVBQUUsaURBQUM7QUFDSCxFQUFFLGlEQUFDO0FBQ0gsRUFBRSxpREFBQztBQUNILFNBQVM7QUFDVCxZQUFZLHlEQUFDLG1CQUFtQiwyQ0FBVSxlQUFlLDJDQUFVLFVBQVUsMENBQVMsb0JBQW9CLHlEQUFFO0FBQzVHLFNBQVMsNENBQVc7QUFDcEIsY0FBYyx5REFBRTtBQUNoQjtBQUNBO0FBQ0EsS0FBSyxlQUFlLHFDQUFxQztBQUN6RCxNQUFNLHFEQUFDO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwQ0FBUztBQUNmLFFBQVEseURBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQSxVQUFVLHFEQUFDO0FBQ1gsbUJBQW1CLEdBQUcsOEJBQThCLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5REFBRTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVLENBQUMseURBQUUsUUFBUSxtQkFBbUIsRUFBRSwwQ0FBUyxPQUFPLHlEQUFFO0FBQzdFLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixpREFBQztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUM7QUFDYixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0EsWUFBWSx5REFBQyw4Q0FBOEMsMENBQVM7QUFDcEUsZ0JBQWdCLDJEQUFDO0FBQ2pCO0FBQ0EsU0FBUywwQ0FBUztBQUNsQixVQUFVLHlEQUFFO0FBQ1o7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUIsMkNBQVU7QUFDM0IsSUFBSSx5REFBRTtBQUNOLFNBQVMsOENBQWE7QUFDdEIsZ0JBQWdCLHVCQUF1QjtBQUN2QyxHQUFHLFdBQVcsOENBQWE7QUFDM0IsZ0JBQWdCLHVCQUF1QjtBQUN2QyxHQUFHLFdBQVcsOENBQWE7QUFDM0IsZ0JBQWdCLHdCQUF3QjtBQUN4QyxHQUFHLFdBQVcsOENBQWE7QUFDM0IsZ0JBQWdCLHdCQUF3QjtBQUN4QyxHQUFHLFdBQVcsOENBQWE7QUFDM0IsZ0JBQWdCLG1CQUFtQjtBQUNuQyxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQixJQUFJLHlEQUFFO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsWUFBWSx5REFBQyxTQUFTLHlEQUFDLGNBQWMsMENBQVMsT0FBTywwREFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RCxZQUFZLDBEQUFFLHdDQUF3QywyQ0FBVTtBQUNoRSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixFQUFFLG1FQUFFO0FBQzFDO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx5QkFBeUIsaURBQUMsa0ZBQWtGLGFBQWEsV0FBVywyQ0FBVTtBQUM5STtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCLEVBQUUsbUVBQUU7QUFDMUM7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx5QkFBeUIsaURBQUMsa0ZBQWtGLGFBQWEsTUFBTSx5Q0FBUSwwQkFBMEIseUNBQVEseUJBQXlCLHlDQUFRLGNBQWMsMkNBQVUsVUFBVSw4Q0FBYTtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSxtRUFBRTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFlBQVkseURBQUUsYUFBYSwyQkFBMkIsT0FBTywwQ0FBUyxnRUFBZ0UsMENBQVM7QUFDL0k7QUFDQSxhQUFhLDBEQUFFLE1BQU0sWUFBWTtBQUNqQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUFTO0FBQ3JCO0FBQ0E7QUFDQSwyRUFBMkUsMERBQUU7QUFDN0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLFdBQVcsMkNBQVU7QUFDaEQ7QUFDQTtBQUNBLGFBQWEsMERBQUU7QUFDZjtBQUNBO0FBQ0EscUJBQXFCLDBEQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0EsY0FBYywwREFBRTtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFFBQVEseURBQUUsWUFBWTtBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQixZQUFZLHlEQUFFLGdDQUFnQywwQ0FBUztBQUN2RDtBQUNBLGNBQWMsMERBQUUsTUFBTSwwREFBRTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQixZQUFZLHlEQUFDLDBCQUEwQiwyQ0FBVTtBQUNqRCxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjLDBEQUFFO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQUM7QUFDWjtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFFLFlBQVksc0RBQUM7QUFDckM7QUFDQSxzQkFBc0IsMkRBQUUsdUJBQXVCLHNEQUFDO0FBQ2hEO0FBQ0EsS0FBSyxpREFBQyxvQkFBb0IsaURBQUM7QUFDM0I7QUFDQTtBQUNBLEtBQUssaURBQUMsb0JBQW9CLGlEQUFDO0FBQzNCO0FBQ0Esb0NBQW9DLGlEQUFDLGtEQUFrRCxpREFBQyxvREFBb0QsaURBQUMsOENBQThDLGlEQUFDLG1CQUFtQixjQUFjLHFCQUFxQixnQkFBZ0IsT0FBTyxnQkFBZ0IsT0FBTywwQ0FBUyxhQUFhLDJEQUFDLHVDQUF1QywyREFBQztBQUMvVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUMsb0JBQW9CLDBDQUFTLE9BQU8sMERBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQyw2Q0FBNkMsMkRBQUMsbUJBQW1CLDBDQUFTLE9BQU8sMERBQUU7QUFDaEcsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLHlDQUF5QyxTQUFTLElBQUksaUJBQWlCLEtBQUssc0RBQUUsa0JBQWtCLG1DQUFtQztBQUM3SSxTQUFTLDBDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzREFBQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBRSxVQUFVLDhDQUFFLFdBQVcsaURBQUUsYUFBYSxrREFBRTtBQUN0RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSw2Q0FBRSxVQUFVLGtEQUFFO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxhQUFhLHFEQUFDO0FBQ25CLGtGQUFrRixHQUFHLE9BQU8sR0FBRztBQUMvRjtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFFO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksNkNBQUUsVUFBVSxrREFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssYUFBYSxxREFBQztBQUNuQix5R0FBeUcsR0FBRyxPQUFPLEdBQUc7QUFDdEg7QUFDQSxHQUFHLFdBQVcsa0RBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQTBEO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBLFNBQVMsa0RBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBNkQ7QUFDMUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLDhCQUE4QixVQUFVO0FBQ3JFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZKQUE2SjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwyQ0FBVTtBQUMzQjtBQUNBLGNBQWMsMkNBQVU7QUFDeEI7QUFDQSxTQUFTLHlDQUFRLG9CQUFvQix5Q0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsOENBQWE7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFhO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyw4Q0FBYTtBQUNqRDtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsOENBQWE7QUFDMUM7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLDhDQUFhO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQVE7QUFDcEIsRUFBRSw0Q0FBVztBQUNiO0FBQ0EsR0FBRztBQUNILFlBQVksOENBQWE7QUFDekI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFhO0FBQ3RCO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFhO0FBQ3RCO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVksMERBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsMENBQVMsNENBQTRDLFNBQVMsT0FBTywwQ0FBUztBQUMzRixzQkFBc0IsMkRBQUUsWUFBWSxzREFBQztBQUNyQyx1QkFBdUIsMENBQVM7QUFDaEMsc0JBQXNCLDJEQUFFLHVCQUF1QixzREFBQztBQUNoRCxzQ0FBc0MsMkNBQVUsR0FBRztBQUNuRCxFQUFFLDRDQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBQztBQUNqQixZQUFZLDREQUFDO0FBQ2I7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLGlEQUFDLGdCQUFnQixpREFBQztBQUNsQztBQUNBO0FBQ0EsR0FBRyxXQUFXLGlEQUFDLGdCQUFnQixpREFBQztBQUNoQztBQUNBO0FBQ0EsR0FBRyxPQUFPLDBDQUFTO0FBQ25CLHFDQUFxQyxpREFBQyw4Q0FBOEMsaURBQUM7QUFDckY7QUFDQTtBQUNBLEVBQUUsNENBQVc7QUFDYjtBQUNBLEdBQUc7QUFDSCxZQUFZLDBDQUFTO0FBQ3JCLHFDQUFxQyxpREFBQyxrREFBa0QsaURBQUM7QUFDekY7QUFDQTtBQUNBLEVBQUUsNENBQVc7QUFDYjtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsMkNBQVU7QUFDM0IsRUFBRSw0Q0FBVztBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBQztBQUNqQixZQUFZLHFEQUFDO0FBQ2I7QUFDQSxHQUFHLFFBQVEsNENBQVc7QUFDdEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLDJDQUFVO0FBQzNCLEVBQUUsNENBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDO0FBQ2pCLFlBQVkscURBQUM7QUFDYjtBQUNBLEdBQUcsV0FBVyw0Q0FBVztBQUN6QixVQUFVLDJEQUFDO0FBQ1gsR0FBRztBQUNILGlCQUFpQiwyQ0FBVTtBQUMzQixpREFBaUQsaURBQUM7QUFDbEQ7QUFDQSxFQUFFLDRDQUFXO0FBQ2I7QUFDQSwrQ0FBK0MsaURBQUM7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQUM7QUFDUDtBQUNBO0FBQ0EsTUFBTSw0REFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQUM7QUFDVDtBQUNBO0FBQ0EsUUFBUSw0REFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDBDQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLGVBQWUsMENBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFDLGdGQUFnRixzREFBQyx1QkFBdUIsc0RBQUM7QUFDM0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQVc7QUFDYjtBQUNBLEdBQUcsV0FBVyw0Q0FBVztBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsNENBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDBDQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5QkFBeUIsNEVBQTRFLGdCQUFnQiw4Q0FBYTtBQUNySTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyw4Q0FBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLDBDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUxBQXFMO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFRO0FBQ3BCLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxHQUFHLFFBQVEsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1FQUFFLE1BQU0seUNBQVE7QUFDekM7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyw4Q0FBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckIsVUFBVSxvREFBb0QsU0FBUyx5REFBRSxRQUFRLDBDQUFTO0FBQzFGLHdCQUF3QixnREFBRTtBQUMxQjtBQUNBLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBLFNBQVMsOENBQWE7QUFDdEI7QUFDQSx5QkFBeUIsMkRBQUMsb0JBQW9CLDJEQUFDLHVCQUF1QiwyREFBQztBQUN2RSxLQUFLO0FBQ0w7QUFDQSxjQUFjLDJDQUFVO0FBQ3hCLEVBQUUsNENBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQUM7QUFDakIsWUFBWSxxREFBQztBQUNiO0FBQ0EsR0FBRyxRQUFRLDRDQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBQztBQUNqQixZQUFZLHFEQUFDO0FBQ2I7QUFDQSxHQUFHLFdBQVcsNENBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDO0FBQ2pCLFlBQVkscURBQUM7QUFDYjtBQUNBLEdBQUc7QUFDSCxVQUFVLHNCQUFzQixPQUFPLFNBQVMsNkJBQTZCLGlEQUFDLHFCQUFxQiwwQ0FBUztBQUM1RyxZQUFZLGlEQUFDO0FBQ2I7QUFDQTtBQUNBLEdBQUcscUVBQXFFLGlEQUFDLHlCQUF5QiwwQ0FBUztBQUMzRyxZQUFZLGlEQUFDO0FBQ2I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVksMENBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUM7QUFDWjtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFDO0FBQzVCLGVBQWUsMkRBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUM7QUFDWixXQUFXLDJEQUFDO0FBQ1osV0FBVywyREFBQztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUM7QUFDWjtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFDO0FBQzVCLGVBQWUsMkRBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBVztBQUNiO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWE7QUFDdEI7QUFDQSxNQUFNLDJEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBYTtBQUN0QixtQkFBbUIsMkRBQUM7QUFDcEI7QUFDQTtBQUNBLElBQUksMENBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFhO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYywrQkFBK0IsMEJBQTBCO0FBQzdGO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLG1DQUFtQyxrRUFBRTtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFhO0FBQ3RCO0FBQ0EsR0FBRyxZQUFZLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUssMENBQVM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQVM7QUFDckIsR0FBRyxXQUFXLDhDQUFhLHNDQUFzQywwQ0FBUztBQUMxRSxFQUFFLDRDQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxVQUFVLFVBQVUsRUFBRSwwREFBRSxTQUFTLDBDQUFTO0FBQzFDO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUyxPQUFPLDBDQUFTLFVBQVUsU0FBUyx3QkFBd0IsMENBQVM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsMENBQVMsNERBQTRELHlDQUFRLGlDQUFpQywwQ0FBUztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxZQUFZLHlDQUFRO0FBQ3ZCLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBLEdBQUcsUUFBUSwwQ0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBK0RFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZla2l0L2NvbXBvbmVudHMtcmVhY3QvZGlzdC9ob29rcy15VS1zcnJJTy5tanM/NTNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVmIGFzIGFlLCB1c2VNZW1vIGFzIE5lLCB1c2VDYWxsYmFjayBhcyBlZSwgdXNlRWZmZWN0IGFzIF9lIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1IGFzIFUsIHIgYXMgRmUsIGEgYXMgUGUsIGIgYXMgeGUsIGMgYXMgUSwgZCBhcyBVZSwgZSBhcyBIZSwgZiBhcyBvZSwgZyBhcyBWZSwgaCBhcyBxZSwgaSBhcyB1ZSwgaiBhcyBCZSwgayBhcyBqZSwgbSBhcyB6ZSwgRyBhcyBXZSwgbiBhcyBHZSwgbyBhcyBKZSwgcCBhcyBsZSwgcSBhcyAkZSwgdCBhcyBRZSwgdiBhcyBMZSwgdyBhcyBkZSwgeCBhcyBBZSwgeSBhcyBLZSwgbCBhcyBWLCB6IGFzIFllLCBBIGFzIFhlLCBCIGFzIGZlLCBDIGFzIFplLCBEIGFzIGV0LCBFIGFzIHR0LCBGIGFzIG50LCBIIGFzIHN0LCBJIGFzIHJ0LCBKIGFzIG90LCBLIGFzIGF0LCBNIGFzIHZlLCBOIGFzIGN0LCBPIGFzIGl0LCBQIGFzIHV0LCBRIGFzIGx0LCBTIGFzIGR0LCBUIGFzIGZ0LCBVIGFzIG10LCBWIGFzIHB0LCBXIGFzIFJlLCBYIGFzIGh0LCBZIGFzIGJ0LCBaIGFzIGd0LCBfIGFzIHZ0LCAkIGFzIFN0LCBhMCBhcyB5dCwgYTEgYXMgQ3QsIGEyIGFzIE10LCBhMyBhcyBUdCwgYTQgYXMgRXQsIGE1IGFzIGt0LCBhNiBhcyB3dCwgYTcgYXMgaWUsIGE4IGFzIFcsIGE5IGFzIFB0LCBhYSBhcyBMdCwgYWIgYXMgQXQsIGFjIGFzIFJ0LCBhZCBhcyBEdCB9IGZyb20gXCIuL2NvbnRleHRzLUNzTzFRWjNyLm1qc1wiO1xuaW1wb3J0IHsgbSBhcyBHIH0gZnJvbSBcIi4vcm9vbS1CYjZ1THhTNS5tanNcIjtcbmltcG9ydCB7IENvbm5lY3Rpb25TdGF0ZSBhcyBJLCBMb2NhbFRyYWNrUHVibGljYXRpb24gYXMgT3QsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayBhcyBJdCwgUm9vbSBhcyBEZSwgVHJhY2sgYXMgRSwgY3JlYXRlQXVkaW9BbmFseXNlciBhcyBtZSwgUGFydGljaXBhbnRLaW5kIGFzIHNlLCBNdXRleCBhcyBOdCwgUGFydGljaXBhbnRFdmVudCBhcyBYLCBSb29tRXZlbnQgYXMgSCwgZGVjb2RlVG9rZW5QYXlsb2FkIGFzIF90LCBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZSBhcyBGdCB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xuY29uc3QgeHQgPSAoZSkgPT4ge1xuICBjb25zdCBuID0gcy51c2VSZWYoZSk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbi5jdXJyZW50ID0gZTtcbiAgfSksIG47XG59O1xuZnVuY3Rpb24gVXQoZSwgbikge1xuICBjb25zdCB0ID0gVnQoKSwgciA9IHh0KG4pO1xuICByZXR1cm4gcy51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvID0gITE7XG4gICAgY29uc3QgYyA9IGUuY3VycmVudDtcbiAgICBpZiAoIWMpIHJldHVybjtcbiAgICBmdW5jdGlvbiBhKGksIHUpIHtcbiAgICAgIG8gfHwgci5jdXJyZW50KGksIHUpO1xuICAgIH1cbiAgICByZXR1cm4gdCA9PSBudWxsIHx8IHQuc3Vic2NyaWJlKGMsIGEpLCAoKSA9PiB7XG4gICAgICBvID0gITAsIHQgPT0gbnVsbCB8fCB0LnVuc3Vic2NyaWJlKGMsIGEpO1xuICAgIH07XG4gIH0sIFtlLmN1cnJlbnQsIHQsIHJdKSwgdCA9PSBudWxsID8gdm9pZCAwIDogdC5vYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIEh0KCkge1xuICBsZXQgZSA9ICExLCBuID0gW107XG4gIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAodHlwZW9mIHdpbmRvdyA+IFwidVwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IG5ldyBSZXNpemVPYnNlcnZlcigobywgYykgPT4ge1xuICAgIG4gPSBuLmNvbmNhdChvKSwgZSB8fCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhLmhhcyhuW2ldLnRhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICBhLmFkZChuW2ldLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IHUgPSB0LmdldChuW2ldLnRhcmdldCk7XG4gICAgICAgIHUgPT0gbnVsbCB8fCB1LmZvckVhY2goKHApID0+IHAobltpXSwgYykpO1xuICAgICAgfVxuICAgICAgbiA9IFtdLCBlID0gITE7XG4gICAgfSksIGUgPSAhMDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb2JzZXJ2ZXI6IHIsXG4gICAgc3Vic2NyaWJlKG8sIGMpIHtcbiAgICAgIHIub2JzZXJ2ZShvKTtcbiAgICAgIGNvbnN0IGEgPSB0LmdldChvKSA/PyBbXTtcbiAgICAgIGEucHVzaChjKSwgdC5zZXQobywgYSk7XG4gICAgfSxcbiAgICB1bnN1YnNjcmliZShvLCBjKSB7XG4gICAgICBjb25zdCBhID0gdC5nZXQobykgPz8gW107XG4gICAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgci51bm9ic2VydmUobyksIHQuZGVsZXRlKG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gYS5pbmRleE9mKGMpO1xuICAgICAgaSAhPT0gLTEgJiYgYS5zcGxpY2UoaSwgMSksIHQuc2V0KG8sIGEpO1xuICAgIH1cbiAgfTtcbn1cbmxldCBjZTtcbmNvbnN0IFZ0ID0gKCkgPT4gY2UgfHwgKGNlID0gSHQoKSksIHF0ID0gKGUpID0+IHtcbiAgY29uc3QgW24sIHRdID0gcy51c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gIHMudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCB7IHdpZHRoOiBvLCBoZWlnaHQ6IGMgfSA9IGUuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHQoeyB3aWR0aDogbywgaGVpZ2h0OiBjIH0pO1xuICAgIH1cbiAgfSwgW2UuY3VycmVudF0pO1xuICBjb25zdCByID0gcy51c2VDYWxsYmFjayhcbiAgICAobykgPT4gdChvLmNvbnRlbnRSZWN0KSxcbiAgICBbXVxuICApO1xuICByZXR1cm4gVXQoZSwgciksIG47XG59O1xuZnVuY3Rpb24gRChlLCBuLCB0ID0gITApIHtcbiAgY29uc3QgW3IsIG9dID0gcy51c2VTdGF0ZShuKTtcbiAgcmV0dXJuIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodCAmJiBvKG4pLCB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgfHwgIWUpIHJldHVybjtcbiAgICBjb25zdCBjID0gZS5zdWJzY3JpYmUobyk7XG4gICAgcmV0dXJuICgpID0+IGMudW5zdWJzY3JpYmUoKTtcbiAgfSwgW2UsIHRdKSwgcjtcbn1cbmZ1bmN0aW9uIGtuKGUpIHtcbiAgY29uc3QgbiA9IChjKSA9PiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cubWF0Y2hNZWRpYShjKS5tYXRjaGVzIDogITEsIFt0LCByXSA9IHMudXNlU3RhdGUobihlKSk7XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgcihuKGUpKTtcbiAgfVxuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGMgPSB3aW5kb3cubWF0Y2hNZWRpYShlKTtcbiAgICByZXR1cm4gbygpLCBjLmFkZExpc3RlbmVyID8gYy5hZGRMaXN0ZW5lcihvKSA6IGMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvKSwgKCkgPT4ge1xuICAgICAgYy5yZW1vdmVMaXN0ZW5lciA/IGMucmVtb3ZlTGlzdGVuZXIobykgOiBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgbyk7XG4gICAgfTtcbiAgfSwgW2VdKSwgdDtcbn1cbmZ1bmN0aW9uIHduKGUpIHtcbiAgY29uc3QgbiA9IFUoZSksIHQgPSBzLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBuLnN0YXJ0QXVkaW8oKTtcbiAgfSwgW25dKSwgciA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBGZShuKSxcbiAgICBbbl1cbiAgKSwgeyBjYW5QbGF5QXVkaW86IG8gfSA9IEQociwge1xuICAgIGNhblBsYXlBdWRpbzogbi5jYW5QbGF5YmFja0F1ZGlvXG4gIH0pO1xuICByZXR1cm4geyBjYW5QbGF5QXVkaW86IG8sIHN0YXJ0QXVkaW86IHQgfTtcbn1cbmZ1bmN0aW9uIFBuKGUpIHtcbiAgY29uc3QgeyBzdGF0ZTogbiwgZGlzcGF0Y2g6IHQgfSA9IFBlKCkucGluO1xuICByZXR1cm4geyBidXR0b25Qcm9wczogcy51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogbyB9ID0geGUoKTtcbiAgICByZXR1cm4gRyhlLCB7XG4gICAgICBjbGFzc05hbWU6IG8sXG4gICAgICBkaXNhYmxlZDogIShuICE9IG51bGwgJiYgbi5sZW5ndGgpLFxuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICB0ICYmIHQoeyBtc2c6IFwiY2xlYXJfcGluXCIgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlLCB0LCBuXSkgfTtcbn1cbmZ1bmN0aW9uIExuKGUgPSB7fSkge1xuICBjb25zdCBuID0gUShlLnBhcnRpY2lwYW50KSwgeyBjbGFzc05hbWU6IHQsIGNvbm5lY3Rpb25RdWFsaXR5T2JzZXJ2ZXI6IHIgfSA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBVZShuKSxcbiAgICBbbl1cbiAgKSwgbyA9IEQociwgbi5jb25uZWN0aW9uUXVhbGl0eSk7XG4gIHJldHVybiB7IGNsYXNzTmFtZTogdCwgcXVhbGl0eTogbyB9O1xufVxuZnVuY3Rpb24gdGUoZSkge1xuICBjb25zdCBuID0gVShlKSwgdCA9IHMudXNlTWVtbygoKSA9PiBIZShuKSwgW25dKTtcbiAgcmV0dXJuIEQodCwgbi5zdGF0ZSk7XG59XG5mdW5jdGlvbiBBbihlLCBuKSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogbiwgciA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogdm9pZCAwLCBvID0gb2UoKSwgeyBzZW5kOiBjLCBtZXNzYWdlT2JzZXJ2YWJsZTogYSwgaXNTZW5kaW5nT2JzZXJ2YWJsZTogaSB9ID0gcy51c2VNZW1vKFxuICAgICgpID0+IFZlKG8sIHIsIHQpLFxuICAgIFtvLCByLCB0XVxuICApLCB1ID0gRChhLCB2b2lkIDApLCBwID0gRChpLCAhMSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogdSxcbiAgICBzZW5kOiBjLFxuICAgIGlzU2VuZGluZzogcFxuICB9O1xufVxuZnVuY3Rpb24gUm4oZSkge1xuICBjb25zdCBuID0gb2UoKSwgdCA9IHRlKG4pO1xuICByZXR1cm4geyBidXR0b25Qcm9wczogcy51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogbywgZGlzY29ubmVjdDogYyB9ID0gcWUobik7XG4gICAgcmV0dXJuIEcoZSwge1xuICAgICAgY2xhc3NOYW1lOiBvLFxuICAgICAgb25DbGljazogKCkgPT4gYyhlLnN0b3BUcmFja3MgPz8gITApLFxuICAgICAgZGlzYWJsZWQ6IHQgPT09IEkuRGlzY29ubmVjdGVkXG4gICAgfSk7XG4gIH0sIFtuLCBlLCB0XSkgfTtcbn1cbmZ1bmN0aW9uIEJ0KGUpIHtcbiAgaWYgKGUucHVibGljYXRpb24gaW5zdGFuY2VvZiBPdCkge1xuICAgIGNvbnN0IG4gPSBlLnB1YmxpY2F0aW9uLnRyYWNrO1xuICAgIGlmIChuKSB7XG4gICAgICBjb25zdCB7IGZhY2luZ01vZGU6IHQgfSA9IEl0KG4pO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gRG4oeyB0cmFja1JlZjogZSwgcHJvcHM6IG4gfSkge1xuICBjb25zdCB0ID0gdWUoZSksIHIgPSBCZSgpLCB7IGNsYXNzTmFtZTogbyB9ID0gcy51c2VNZW1vKCgpID0+IGplKCksIFtdKSwgYyA9IHMudXNlTWVtbygoKSA9PiB6ZSh0LCByID09IG51bGwgPyB2b2lkIDAgOiByLnBpbi5zdGF0ZSksIFt0LCByID09IG51bGwgPyB2b2lkIDAgOiByLnBpbi5zdGF0ZV0pO1xuICByZXR1cm4geyBtZXJnZWRQcm9wczogcy51c2VNZW1vKFxuICAgICgpID0+IEcobiwge1xuICAgICAgY2xhc3NOYW1lOiBvLFxuICAgICAgb25DbGljazogKGkpID0+IHtcbiAgICAgICAgdmFyIHUsIHAsIGgsIGQsIGw7XG4gICAgICAgICh1ID0gbi5vbkNsaWNrKSA9PSBudWxsIHx8IHUuY2FsbChuLCBpKSwgYyA/IChoID0gciA9PSBudWxsID8gdm9pZCAwIDogKHAgPSByLnBpbikuZGlzcGF0Y2gpID09IG51bGwgfHwgaC5jYWxsKHAsIHtcbiAgICAgICAgICBtc2c6IFwiY2xlYXJfcGluXCJcbiAgICAgICAgfSkgOiAobCA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IChkID0gci5waW4pLmRpc3BhdGNoKSA9PSBudWxsIHx8IGwuY2FsbChkLCB7XG4gICAgICAgICAgbXNnOiBcInNldF9waW5cIixcbiAgICAgICAgICB0cmFja1JlZmVyZW5jZTogdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBbbiwgbywgdCwgYywgciA9PSBudWxsID8gdm9pZCAwIDogci5waW5dXG4gICksIGluRm9jdXM6IGMgfTtcbn1cbmZ1bmN0aW9uIE9uKGUsIG4sIHQgPSB7fSkge1xuICBjb25zdCByID0gdC5ncmlkTGF5b3V0cyA/PyBXZSwgeyB3aWR0aDogbywgaGVpZ2h0OiBjIH0gPSBxdChlKSwgYSA9IEdlKHIsIG4sIG8sIGMpO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUuY3VycmVudCAmJiBhICYmIChlLmN1cnJlbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWxrLWNvbC1jb3VudFwiLCBhID09IG51bGwgPyB2b2lkIDAgOiBhLmNvbHVtbnMudG9TdHJpbmcoKSksIGUuY3VycmVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbGstcm93LWNvdW50XCIsIGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEucm93cy50b1N0cmluZygpKSk7XG4gIH0sIFtlLCBhXSksIHtcbiAgICBsYXlvdXQ6IGEsXG4gICAgY29udGFpbmVyV2lkdGg6IG8sXG4gICAgY29udGFpbmVySGVpZ2h0OiBjXG4gIH07XG59XG5mdW5jdGlvbiBTZShlLCBuID0ge30pIHtcbiAgdmFyIGksIHU7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gbi5wYXJ0aWNpcGFudCA6IGUucGFydGljaXBhbnQsIHIgPSBRKHQpLCBvID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHsgcGFydGljaXBhbnQ6IHIsIHNvdXJjZTogZSB9IDogZSwgW2MsIGFdID0gcy51c2VTdGF0ZShcbiAgICAhISgoaSA9IG8ucHVibGljYXRpb24pICE9IG51bGwgJiYgaS5pc011dGVkIHx8ICh1ID0gci5nZXRUcmFja1B1YmxpY2F0aW9uKG8uc291cmNlKSkgIT0gbnVsbCAmJiB1LmlzTXV0ZWQpXG4gICk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcCA9IEplKG8pLnN1YnNjcmliZShhKTtcbiAgICByZXR1cm4gKCkgPT4gcC51bnN1YnNjcmliZSgpO1xuICB9LCBbbGUobyldKSwgYztcbn1cbmZ1bmN0aW9uIGp0KGUpIHtcbiAgY29uc3QgbiA9IFEoZSksIHQgPSBzLnVzZU1lbW8oKCkgPT4gJGUobiksIFtuXSk7XG4gIHJldHVybiBEKHQsIG4uaXNTcGVha2luZyk7XG59XG5mdW5jdGlvbiBPZShlID0ge30pIHtcbiAgY29uc3QgbiA9IFUoZS5yb29tKSwgW3QsIHJdID0gcy51c2VTdGF0ZShuLmxvY2FsUGFydGljaXBhbnQpLCBbbywgY10gPSBzLnVzZVN0YXRlKFxuICAgIHQuaXNNaWNyb3Bob25lRW5hYmxlZFxuICApLCBbYSwgaV0gPSBzLnVzZVN0YXRlKHQuaXNDYW1lcmFFbmFibGVkKSwgW3UsIHBdID0gcy51c2VTdGF0ZShcbiAgICB0LmlzU2NyZWVuU2hhcmVFbmFibGVkXG4gICksIFtoLCBkXSA9IHMudXNlU3RhdGUoXG4gICAgdC5sYXN0TWljcm9waG9uZUVycm9yXG4gICksIFtsLCB2XSA9IHMudXNlU3RhdGUodC5sYXN0Q2FtZXJhRXJyb3IpLCBbQywga10gPSBzLnVzZVN0YXRlKFxuICAgIHZvaWQgMFxuICApLCBbQSwgd10gPSBzLnVzZVN0YXRlKHZvaWQgMCksIE8gPSAoUikgPT4ge1xuICAgIGkoUi5pc0NhbWVyYUVuYWJsZWQpLCBjKFIuaXNNaWNyb3Bob25lRW5hYmxlZCksIHAoUi5pc1NjcmVlblNoYXJlRW5hYmxlZCksIHcoUi5jYW1lcmFUcmFjayksIGsoUi5taWNyb3Bob25lVHJhY2spLCBkKFIucGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvciksIHYoUi5wYXJ0aWNpcGFudC5sYXN0Q2FtZXJhRXJyb3IpLCByKFIucGFydGljaXBhbnQpO1xuICB9O1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IFIgPSBRZShuLmxvY2FsUGFydGljaXBhbnQpLnN1YnNjcmliZShPKTtcbiAgICByZXR1cm4gKCkgPT4gUi51bnN1YnNjcmliZSgpO1xuICB9LCBbbl0pLCB7XG4gICAgaXNNaWNyb3Bob25lRW5hYmxlZDogbyxcbiAgICBpc1NjcmVlblNoYXJlRW5hYmxlZDogdSxcbiAgICBpc0NhbWVyYUVuYWJsZWQ6IGEsXG4gICAgbWljcm9waG9uZVRyYWNrOiBDLFxuICAgIGNhbWVyYVRyYWNrOiBBLFxuICAgIGxhc3RNaWNyb3Bob25lRXJyb3I6IGgsXG4gICAgbGFzdENhbWVyYUVycm9yOiBsLFxuICAgIGxvY2FsUGFydGljaXBhbnQ6IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIEluKCkge1xuICBjb25zdCBlID0gb2UoKSwgbiA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBMZShlLmxvY2FsUGFydGljaXBhbnQpLFxuICAgIFtlXVxuICApO1xuICByZXR1cm4gRChuLCBlLmxvY2FsUGFydGljaXBhbnQucGVybWlzc2lvbnMpO1xufVxuZnVuY3Rpb24gTm4oe1xuICBraW5kOiBlLFxuICByb29tOiBuLFxuICB0cmFjazogdCxcbiAgcmVxdWVzdFBlcm1pc3Npb25zOiByLFxuICBvbkVycm9yOiBvXG59KSB7XG4gIGNvbnN0IGMgPSBkZSgpLCBhID0gcy51c2VNZW1vKCgpID0+IG4gPz8gYyA/PyBuZXcgRGUoKSwgW24sIGNdKSwgaSA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBBZShlLCBvLCByKSxcbiAgICBbZSwgciwgb11cbiAgKSwgdSA9IEQoaSwgW10pLCBbcCwgaF0gPSBzLnVzZVN0YXRlKFxuICAgIChhID09IG51bGwgPyB2b2lkIDAgOiBhLmdldEFjdGl2ZURldmljZShlKSkgPz8gXCJkZWZhdWx0XCJcbiAgKSwgeyBjbGFzc05hbWU6IGQsIGFjdGl2ZURldmljZU9ic2VydmFibGU6IGwsIHNldEFjdGl2ZU1lZGlhRGV2aWNlOiB2IH0gPSBzLnVzZU1lbW8oXG4gICAgKCkgPT4gS2UoZSwgYSksXG4gICAgW2UsIGEsIHRdXG4gICk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgQyA9IGwuc3Vic2NyaWJlKChrKSA9PiB7XG4gICAgICBrICYmIChWLmluZm8oXCJzZXRDdXJyZW50RGV2aWNlSWRcIiwgayksIGgoaykpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBDID09IG51bGwgfHwgQy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtsXSksIHsgZGV2aWNlczogdSwgY2xhc3NOYW1lOiBkLCBhY3RpdmVEZXZpY2VJZDogcCwgc2V0QWN0aXZlTWVkaWFEZXZpY2U6IHYgfTtcbn1cbmZ1bmN0aW9uIF9uKHtcbiAga2luZDogZSxcbiAgb25FcnJvcjogblxufSkge1xuICBjb25zdCB0ID0gcy51c2VNZW1vKFxuICAgICgpID0+IEFlKGUsIG4pLFxuICAgIFtlLCBuXVxuICApO1xuICByZXR1cm4gRCh0LCBbXSk7XG59XG5mdW5jdGlvbiB6dChlLCBuLCB0ID0ge30pIHtcbiAgY29uc3QgciA9IHMudXNlUmVmKFtdKSwgbyA9IHMudXNlUmVmKC0xKSwgYyA9IG4gIT09IG8uY3VycmVudCwgYSA9IHR5cGVvZiB0LmN1c3RvbVNvcnRGdW5jdGlvbiA9PSBcImZ1bmN0aW9uXCIgPyB0LmN1c3RvbVNvcnRGdW5jdGlvbihlKSA6IFllKGUpO1xuICBsZXQgaSA9IFsuLi5hXTtcbiAgaWYgKGMgPT09ICExKVxuICAgIHRyeSB7XG4gICAgICBpID0gWGUoci5jdXJyZW50LCBhLCBuKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBWLmVycm9yKFwiRXJyb3Igd2hpbGUgcnVubmluZyB1cGRhdGVQYWdlcygpOiBcIiwgdSk7XG4gICAgfVxuICByZXR1cm4gYyA/IHIuY3VycmVudCA9IGEgOiByLmN1cnJlbnQgPSBpLCBvLmN1cnJlbnQgPSBuLCBpO1xufVxuZnVuY3Rpb24gRm4oZSwgbikge1xuICBjb25zdCBbdCwgcl0gPSBzLnVzZVN0YXRlKDEpLCBvID0gTWF0aC5tYXgoTWF0aC5jZWlsKG4ubGVuZ3RoIC8gZSksIDEpO1xuICB0ID4gbyAmJiByKG8pO1xuICBjb25zdCBjID0gdCAqIGUsIGEgPSBjIC0gZSwgaSA9IChkKSA9PiB7XG4gICAgcigobCkgPT4gZCA9PT0gXCJuZXh0XCIgPyBsID09PSBvID8gbCA6IGwgKyAxIDogbCA9PT0gMSA/IGwgOiBsIC0gMSk7XG4gIH0sIHUgPSAoZCkgPT4ge1xuICAgIGQgPiBvID8gcihvKSA6IGQgPCAxID8gcigxKSA6IHIoZCk7XG4gIH0sIGggPSB6dChuLCBlKS5zbGljZShhLCBjKTtcbiAgcmV0dXJuIHtcbiAgICB0b3RhbFBhZ2VDb3VudDogbyxcbiAgICBuZXh0UGFnZTogKCkgPT4gaShcIm5leHRcIiksXG4gICAgcHJldlBhZ2U6ICgpID0+IGkoXCJwcmV2aW91c1wiKSxcbiAgICBzZXRQYWdlOiB1LFxuICAgIGZpcnN0SXRlbUluZGV4OiBhLFxuICAgIGxhc3RJdGVtSW5kZXg6IGMsXG4gICAgdHJhY2tzOiBoLFxuICAgIGN1cnJlbnRQYWdlOiB0XG4gIH07XG59XG5mdW5jdGlvbiB4bihlID0ge30pIHtcbiAgbGV0IG4gPSBmZSgpO1xuICBlLnBhcnRpY2lwYW50ICYmIChuID0gZS5wYXJ0aWNpcGFudCk7XG4gIGNvbnN0IHQgPSBzLnVzZU1lbW8oKCkgPT4gWmUobiksIFtuXSksIHsgaWRlbnRpdHk6IHIsIG5hbWU6IG8sIG1ldGFkYXRhOiBjIH0gPSBEKHQsIHtcbiAgICBuYW1lOiBuID09IG51bGwgPyB2b2lkIDAgOiBuLm5hbWUsXG4gICAgaWRlbnRpdHk6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaWRlbnRpdHksXG4gICAgbWV0YWRhdGE6IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubWV0YWRhdGFcbiAgfSk7XG4gIHJldHVybiB7IGlkZW50aXR5OiByLCBuYW1lOiBvLCBtZXRhZGF0YTogYyB9O1xufVxuZnVuY3Rpb24gVW4oZSA9IHt9KSB7XG4gIGNvbnN0IG4gPSBRKGUucGFydGljaXBhbnQpLCB0ID0gcy51c2VNZW1vKCgpID0+IExlKG4pLCBbbl0pO1xuICByZXR1cm4gRCh0LCBuLnBlcm1pc3Npb25zKTtcbn1cbmZ1bmN0aW9uIEhuKHtcbiAgdHJhY2tSZWY6IGUsXG4gIG9uUGFydGljaXBhbnRDbGljazogbixcbiAgZGlzYWJsZVNwZWFraW5nSW5kaWNhdG9yOiB0LFxuICBodG1sUHJvcHM6IHJcbn0pIHtcbiAgY29uc3QgbyA9IHVlKGUpLCBjID0gcy51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogbCB9ID0gZXQoKTtcbiAgICByZXR1cm4gRyhyLCB7XG4gICAgICBjbGFzc05hbWU6IGwsXG4gICAgICBvbkNsaWNrOiAodikgPT4ge1xuICAgICAgICB2YXIgQztcbiAgICAgICAgaWYgKChDID0gci5vbkNsaWNrKSA9PSBudWxsIHx8IEMuY2FsbChyLCB2KSwgdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgayA9IG8ucHVibGljYXRpb24gPz8gby5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKG8uc291cmNlKTtcbiAgICAgICAgICBuKHsgcGFydGljaXBhbnQ6IG8ucGFydGljaXBhbnQsIHRyYWNrOiBrIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtcbiAgICByLFxuICAgIG4sXG4gICAgby5wdWJsaWNhdGlvbixcbiAgICBvLnNvdXJjZSxcbiAgICBvLnBhcnRpY2lwYW50XG4gIF0pLCBhID0gby5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKEUuU291cmNlLk1pY3JvcGhvbmUpLCBpID0gcy51c2VNZW1vKCgpID0+ICh7XG4gICAgcGFydGljaXBhbnQ6IG8ucGFydGljaXBhbnQsXG4gICAgc291cmNlOiBFLlNvdXJjZS5NaWNyb3Bob25lLFxuICAgIHB1YmxpY2F0aW9uOiBhXG4gIH0pLCBbYSwgby5wYXJ0aWNpcGFudF0pLCB1ID0gU2UobyksIHAgPSBTZShpKSwgaCA9IGp0KG8ucGFydGljaXBhbnQpLCBkID0gQnQobyk7XG4gIHJldHVybiB7XG4gICAgZWxlbWVudFByb3BzOiB7XG4gICAgICBcImRhdGEtbGstYXVkaW8tbXV0ZWRcIjogcCxcbiAgICAgIFwiZGF0YS1say12aWRlby1tdXRlZFwiOiB1LFxuICAgICAgXCJkYXRhLWxrLXNwZWFraW5nXCI6IHQgPT09ICEwID8gITEgOiBoLFxuICAgICAgXCJkYXRhLWxrLWxvY2FsLXBhcnRpY2lwYW50XCI6IG8ucGFydGljaXBhbnQuaXNMb2NhbCxcbiAgICAgIFwiZGF0YS1say1zb3VyY2VcIjogby5zb3VyY2UsXG4gICAgICBcImRhdGEtbGstZmFjaW5nLW1vZGVcIjogZCxcbiAgICAgIC4uLmNcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBwZShlID0ge30pIHtcbiAgY29uc3QgbiA9IFUoZS5yb29tKSwgW3QsIHJdID0gcy51c2VTdGF0ZShbXSk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbyA9IHR0KG4sIHtcbiAgICAgIGFkZGl0aW9uYWxSb29tRXZlbnRzOiBlLnVwZGF0ZU9ubHlPblxuICAgIH0pLnN1YnNjcmliZShyKTtcbiAgICByZXR1cm4gKCkgPT4gby51bnN1YnNjcmliZSgpO1xuICB9LCBbbiwgSlNPTi5zdHJpbmdpZnkoZS51cGRhdGVPbmx5T24pXSksIHQ7XG59XG5mdW5jdGlvbiBXdChlID0ge30pIHtcbiAgY29uc3QgbiA9IHBlKGUpLCB7IGxvY2FsUGFydGljaXBhbnQ6IHQgfSA9IE9lKGUpO1xuICByZXR1cm4gcy51c2VNZW1vKFxuICAgICgpID0+IFt0LCAuLi5uXSxcbiAgICBbdCwgbl1cbiAgKTtcbn1cbmZ1bmN0aW9uIFZuKGUpIHtcbiAgcmV0dXJuIGUgPSBudChlKSwgcy51c2VNZW1vKCgpID0+IChlID09IG51bGwgPyB2b2lkIDAgOiBlLnBpbi5zdGF0ZSkgIT09IHZvaWQgMCAmJiBlLnBpbi5zdGF0ZS5sZW5ndGggPj0gMSA/IGUucGluLnN0YXRlIDogW10sIFtlLnBpbi5zdGF0ZV0pO1xufVxuZnVuY3Rpb24gcW4oZSwgbiA9IHt9KSB7XG4gIGNvbnN0IHQgPSBvZSgpLCBbcl0gPSBzLnVzZVN0YXRlKG4udXBkYXRlT25seU9uKSwgbyA9IHMudXNlTWVtbygoKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gc3QodCwgZSwge1xuICAgIGFkZGl0aW9uYWxFdmVudHM6IHJcbiAgfSkgOiBydCh0LCBlLCB7XG4gICAgYWRkaXRpb25hbEV2ZW50czogclxuICB9KSwgW3QsIEpTT04uc3RyaW5naWZ5KGUpLCByXSksIFtjLCBhXSA9IHMudXNlU3RhdGUoe1xuICAgIHA6IHZvaWQgMFxuICB9KTtcbiAgcmV0dXJuIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpID0gby5zdWJzY3JpYmUoKHUpID0+IGEoeyBwOiB1IH0pKTtcbiAgICByZXR1cm4gKCkgPT4gaS51bnN1YnNjcmliZSgpO1xuICB9LCBbb10pLCBjLnA7XG59XG5mdW5jdGlvbiBCbihlID0ge30pIHtcbiAgY29uc3QgbiA9IFUoZS5yb29tKSwgdCA9IHMudXNlTWVtbygoKSA9PiBvdChuKSwgW25dKSwgeyBuYW1lOiByLCBtZXRhZGF0YTogbyB9ID0gRCh0LCB7XG4gICAgbmFtZTogbi5uYW1lLFxuICAgIG1ldGFkYXRhOiBuLm1ldGFkYXRhXG4gIH0pO1xuICByZXR1cm4geyBuYW1lOiByLCBtZXRhZGF0YTogbyB9O1xufVxuZnVuY3Rpb24gR3QoZSkge1xuICBjb25zdCBuID0gVShlID09IG51bGwgPyB2b2lkIDAgOiBlLnJvb20pLCB0ID0gcy51c2VNZW1vKCgpID0+IGF0KG4pLCBbbl0pO1xuICByZXR1cm4gRCh0LCBuLmFjdGl2ZVNwZWFrZXJzKTtcbn1cbmZ1bmN0aW9uIGpuKGUpIHtcbiAgY29uc3QgW24sIHRdID0gcy51c2VTdGF0ZShcbiAgICB2ZShlKVxuICApLCByID0gR3QoKTtcbiAgcmV0dXJuIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB0KHZlKGUpKTtcbiAgfSwgW3IsIGVdKSwgbjtcbn1cbmZ1bmN0aW9uIHpuKHsgcm9vbTogZSwgcHJvcHM6IG4gfSkge1xuICBjb25zdCB0ID0gVShlKSwgeyBjbGFzc05hbWU6IHIsIHJvb21BdWRpb1BsYXliYWNrQWxsb3dlZE9ic2VydmFibGU6IG8sIGhhbmRsZVN0YXJ0QXVkaW9QbGF5YmFjazogYyB9ID0gcy51c2VNZW1vKFxuICAgICgpID0+IGN0KCksXG4gICAgW11cbiAgKSwgYSA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBvKHQpLFxuICAgIFt0LCBvXVxuICApLCB7IGNhblBsYXlBdWRpbzogaSB9ID0gRChhLCB7XG4gICAgY2FuUGxheUF1ZGlvOiB0LmNhblBsYXliYWNrQXVkaW9cbiAgfSk7XG4gIHJldHVybiB7IG1lcmdlZFByb3BzOiBzLnVzZU1lbW8oXG4gICAgKCkgPT4gRyhuLCB7XG4gICAgICBjbGFzc05hbWU6IHIsXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGModCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHsgZGlzcGxheTogaSA/IFwibm9uZVwiIDogXCJibG9ja1wiIH1cbiAgICB9KSxcbiAgICBbbiwgciwgaSwgYywgdF1cbiAgKSwgY2FuUGxheUF1ZGlvOiBpIH07XG59XG5mdW5jdGlvbiBXbih7IHJvb206IGUsIHByb3BzOiBuIH0pIHtcbiAgY29uc3QgdCA9IFUoZSksIHsgY2xhc3NOYW1lOiByLCByb29tVmlkZW9QbGF5YmFja0FsbG93ZWRPYnNlcnZhYmxlOiBvLCBoYW5kbGVTdGFydFZpZGVvUGxheWJhY2s6IGMgfSA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBpdCgpLFxuICAgIFtdXG4gICksIGEgPSBzLnVzZU1lbW8oXG4gICAgKCkgPT4gbyh0KSxcbiAgICBbdCwgb11cbiAgKSwgeyBjYW5QbGF5VmlkZW86IGkgfSA9IEQoYSwge1xuICAgIGNhblBsYXlWaWRlbzogdC5jYW5QbGF5YmFja1ZpZGVvXG4gIH0pO1xuICByZXR1cm4geyBtZXJnZWRQcm9wczogcy51c2VNZW1vKFxuICAgICgpID0+IEcobiwge1xuICAgICAgY2xhc3NOYW1lOiByLFxuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICBjKHQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IGkgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIiB9XG4gICAgfSksXG4gICAgW24sIHIsIGksIGMsIHRdXG4gICksIGNhblBsYXlWaWRlbzogaSB9O1xufVxuZnVuY3Rpb24gR24oZSwgbiA9IHt9KSB7XG4gIGNvbnN0IHQgPSBzLnVzZVJlZihudWxsKSwgciA9IHMudXNlUmVmKG51bGwpLCBvID0gbi5taW5Td2lwZURpc3RhbmNlID8/IDUwLCBjID0gKHUpID0+IHtcbiAgICByLmN1cnJlbnQgPSBudWxsLCB0LmN1cnJlbnQgPSB1LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgfSwgYSA9ICh1KSA9PiB7XG4gICAgci5jdXJyZW50ID0gdS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg7XG4gIH0sIGkgPSBzLnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXQuY3VycmVudCB8fCAhci5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHUgPSB0LmN1cnJlbnQgLSByLmN1cnJlbnQsIHAgPSB1ID4gbywgaCA9IHUgPCAtbztcbiAgICBwICYmIG4ub25MZWZ0U3dpcGUgJiYgbi5vbkxlZnRTd2lwZSgpLCBoICYmIG4ub25SaWdodFN3aXBlICYmIG4ub25SaWdodFN3aXBlKCk7XG4gIH0sIFtvLCBuXSk7XG4gIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1ID0gZS5jdXJyZW50O1xuICAgIHJldHVybiB1ICYmICh1LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGMsIHsgcGFzc2l2ZTogITAgfSksIHUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBhLCB7IHBhc3NpdmU6ICEwIH0pLCB1LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBpLCB7IHBhc3NpdmU6ICEwIH0pKSwgKCkgPT4ge1xuICAgICAgdSAmJiAodS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBjKSwgdS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGEpLCB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBpKSk7XG4gICAgfTtcbiAgfSwgW2UsIGldKTtcbn1cbmZ1bmN0aW9uIEpuKHsgcHJvcHM6IGUgfSkge1xuICBjb25zdCB7IGRpc3BhdGNoOiBuLCBzdGF0ZTogdCB9ID0gUGUoKS53aWRnZXQsIHsgY2xhc3NOYW1lOiByIH0gPSBzLnVzZU1lbW8oKCkgPT4gdXQoKSwgW10pO1xuICByZXR1cm4geyBtZXJnZWRQcm9wczogcy51c2VNZW1vKCgpID0+IEcoZSwge1xuICAgIGNsYXNzTmFtZTogcixcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBuICYmIG4oeyBtc2c6IFwidG9nZ2xlX2NoYXRcIiB9KTtcbiAgICB9LFxuICAgIFwiYXJpYS1wcmVzc2VkXCI6IHQgIT0gbnVsbCAmJiB0LnNob3dDaGF0ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsXG4gICAgXCJkYXRhLWxrLXVucmVhZC1tc2dzXCI6IHQgPyB0LnVucmVhZE1lc3NhZ2VzIDwgMTAgPyB0LnVucmVhZE1lc3NhZ2VzLnRvRml4ZWQoMCkgOiBcIjkrXCIgOiBcIjBcIlxuICB9KSwgW2UsIHIsIG4sIHRdKSB9O1xufVxuZnVuY3Rpb24gJG4oZSwgbiwgdCA9IHt9KSB7XG4gIGNvbnN0IFtyLCBvXSA9IHMudXNlU3RhdGUodm9pZCAwKTtcbiAgcmV0dXJuIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgYTtcbiAgICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJ0b2tlbiBlbmRwb2ludCBuZWVkcyB0byBiZSBkZWZpbmVkXCIpO1xuICAgIGlmICgoKGEgPSB0LnVzZXJJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogYS5pZGVudGl0eSkgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgVi5kZWJ1ZyhcImZldGNoaW5nIHRva2VuXCIpO1xuICAgICAgY29uc3QgaSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyAuLi50LnVzZXJJbmZvLCByb29tTmFtZTogbiB9KSwgdSA9IGF3YWl0IGZldGNoKGAke2V9PyR7aS50b1N0cmluZygpfWApO1xuICAgICAgaWYgKCF1Lm9rKSB7XG4gICAgICAgIFYuZXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmZXRjaCB0b2tlbi4gU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke3Uuc3RhdHVzfTogJHt1LnN0YXR1c1RleHR9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuOiBwIH0gPSBhd2FpdCB1Lmpzb24oKTtcbiAgICAgIG8ocCk7XG4gICAgfSkoKTtcbiAgfSwgW2UsIG4sIEpTT04uc3RyaW5naWZ5KHQpXSksIHI7XG59XG5mdW5jdGlvbiBRbihlKSB7XG4gIHZhciBjLCBhO1xuICBjb25zdCBuID0gdWUoZSksIHsgY2xhc3NOYW1lOiB0LCBtZWRpYU11dGVkT2JzZXJ2ZXI6IHIgfSA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBsdChuKSxcbiAgICBbbGUobildXG4gICk7XG4gIHJldHVybiB7IGlzTXV0ZWQ6IEQoXG4gICAgcixcbiAgICAhISgoYyA9IG4ucHVibGljYXRpb24pICE9IG51bGwgJiYgYy5pc011dGVkIHx8IChhID0gbi5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKG4uc291cmNlKSkgIT0gbnVsbCAmJiBhLmlzTXV0ZWQpXG4gICksIGNsYXNzTmFtZTogdCB9O1xufVxuZnVuY3Rpb24gS24oe1xuICBzb3VyY2U6IGUsXG4gIG9uQ2hhbmdlOiBuLFxuICBpbml0aWFsU3RhdGU6IHQsXG4gIGNhcHR1cmVPcHRpb25zOiByLFxuICBwdWJsaXNoT3B0aW9uczogbyxcbiAgb25EZXZpY2VFcnJvcjogYyxcbiAgcm9vbTogYSxcbiAgLi4uaVxufSkge1xuICB2YXIgbTtcbiAgY29uc3QgdSA9IGRlKCksIHAgPSBzLnVzZU1lbW8oKCkgPT4gYSA/PyB1LCBbYSwgdV0pLCBoID0gKG0gPSBwID09IG51bGwgPyB2b2lkIDAgOiBwLmxvY2FsUGFydGljaXBhbnQpID09IG51bGwgPyB2b2lkIDAgOiBtLmdldFRyYWNrUHVibGljYXRpb24oZSksIGQgPSBzLnVzZVJlZighMSksIHsgdG9nZ2xlOiBsLCBjbGFzc05hbWU6IHYsIHBlbmRpbmdPYnNlcnZlcjogQywgZW5hYmxlZE9ic2VydmVyOiBrIH0gPSBzLnVzZU1lbW8oXG4gICAgKCkgPT4gcCA/IGR0KGUsIHAsIHIsIG8sIGMpIDogZnQoKSxcbiAgICBbcCwgZSwgSlNPTi5zdHJpbmdpZnkociksIG9dXG4gICksIEEgPSBEKEMsICExKSwgdyA9IEQoaywgdCA/PyAhIShoICE9IG51bGwgJiYgaC5pc0VuYWJsZWQpKTtcbiAgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG4gPT0gbnVsbCB8fCBuKHcsIGQuY3VycmVudCksIGQuY3VycmVudCA9ICExO1xuICB9LCBbdywgbl0pLCBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdCAhPT0gdm9pZCAwICYmIChWLmRlYnVnKFwiZm9yY2luZyBpbml0aWFsIHRvZ2dsZSBzdGF0ZVwiLCBlLCB0KSwgbCh0KSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgTyA9IHMudXNlTWVtbygoKSA9PiBHKGksIHsgY2xhc3NOYW1lOiB2IH0pLCBbaSwgdl0pLCBSID0gcy51c2VDYWxsYmFjayhcbiAgICAoZikgPT4ge1xuICAgICAgdmFyIGI7XG4gICAgICBkLmN1cnJlbnQgPSAhMCwgbCgpLmNhdGNoKCgpID0+IGQuY3VycmVudCA9ICExKSwgKGIgPSBpLm9uQ2xpY2spID09IG51bGwgfHwgYi5jYWxsKGksIGYpO1xuICAgIH0sXG4gICAgW2ksIGxdXG4gICk7XG4gIHJldHVybiB7XG4gICAgdG9nZ2xlOiBsLFxuICAgIGVuYWJsZWQ6IHcsXG4gICAgcGVuZGluZzogQSxcbiAgICB0cmFjazogaCxcbiAgICBidXR0b25Qcm9wczoge1xuICAgICAgLi4uTyxcbiAgICAgIFwiYXJpYS1wcmVzc2VkXCI6IHcsXG4gICAgICBcImRhdGEtbGstc291cmNlXCI6IGUsXG4gICAgICBcImRhdGEtbGstZW5hYmxlZFwiOiB3LFxuICAgICAgZGlzYWJsZWQ6IEEsXG4gICAgICBvbkNsaWNrOiBSXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gWW4oZSA9IFtcbiAgRS5Tb3VyY2UuQ2FtZXJhLFxuICBFLlNvdXJjZS5NaWNyb3Bob25lLFxuICBFLlNvdXJjZS5TY3JlZW5TaGFyZSxcbiAgRS5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyxcbiAgRS5Tb3VyY2UuVW5rbm93blxuXSwgbiA9IHt9KSB7XG4gIGNvbnN0IHQgPSBVKG4ucm9vbSksIFtyLCBvXSA9IHMudXNlU3RhdGUoW10pLCBbYywgYV0gPSBzLnVzZVN0YXRlKFtdKSwgaSA9IHMudXNlTWVtbygoKSA9PiBlLm1hcCgocCkgPT4gbXQocCkgPyBwLnNvdXJjZSA6IHApLCBbSlNPTi5zdHJpbmdpZnkoZSldKTtcbiAgcmV0dXJuIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwID0gcHQodCwgaSwge1xuICAgICAgYWRkaXRpb25hbFJvb21FdmVudHM6IG4udXBkYXRlT25seU9uLFxuICAgICAgb25seVN1YnNjcmliZWQ6IG4ub25seVN1YnNjcmliZWRcbiAgICB9KS5zdWJzY3JpYmUoKHsgdHJhY2tSZWZlcmVuY2VzOiBoLCBwYXJ0aWNpcGFudHM6IGQgfSkgPT4ge1xuICAgICAgVi5kZWJ1ZyhcInNldHRpbmcgdHJhY2sgYnVuZGxlc1wiLCBoLCBkKSwgbyhoKSwgYShkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gcC51bnN1YnNjcmliZSgpO1xuICB9LCBbXG4gICAgdCxcbiAgICBKU09OLnN0cmluZ2lmeShuLm9ubHlTdWJzY3JpYmVkKSxcbiAgICBKU09OLnN0cmluZ2lmeShuLnVwZGF0ZU9ubHlPbiksXG4gICAgSlNPTi5zdHJpbmdpZnkoZSlcbiAgXSksIHMudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKFJlKGUpKSB7XG4gICAgICBjb25zdCBwID0gJHQoZSwgYyksIGggPSBBcnJheS5mcm9tKHIpO1xuICAgICAgcmV0dXJuIGMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBwLmhhcyhkLmlkZW50aXR5KSAmJiAocC5nZXQoZC5pZGVudGl0eSkgPz8gW10pLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICBpZiAoci5maW5kKFxuICAgICAgICAgICAgKHsgcGFydGljaXBhbnQ6IGssIHB1YmxpY2F0aW9uOiBBIH0pID0+IGQuaWRlbnRpdHkgPT09IGsuaWRlbnRpdHkgJiYgQS5zb3VyY2UgPT09IHZcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIFYuZGVidWcoXG4gICAgICAgICAgICBgQWRkICR7dn0gcGxhY2Vob2xkZXIgZm9yIHBhcnRpY2lwYW50ICR7ZC5pZGVudGl0eX0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgQyA9IHtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50OiBkLFxuICAgICAgICAgICAgc291cmNlOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgICBoLnB1c2goQyk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIGg7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gcjtcbiAgfSwgW3IsIGMsIGVdKTtcbn1cbmZ1bmN0aW9uIEp0KGUsIG4pIHtcbiAgY29uc3QgdCA9IG5ldyBTZXQoZSk7XG4gIGZvciAoY29uc3QgciBvZiBuKVxuICAgIHQuZGVsZXRlKHIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uICR0KGUsIG4pIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmIChSZShlKSkge1xuICAgIGNvbnN0IHIgPSBlLmZpbHRlcigobykgPT4gby53aXRoUGxhY2Vob2xkZXIpLm1hcCgobykgPT4gby5zb3VyY2UpO1xuICAgIG4uZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgYyA9IG8uZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKS5tYXAoKGkpID0+IHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHJldHVybiAodSA9IGkudHJhY2spID09IG51bGwgPyB2b2lkIDAgOiB1LnNvdXJjZTtcbiAgICAgIH0pLmZpbHRlcigoaSkgPT4gaSAhPT0gdm9pZCAwKSwgYSA9IEFycmF5LmZyb20oXG4gICAgICAgIEp0KG5ldyBTZXQociksIG5ldyBTZXQoYykpXG4gICAgICApO1xuICAgICAgYS5sZW5ndGggPiAwICYmIHQuc2V0KG8uaWRlbnRpdHksIGEpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gUXQoZSkge1xuICBjb25zdCBbbiwgdF0gPSBzLnVzZVN0YXRlKGh0KGUpKSwgeyB0cmFja09ic2VydmVyOiByIH0gPSBzLnVzZU1lbW8oKCkgPT4gYnQoZSksIFtlLnBhcnRpY2lwYW50LnNpZCA/PyBlLnBhcnRpY2lwYW50LmlkZW50aXR5LCBlLnNvdXJjZV0pO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG8gPSByLnN1YnNjcmliZSgoYykgPT4ge1xuICAgICAgdChjKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gbyA9PSBudWxsID8gdm9pZCAwIDogby51bnN1YnNjcmliZSgpO1xuICB9LCBbcl0pLCB7XG4gICAgcGFydGljaXBhbnQ6IGUucGFydGljaXBhbnQsXG4gICAgc291cmNlOiBlLnNvdXJjZSA/PyBFLlNvdXJjZS5Vbmtub3duLFxuICAgIHB1YmxpY2F0aW9uOiBuXG4gIH07XG59XG5mdW5jdGlvbiBYbihlLCBuKSB7XG4gIGNvbnN0IHQgPSBRKG4pO1xuICByZXR1cm4gUXQoeyBuYW1lOiBlLCBwYXJ0aWNpcGFudDogdCB9KTtcbn1cbmZ1bmN0aW9uIEt0KGUpIHtcbiAgY29uc3QgbiA9IFUoZSA9PSBudWxsID8gdm9pZCAwIDogZS5yb29tKSwgdCA9IHRlKG4pLCByID0gcy51c2VNZW1vKFxuICAgICgpID0+IHQgPT09IEkuRGlzY29ubmVjdGVkLFxuICAgIFt0XVxuICApLCBvID0gcy51c2VNZW1vKFxuICAgICgpID0+IGd0KG4sIGUpLFxuICAgIFtuLCBlLCByXVxuICApLCBjID0gRChvLmlzU2VuZGluZ09ic2VydmFibGUsICExKSwgYSA9IEQoby5tZXNzYWdlT2JzZXJ2YWJsZSwgW10pO1xuICByZXR1cm4geyBzZW5kOiBvLnNlbmQsIGNoYXRNZXNzYWdlczogYSwgaXNTZW5kaW5nOiBjIH07XG59XG5mdW5jdGlvbiBabihlID0ge30pIHtcbiAgY29uc3QgW24sIHRdID0gcy51c2VTdGF0ZShcbiAgICB2dChlLmRlZmF1bHRzLCBlLnByZXZlbnRMb2FkID8/ICExKVxuICApLCByID0gcy51c2VDYWxsYmFjaygodSkgPT4ge1xuICAgIHQoKHApID0+ICh7IC4uLnAsIGF1ZGlvRW5hYmxlZDogdSB9KSk7XG4gIH0sIFtdKSwgbyA9IHMudXNlQ2FsbGJhY2soKHUpID0+IHtcbiAgICB0KChwKSA9PiAoeyAuLi5wLCB2aWRlb0VuYWJsZWQ6IHUgfSkpO1xuICB9LCBbXSksIGMgPSBzLnVzZUNhbGxiYWNrKCh1KSA9PiB7XG4gICAgdCgocCkgPT4gKHsgLi4ucCwgYXVkaW9EZXZpY2VJZDogdSB9KSk7XG4gIH0sIFtdKSwgYSA9IHMudXNlQ2FsbGJhY2soKHUpID0+IHtcbiAgICB0KChwKSA9PiAoeyAuLi5wLCB2aWRlb0RldmljZUlkOiB1IH0pKTtcbiAgfSwgW10pLCBpID0gcy51c2VDYWxsYmFjaygodSkgPT4ge1xuICAgIHQoKHApID0+ICh7IC4uLnAsIHVzZXJuYW1lOiB1IH0pKTtcbiAgfSwgW10pO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIFN0KG4sIGUucHJldmVudFNhdmUgPz8gITEpO1xuICB9LCBbbiwgZS5wcmV2ZW50U2F2ZV0pLCB7XG4gICAgdXNlckNob2ljZXM6IG4sXG4gICAgc2F2ZUF1ZGlvSW5wdXRFbmFibGVkOiByLFxuICAgIHNhdmVWaWRlb0lucHV0RW5hYmxlZDogbyxcbiAgICBzYXZlQXVkaW9JbnB1dERldmljZUlkOiBjLFxuICAgIHNhdmVWaWRlb0lucHV0RGV2aWNlSWQ6IGEsXG4gICAgc2F2ZVVzZXJuYW1lOiBpXG4gIH07XG59XG5mdW5jdGlvbiBlcyhlLCBuID0ge30pIHtcbiAgY29uc3QgdCA9IFEoZSksIHIgPSBVKG4ucm9vbSksIG8gPSBzLnVzZU1lbW8oKCkgPT4geXQociwgdCksIFtyLCB0XSk7XG4gIHJldHVybiBEKFxuICAgIG8sXG4gICAgdC5pc0xvY2FsID8gdC5pc0UyRUVFbmFibGVkIDogISEodCAhPSBudWxsICYmIHQuaXNFbmNyeXB0ZWQpXG4gICk7XG59XG5mdW5jdGlvbiB0cyhlLCBuID0geyBmZnRTaXplOiAzMiwgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwIH0pIHtcbiAgY29uc3QgdCA9IEN0KGUpID8gZS5wdWJsaWNhdGlvbi50cmFjayA6IGUsIFtyLCBvXSA9IHMudXNlU3RhdGUoMCk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF0IHx8ICF0Lm1lZGlhU3RyZWFtKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xlYW51cDogYywgYW5hbHlzZXI6IGEgfSA9IG1lKHQsIG4pLCBpID0gYS5mcmVxdWVuY3lCaW5Db3VudCwgdSA9IG5ldyBVaW50OEFycmF5KGkpLCBoID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgYS5nZXRCeXRlRnJlcXVlbmN5RGF0YSh1KTtcbiAgICAgIGxldCBkID0gMDtcbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdS5sZW5ndGg7IGwrKykge1xuICAgICAgICBjb25zdCB2ID0gdVtsXTtcbiAgICAgICAgZCArPSB2ICogdjtcbiAgICAgIH1cbiAgICAgIG8oTWF0aC5zcXJ0KGQgLyB1Lmxlbmd0aCkgLyAyNTUpO1xuICAgIH0sIDFlMyAvIDMwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYygpLCBjbGVhckludGVydmFsKGgpO1xuICAgIH07XG4gIH0sIFt0LCB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1lZGlhU3RyZWFtLCBKU09OLnN0cmluZ2lmeShuKV0pLCByO1xufVxuY29uc3QgWXQgPSAoZSkgPT4ge1xuICBjb25zdCBuID0gKHQpID0+IHtcbiAgICBsZXQgYyA9IDEgLSBNYXRoLm1heCgtMTAwLCBNYXRoLm1pbigtMTAsIHQpKSAqIC0xIC8gMTAwO1xuICAgIHJldHVybiBjID0gTWF0aC5zcXJ0KGMpLCBjO1xuICB9O1xuICByZXR1cm4gZS5tYXAoKHQpID0+IHQgPT09IC0xIC8gMCA/IDAgOiBuKHQpKTtcbn0sIFh0ID0ge1xuICBiYW5kczogNSxcbiAgbG9QYXNzOiAxMDAsXG4gIGhpUGFzczogNjAwLFxuICB1cGRhdGVJbnRlcnZhbDogMzIsXG4gIGFuYWx5c2VyT3B0aW9uczogeyBmZnRTaXplOiAyMDQ4IH1cbn07XG5mdW5jdGlvbiBucyhlLCBuID0ge30pIHtcbiAgdmFyIGE7XG4gIGNvbnN0IHQgPSBlIGluc3RhbmNlb2YgRSA/IGUgOiAoYSA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBhLnRyYWNrLCByID0geyAuLi5YdCwgLi4ubiB9LCBbbywgY10gPSBzLnVzZVN0YXRlKFxuICAgIG5ldyBBcnJheShyLmJhbmRzKS5maWxsKDApXG4gICk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF0IHx8ICEodCAhPSBudWxsICYmIHQubWVkaWFTdHJlYW0pKSB7XG4gICAgICBjKCh2KSA9PiB2LnNsaWNlKCkuZmlsbCgwKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgYW5hbHlzZXI6IGksIGNsZWFudXA6IHUgfSA9IG1lKHQsIHIuYW5hbHlzZXJPcHRpb25zKSwgcCA9IGkuZnJlcXVlbmN5QmluQ291bnQsIGggPSBuZXcgRmxvYXQzMkFycmF5KHApLCBsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaS5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoaCk7XG4gICAgICBsZXQgdiA9IG5ldyBGbG9hdDMyQXJyYXkoaC5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBoLmxlbmd0aDsgdysrKVxuICAgICAgICB2W3ddID0gaFt3XTtcbiAgICAgIHYgPSB2LnNsaWNlKG4ubG9QYXNzLCBuLmhpUGFzcyk7XG4gICAgICBjb25zdCBDID0gWXQodiksIGsgPSBNYXRoLmNlaWwoQy5sZW5ndGggLyByLmJhbmRzKSwgQSA9IFtdO1xuICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCByLmJhbmRzOyB3KyspIHtcbiAgICAgICAgY29uc3QgTyA9IEMuc2xpY2UodyAqIGssICh3ICsgMSkgKiBrKS5yZWR1Y2UoKFIsIG0pID0+IFIgKz0gbSwgMCk7XG4gICAgICAgIEEucHVzaChPIC8gayk7XG4gICAgICB9XG4gICAgICBjKEEpO1xuICAgIH0sIHIudXBkYXRlSW50ZXJ2YWwpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1KCksIGNsZWFySW50ZXJ2YWwobCk7XG4gICAgfTtcbiAgfSwgW3QsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWVkaWFTdHJlYW0sIEpTT04uc3RyaW5naWZ5KG4pXSksIG87XG59XG5jb25zdCBadCA9IHtcbiAgYmFyQ291bnQ6IDEyMCxcbiAgdm9sTXVsdGlwbGllcjogNSxcbiAgdXBkYXRlSW50ZXJ2YWw6IDIwXG59O1xuZnVuY3Rpb24gc3MoZSwgbiA9IHt9KSB7XG4gIHZhciBoO1xuICBjb25zdCB0ID0gZSBpbnN0YW5jZW9mIEUgPyBlIDogKGggPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogaC50cmFjaywgciA9IHsgLi4uWnQsIC4uLm4gfSwgbyA9IHMudXNlUmVmKG5ldyBGbG9hdDMyQXJyYXkoKSksIGMgPSBzLnVzZVJlZihwZXJmb3JtYW5jZS5ub3coKSksIGEgPSBzLnVzZVJlZigwKSwgW2ksIHVdID0gcy51c2VTdGF0ZShbXSksIHAgPSBzLnVzZUNhbGxiYWNrKChkKSA9PiB7XG4gICAgdShcbiAgICAgIEFycmF5LmZyb20oXG4gICAgICAgIHRuKGQsIHIuYmFyQ291bnQpLm1hcCgobCkgPT4gTWF0aC5zcXJ0KGwpICogci52b2xNdWx0aXBsaWVyKVxuICAgICAgICAvLyB3YXZlLnNsaWNlKDAsIG9wdHMuYmFyQ291bnQpLm1hcCgodikgPT4gc2lnbW9pZCh2ICogb3B0cy52b2xNdWx0aXBsaWVyLCAwLjA4LCAwLjIpKSxcbiAgICAgIClcbiAgICApO1xuICB9LCBbXSk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF0IHx8ICEodCAhPSBudWxsICYmIHQubWVkaWFTdHJlYW0pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYW5hbHlzZXI6IGQsIGNsZWFudXA6IGwgfSA9IG1lKHQsIHtcbiAgICAgIGZmdFNpemU6IHllKHIuYmFyQ291bnQpXG4gICAgfSksIHYgPSB5ZShyLmJhckNvdW50KSwgQyA9IG5ldyBGbG9hdDMyQXJyYXkodiksIGsgPSAoKSA9PiB7XG4gICAgICBpZiAoQSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShrKSwgZC5nZXRGbG9hdFRpbWVEb21haW5EYXRhKEMpLCBvLmN1cnJlbnQubWFwKCh3LCBPKSA9PiB3ICsgQ1tPXSksIGEuY3VycmVudCArPSAxLCBwZXJmb3JtYW5jZS5ub3coKSAtIGMuY3VycmVudCA+PSByLnVwZGF0ZUludGVydmFsKSB7XG4gICAgICAgIGNvbnN0IHcgPSBDLm1hcCgoTykgPT4gTyAvIGEuY3VycmVudCk7XG4gICAgICAgIHAodyksIGMuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpLCBhLmN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IEEgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGwoKSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUoQSk7XG4gICAgfTtcbiAgfSwgW3QsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWVkaWFTdHJlYW0sIEpTT04uc3RyaW5naWZ5KG4pLCBwXSksIHtcbiAgICBiYXJzOiBpXG4gIH07XG59XG5mdW5jdGlvbiB5ZShlKSB7XG4gIHJldHVybiBlIDwgMzIgPyAzMiA6IGVuKGUpO1xufVxuZnVuY3Rpb24gZW4oZSkge1xuICBsZXQgbiA9IDI7XG4gIGZvciAoOyBlID4+PSAxOyApXG4gICAgbiA8PD0gMTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB0bihlLCBuKSB7XG4gIGNvbnN0IHQgPSBNYXRoLmZsb29yKGUubGVuZ3RoIC8gbiksIHIgPSBuZXcgRmxvYXQzMkFycmF5KG4pO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IG47IG8rKykge1xuICAgIGNvbnN0IGMgPSB0ICogbztcbiAgICBsZXQgYSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0OyBpKyspXG4gICAgICBhID0gYSArIE1hdGguYWJzKGVbYyArIGldKTtcbiAgICByW29dID0gYSAvIHQ7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiByZShlLCBuID0ge30pIHtcbiAgbGV0IHQsIHI7XG4gIHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyB0ID0gbiA6ICh0ID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5wYXJ0aWNpcGFudElkZW50aXR5LCByID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5yb29tKTtcbiAgY29uc3QgbyA9IGZlKCksIGMgPSBXdCh7IHJvb206IHIsIHVwZGF0ZU9ubHlPbjogW10gfSksIGEgPSBzLnVzZU1lbW8oKCkgPT4gdCA/IGMuZmluZCgocCkgPT4gcC5pZGVudGl0eSA9PT0gdCkgOiBvLCBbdCwgYywgb10pLCBpID0gcy51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiBNdChhLCB7IHNvdXJjZXM6IGUgfSk7XG4gIH0sIFthLCBKU09OLnN0cmluZ2lmeShlKV0pO1xuICByZXR1cm4gRChpLCBbXSk7XG59XG5mdW5jdGlvbiBubihlKSB7XG4gIHZhciB0LCByLCBvO1xuICBjb25zdCBuID0gcy51c2VNZW1vKFxuICAgICgpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgcmV0dXJuIChjID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNhdGlvbikgIT0gbnVsbCAmJiBjLnRyYWNrID8gVHQoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNhdGlvbi50cmFjaykgOiB2b2lkIDA7XG4gICAgfSxcbiAgICBbKHQgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC50cmFja11cbiAgKTtcbiAgcmV0dXJuIEQobiwge1xuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICBydHBUaW1lc3RhbXA6IChvID0gKHIgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogci50cmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IG8ucnRwVGltZXN0YW1wXG4gIH0pO1xufVxuY29uc3Qgc24gPSB7XG4gIGJ1ZmZlclNpemU6IDEwMFxuICAvLyBtYXhBZ2U6IDJfMDAwLFxufTtcbmZ1bmN0aW9uIHJuKGUsIG4pIHtcbiAgY29uc3QgdCA9IHsgLi4uc24sIC4uLm4gfSwgW3IsIG9dID0gcy51c2VTdGF0ZShbXSksIGMgPSBubihlKSwgYSA9IChpKSA9PiB7XG4gICAgdmFyIHU7XG4gICAgKHUgPSB0Lm9uVHJhbnNjcmlwdGlvbikgPT0gbnVsbCB8fCB1LmNhbGwodCwgaSksIG8oXG4gICAgICAocCkgPT4ga3QoXG4gICAgICAgIHAsXG4gICAgICAgIC8vIHdoZW4gZmlyc3QgcmVjZWl2aW5nIGEgc2VnbWVudCwgYWRkIHRoZSBjdXJyZW50IG1lZGlhIHRpbWVzdGFtcCB0byBpdFxuICAgICAgICBpLm1hcCgoaCkgPT4gd3QoaCwgYykpLFxuICAgICAgICB0LmJ1ZmZlclNpemVcbiAgICAgIClcbiAgICApO1xuICB9O1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghKGUgIT0gbnVsbCAmJiBlLnB1YmxpY2F0aW9uKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gRXQoZS5wdWJsaWNhdGlvbikuc3Vic2NyaWJlKCh1KSA9PiB7XG4gICAgICBhKC4uLnUpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2UgJiYgbGUoZSksIGFdKSwgeyBzZWdtZW50czogciB9O1xufVxuZnVuY3Rpb24gb24oZSA9IHt9KSB7XG4gIGNvbnN0IG4gPSBmZSgpLCB0ID0gZS5wYXJ0aWNpcGFudCA/PyBuLCByID0gcy51c2VNZW1vKFxuICAgIC8vIHdlaXJkIHR5cGVzY3JpcHQgY29uc3RyYWludFxuICAgICgpID0+IHQgPyBpZSh0KSA6IGllKHQpLFxuICAgIFt0XVxuICApO1xuICByZXR1cm4gRChyLCB7XG4gICAgYXR0cmlidXRlczogdCA9PSBudWxsID8gdm9pZCAwIDogdC5hdHRyaWJ1dGVzXG4gIH0pO1xufVxuZnVuY3Rpb24gcnMoZSwgbiA9IHt9KSB7XG4gIGNvbnN0IHQgPSBRKG4ucGFydGljaXBhbnQpLCBbciwgb10gPSBzLnVzZVN0YXRlKHQuYXR0cmlidXRlc1tlXSk7XG4gIHJldHVybiBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGMgPSBpZSh0KS5zdWJzY3JpYmUoKGEpID0+IHtcbiAgICAgIGEuY2hhbmdlZFtlXSAhPT0gdm9pZCAwICYmIG8oYS5hdHRyaWJ1dGVzW2VdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFt0LCBlXSksIHI7XG59XG5jb25zdCBDZSA9IFcuQWdlbnRTdGF0ZTtcbmZ1bmN0aW9uIG9zKCkge1xuICBjb25zdCBlID0gcGUoKSwgbiA9IGUuZmluZChcbiAgICAoZCkgPT4gZC5raW5kID09PSBzZS5BR0VOVCAmJiAhKFcuUHVibGlzaE9uQmVoYWxmIGluIGQuYXR0cmlidXRlcylcbiAgKSwgdCA9IGUuZmluZChcbiAgICAoZCkgPT4gZC5raW5kID09PSBzZS5BR0VOVCAmJiBkLmF0dHJpYnV0ZXNbVy5QdWJsaXNoT25CZWhhbGZdID09PSAobiA9PSBudWxsID8gdm9pZCAwIDogbi5pZGVudGl0eSlcbiAgKSwgciA9IHJlKFxuICAgIFtFLlNvdXJjZS5NaWNyb3Bob25lLCBFLlNvdXJjZS5DYW1lcmFdLFxuICAgIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaWRlbnRpdHlcbiAgKSwgbyA9IHJlKFxuICAgIFtFLlNvdXJjZS5NaWNyb3Bob25lLCBFLlNvdXJjZS5DYW1lcmFdLFxuICAgIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaWRlbnRpdHlcbiAgKSwgYyA9IHIuZmluZCgoZCkgPT4gZC5zb3VyY2UgPT09IEUuU291cmNlLk1pY3JvcGhvbmUpID8/IG8uZmluZCgoZCkgPT4gZC5zb3VyY2UgPT09IEUuU291cmNlLk1pY3JvcGhvbmUpLCBhID0gci5maW5kKChkKSA9PiBkLnNvdXJjZSA9PT0gRS5Tb3VyY2UuQ2FtZXJhKSA/PyBvLmZpbmQoKGQpID0+IGQuc291cmNlID09PSBFLlNvdXJjZS5DYW1lcmEpLCB7IHNlZ21lbnRzOiBpIH0gPSBybihjKSwgdSA9IHRlKCksIHsgYXR0cmlidXRlczogcCB9ID0gb24oeyBwYXJ0aWNpcGFudDogbiB9KSwgaCA9IHMudXNlTWVtbygoKSA9PiB1ID09PSBJLkRpc2Nvbm5lY3RlZCA/IFwiZGlzY29ubmVjdGVkXCIgOiB1ID09PSBJLkNvbm5lY3RpbmcgfHwgIW4gfHwgIShwICE9IG51bGwgJiYgcFtDZV0pID8gXCJjb25uZWN0aW5nXCIgOiBwW0NlXSwgW3AsIG4sIHVdKTtcbiAgcmV0dXJuIHtcbiAgICBhZ2VudDogbixcbiAgICBzdGF0ZTogaCxcbiAgICBhdWRpb1RyYWNrOiBjLFxuICAgIHZpZGVvVHJhY2s6IGEsXG4gICAgYWdlbnRUcmFuc2NyaXB0aW9uczogaSxcbiAgICBhZ2VudEF0dHJpYnV0ZXM6IHBcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzKGUpIHtcbiAgY29uc3QgbiA9IFUoZSksIHQgPSB0ZShuKSwgciA9IHMudXNlTWVtbygoKSA9PiBQdChuKSwgW24sIHRdKTtcbiAgcmV0dXJuIEQociwgbi5pc1JlY29yZGluZyk7XG59XG5mdW5jdGlvbiBhbihlLCBuKSB7XG4gIGNvbnN0IHQgPSBVKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ucm9vbSksIG8gPSB0ZSh0KSA9PT0gSS5EaXNjb25uZWN0ZWQsIGMgPSBzLnVzZU1lbW8oKCkgPT4gTHQodCwgZSksIFt0LCBlXSk7XG4gIHJldHVybiB7IHRleHRTdHJlYW1zOiBEKG8gPyB2b2lkIDAgOiBjLCBbXSkgfTtcbn1cbmZ1bmN0aW9uIGNuKGUpIHtcbiAgY29uc3QgeyBwYXJ0aWNpcGFudElkZW50aXRpZXM6IG4sIHRyYWNrU2lkczogdCB9ID0gZSA/PyB7fSwgeyB0ZXh0U3RyZWFtczogciB9ID0gYW4oQXQuVFJBTlNDUklQVElPTiwgeyByb29tOiBlID09IG51bGwgPyB2b2lkIDAgOiBlLnJvb20gfSk7XG4gIHJldHVybiBzLnVzZU1lbW8oXG4gICAgKCkgPT4gci5maWx0ZXIoXG4gICAgICAoYykgPT4gbiA/IG4uaW5jbHVkZXMoYy5wYXJ0aWNpcGFudEluZm8uaWRlbnRpdHkpIDogITBcbiAgICApLmZpbHRlcihcbiAgICAgIChjKSA9PiB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gdCA/IHQuaW5jbHVkZXMoXG4gICAgICAgICAgKChhID0gYy5zdHJlYW1JbmZvLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBhW1cuVHJhbnNjcmliZWRUcmFja0lkXSkgPz8gXCJcIlxuICAgICAgICApIDogITA7XG4gICAgICB9XG4gICAgKSxcbiAgICBbciwgbiwgdF1cbiAgKTtcbn1cbmNvbnN0IE1lID0gMiwgVGUgPSA0MDAsIEVlID0gMywga2UgPSAxZTM7XG5mdW5jdGlvbiBjcyhlKSB7XG4gIGNvbnN0IG4gPSBhZShbXSksIHQgPSBOZSgoKSA9PiBuZXcgTnQoKSwgW10pLCByID0gZWUoYXN5bmMgKCkgPT4gdC5sb2NrKCkudGhlbihhc3luYyAoaCkgPT4ge1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgZCA9IG4uY3VycmVudC5wb3AoKTtcbiAgICAgIGlmICghZCkge1xuICAgICAgICBoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNvbm5lY3RcIjpcbiAgICAgICAgICBhd2FpdCBkLnJvb20uY29ubmVjdCguLi5kLmFyZ3MpLnRoZW4oZC5yZXNvbHZlKS5jYXRjaChkLnJlamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXNjb25uZWN0XCI6XG4gICAgICAgICAgYXdhaXQgZC5yb29tLmRpc2Nvbm5lY3QoLi4uZC5hcmdzKS50aGVuKGQucmVzb2x2ZSkuY2F0Y2goZC5yZWplY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtdKSwgbyA9IGFlKFtdKSwgYyA9IGVlKChoKSA9PiB7XG4gICAgbGV0IGQgPSAwO1xuICAgIG8uY3VycmVudCA9IG8uY3VycmVudC5maWx0ZXIoKGwpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBoLmdldFRpbWUoKSAtIGwuZ2V0VGltZSgpIDwga2U7XG4gICAgICByZXR1cm4gdiAmJiAoZCArPSAxKSwgdjtcbiAgICB9KSwgZCA+IEVlICYmIFYud2FybihcbiAgICAgIGB1c2VTZXF1ZW50aWFsUm9vbUNvbm5lY3REaXNjb25uZWN0OiByb29tIGNoYW5nZWQgcmVmZXJlbmNlIHJhcGlkbHkgKG92ZXIgJHtFZX14IGluICR7a2V9bXMpLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC5gXG4gICAgKTtcbiAgfSwgW10pO1xuICBfZSgoKSA9PiB7XG4gICAgbi5jdXJyZW50ID0gW107XG4gICAgY29uc3QgaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIG8uY3VycmVudC5wdXNoKGgpLCBjKGgpO1xuICB9LCBbZSwgY10pO1xuICBjb25zdCBhID0gYWUoW10pLCBpID0gZWUoKGgpID0+IHtcbiAgICBsZXQgZCA9IDA7XG4gICAgYS5jdXJyZW50ID0gYS5jdXJyZW50LmZpbHRlcigobCkgPT4ge1xuICAgICAgY29uc3QgdiA9IGguZ2V0VGltZSgpIC0gbC5nZXRUaW1lKCkgPCBUZTtcbiAgICAgIHJldHVybiB2ICYmIChkICs9IDEpLCB2O1xuICAgIH0pLCBkID4gTWUgJiYgVi53YXJuKFxuICAgICAgYHVzZVNlcXVlbnRpYWxSb29tQ29ubmVjdERpc2Nvbm5lY3Q6IHJvb20gY29ubmVjdCAvIGRpc2Nvbm5lY3Qgb2NjdXJyaW5nIGluIHJhcGlkIHNlcXVlbmNlIChvdmVyICR7TWV9eCBpbiAke1RlfW1zKS4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBiZSB0aGUgc2lnbiBvZiBhIGJ1ZyBsaWtlIGEgdXNlRWZmZWN0IGRlcGVuZGVuY3kgY2hhbmdpbmcgZXZlcnkgcmVuZGVyLmBcbiAgICApO1xuICB9LCBbXSksIHUgPSBlZShcbiAgICBhc3luYyAoLi4uaCkgPT4gbmV3IFByb21pc2UoKGQsIGwpID0+IHtcbiAgICAgIGlmICghZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbm5lY3QoKSwgYnV0IHJvb20gd2FzIHVuc2V0XCIpO1xuICAgICAgY29uc3QgdiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgaSh2KSwgbi5jdXJyZW50LnB1c2goeyB0eXBlOiBcImNvbm5lY3RcIiwgcm9vbTogZSwgYXJnczogaCwgcmVzb2x2ZTogZCwgcmVqZWN0OiBsIH0pLCBhLmN1cnJlbnQucHVzaCh2KSwgcigpO1xuICAgIH0pLFxuICAgIFtlLCBpLCByXVxuICApLCBwID0gZWUoXG4gICAgYXN5bmMgKC4uLmgpID0+IG5ldyBQcm9taXNlKChkLCBsKSA9PiB7XG4gICAgICBpZiAoIWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBkaXNjY29ubmVjdCgpLCBidXQgcm9vbSB3YXMgdW5zZXRcIik7XG4gICAgICBjb25zdCB2ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBpKHYpLCBuLmN1cnJlbnQucHVzaCh7IHR5cGU6IFwiZGlzY29ubmVjdFwiLCByb29tOiBlLCBhcmdzOiBoLCByZXNvbHZlOiBkLCByZWplY3Q6IGwgfSksIGEuY3VycmVudC5wdXNoKHYpLCByKCk7XG4gICAgfSksXG4gICAgW2UsIGksIHJdXG4gICk7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdDogZSA/IHUgOiBudWxsLFxuICAgIGRpc2Nvbm5lY3Q6IGUgPyBwIDogbnVsbFxuICB9O1xufVxudmFyIG5lID0geyBleHBvcnRzOiB7fSB9LCB3ZTtcbmZ1bmN0aW9uIHVuKCkge1xuICBpZiAod2UpIHJldHVybiBuZS5leHBvcnRzO1xuICB3ZSA9IDE7XG4gIHZhciBlID0gdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiA/IFJlZmxlY3QgOiBudWxsLCBuID0gZSAmJiB0eXBlb2YgZS5hcHBseSA9PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5IDogZnVuY3Rpb24oZiwgYiwgZykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChmLCBiLCBnKTtcbiAgfSwgdDtcbiAgZSAmJiB0eXBlb2YgZS5vd25LZXlzID09IFwiZnVuY3Rpb25cIiA/IHQgPSBlLm93bktleXMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZikpO1xuICB9IDogdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZik7XG4gIH07XG4gIGZ1bmN0aW9uIHIobSkge1xuICAgIGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2FybihtKTtcbiAgfVxuICB2YXIgbyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGYgIT09IGY7XG4gIH07XG4gIGZ1bmN0aW9uIGMoKSB7XG4gICAgYy5pbml0LmNhbGwodGhpcyk7XG4gIH1cbiAgbmUuZXhwb3J0cyA9IGMsIG5lLmV4cG9ydHMub25jZSA9IHcsIGMuRXZlbnRFbWl0dGVyID0gYywgYy5wcm90b3R5cGUuX2V2ZW50cyA9IHZvaWQgMCwgYy5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMCwgYy5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHZvaWQgMDtcbiAgdmFyIGEgPSAxMDtcbiAgZnVuY3Rpb24gaShtKSB7XG4gICAgaWYgKHR5cGVvZiBtICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbSk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihtKSB7XG4gICAgICBpZiAodHlwZW9mIG0gIT0gXCJudW1iZXJcIiB8fCBtIDwgMCB8fCBvKG0pKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBtICsgXCIuXCIpO1xuICAgICAgYSA9IG07XG4gICAgfVxuICB9KSwgYy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgKHRoaXMuX2V2ZW50cyA9PT0gdm9pZCAwIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpICYmICh0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwKSwgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHZvaWQgMDtcbiAgfSwgYy5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oZikge1xuICAgIGlmICh0eXBlb2YgZiAhPSBcIm51bWJlclwiIHx8IGYgPCAwIHx8IG8oZikpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBmICsgXCIuXCIpO1xuICAgIHJldHVybiB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBmLCB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiB1KG0pIHtcbiAgICByZXR1cm4gbS5fbWF4TGlzdGVuZXJzID09PSB2b2lkIDAgPyBjLmRlZmF1bHRNYXhMaXN0ZW5lcnMgOiBtLl9tYXhMaXN0ZW5lcnM7XG4gIH1cbiAgYy5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHUodGhpcyk7XG4gIH0sIGMucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgYiA9IFtdLCBnID0gMTsgZyA8IGFyZ3VtZW50cy5sZW5ndGg7IGcrKykgYi5wdXNoKGFyZ3VtZW50c1tnXSk7XG4gICAgdmFyIHkgPSBmID09PSBcImVycm9yXCIsIFQgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKFQgIT09IHZvaWQgMClcbiAgICAgIHkgPSB5ICYmIFQuZXJyb3IgPT09IHZvaWQgMDtcbiAgICBlbHNlIGlmICgheSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoeSkge1xuICAgICAgdmFyIE07XG4gICAgICBpZiAoYi5sZW5ndGggPiAwICYmIChNID0gYlswXSksIE0gaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgdGhyb3cgTTtcbiAgICAgIHZhciBQID0gbmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiICsgKE0gPyBcIiAoXCIgKyBNLm1lc3NhZ2UgKyBcIilcIiA6IFwiXCIpKTtcbiAgICAgIHRocm93IFAuY29udGV4dCA9IE0sIFA7XG4gICAgfVxuICAgIHZhciBGID0gVFtmXTtcbiAgICBpZiAoRiA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICh0eXBlb2YgRiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICBuKEYsIHRoaXMsIGIpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIHEgPSBGLmxlbmd0aCwgSiA9IEMoRiwgcSksIGcgPSAwOyBnIDwgcTsgKytnKVxuICAgICAgICBuKEpbZ10sIHRoaXMsIGIpO1xuICAgIHJldHVybiAhMDtcbiAgfTtcbiAgZnVuY3Rpb24gcChtLCBmLCBiLCBnKSB7XG4gICAgdmFyIHksIFQsIE07XG4gICAgaWYgKGkoYiksIFQgPSBtLl9ldmVudHMsIFQgPT09IHZvaWQgMCA/IChUID0gbS5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG0uX2V2ZW50c0NvdW50ID0gMCkgOiAoVC5uZXdMaXN0ZW5lciAhPT0gdm9pZCAwICYmIChtLmVtaXQoXG4gICAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgICBmLFxuICAgICAgYi5saXN0ZW5lciA/IGIubGlzdGVuZXIgOiBiXG4gICAgKSwgVCA9IG0uX2V2ZW50cyksIE0gPSBUW2ZdKSwgTSA9PT0gdm9pZCAwKVxuICAgICAgTSA9IFRbZl0gPSBiLCArK20uX2V2ZW50c0NvdW50O1xuICAgIGVsc2UgaWYgKHR5cGVvZiBNID09IFwiZnVuY3Rpb25cIiA/IE0gPSBUW2ZdID0gZyA/IFtiLCBNXSA6IFtNLCBiXSA6IGcgPyBNLnVuc2hpZnQoYikgOiBNLnB1c2goYiksIHkgPSB1KG0pLCB5ID4gMCAmJiBNLmxlbmd0aCA+IHkgJiYgIU0ud2FybmVkKSB7XG4gICAgICBNLndhcm5lZCA9ICEwO1xuICAgICAgdmFyIFAgPSBuZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiICsgTS5sZW5ndGggKyBcIiBcIiArIFN0cmluZyhmKSArIFwiIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRcIik7XG4gICAgICBQLm5hbWUgPSBcIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLCBQLmVtaXR0ZXIgPSBtLCBQLnR5cGUgPSBmLCBQLmNvdW50ID0gTS5sZW5ndGgsIHIoUCk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9XG4gIGMucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZiwgYikge1xuICAgIHJldHVybiBwKHRoaXMsIGYsIGIsICExKTtcbiAgfSwgYy5wcm90b3R5cGUub24gPSBjLnByb3RvdHlwZS5hZGRMaXN0ZW5lciwgYy5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24oZiwgYikge1xuICAgIHJldHVybiBwKHRoaXMsIGYsIGIsICEwKTtcbiAgfTtcbiAgZnVuY3Rpb24gaCgpIHtcbiAgICBpZiAoIXRoaXMuZmlyZWQpXG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbiksIHRoaXMuZmlyZWQgPSAhMCwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCkgOiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQobSwgZiwgYikge1xuICAgIHZhciBnID0geyBmaXJlZDogITEsIHdyYXBGbjogdm9pZCAwLCB0YXJnZXQ6IG0sIHR5cGU6IGYsIGxpc3RlbmVyOiBiIH0sIHkgPSBoLmJpbmQoZyk7XG4gICAgcmV0dXJuIHkubGlzdGVuZXIgPSBiLCBnLndyYXBGbiA9IHksIHk7XG4gIH1cbiAgYy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGYsIGIpIHtcbiAgICByZXR1cm4gaShiKSwgdGhpcy5vbihmLCBkKHRoaXMsIGYsIGIpKSwgdGhpcztcbiAgfSwgYy5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGYsIGIpIHtcbiAgICByZXR1cm4gaShiKSwgdGhpcy5wcmVwZW5kTGlzdGVuZXIoZiwgZCh0aGlzLCBmLCBiKSksIHRoaXM7XG4gIH0sIGMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZiwgYikge1xuICAgIHZhciBnLCB5LCBULCBNLCBQO1xuICAgIGlmIChpKGIpLCB5ID0gdGhpcy5fZXZlbnRzLCB5ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoZyA9IHlbZl0sIGcgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmIChnID09PSBiIHx8IGcubGlzdGVuZXIgPT09IGIpXG4gICAgICAtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwID8gdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkgOiAoZGVsZXRlIHlbZl0sIHkucmVtb3ZlTGlzdGVuZXIgJiYgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgZiwgZy5saXN0ZW5lciB8fCBiKSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGcgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKFQgPSAtMSwgTSA9IGcubGVuZ3RoIC0gMTsgTSA+PSAwOyBNLS0pXG4gICAgICAgIGlmIChnW01dID09PSBiIHx8IGdbTV0ubGlzdGVuZXIgPT09IGIpIHtcbiAgICAgICAgICBQID0gZ1tNXS5saXN0ZW5lciwgVCA9IE07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGlmIChUIDwgMClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBUID09PSAwID8gZy5zaGlmdCgpIDogayhnLCBUKSwgZy5sZW5ndGggPT09IDEgJiYgKHlbZl0gPSBnWzBdKSwgeS5yZW1vdmVMaXN0ZW5lciAhPT0gdm9pZCAwICYmIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIGYsIFAgfHwgYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LCBjLnByb3RvdHlwZS5vZmYgPSBjLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciwgYy5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBiLCBnLCB5O1xuICAgIGlmIChnID0gdGhpcy5fZXZlbnRzLCBnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoZy5yZW1vdmVMaXN0ZW5lciA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyAodGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCkgOiBnW2ZdICE9PSB2b2lkIDAgJiYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDAgPyB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGRlbGV0ZSBnW2ZdKSwgdGhpcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIFQgPSBPYmplY3Qua2V5cyhnKSwgTTtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBULmxlbmd0aDsgKyt5KVxuICAgICAgICBNID0gVFt5XSwgTSAhPT0gXCJyZW1vdmVMaXN0ZW5lclwiICYmIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKE0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksIHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLl9ldmVudHNDb3VudCA9IDAsIHRoaXM7XG4gICAgfVxuICAgIGlmIChiID0gZ1tmXSwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihmLCBiKTtcbiAgICBlbHNlIGlmIChiICE9PSB2b2lkIDApXG4gICAgICBmb3IgKHkgPSBiLmxlbmd0aCAtIDE7IHkgPj0gMDsgeS0tKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGYsIGJbeV0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBsKG0sIGYsIGIpIHtcbiAgICB2YXIgZyA9IG0uX2V2ZW50cztcbiAgICBpZiAoZyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIHZhciB5ID0gZ1tmXTtcbiAgICByZXR1cm4geSA9PT0gdm9pZCAwID8gW10gOiB0eXBlb2YgeSA9PSBcImZ1bmN0aW9uXCIgPyBiID8gW3kubGlzdGVuZXIgfHwgeV0gOiBbeV0gOiBiID8gQSh5KSA6IEMoeSwgeS5sZW5ndGgpO1xuICB9XG4gIGMucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gbCh0aGlzLCBmLCAhMCk7XG4gIH0sIGMucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gbCh0aGlzLCBmLCAhMSk7XG4gIH0sIGMubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKG0sIGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIG0ubGlzdGVuZXJDb3VudCA9PSBcImZ1bmN0aW9uXCIgPyBtLmxpc3RlbmVyQ291bnQoZikgOiB2LmNhbGwobSwgZik7XG4gIH0sIGMucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSB2O1xuICBmdW5jdGlvbiB2KG0pIHtcbiAgICB2YXIgZiA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZiAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgYiA9IGZbbV07XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmIChiICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgYy5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyB0KHRoaXMuX2V2ZW50cykgOiBbXTtcbiAgfTtcbiAgZnVuY3Rpb24gQyhtLCBmKSB7XG4gICAgZm9yICh2YXIgYiA9IG5ldyBBcnJheShmKSwgZyA9IDA7IGcgPCBmOyArK2cpXG4gICAgICBiW2ddID0gbVtnXTtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBmdW5jdGlvbiBrKG0sIGYpIHtcbiAgICBmb3IgKDsgZiArIDEgPCBtLmxlbmd0aDsgZisrKVxuICAgICAgbVtmXSA9IG1bZiArIDFdO1xuICAgIG0ucG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gQShtKSB7XG4gICAgZm9yICh2YXIgZiA9IG5ldyBBcnJheShtLmxlbmd0aCksIGIgPSAwOyBiIDwgZi5sZW5ndGg7ICsrYilcbiAgICAgIGZbYl0gPSBtW2JdLmxpc3RlbmVyIHx8IG1bYl07XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZnVuY3Rpb24gdyhtLCBmKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgIGZ1bmN0aW9uIHkoTSkge1xuICAgICAgICBtLnJlbW92ZUxpc3RlbmVyKGYsIFQpLCBnKE0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgdHlwZW9mIG0ucmVtb3ZlTGlzdGVuZXIgPT0gXCJmdW5jdGlvblwiICYmIG0ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB5KSwgYihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgUihtLCBmLCBULCB7IG9uY2U6ICEwIH0pLCBmICE9PSBcImVycm9yXCIgJiYgTyhtLCB5LCB7IG9uY2U6ICEwIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIE8obSwgZiwgYikge1xuICAgIHR5cGVvZiBtLm9uID09IFwiZnVuY3Rpb25cIiAmJiBSKG0sIFwiZXJyb3JcIiwgZiwgYik7XG4gIH1cbiAgZnVuY3Rpb24gUihtLCBmLCBiLCBnKSB7XG4gICAgaWYgKHR5cGVvZiBtLm9uID09IFwiZnVuY3Rpb25cIilcbiAgICAgIGcub25jZSA/IG0ub25jZShmLCBiKSA6IG0ub24oZiwgYik7XG4gICAgZWxzZSBpZiAodHlwZW9mIG0uYWRkRXZlbnRMaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICBtLmFkZEV2ZW50TGlzdGVuZXIoZiwgZnVuY3Rpb24geShUKSB7XG4gICAgICAgIGcub25jZSAmJiBtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZiwgeSksIGIoVCk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIG0pO1xuICB9XG4gIHJldHVybiBuZS5leHBvcnRzO1xufVxudmFyIGhlID0gdW4oKTtcbmNvbnN0IGxuID0gMmU0O1xudmFyIGRuID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQ2FtZXJhQ2hhbmdlZCA9IFwiY2FtZXJhQ2hhbmdlZFwiLCBlLk1pY3JvcGhvbmVDaGFuZ2VkID0gXCJtaWNyb3Bob25lQ2hhbmdlZFwiLCBlLlN0YXRlQ2hhbmdlZCA9IFwic3RhdGVDaGFuZ2VkXCIsIGUpKShkbiB8fCB7fSk7XG5jb25zdCB4ID0gKGUpID0+ICh7XG4gIGlzQ29ubmVjdGVkOiBlID09PSBcImxpc3RlbmluZ1wiIHx8IGUgPT09IFwidGhpbmtpbmdcIiB8fCBlID09PSBcInNwZWFraW5nXCIsXG4gIGNhbkxpc3RlbjogZSA9PT0gXCJwcmUtY29ubmVjdC1idWZmZXJpbmdcIiB8fCBlID09PSBcImxpc3RlbmluZ1wiIHx8IGUgPT09IFwidGhpbmtpbmdcIiB8fCBlID09PSBcInNwZWFraW5nXCIsXG4gIGlzRmluaXNoZWQ6IGUgPT09IFwiZGlzY29ubmVjdGVkXCIgfHwgZSA9PT0gXCJmYWlsZWRcIixcbiAgaXNQZW5kaW5nOiBlID09PSBcImNvbm5lY3RpbmdcIiB8fCBlID09PSBcImluaXRpYWxpemluZ1wiIHx8IGUgPT09IFwiaWRsZVwiXG59KSwgZm4gPSAoKSA9PiB7XG4gIGNvbnN0IFtlLCBuXSA9IHMudXNlU3RhdGUoXG4gICAgbnVsbFxuICApLCBbdCwgcl0gPSBzLnVzZVN0YXRlKFxuICAgIG51bGxcbiAgKSwgbyA9IHMudXNlUmVmKFwiY29ubmVjdGluZ1wiKSwgYyA9IHMudXNlUmVmKCExKSwgYSA9IChpKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWMuY3VycmVudCkge1xuICAgICAgbihcIkFnZW50IGRpZCBub3Qgam9pbiB0aGUgcm9vbS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgaXNDb25uZWN0ZWQ6IHUgfSA9IHgoby5jdXJyZW50KTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIG4oXCJBZ2VudCBqb2luZWQgdGhlIHJvb20gYnV0IGRpZCBub3QgY29tcGxldGUgaW5pdGlhbGl6aW5nLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sIGkgPz8gbG4pO1xuICByZXR1cm4ge1xuICAgIGFnZW50VGltZW91dEZhaWx1cmVSZWFzb246IGUsXG4gICAgc3RhcnRBZ2VudFRpbWVvdXQ6IHMudXNlQ2FsbGJhY2soXG4gICAgICAoaSkgPT4ge1xuICAgICAgICB0ICYmIGNsZWFyVGltZW91dCh0KSwgbihudWxsKSwgcihhKGkpKSwgby5jdXJyZW50ID0gXCJjb25uZWN0aW5nXCIsIGMuY3VycmVudCA9ICExO1xuICAgICAgfSxcbiAgICAgIFt0XVxuICAgICksXG4gICAgY2xlYXJBZ2VudFRpbWVvdXQ6IHMudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdCAmJiBjbGVhclRpbWVvdXQodCksIG4obnVsbCksIHIobnVsbCksIG8uY3VycmVudCA9IFwiY29ubmVjdGluZ1wiLCBjLmN1cnJlbnQgPSAhMTtcbiAgICB9LCBbdF0pLFxuICAgIGNsZWFyQWdlbnRUaW1lb3V0RmFpbHVyZVJlYXNvbjogcy51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBuKG51bGwpO1xuICAgIH0sIFtdKSxcbiAgICB1cGRhdGVBZ2VudFRpbWVvdXRTdGF0ZTogcy51c2VDYWxsYmFjaygoaSkgPT4ge1xuICAgICAgby5jdXJyZW50ID0gaTtcbiAgICB9LCBbXSksXG4gICAgdXBkYXRlQWdlbnRUaW1lb3V0UGFydGljaXBhbnRFeGlzdHM6IHMudXNlQ2FsbGJhY2soKGkpID0+IHtcbiAgICAgIGMuY3VycmVudCA9IGk7XG4gICAgfSwgW10pXG4gIH07XG59O1xuZnVuY3Rpb24gbW4oZSwgbikge1xuICBjb25zdCB0ID0gcy51c2VSZWYobik7XG4gIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB0LmN1cnJlbnQgPSBuO1xuICB9LCBbbl0pO1xuICBjb25zdCByID0gcy51c2VDYWxsYmFjayhcbiAgICBhc3luYyAoYSkgPT4ge1xuICAgICAgY29uc3QgeyBpc0Nvbm5lY3RlZDogaSB9ID0geCh0LmN1cnJlbnQpO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHUsIHApID0+IHtcbiAgICAgICAgICBjb25zdCBoID0gKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDb25uZWN0ZWQ6IEMgfSA9IHgodik7XG4gICAgICAgICAgICBDICYmIChsKCksIHUoKSk7XG4gICAgICAgICAgfSwgZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGwoKSwgcChuZXcgRXJyb3IoXCJ1c2VBZ2VudCgvKiAuLi4gKi8pLndhaXRVbnRpbENvbm5lY3RlZCAtIHNpZ25hbCBhYm9ydGVkXCIpKTtcbiAgICAgICAgICB9LCBsID0gKCkgPT4ge1xuICAgICAgICAgICAgZS5vZmYoXCJzdGF0ZUNoYW5nZWRcIiwgaCksIGEgPT0gbnVsbCB8fCBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBkKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGUub24oXCJzdGF0ZUNoYW5nZWRcIiwgaCksIGEgPT0gbnVsbCB8fCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBbZV1cbiAgKSwgbyA9IHMudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGEpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FuTGlzdGVuOiBpIH0gPSB4KHQuY3VycmVudCk7XG4gICAgICBpZiAoIWkpXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgodSwgcCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGggPSAodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYW5MaXN0ZW46IEMgfSA9IHgodik7XG4gICAgICAgICAgICBDICYmIChsKCksIHUoKSk7XG4gICAgICAgICAgfSwgZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGwoKSwgcChuZXcgRXJyb3IoXCJ1c2VBZ2VudCgvKiAuLi4gKi8pLndhaXRVbnRpbENvdWxkQmVMaXN0ZW5pbmcgLSBzaWduYWwgYWJvcnRlZFwiKSk7XG4gICAgICAgICAgfSwgbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGUub2ZmKFwic3RhdGVDaGFuZ2VkXCIsIGgpLCBhID09IG51bGwgfHwgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlLm9uKFwic3RhdGVDaGFuZ2VkXCIsIGgpLCBhID09IG51bGwgfHwgYS5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgW2VdXG4gICksIGMgPSBzLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChhKSA9PiB7XG4gICAgICBjb25zdCB7IGlzRmluaXNoZWQ6IGkgfSA9IHgodC5jdXJyZW50KTtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCh1LCBwKSA9PiB7XG4gICAgICAgICAgY29uc3QgaCA9ICh2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlzRmluaXNoZWQ6IEMgfSA9IHgodik7XG4gICAgICAgICAgICBDICYmIChsKCksIHUoKSk7XG4gICAgICAgICAgfSwgZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGwoKSwgcChuZXcgRXJyb3IoXCJ1c2VBZ2VudCgvKiAuLi4gKi8pLndhaXRVbnRpbEZpbmlzaGVkIC0gc2lnbmFsIGFib3J0ZWRcIikpO1xuICAgICAgICAgIH0sIGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBlLm9mZihcInN0YXRlQ2hhbmdlZFwiLCBoKSwgYSA9PSBudWxsIHx8IGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZS5vbihcInN0YXRlQ2hhbmdlZFwiLCBoKSwgYSA9PSBudWxsIHx8IGEuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFtlXVxuICApO1xuICByZXR1cm4geyB3YWl0VW50aWxDb25uZWN0ZWQ6IHIsIHdhaXRVbnRpbENvdWxkQmVMaXN0ZW5pbmc6IG8sIHdhaXRVbnRpbEZpbmlzaGVkOiBjIH07XG59XG5mdW5jdGlvbiBJZShlKSB7XG4gIGNvbnN0IG4gPSBSdCgpO1xuICBpZiAoZSA9IGUgPz8gbiwgIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJObyBzZXNzaW9uIHByb3ZpZGVkLCBtYWtlIHN1cmUgeW91IGFyZSBpbnNpZGUgYSBTZXNzaW9uIGNvbnRleHQgb3IgcGFzcyB0aGUgc2Vzc2lvbiBleHBsaWNpdGx5XCJcbiAgICApO1xuICBjb25zdCB7XG4gICAgcm9vbTogdCxcbiAgICBpbnRlcm5hbDoge1xuICAgICAgYWdlbnRDb25uZWN0VGltZW91dE1pbGxpc2Vjb25kczogcixcbiAgICAgIGFnZW50VGltZW91dEZhaWx1cmVSZWFzb246IG8sXG4gICAgICBzdGFydEFnZW50VGltZW91dDogYyxcbiAgICAgIGNsZWFyQWdlbnRUaW1lb3V0OiBhLFxuICAgICAgY2xlYXJBZ2VudFRpbWVvdXRGYWlsdXJlUmVhc29uOiBpLFxuICAgICAgdXBkYXRlQWdlbnRUaW1lb3V0U3RhdGU6IHUsXG4gICAgICB1cGRhdGVBZ2VudFRpbWVvdXRQYXJ0aWNpcGFudEV4aXN0czogcFxuICAgIH1cbiAgfSA9IGUsIGggPSBzLnVzZU1lbW8oKCkgPT4gbmV3IGhlLkV2ZW50RW1pdHRlcigpLCBbXSksIGQgPSBwZSh7IHJvb206IHQgfSksIGwgPSBzLnVzZU1lbW8oKCkgPT4gZC5maW5kKFxuICAgIChTKSA9PiBTLmtpbmQgPT09IHNlLkFHRU5UICYmICEoVy5QdWJsaXNoT25CZWhhbGYgaW4gUy5hdHRyaWJ1dGVzKVxuICApID8/IG51bGwsIFtkXSksIHYgPSBzLnVzZU1lbW8oKCkgPT4gbCA/IGQuZmluZChcbiAgICAoUykgPT4gUy5raW5kID09PSBzZS5BR0VOVCAmJiBTLmF0dHJpYnV0ZXNbVy5QdWJsaXNoT25CZWhhbGZdID09PSBsLmlkZW50aXR5XG4gICkgPz8gbnVsbCA6IG51bGwsIFtsLCBkXSksIFtDLCBrXSA9IHMudXNlU3RhdGUoe30pO1xuICBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFMgPSAoXykgPT4ge1xuICAgICAgayhfKTtcbiAgICB9O1xuICAgIHJldHVybiBsLm9uKFguQXR0cmlidXRlc0NoYW5nZWQsIFMpLCAoKSA9PiB7XG4gICAgICBsLm9mZihYLkF0dHJpYnV0ZXNDaGFuZ2VkLCBTKTtcbiAgICB9O1xuICB9LCBbbCwgaF0pO1xuICBjb25zdCBBID0gcmUoW0UuU291cmNlLkNhbWVyYSwgRS5Tb3VyY2UuTWljcm9waG9uZV0sIHtcbiAgICByb29tOiB0LFxuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuaWRlbnRpdHlcbiAgfSksIHcgPSByZShbRS5Tb3VyY2UuQ2FtZXJhLCBFLlNvdXJjZS5NaWNyb3Bob25lXSwge1xuICAgIHJvb206IHQsXG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogdiA9PSBudWxsID8gdm9pZCAwIDogdi5pZGVudGl0eVxuICB9KSwgTyA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBBLmZpbmQoKFMpID0+IFMuc291cmNlID09PSBFLlNvdXJjZS5DYW1lcmEpID8/IHcuZmluZCgoUykgPT4gUy5zb3VyY2UgPT09IEUuU291cmNlLkNhbWVyYSksXG4gICAgW0EsIHddXG4gICk7XG4gIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBoLmVtaXQoXCJjYW1lcmFDaGFuZ2VkXCIsIE8pO1xuICB9LCBbaCwgT10pO1xuICBjb25zdCBSID0gcy51c2VNZW1vKFxuICAgICgpID0+IEEuZmluZCgoUykgPT4gUy5zb3VyY2UgPT09IEUuU291cmNlLk1pY3JvcGhvbmUpID8/IHcuZmluZCgoUykgPT4gUy5zb3VyY2UgPT09IEUuU291cmNlLk1pY3JvcGhvbmUpLFxuICAgIFtBLCB3XVxuICApO1xuICBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaC5lbWl0KFwibWljcm9waG9uZUNoYW5nZWRcIiwgUik7XG4gIH0sIFtoLCBSXSk7XG4gIGNvbnN0IFttLCBmXSA9IHMudXNlU3RhdGUodC5zdGF0ZSk7XG4gIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBTID0gKF8pID0+IHtcbiAgICAgIGYoXyk7XG4gICAgfTtcbiAgICByZXR1cm4gdC5vbihILkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIFMpLCAoKSA9PiB7XG4gICAgICB0Lm9mZihILkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIFMpO1xuICAgIH07XG4gIH0sIFt0XSksIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsICYmIGkoKTtcbiAgfSwgW2xdKTtcbiAgY29uc3QgW2IsIGddID0gcy51c2VTdGF0ZShudWxsKTtcbiAgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBTID0gKF8pID0+IHtcbiAgICAgIF8uaWRlbnRpdHkgPT09IChsID09IG51bGwgPyB2b2lkIDAgOiBsLmlkZW50aXR5KSAmJiBnKFwiQWdlbnQgbGVmdCB0aGUgcm9vbSB1bmV4cGVjdGVkbHkuXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIHQub24oSC5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCwgUyksICgpID0+IHtcbiAgICAgIHQub2ZmKEguUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIFMpO1xuICAgIH07XG4gIH0sIFtsLCB0XSksIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBtID09PSBJLkRpc2Nvbm5lY3RlZCAmJiBnKG51bGwpO1xuICB9LCBbbV0pO1xuICBjb25zdCBbeSwgVF0gPSBzLnVzZVN0YXRlKFxuICAgICgpID0+IHQubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKEUuU291cmNlLk1pY3JvcGhvbmUpID8/IG51bGxcbiAgKTtcbiAgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IFMgPSAoKSA9PiB7XG4gICAgICBUKHQubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKEUuU291cmNlLk1pY3JvcGhvbmUpID8/IG51bGwpO1xuICAgIH0sIF8gPSAoKSA9PiB7XG4gICAgICBUKG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIHQubG9jYWxQYXJ0aWNpcGFudC5vbihcbiAgICAgIFguTG9jYWxUcmFja1B1Ymxpc2hlZCxcbiAgICAgIFNcbiAgICApLCB0LmxvY2FsUGFydGljaXBhbnQub24oXG4gICAgICBYLkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCxcbiAgICAgIF9cbiAgICApLCAoKSA9PiB7XG4gICAgICB0LmxvY2FsUGFydGljaXBhbnQub2ZmKFxuICAgICAgICBYLkxvY2FsVHJhY2tQdWJsaXNoZWQsXG4gICAgICAgIFNcbiAgICAgICksIHQubG9jYWxQYXJ0aWNpcGFudC5vZmYoXG4gICAgICAgIFguTG9jYWxUcmFja1VucHVibGlzaGVkLFxuICAgICAgICBfXG4gICAgICApO1xuICAgIH07XG4gIH0sIFt0LmxvY2FsUGFydGljaXBhbnRdKTtcbiAgY29uc3QgTSA9IHMudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgUyA9IFtdO1xuICAgIHJldHVybiBvICYmIFMucHVzaChvKSwgYiAmJiBTLnB1c2goYiksIFM7XG4gIH0sIFtvLCBiXSksIFAgPSBzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChNLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gXCJmYWlsZWRcIjtcbiAgICBsZXQgUyA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgcmV0dXJuIG0gIT09IEkuRGlzY29ubmVjdGVkICYmIChTID0gXCJjb25uZWN0aW5nXCIpLCB5ICYmIChTID0gXCJwcmUtY29ubmVjdC1idWZmZXJpbmdcIiksIGwgJiYgQ1tXLkFnZW50U3RhdGVdICYmIChTID0gQ1tXLkFnZW50U3RhdGVdKSwgUztcbiAgfSwgW1xuICAgIE0sXG4gICAgbSxcbiAgICB5LFxuICAgIGwsXG4gICAgQ1xuICBdKTtcbiAgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGguZW1pdChcInN0YXRlQ2hhbmdlZFwiLCBQKSwgdShQKTtcbiAgfSwgW2gsIFBdKSwgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHAobCAhPT0gbnVsbCk7XG4gIH0sIFtsXSk7XG4gIGNvbnN0IEYgPSBlLmNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghRilcbiAgICAgIHJldHVybiBjKHIpLCAoKSA9PiB7XG4gICAgICAgIGEoKTtcbiAgICAgIH07XG4gIH0sIFtGLCByXSk7XG4gIGNvbnN0IHEgPSBzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFMgPSB7XG4gICAgICBhdHRyaWJ1dGVzOiBDLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgYWdlbnRQYXJ0aWNpcGFudDogbCxcbiAgICAgICAgd29ya2VyUGFydGljaXBhbnQ6IHYsXG4gICAgICAgIGVtaXR0ZXI6IGhcbiAgICAgIH1cbiAgICB9O1xuICAgIHN3aXRjaCAoUCkge1xuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLlMsXG4gICAgICAgICAgc3RhdGU6IFAsXG4gICAgICAgICAgLi4ueChQKSxcbiAgICAgICAgICBmYWlsdXJlUmVhc29uczogbnVsbCxcbiAgICAgICAgICAvLyBDbGVhciBpbm5lciB2YWx1ZXMgaWYgbm8gbG9uZ2VyIGNvbm5lY3RlZFxuICAgICAgICAgIGNhbWVyYVRyYWNrOiB2b2lkIDAsXG4gICAgICAgICAgbWljcm9waG9uZVRyYWNrOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uUyxcbiAgICAgICAgICBzdGF0ZTogUCxcbiAgICAgICAgICAuLi54KFApLFxuICAgICAgICAgIGZhaWx1cmVSZWFzb25zOiBudWxsLFxuICAgICAgICAgIC8vIENsZWFyIGlubmVyIHZhbHVlcyBpZiBubyBsb25nZXIgY29ubmVjdGVkXG4gICAgICAgICAgY2FtZXJhVHJhY2s6IHZvaWQgMCxcbiAgICAgICAgICBtaWNyb3Bob25lVHJhY2s6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgY2FzZSBcImluaXRpYWxpemluZ1wiOlxuICAgICAgY2FzZSBcImlkbGVcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5TLFxuICAgICAgICAgIHN0YXRlOiBQLFxuICAgICAgICAgIC4uLngoUCksXG4gICAgICAgICAgZmFpbHVyZVJlYXNvbnM6IG51bGwsXG4gICAgICAgICAgY2FtZXJhVHJhY2s6IE8sXG4gICAgICAgICAgbWljcm9waG9uZVRyYWNrOiBSXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwicHJlLWNvbm5lY3QtYnVmZmVyaW5nXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uUyxcbiAgICAgICAgICBzdGF0ZTogUCxcbiAgICAgICAgICAuLi54KFApLFxuICAgICAgICAgIGZhaWx1cmVSZWFzb25zOiBudWxsLFxuICAgICAgICAgIGNhbWVyYVRyYWNrOiBPLFxuICAgICAgICAgIG1pY3JvcGhvbmVUcmFjazogUlxuICAgICAgICB9O1xuICAgICAgY2FzZSBcImxpc3RlbmluZ1wiOlxuICAgICAgY2FzZSBcInRoaW5raW5nXCI6XG4gICAgICBjYXNlIFwic3BlYWtpbmdcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5TLFxuICAgICAgICAgIHN0YXRlOiBQLFxuICAgICAgICAgIC4uLngoUCksXG4gICAgICAgICAgZmFpbHVyZVJlYXNvbnM6IG51bGwsXG4gICAgICAgICAgY2FtZXJhVHJhY2s6IE8sXG4gICAgICAgICAgbWljcm9waG9uZVRyYWNrOiBSXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uUyxcbiAgICAgICAgICBzdGF0ZTogXCJmYWlsZWRcIixcbiAgICAgICAgICAuLi54KFwiZmFpbGVkXCIpLFxuICAgICAgICAgIGZhaWx1cmVSZWFzb25zOiBNLFxuICAgICAgICAgIC8vIENsZWFyIGlubmVyIHZhbHVlcyBpZiBubyBsb25nZXIgY29ubmVjdGVkXG4gICAgICAgICAgY2FtZXJhVHJhY2s6IHZvaWQgMCxcbiAgICAgICAgICBtaWNyb3Bob25lVHJhY2s6IHZvaWQgMFxuICAgICAgICB9O1xuICAgIH1cbiAgfSwgW0MsIGgsIGwsIFAsIE8sIFJdKSwgeyB3YWl0VW50aWxDb25uZWN0ZWQ6IEosIHdhaXRVbnRpbENvdWxkQmVMaXN0ZW5pbmc6IEssIHdhaXRVbnRpbEZpbmlzaGVkOiBMIH0gPSBtbihoLCBQKSwgTiA9IHMudXNlQ2FsbGJhY2soXG4gICAgKFMpID0+IG5ldyBQcm9taXNlKChfLCBZKSA9PiB7XG4gICAgICBjb25zdCBCID0gKHopID0+IHtcbiAgICAgICAgeiAmJiAoJCgpLCBfKHopKTtcbiAgICAgIH0sIGogPSAoKSA9PiB7XG4gICAgICAgICQoKSwgWShuZXcgRXJyb3IoXCJ1c2VBZ2VudCgvKiAuLi4gKi8pLndhaXRVbnRpbENhbWVyYSAtIHNpZ25hbCBhYm9ydGVkXCIpKTtcbiAgICAgIH0sICQgPSAoKSA9PiB7XG4gICAgICAgIGgub2ZmKFwiY2FtZXJhQ2hhbmdlZFwiLCBCKSwgUyA9PSBudWxsIHx8IFMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGopO1xuICAgICAgfTtcbiAgICAgIGgub24oXCJjYW1lcmFDaGFuZ2VkXCIsIEIpLCBTID09IG51bGwgfHwgUy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaik7XG4gICAgfSksXG4gICAgW2hdXG4gICksIFogPSBzLnVzZUNhbGxiYWNrKFxuICAgIChTKSA9PiBuZXcgUHJvbWlzZSgoXywgWSkgPT4ge1xuICAgICAgY29uc3QgQiA9ICh6KSA9PiB7XG4gICAgICAgIHogJiYgKCQoKSwgXyh6KSk7XG4gICAgICB9LCBqID0gKCkgPT4ge1xuICAgICAgICAkKCksIFkobmV3IEVycm9yKFwidXNlQWdlbnQoLyogLi4uICovKS53YWl0VW50aWxNaWNyb3Bob25lIC0gc2lnbmFsIGFib3J0ZWRcIikpO1xuICAgICAgfSwgJCA9ICgpID0+IHtcbiAgICAgICAgaC5vZmYoXCJtaWNyb3Bob25lQ2hhbmdlZFwiLCBCKSwgUyA9PSBudWxsIHx8IFMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGopO1xuICAgICAgfTtcbiAgICAgIGgub24oXCJtaWNyb3Bob25lQ2hhbmdlZFwiLCBCKSwgUyA9PSBudWxsIHx8IFMuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGopO1xuICAgIH0pLFxuICAgIFtoXVxuICApO1xuICByZXR1cm4gcy51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucSxcbiAgICB3YWl0VW50aWxDb25uZWN0ZWQ6IEosXG4gICAgd2FpdFVudGlsQ291bGRCZUxpc3RlbmluZzogSyxcbiAgICB3YWl0VW50aWxGaW5pc2hlZDogTCxcbiAgICB3YWl0VW50aWxDYW1lcmE6IE4sXG4gICAgd2FpdFVudGlsTWljcm9waG9uZTogWlxuICB9KSwgW1xuICAgIHEsXG4gICAgSixcbiAgICBLLFxuICAgIEwsXG4gICAgTixcbiAgICBaXG4gIF0pO1xufVxudmFyIHBuID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiLCBlLk1lZGlhRGV2aWNlc0Vycm9yID0gXCJtZWRpYURldmljZXNFcnJvclwiLCBlLkVuY3J5cHRpb25FcnJvciA9IFwiZW5jcnlwdGlvbkVycm9yXCIsIGUpKShwbiB8fCB7fSk7XG5mdW5jdGlvbiBobihlLCBuKSB7XG4gIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uT2JqZWN0LmtleXMoZSksIC4uLk9iamVjdC5rZXlzKG4pXSk7XG4gIGZvciAoY29uc3QgciBvZiB0KVxuICAgIHN3aXRjaCAocikge1xuICAgICAgY2FzZSBcInJvb21OYW1lXCI6XG4gICAgICBjYXNlIFwicGFydGljaXBhbnROYW1lXCI6XG4gICAgICBjYXNlIFwicGFydGljaXBhbnRJZGVudGl0eVwiOlxuICAgICAgY2FzZSBcInBhcnRpY2lwYW50TWV0YWRhdGFcIjpcbiAgICAgIGNhc2UgXCJwYXJ0aWNpcGFudEF0dHJpYnV0ZXNcIjpcbiAgICAgIGNhc2UgXCJhZ2VudE5hbWVcIjpcbiAgICAgIGNhc2UgXCJhZ2VudE1ldGFkYXRhXCI6XG4gICAgICAgIGlmIChlW3JdICE9PSBuW3JdKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCBvID0gcjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb25zIGtleSAke299IG5vdCBiZWluZyBjaGVja2VkIGZvciBlcXVhbGl0eSFgKTtcbiAgICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGJuKGUsIG4pIHtcbiAgY29uc3QgdCA9IHMudXNlUmVmKG4pO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHQuY3VycmVudCA9IG47XG4gIH0sIFtuXSksIHMudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG8sIGMpID0+IHtcbiAgICAgIGlmICh0LmN1cnJlbnQgIT09IG8pXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYSwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHUgPSAoZCkgPT4ge1xuICAgICAgICAgICAgZCA9PT0gbyAmJiAoaCgpLCBhKCkpO1xuICAgICAgICAgIH0sIHAgPSAoKSA9PiB7XG4gICAgICAgICAgICBoKCksIGkoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgdXNlU2Vzc2lvbigvKiAuLi4gKi8pLndhaXRVbnRpbENvbm5lY3Rpb25TdGF0ZSgke299LCAvKiBzaWduYWwgKi8pIC0gc2lnbmFsIGFib3J0ZWRgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGUub2ZmKFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiLCB1KSwgYyA9PSBudWxsIHx8IGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZS5vbihcImNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcIiwgdSksIGMgPT0gbnVsbCB8fCBjLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBbZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGduKGUsIG4pIHtcbiAgY29uc3QgdCA9IGUgaW5zdGFuY2VvZiBGdCwgciA9IHMudXNlUmVmKFxuICAgIHQgPyBuIDogbnVsbFxuICApO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdCkge1xuICAgICAgci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5jdXJyZW50ICE9PSBudWxsICYmIGhuKHIuY3VycmVudCwgbikgfHwgKHIuY3VycmVudCA9IG4pO1xuICB9LCBbdCwgbl0pLCBzLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAodCkge1xuICAgICAgaWYgKCFyLmN1cnJlbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkFnZW50U2Vzc2lvbiAtIG1lbW9pemVkIHRva2VuIGZldGNoIG9wdGlvbnMgYXJlIG5vdCBzZXQsIGJ1dCB0aGUgcGFzc2VkIHRva2VuU291cmNlIHdhcyBhbiBpbnN0YW5jZSBvZiBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZS4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBwbGVhc2UgbWFrZSBhIG5ldyBHaXRIdWIgaXNzdWUhXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBlLmZldGNoKHIuY3VycmVudCk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZS5mZXRjaCgpO1xuICB9LCBbdCwgZV0pO1xufVxuZnVuY3Rpb24gaXMoZSwgbiA9IHt9KSB7XG4gIGNvbnN0IHsgcm9vbTogdCwgYWdlbnRDb25uZWN0VGltZW91dE1pbGxpc2Vjb25kczogciwgLi4ubyB9ID0gbiwgYyA9IGRlKCksIGEgPSBzLnVzZU1lbW8oXG4gICAgKCkgPT4gYyA/PyB0ID8/IG5ldyBEZSgpLFxuICAgIFtjLCB0XVxuICApLCBpID0gcy51c2VNZW1vKFxuICAgICgpID0+IG5ldyBoZS5FdmVudEVtaXR0ZXIoKSxcbiAgICBbXVxuICApLCB1ID0gcy51c2VDYWxsYmFjayhcbiAgICAoTCkgPT4gKHtcbiAgICAgIGlzQ29ubmVjdGVkOiBMID09PSBJLkNvbm5lY3RlZCB8fCBMID09PSBJLlJlY29ubmVjdGluZyB8fCBMID09PSBJLlNpZ25hbFJlY29ubmVjdGluZ1xuICAgIH0pLFxuICAgIFtdXG4gICksIFtwLCBoXSA9IHMudXNlU3RhdGUoYS5zdGF0ZSk7XG4gIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBMID0gKE4pID0+IHtcbiAgICAgIGgoTik7XG4gICAgfTtcbiAgICByZXR1cm4gYS5vbihILkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIEwpLCAoKSA9PiB7XG4gICAgICBhLm9mZihILkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIEwpO1xuICAgIH07XG4gIH0sIFthXSksIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBMID0gYXN5bmMgKE4pID0+IHtcbiAgICAgIGkuZW1pdChcIm1lZGlhRGV2aWNlc0Vycm9yXCIsIE4pO1xuICAgIH07XG4gICAgcmV0dXJuIGEub24oSC5NZWRpYURldmljZXNFcnJvciwgTCksICgpID0+IHtcbiAgICAgIGEub2ZmKEguTWVkaWFEZXZpY2VzRXJyb3IsIEwpO1xuICAgIH07XG4gIH0sIFthLCBpXSksIHMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBMID0gYXN5bmMgKE4pID0+IHtcbiAgICAgIGkuZW1pdChcImVuY3J5cHRpb25FcnJvclwiLCBOKTtcbiAgICB9O1xuICAgIHJldHVybiBhLm9uKEguRW5jcnlwdGlvbkVycm9yLCBMKSwgKCkgPT4ge1xuICAgICAgYS5vZmYoSC5FbmNyeXB0aW9uRXJyb3IsIEwpO1xuICAgIH07XG4gIH0sIFthLCBpXSk7XG4gIGNvbnN0IHsgbG9jYWxQYXJ0aWNpcGFudDogZCB9ID0gT2UoeyByb29tOiBhIH0pLCBsID0gZC5nZXRUcmFja1B1YmxpY2F0aW9uKEUuU291cmNlLkNhbWVyYSksIHYgPSBzLnVzZU1lbW8oKCkgPT4gIWwgfHwgbC5pc011dGVkID8gbnVsbCA6IHtcbiAgICBzb3VyY2U6IEUuU291cmNlLkNhbWVyYSxcbiAgICBwYXJ0aWNpcGFudDogZCxcbiAgICBwdWJsaWNhdGlvbjogbFxuICB9LCBbZCwgbCwgbCA9PSBudWxsID8gdm9pZCAwIDogbC5pc011dGVkXSksIEMgPSBkLmdldFRyYWNrUHVibGljYXRpb24oRS5Tb3VyY2UuTWljcm9waG9uZSksIGsgPSBzLnVzZU1lbW8oKCkgPT4gIUMgfHwgQy5pc011dGVkID8gbnVsbCA6IHtcbiAgICBzb3VyY2U6IEUuU291cmNlLk1pY3JvcGhvbmUsXG4gICAgcGFydGljaXBhbnQ6IGQsXG4gICAgcHVibGljYXRpb246IENcbiAgfSwgW2QsIEMsIEMgPT0gbnVsbCA/IHZvaWQgMCA6IEMuaXNNdXRlZF0pLCB7XG4gICAgYWdlbnRUaW1lb3V0RmFpbHVyZVJlYXNvbjogQSxcbiAgICBzdGFydEFnZW50VGltZW91dDogdyxcbiAgICBjbGVhckFnZW50VGltZW91dDogTyxcbiAgICBjbGVhckFnZW50VGltZW91dEZhaWx1cmVSZWFzb246IFIsXG4gICAgdXBkYXRlQWdlbnRUaW1lb3V0U3RhdGU6IG0sXG4gICAgdXBkYXRlQWdlbnRUaW1lb3V0UGFydGljaXBhbnRFeGlzdHM6IGZcbiAgfSA9IGZuKCksIGIgPSBzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGVtaXR0ZXI6IGksXG4gICAgICB0b2tlblNvdXJjZTogZSxcbiAgICAgIGFnZW50Q29ubmVjdFRpbWVvdXRNaWxsaXNlY29uZHM6IHIsXG4gICAgICBhZ2VudFRpbWVvdXRGYWlsdXJlUmVhc29uOiBBLFxuICAgICAgc3RhcnRBZ2VudFRpbWVvdXQ6IHcsXG4gICAgICBjbGVhckFnZW50VGltZW91dDogTyxcbiAgICAgIGNsZWFyQWdlbnRUaW1lb3V0RmFpbHVyZVJlYXNvbjogUixcbiAgICAgIHVwZGF0ZUFnZW50VGltZW91dFN0YXRlOiBtLFxuICAgICAgdXBkYXRlQWdlbnRUaW1lb3V0UGFydGljaXBhbnRFeGlzdHM6IGZcbiAgICB9KSxcbiAgICBbXG4gICAgICBpLFxuICAgICAgcixcbiAgICAgIGUsXG4gICAgICBBLFxuICAgICAgdyxcbiAgICAgIE8sXG4gICAgICBSLFxuICAgICAgbSxcbiAgICAgIGZcbiAgICBdXG4gICksIGcgPSBzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IEwgPSB7XG4gICAgICByb29tOiBhLFxuICAgICAgaW50ZXJuYWw6IGJcbiAgICB9O1xuICAgIHN3aXRjaCAocCkge1xuICAgICAgY2FzZSBJLkNvbm5lY3Rpbmc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uTCxcbiAgICAgICAgICBjb25uZWN0aW9uU3RhdGU6IEkuQ29ubmVjdGluZyxcbiAgICAgICAgICAuLi51KEkuQ29ubmVjdGluZyksXG4gICAgICAgICAgbG9jYWw6IHtcbiAgICAgICAgICAgIGNhbWVyYVRyYWNrOiBudWxsLFxuICAgICAgICAgICAgbWljcm9waG9uZVRyYWNrOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgY2FzZSBJLkNvbm5lY3RlZDpcbiAgICAgIGNhc2UgSS5SZWNvbm5lY3Rpbmc6XG4gICAgICBjYXNlIEkuU2lnbmFsUmVjb25uZWN0aW5nOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLkwsXG4gICAgICAgICAgY29ubmVjdGlvblN0YXRlOiBwLFxuICAgICAgICAgIC4uLnUocCksXG4gICAgICAgICAgbG9jYWw6IHtcbiAgICAgICAgICAgIGNhbWVyYVRyYWNrOiB2LFxuICAgICAgICAgICAgbWljcm9waG9uZVRyYWNrOiBrXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgY2FzZSBJLkRpc2Nvbm5lY3RlZDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5MLFxuICAgICAgICAgIGNvbm5lY3Rpb25TdGF0ZTogSS5EaXNjb25uZWN0ZWQsXG4gICAgICAgICAgLi4udShJLkRpc2Nvbm5lY3RlZCksXG4gICAgICAgICAgbG9jYWw6IHtcbiAgICAgICAgICAgIGNhbWVyYVRyYWNrOiBudWxsLFxuICAgICAgICAgICAgbWljcm9waG9uZVRyYWNrOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGIsXG4gICAgYSxcbiAgICBwLFxuICAgIHYsXG4gICAgayxcbiAgICB1XG4gIF0pO1xuICBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaS5lbWl0KFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiLCBnLmNvbm5lY3Rpb25TdGF0ZSk7XG4gIH0sIFtpLCBnLmNvbm5lY3Rpb25TdGF0ZV0pO1xuICBjb25zdCB5ID0gYm4oXG4gICAgaSxcbiAgICBnLmNvbm5lY3Rpb25TdGF0ZVxuICApLCBUID0gcy51c2VDYWxsYmFjayhcbiAgICBhc3luYyAoTCkgPT4geShcbiAgICAgIEkuQ29ubmVjdGVkLFxuICAgICAgTFxuICAgICksXG4gICAgW3ldXG4gICksIE0gPSBzLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChMKSA9PiB5KEkuRGlzY29ubmVjdGVkLCBMKSxcbiAgICBbeV1cbiAgKSwgUCA9IEllKFxuICAgIHMudXNlTWVtbyhcbiAgICAgICgpID0+ICh7XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0ZTogZy5jb25uZWN0aW9uU3RhdGUsXG4gICAgICAgIHJvb206IGEsXG4gICAgICAgIGludGVybmFsOiBiXG4gICAgICB9KSxcbiAgICAgIFtnLCBhLCBiXVxuICAgIClcbiAgKSwgRiA9IGduKGUsIG8pLCBxID0gcy51c2VDYWxsYmFjayhcbiAgICBhc3luYyAoTCA9IHt9KSA9PiB7XG4gICAgICB2YXIgQiwgajtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmFsOiBOLFxuICAgICAgICB0cmFja3M6IFogPSB7IG1pY3JvcGhvbmU6IHsgZW5hYmxlZDogITAsIHB1Ymxpc2hPcHRpb25zOiB7IHByZUNvbm5lY3RCdWZmZXI6ICEwIH0gfSB9LFxuICAgICAgICByb29tQ29ubmVjdE9wdGlvbnM6IFNcbiAgICAgIH0gPSBMO1xuICAgICAgYXdhaXQgTShOKTtcbiAgICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICAgIGEuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICAgIE4gPT0gbnVsbCB8fCBOLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBfKTtcbiAgICAgIGxldCBZID0gITE7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIEYoKS50aGVuKCh7IHNlcnZlclVybDogJCwgcGFydGljaXBhbnRUb2tlbjogeiB9KSA9PiB7XG4gICAgICAgICAgdmFyIGJlLCBnZTtcbiAgICAgICAgICByZXR1cm4gWSA9ICgoKGdlID0gKGJlID0gX3Qoeikucm9vbUNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IGJlLmFnZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IGdlLmxlbmd0aCkgPz8gMCkgPiAwLCBhLmNvbm5lY3QoJCwgeiwgUyk7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBTdGFydCBtaWNyb3Bob25lICh3aXRoIHByZWNvbm5lY3QgYnVmZmVyKSBieSBkZWZhdWx0XG4gICAgICAgIChCID0gWi5taWNyb3Bob25lKSAhPSBudWxsICYmIEIuZW5hYmxlZCA/IGEubG9jYWxQYXJ0aWNpcGFudC5zZXRNaWNyb3Bob25lRW5hYmxlZChcbiAgICAgICAgICAhMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgKChqID0gWi5taWNyb3Bob25lKSA9PSBudWxsID8gdm9pZCAwIDogai5wdWJsaXNoT3B0aW9ucykgPz8ge31cbiAgICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICBdKSwgYXdhaXQgVChOKSwgWSAmJiBhd2FpdCBQLndhaXRVbnRpbENvbm5lY3RlZChOKSwgTiA9PSBudWxsIHx8IE4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIF8pO1xuICAgIH0sXG4gICAgW2EsIE0sIEYsIFQsIFAud2FpdFVudGlsQ29ubmVjdGVkXVxuICApLCBKID0gcy51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYS5kaXNjb25uZWN0KCk7XG4gIH0sIFthXSksIEsgPSBzLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBMID0gYXdhaXQgRigpO1xuICAgIGF3YWl0IGEucHJlcGFyZUNvbm5lY3Rpb24oTC5zZXJ2ZXJVcmwsIEwucGFydGljaXBhbnRUb2tlbik7XG4gIH0sIFtGLCBhXSk7XG4gIHJldHVybiBzLnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBLKCkuY2F0Y2goKEwpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogUm9vbS5wcmVwYXJlQ29ubmVjdGlvbiBmYWlsZWQ6XCIsIEwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbXG4gICAgICAvKiBub3RlOiBubyBwcmVwYXJlQ29ubmVjdGlvbiBoZXJlLCB0aGlzIGVmZmVjdCBzaG91bGQgb25seSBldmVyIHJ1biBvbmNlISAqL1xuICAgIF1cbiAgKSwgcy51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICAuLi5nLFxuICAgICAgd2FpdFVudGlsQ29ubmVjdGVkOiBULFxuICAgICAgd2FpdFVudGlsRGlzY29ubmVjdGVkOiBNLFxuICAgICAgcHJlcGFyZUNvbm5lY3Rpb246IEssXG4gICAgICBzdGFydDogcSxcbiAgICAgIGVuZDogSlxuICAgIH0pLFxuICAgIFtnLCBULCBNLCBLLCBxLCBKXVxuICApO1xufVxuZnVuY3Rpb24gdXMoZSwgbiwgdCwgcikge1xuICBjb25zdCBvID0gcy51c2VNZW1vKCgpID0+ICgpID0+IHtcbiAgfSwgW10pLCBjID0gcy51c2VDYWxsYmFjayh0ID8/IG8sIHIgPz8gW10pLCBhID0gciA/IGMgOiB0LCBpID0gcy51c2VNZW1vKCgpID0+IGUgPyBcImludGVybmFsXCIgaW4gZSA/IGUuaW50ZXJuYWwuZW1pdHRlciA6IGUgOiBudWxsLCBbZV0pO1xuICBzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCEoIWkgfHwgIWEpKVxuICAgICAgcmV0dXJuIGkub24obiwgYSksICgpID0+IHtcbiAgICAgICAgaS5vZmYobiwgYSk7XG4gICAgICB9O1xuICB9LCBbaSwgbiwgYV0pO1xufVxudmFyIHZuID0gLyogQF9fUFVSRV9fICovICgoZSkgPT4gKGUuTWVzc2FnZVJlY2VpdmVkID0gXCJtZXNzYWdlUmVjZWl2ZWRcIiwgZSkpKHZuIHx8IHt9KTtcbmZ1bmN0aW9uIGxzKGUpIHtcbiAgY29uc3QgeyByb29tOiBuIH0gPSBEdChlKSwgdCA9IHMudXNlTWVtbyhcbiAgICAoKSA9PiBuZXcgaGUuRXZlbnRFbWl0dGVyKCksXG4gICAgW11cbiAgKSwgciA9IEllKGUpLCBvID0gY24oeyByb29tOiBuIH0pLCBjID0gcy51c2VNZW1vKCgpID0+ICh7IHJvb206IG4gfSksIFtuXSksIGEgPSBLdChjKSwgaSA9IHMudXNlTWVtbygoKSA9PiBvLm1hcCgobCkgPT4ge1xuICAgIHZhciB2LCBDLCBrO1xuICAgIHN3aXRjaCAobC5wYXJ0aWNpcGFudEluZm8uaWRlbnRpdHkpIHtcbiAgICAgIGNhc2Ugbi5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidXNlclRyYW5zY3JpcHRcIixcbiAgICAgICAgICBtZXNzYWdlOiBsLnRleHQsXG4gICAgICAgICAgaWQ6IGwuc3RyZWFtSW5mby5pZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IGwuc3RyZWFtSW5mby50aW1lc3RhbXAsXG4gICAgICAgICAgZnJvbTogbi5sb2NhbFBhcnRpY2lwYW50XG4gICAgICAgIH07XG4gICAgICBjYXNlICgodiA9IHIuaW50ZXJuYWwuYWdlbnRQYXJ0aWNpcGFudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHYuaWRlbnRpdHkpOlxuICAgICAgY2FzZSAoKEMgPSByLmludGVybmFsLndvcmtlclBhcnRpY2lwYW50KSA9PSBudWxsID8gdm9pZCAwIDogQy5pZGVudGl0eSk6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhZ2VudFRyYW5zY3JpcHRcIixcbiAgICAgICAgICBtZXNzYWdlOiBsLnRleHQsXG4gICAgICAgICAgaWQ6IGwuc3RyZWFtSW5mby5pZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IGwuc3RyZWFtSW5mby50aW1lc3RhbXAsXG4gICAgICAgICAgZnJvbTogKChrID0gci5pbnRlcm5hbC5hZ2VudFBhcnRpY2lwYW50KSA9PSBudWxsID8gdm9pZCAwIDogay5pZGVudGl0eSkgPT09IGwucGFydGljaXBhbnRJbmZvLmlkZW50aXR5ID8gci5pbnRlcm5hbC5hZ2VudFBhcnRpY2lwYW50IDogci5pbnRlcm5hbC53b3JrZXJQYXJ0aWNpcGFudFxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFnZW50VHJhbnNjcmlwdFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGwudGV4dCxcbiAgICAgICAgICBpZDogbC5zdHJlYW1JbmZvLmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogbC5zdHJlYW1JbmZvLnRpbWVzdGFtcCxcbiAgICAgICAgICBmcm9tOiBBcnJheS5mcm9tKG4ucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5maW5kKFxuICAgICAgICAgICAgKEEpID0+IEEuaWRlbnRpdHkgPT09IGwucGFydGljaXBhbnRJbmZvLmlkZW50aXR5XG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH1cbiAgfSksIFtvLCBuXSksIHUgPSBzLnVzZU1lbW8oKCkgPT4gWy4uLmksIC4uLmEuY2hhdE1lc3NhZ2VzXSwgW2ksIGEuY2hhdE1lc3NhZ2VzXSksIHAgPSBzLnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgaCA9IHMudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGZvciAoY29uc3QgdiBvZiB1KVxuICAgICAgcC5jdXJyZW50Lmhhcyh2LmlkKSB8fCBwLmN1cnJlbnQuc2V0KHYuaWQsIGwpO1xuICAgIHJldHVybiB1LnNvcnQoKHYsIEMpID0+IHtcbiAgICAgIGNvbnN0IGsgPSBwLmN1cnJlbnQuZ2V0KHYuaWQpLCBBID0gcC5jdXJyZW50LmdldChDLmlkKTtcbiAgICAgIHJldHVybiB0eXBlb2YgayA+IFwidVwiIHx8IHR5cGVvZiBBID4gXCJ1XCIgPyAwIDogay5nZXRUaW1lKCkgLSBBLmdldFRpbWUoKTtcbiAgICB9KTtcbiAgfSwgW3VdKSwgZCA9IHMudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICByZXR1cm4gcy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbCBvZiBoKVxuICAgICAgZC5jdXJyZW50LmhhcyhsLmlkKSB8fCAoZC5jdXJyZW50LmFkZChsLmlkKSwgdC5lbWl0KFwibWVzc2FnZVJlY2VpdmVkXCIsIGwpKTtcbiAgfSwgW2hdKSwgcy51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBtZXNzYWdlczogaCxcbiAgICAgIHNlbmQ6IGEuc2VuZCxcbiAgICAgIGlzU2VuZGluZzogYS5pc1NlbmRpbmcsXG4gICAgICBpbnRlcm5hbDogeyBlbWl0dGVyOiB0IH1cbiAgICB9KSxcbiAgICBbaCwgYS5zZW5kLCBhLmlzU2VuZGluZ11cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIGFuIGFzICQsXG4gIEluIGFzIEEsXG4gIFZuIGFzIEIsXG4gIE9lIGFzIEMsXG4gIHduIGFzIEQsXG4gIEFuIGFzIEUsXG4gIEJ0IGFzIEYsXG4gIFNlIGFzIEcsXG4gIGp0IGFzIEgsXG4gIHhuIGFzIEksXG4gIFVuIGFzIEosXG4gIFd0IGFzIEssXG4gIHFuIGFzIEwsXG4gIHBlIGFzIE0sXG4gIGpuIGFzIE4sXG4gIEd0IGFzIE8sXG4gICRuIGFzIFAsXG4gIFhuIGFzIFEsXG4gIGRuIGFzIFIsXG4gIEllIGFzIFMsXG4gIHRzIGFzIFQsXG4gIHNzIGFzIFUsXG4gIHJlIGFzIFYsXG4gIHJuIGFzIFcsXG4gIG9zIGFzIFgsXG4gIG9uIGFzIFksXG4gIHJzIGFzIFosXG4gIGFzIGFzIF8sXG4gIHRlIGFzIGEsXG4gIGNuIGFzIGEwLFxuICBjcyBhcyBhMSxcbiAgcG4gYXMgYTIsXG4gIGlzIGFzIGEzLFxuICB1cyBhcyBhNCxcbiAgdm4gYXMgYTUsXG4gIGxzIGFzIGE2LFxuICBKbiBhcyBiLFxuICBSbiBhcyBjLFxuICBEbiBhcyBkLFxuICBObiBhcyBlLFxuICB6biBhcyBmLFxuICBXbiBhcyBnLFxuICBLbiBhcyBoLFxuICBMbiBhcyBpLFxuICBEIGFzIGosXG4gIFFuIGFzIGssXG4gIEhuIGFzIGwsXG4gIGVzIGFzIG0sXG4gIE9uIGFzIG4sXG4gIEZuIGFzIG8sXG4gIEduIGFzIHAsXG4gIHF0IGFzIHEsXG4gIHp0IGFzIHIsXG4gIG5zIGFzIHMsXG4gIFluIGFzIHQsXG4gIFBuIGFzIHUsXG4gIEJuIGFzIHYsXG4gIEt0IGFzIHcsXG4gIFpuIGFzIHgsXG4gIF9uIGFzIHksXG4gIGtuIGFzIHpcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy15VS1zcnJJTy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-yU-srrIO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: function() { return /* binding */ W; },\n/* harmony export */   a: function() { return /* binding */ G; },\n/* harmony export */   c: function() { return /* binding */ H; },\n/* harmony export */   m: function() { return /* binding */ M; },\n/* harmony export */   r: function() { return /* binding */ T; },\n/* harmony export */   u: function() { return /* binding */ $; },\n/* harmony export */   w: function() { return /* binding */ Q; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contexts-CsO1QZ3r.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-CsO1QZ3r.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nfunction L(n) {\n  var e, o, t = \"\";\n  if (typeof n == \"string\" || typeof n == \"number\") t += n;\n  else if (typeof n == \"object\") if (Array.isArray(n)) {\n    var r = n.length;\n    for (e = 0; e < r; e++) n[e] && (o = L(n[e])) && (t && (t += \" \"), t += o);\n  } else for (o in n) n[o] && (t && (t += \" \"), t += o);\n  return t;\n}\nfunction A() {\n  for (var n, e, o = 0, t = \"\", r = arguments.length; o < r; o++) (n = arguments[o]) && (e = L(n)) && (t && (t += \" \"), t += e);\n  return t;\n}\nfunction I(...n) {\n  return (...e) => {\n    for (const o of n)\n      if (typeof o == \"function\")\n        try {\n          o(...e);\n        } catch (t) {\n          console.error(t);\n        }\n  };\n}\nfunction M(...n) {\n  const e = { ...n[0] };\n  for (let o = 1; o < n.length; o++) {\n    const t = n[o];\n    for (const r in t) {\n      const d = e[r], a = t[r];\n      typeof d == \"function\" && typeof a == \"function\" && // This is a lot faster than a regex.\n      r[0] === \"o\" && r[1] === \"n\" && r.charCodeAt(2) >= /* 'A' */\n      65 && r.charCodeAt(2) <= /* 'Z' */\n      90 ? e[r] = I(d, a) : (r === \"className\" || r === \"UNSAFE_className\") && typeof d == \"string\" && typeof a == \"string\" ? e[r] = A(d, a) : e[r] = a !== void 0 ? a : d;\n    }\n  }\n  return e;\n}\nfunction J(n) {\n  return n !== void 0;\n}\nfunction G(...n) {\n  return M(...n.filter(J));\n}\nfunction H(n, e, o) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(n, (t) => react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(t) && react__WEBPACK_IMPORTED_MODULE_0__.Children.only(n) ? (t.props.className && (e ?? (e = {}), e.className = A(t.props.className, e.className), e.style = { ...t.props.style, ...e.style }), react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(t, { ...e, key: o })) : t);\n}\nfunction Q(n) {\n  var e, o;\n  if (typeof window < \"u\" && typeof process < \"u\" && // eslint-disable-next-line turbo/no-undeclared-env-vars\n  (((e = process == null ? void 0 : process.env) == null ? void 0 : e.NODE_ENV) === \"dev\" || // eslint-disable-next-line turbo/no-undeclared-env-vars\n  ((o = process == null ? void 0 : process.env) == null ? void 0 : o.NODE_ENV) === \"development\")) {\n    const t = document.querySelector(\".lk-room-container\");\n    t && !getComputedStyle(t).getPropertyValue(\"--lk-has-imported-styles\") && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\n      \"It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page.\"\n    );\n  }\n}\nfunction T(n, e) {\n  return n === \"processor\" && e && typeof e == \"object\" && \"name\" in e ? e.name : n === \"e2ee\" && e ? \"e2ee-enabled\" : e;\n}\nconst q = {\n  connect: !0,\n  audio: !1,\n  video: !1\n};\nfunction $(n) {\n  const {\n    token: e,\n    serverUrl: o,\n    options: t,\n    room: r,\n    connectOptions: d,\n    connect: a,\n    audio: p,\n    video: y,\n    screen: g,\n    onConnected: v,\n    onDisconnected: h,\n    onError: c,\n    onMediaDeviceFailure: b,\n    onEncryptionError: E,\n    simulateParticipants: w,\n    ...N\n  } = { ...q, ...n };\n  t && r && _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\n    \"when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.\"\n  );\n  const [s, O] = react__WEBPACK_IMPORTED_MODULE_0__.useState(), C = react__WEBPACK_IMPORTED_MODULE_0__.useRef(a);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    O(r ?? new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Room(t));\n  }, [r, JSON.stringify(t, T)]);\n  const F = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const { className: m } = (0,_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.s)();\n    return M(N, { className: m });\n  }, [N]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!s) return;\n    const m = () => {\n      const f = s.localParticipant;\n      _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"trying to publish local tracks\"), Promise.all([\n        f.setMicrophoneEnabled(!!p, typeof p != \"boolean\" ? p : void 0),\n        f.setCameraEnabled(!!y, typeof y != \"boolean\" ? y : void 0),\n        f.setScreenShareEnabled(!!g, typeof g != \"boolean\" ? g : void 0)\n      ]).catch((R) => {\n        _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(R), c == null || c(R);\n      });\n    }, P = (f, R) => {\n      const K = livekit_client__WEBPACK_IMPORTED_MODULE_1__.MediaDeviceFailure.getFailure(f);\n      b == null || b(K, R);\n    }, S = (f) => {\n      E == null || E(f);\n    }, k = (f) => {\n      h == null || h(f);\n    }, D = () => {\n      v == null || v();\n    };\n    return s.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.SignalConnected, m).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, P).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, S).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Disconnected, k).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Connected, D), () => {\n      s.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.SignalConnected, m).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, P).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, S).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Disconnected, k).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Connected, D);\n    };\n  }, [\n    s,\n    p,\n    y,\n    g,\n    c,\n    E,\n    b,\n    v,\n    h\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (s) {\n      if (w) {\n        s.simulateParticipants({\n          participants: {\n            count: w\n          },\n          publish: {\n            audio: !0,\n            useRealTracks: !0\n          }\n        });\n        return;\n      }\n      if (a) {\n        if (C.current = !0, _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"connecting\"), !e) {\n          _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"no token yet\");\n          return;\n        }\n        if (!o) {\n          _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\"no livekit url provided\"), c == null || c(Error(\"no livekit url provided\"));\n          return;\n        }\n        s.connect(o, e, d).catch((m) => {\n          _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(m), C.current === !0 && (c == null || c(m));\n        });\n      } else\n        _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"disconnecting because connect is false\"), C.current = !1, s.disconnect();\n    }\n  }, [\n    a,\n    e,\n    JSON.stringify(d),\n    s,\n    c,\n    o,\n    w\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (s)\n      return () => {\n        _contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.l.info(\"disconnecting on onmount\"), s.disconnect();\n      };\n  }, [s]), { room: s, htmlProps: F };\n}\nconst W = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(e, o) {\n  const { room: t, htmlProps: r } = $(e);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, ...r }, t && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.R.Provider, { value: t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_CsO1QZ3r_mjs__WEBPACK_IMPORTED_MODULE_2__.L.Provider, { value: e.featureFlags }, e.children)));\n});\n\n//# sourceMappingURL=room-Bb6uLxS5.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3Qvcm9vbS1CYjZ1THhTNS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkI7QUFDOEM7QUFDVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJDQUFVLGVBQWUsaURBQWdCLE9BQU8sMkNBQVUsOENBQThDLGdFQUFnRSw4QkFBOEIsR0FBRywrQ0FBYyxNQUFNLGNBQWM7QUFDcFA7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0MsU0FBUyxPQUFPLG9CQUFvQixPQUFPO0FBQzNDLFFBQVEsT0FBTyxvQkFBb0IsT0FBTztBQUMxQztBQUNBLDhFQUE4RSxxREFBQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixZQUFZLHFEQUFDO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVSxRQUFRLHlDQUFRO0FBQzNDLEVBQUUsNENBQVc7QUFDYixlQUFlLGdEQUFDO0FBQ2hCLEdBQUc7QUFDSCxZQUFZLDBDQUFTO0FBQ3JCLFlBQVksZUFBZSxFQUFFLHlEQUFDO0FBQzlCLGtCQUFrQixjQUFjO0FBQ2hDLEdBQUc7QUFDSCxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQUM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLGdCQUFnQiw4REFBQztBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLHdCQUF3QixxREFBQywwQkFBMEIscURBQUMsd0JBQXdCLHFEQUFDLHFCQUFxQixxREFBQztBQUNwSCxZQUFZLHFEQUFDLHlCQUF5QixxREFBQywyQkFBMkIscURBQUMseUJBQXlCLHFEQUFDLHNCQUFzQixxREFBQztBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRDQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFEQUFDO0FBQzdCLFVBQVUscURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBQztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUSxxREFBQztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBVztBQUNqQjtBQUNBO0FBQ0EsUUFBUSxxREFBQztBQUNUO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQSwwQkFBMEIsNkNBQVk7QUFDdEMsVUFBVSx3QkFBd0I7QUFDbEMseUJBQXlCLGdEQUFlLFVBQVUsY0FBYyx1QkFBdUIsZ0RBQWUsQ0FBQyxxREFBQyxhQUFhLFVBQVUsa0JBQWtCLGdEQUFlLENBQUMscURBQUMsYUFBYSx1QkFBdUI7QUFDdE0sQ0FBQztBQVNDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZla2l0L2NvbXBvbmVudHMtcmVhY3QvZGlzdC9yb29tLUJiNnVMeFM1Lm1qcz83Mjk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGkgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBsIGFzIHUsIHMgYXMgeCwgUiBhcyBWLCBMIGFzIGogfSBmcm9tIFwiLi9jb250ZXh0cy1Dc08xUVozci5tanNcIjtcbmltcG9ydCB7IFJvb20gYXMgVSwgUm9vbUV2ZW50IGFzIGwsIE1lZGlhRGV2aWNlRmFpbHVyZSBhcyBfIH0gZnJvbSBcImxpdmVraXQtY2xpZW50XCI7XG5mdW5jdGlvbiBMKG4pIHtcbiAgdmFyIGUsIG8sIHQgPSBcIlwiO1xuICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbiA9PSBcIm51bWJlclwiKSB0ICs9IG47XG4gIGVsc2UgaWYgKHR5cGVvZiBuID09IFwib2JqZWN0XCIpIGlmIChBcnJheS5pc0FycmF5KG4pKSB7XG4gICAgdmFyIHIgPSBuLmxlbmd0aDtcbiAgICBmb3IgKGUgPSAwOyBlIDwgcjsgZSsrKSBuW2VdICYmIChvID0gTChuW2VdKSkgJiYgKHQgJiYgKHQgKz0gXCIgXCIpLCB0ICs9IG8pO1xuICB9IGVsc2UgZm9yIChvIGluIG4pIG5bb10gJiYgKHQgJiYgKHQgKz0gXCIgXCIpLCB0ICs9IG8pO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIEEoKSB7XG4gIGZvciAodmFyIG4sIGUsIG8gPSAwLCB0ID0gXCJcIiwgciA9IGFyZ3VtZW50cy5sZW5ndGg7IG8gPCByOyBvKyspIChuID0gYXJndW1lbnRzW29dKSAmJiAoZSA9IEwobikpICYmICh0ICYmICh0ICs9IFwiIFwiKSwgdCArPSBlKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBJKC4uLm4pIHtcbiAgcmV0dXJuICguLi5lKSA9PiB7XG4gICAgZm9yIChjb25zdCBvIG9mIG4pXG4gICAgICBpZiAodHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG8oLi4uZSk7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHQpO1xuICAgICAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBNKC4uLm4pIHtcbiAgY29uc3QgZSA9IHsgLi4ublswXSB9O1xuICBmb3IgKGxldCBvID0gMTsgbyA8IG4ubGVuZ3RoOyBvKyspIHtcbiAgICBjb25zdCB0ID0gbltvXTtcbiAgICBmb3IgKGNvbnN0IHIgaW4gdCkge1xuICAgICAgY29uc3QgZCA9IGVbcl0sIGEgPSB0W3JdO1xuICAgICAgdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIiAmJiAvLyBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIGEgcmVnZXguXG4gICAgICByWzBdID09PSBcIm9cIiAmJiByWzFdID09PSBcIm5cIiAmJiByLmNoYXJDb2RlQXQoMikgPj0gLyogJ0EnICovXG4gICAgICA2NSAmJiByLmNoYXJDb2RlQXQoMikgPD0gLyogJ1onICovXG4gICAgICA5MCA/IGVbcl0gPSBJKGQsIGEpIDogKHIgPT09IFwiY2xhc3NOYW1lXCIgfHwgciA9PT0gXCJVTlNBRkVfY2xhc3NOYW1lXCIpICYmIHR5cGVvZiBkID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiA/IGVbcl0gPSBBKGQsIGEpIDogZVtyXSA9IGEgIT09IHZvaWQgMCA/IGEgOiBkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEoobikge1xuICByZXR1cm4gbiAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gRyguLi5uKSB7XG4gIHJldHVybiBNKC4uLm4uZmlsdGVyKEopKTtcbn1cbmZ1bmN0aW9uIEgobiwgZSwgbykge1xuICByZXR1cm4gaS5DaGlsZHJlbi5tYXAobiwgKHQpID0+IGkuaXNWYWxpZEVsZW1lbnQodCkgJiYgaS5DaGlsZHJlbi5vbmx5KG4pID8gKHQucHJvcHMuY2xhc3NOYW1lICYmIChlID8/IChlID0ge30pLCBlLmNsYXNzTmFtZSA9IEEodC5wcm9wcy5jbGFzc05hbWUsIGUuY2xhc3NOYW1lKSwgZS5zdHlsZSA9IHsgLi4udC5wcm9wcy5zdHlsZSwgLi4uZS5zdHlsZSB9KSwgaS5jbG9uZUVsZW1lbnQodCwgeyAuLi5lLCBrZXk6IG8gfSkpIDogdCk7XG59XG5mdW5jdGlvbiBRKG4pIHtcbiAgdmFyIGUsIG87XG4gIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdHVyYm8vbm8tdW5kZWNsYXJlZC1lbnYtdmFyc1xuICAoKChlID0gcHJvY2VzcyA9PSBudWxsID8gdm9pZCAwIDogcHJvY2Vzcy5lbnYpID09IG51bGwgPyB2b2lkIDAgOiBlLk5PREVfRU5WKSA9PT0gXCJkZXZcIiB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdHVyYm8vbm8tdW5kZWNsYXJlZC1lbnYtdmFyc1xuICAoKG8gPSBwcm9jZXNzID09IG51bGwgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT0gbnVsbCA/IHZvaWQgMCA6IG8uTk9ERV9FTlYpID09PSBcImRldmVsb3BtZW50XCIpKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubGstcm9vbS1jb250YWluZXJcIik7XG4gICAgdCAmJiAhZ2V0Q29tcHV0ZWRTdHlsZSh0KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1say1oYXMtaW1wb3J0ZWQtc3R5bGVzXCIpICYmIHUud2FybihcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgbm90IHVzaW5nIHRoZSBgQGxpdmVraXQvY29tcG9uZW50cy1zdHlsZXMgcGFja2FnZWAuIFRvIHJlbmRlciB0aGUgVUkgd2l0aCB0aGUgZGVmYXVsdCBzdHlsaW5nLCBwbGVhc2UgaW1wb3J0IGl0IGluIHlvdXIgbGF5b3V0IG9yIHBhZ2UuXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBUKG4sIGUpIHtcbiAgcmV0dXJuIG4gPT09IFwicHJvY2Vzc29yXCIgJiYgZSAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIFwibmFtZVwiIGluIGUgPyBlLm5hbWUgOiBuID09PSBcImUyZWVcIiAmJiBlID8gXCJlMmVlLWVuYWJsZWRcIiA6IGU7XG59XG5jb25zdCBxID0ge1xuICBjb25uZWN0OiAhMCxcbiAgYXVkaW86ICExLFxuICB2aWRlbzogITFcbn07XG5mdW5jdGlvbiAkKG4pIHtcbiAgY29uc3Qge1xuICAgIHRva2VuOiBlLFxuICAgIHNlcnZlclVybDogbyxcbiAgICBvcHRpb25zOiB0LFxuICAgIHJvb206IHIsXG4gICAgY29ubmVjdE9wdGlvbnM6IGQsXG4gICAgY29ubmVjdDogYSxcbiAgICBhdWRpbzogcCxcbiAgICB2aWRlbzogeSxcbiAgICBzY3JlZW46IGcsXG4gICAgb25Db25uZWN0ZWQ6IHYsXG4gICAgb25EaXNjb25uZWN0ZWQ6IGgsXG4gICAgb25FcnJvcjogYyxcbiAgICBvbk1lZGlhRGV2aWNlRmFpbHVyZTogYixcbiAgICBvbkVuY3J5cHRpb25FcnJvcjogRSxcbiAgICBzaW11bGF0ZVBhcnRpY2lwYW50czogdyxcbiAgICAuLi5OXG4gIH0gPSB7IC4uLnEsIC4uLm4gfTtcbiAgdCAmJiByICYmIHUud2FybihcbiAgICBcIndoZW4gdXNpbmcgYSBtYW51YWxseSBjcmVhdGVkIHJvb20sIHRoZSBvcHRpb25zIG9iamVjdCB3aWxsIGJlIGlnbm9yZWQuIHNldCB0aGUgZGVzaXJlZCBvcHRpb25zIGRpcmVjdGx5IHdoZW4gY3JlYXRpbmcgdGhlIHJvb20gaW5zdGVhZC5cIlxuICApO1xuICBjb25zdCBbcywgT10gPSBpLnVzZVN0YXRlKCksIEMgPSBpLnVzZVJlZihhKTtcbiAgaS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIE8ociA/PyBuZXcgVSh0KSk7XG4gIH0sIFtyLCBKU09OLnN0cmluZ2lmeSh0LCBUKV0pO1xuICBjb25zdCBGID0gaS51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogbSB9ID0geCgpO1xuICAgIHJldHVybiBNKE4sIHsgY2xhc3NOYW1lOiBtIH0pO1xuICB9LCBbTl0pO1xuICByZXR1cm4gaS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcykgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmID0gcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgICAgdS5kZWJ1ZyhcInRyeWluZyB0byBwdWJsaXNoIGxvY2FsIHRyYWNrc1wiKSwgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmLnNldE1pY3JvcGhvbmVFbmFibGVkKCEhcCwgdHlwZW9mIHAgIT0gXCJib29sZWFuXCIgPyBwIDogdm9pZCAwKSxcbiAgICAgICAgZi5zZXRDYW1lcmFFbmFibGVkKCEheSwgdHlwZW9mIHkgIT0gXCJib29sZWFuXCIgPyB5IDogdm9pZCAwKSxcbiAgICAgICAgZi5zZXRTY3JlZW5TaGFyZUVuYWJsZWQoISFnLCB0eXBlb2YgZyAhPSBcImJvb2xlYW5cIiA/IGcgOiB2b2lkIDApXG4gICAgICBdKS5jYXRjaCgoUikgPT4ge1xuICAgICAgICB1Lndhcm4oUiksIGMgPT0gbnVsbCB8fCBjKFIpO1xuICAgICAgfSk7XG4gICAgfSwgUCA9IChmLCBSKSA9PiB7XG4gICAgICBjb25zdCBLID0gXy5nZXRGYWlsdXJlKGYpO1xuICAgICAgYiA9PSBudWxsIHx8IGIoSywgUik7XG4gICAgfSwgUyA9IChmKSA9PiB7XG4gICAgICBFID09IG51bGwgfHwgRShmKTtcbiAgICB9LCBrID0gKGYpID0+IHtcbiAgICAgIGggPT0gbnVsbCB8fCBoKGYpO1xuICAgIH0sIEQgPSAoKSA9PiB7XG4gICAgICB2ID09IG51bGwgfHwgdigpO1xuICAgIH07XG4gICAgcmV0dXJuIHMub24obC5TaWduYWxDb25uZWN0ZWQsIG0pLm9uKGwuTWVkaWFEZXZpY2VzRXJyb3IsIFApLm9uKGwuRW5jcnlwdGlvbkVycm9yLCBTKS5vbihsLkRpc2Nvbm5lY3RlZCwgaykub24obC5Db25uZWN0ZWQsIEQpLCAoKSA9PiB7XG4gICAgICBzLm9mZihsLlNpZ25hbENvbm5lY3RlZCwgbSkub2ZmKGwuTWVkaWFEZXZpY2VzRXJyb3IsIFApLm9mZihsLkVuY3J5cHRpb25FcnJvciwgUykub2ZmKGwuRGlzY29ubmVjdGVkLCBrKS5vZmYobC5Db25uZWN0ZWQsIEQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBzLFxuICAgIHAsXG4gICAgeSxcbiAgICBnLFxuICAgIGMsXG4gICAgRSxcbiAgICBiLFxuICAgIHYsXG4gICAgaFxuICBdKSwgaS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzKSB7XG4gICAgICBpZiAodykge1xuICAgICAgICBzLnNpbXVsYXRlUGFydGljaXBhbnRzKHtcbiAgICAgICAgICBwYXJ0aWNpcGFudHM6IHtcbiAgICAgICAgICAgIGNvdW50OiB3XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdWJsaXNoOiB7XG4gICAgICAgICAgICBhdWRpbzogITAsXG4gICAgICAgICAgICB1c2VSZWFsVHJhY2tzOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChDLmN1cnJlbnQgPSAhMCwgdS5kZWJ1ZyhcImNvbm5lY3RpbmdcIiksICFlKSB7XG4gICAgICAgICAgdS5kZWJ1ZyhcIm5vIHRva2VuIHlldFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgdS53YXJuKFwibm8gbGl2ZWtpdCB1cmwgcHJvdmlkZWRcIiksIGMgPT0gbnVsbCB8fCBjKEVycm9yKFwibm8gbGl2ZWtpdCB1cmwgcHJvdmlkZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzLmNvbm5lY3QobywgZSwgZCkuY2F0Y2goKG0pID0+IHtcbiAgICAgICAgICB1Lndhcm4obSksIEMuY3VycmVudCA9PT0gITAgJiYgKGMgPT0gbnVsbCB8fCBjKG0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdS5kZWJ1ZyhcImRpc2Nvbm5lY3RpbmcgYmVjYXVzZSBjb25uZWN0IGlzIGZhbHNlXCIpLCBDLmN1cnJlbnQgPSAhMSwgcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCBbXG4gICAgYSxcbiAgICBlLFxuICAgIEpTT04uc3RyaW5naWZ5KGQpLFxuICAgIHMsXG4gICAgYyxcbiAgICBvLFxuICAgIHdcbiAgXSksIGkudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocylcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHUuaW5mbyhcImRpc2Nvbm5lY3Rpbmcgb24gb25tb3VudFwiKSwgcy5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICB9LCBbc10pLCB7IHJvb206IHMsIGh0bWxQcm9wczogRiB9O1xufVxuY29uc3QgVyA9IC8qIEBfX1BVUkVfXyAqLyBpLmZvcndhcmRSZWYoZnVuY3Rpb24oZSwgbykge1xuICBjb25zdCB7IHJvb206IHQsIGh0bWxQcm9wczogciB9ID0gJChlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG8sIC4uLnIgfSwgdCAmJiAvKiBAX19QVVJFX18gKi8gaS5jcmVhdGVFbGVtZW50KFYuUHJvdmlkZXIsIHsgdmFsdWU6IHQgfSwgLyogQF9fUFVSRV9fICovIGkuY3JlYXRlRWxlbWVudChqLlByb3ZpZGVyLCB7IHZhbHVlOiBlLmZlYXR1cmVGbGFncyB9LCBlLmNoaWxkcmVuKSkpO1xufSk7XG5leHBvcnQge1xuICBXIGFzIEwsXG4gIEcgYXMgYSxcbiAgSCBhcyBjLFxuICBNIGFzIG0sXG4gIFQgYXMgcixcbiAgJCBhcyB1LFxuICBRIGFzIHdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb29tLUJiNnVMeFM1Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-Bb6uLxS5.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: function() { return /* binding */ AudioPresets; },\n/* harmony export */   BackupCodecPolicy: function() { return /* binding */ BackupCodecPolicy; },\n/* harmony export */   BaseKeyProvider: function() { return /* binding */ BaseKeyProvider; },\n/* harmony export */   CheckStatus: function() { return /* binding */ CheckStatus; },\n/* harmony export */   Checker: function() { return /* binding */ Checker; },\n/* harmony export */   ConnectionCheck: function() { return /* binding */ ConnectionCheck; },\n/* harmony export */   ConnectionError: function() { return /* binding */ ConnectionError; },\n/* harmony export */   ConnectionErrorReason: function() { return /* binding */ ConnectionErrorReason; },\n/* harmony export */   ConnectionQuality: function() { return /* binding */ ConnectionQuality; },\n/* harmony export */   ConnectionState: function() { return /* binding */ ConnectionState; },\n/* harmony export */   CriticalTimers: function() { return /* binding */ CriticalTimers; },\n/* harmony export */   CryptorError: function() { return /* binding */ CryptorError; },\n/* harmony export */   CryptorErrorReason: function() { return /* binding */ CryptorErrorReason; },\n/* harmony export */   CryptorEvent: function() { return /* binding */ CryptorEvent; },\n/* harmony export */   DataPacket_Kind: function() { return /* binding */ DataPacket_Kind; },\n/* harmony export */   DataStreamError: function() { return /* binding */ DataStreamError; },\n/* harmony export */   DataStreamErrorReason: function() { return /* binding */ DataStreamErrorReason; },\n/* harmony export */   DefaultReconnectPolicy: function() { return /* binding */ DefaultReconnectPolicy; },\n/* harmony export */   DeviceUnsupportedError: function() { return /* binding */ DeviceUnsupportedError; },\n/* harmony export */   DisconnectReason: function() { return /* binding */ DisconnectReason; },\n/* harmony export */   EncryptionEvent: function() { return /* binding */ EncryptionEvent; },\n/* harmony export */   Encryption_Type: function() { return /* binding */ Encryption_Type; },\n/* harmony export */   EngineEvent: function() { return /* binding */ EngineEvent; },\n/* harmony export */   ExternalE2EEKeyProvider: function() { return /* binding */ ExternalE2EEKeyProvider; },\n/* harmony export */   KeyHandlerEvent: function() { return /* binding */ KeyHandlerEvent; },\n/* harmony export */   KeyProviderEvent: function() { return /* binding */ KeyProviderEvent; },\n/* harmony export */   LivekitError: function() { return /* binding */ LivekitError; },\n/* harmony export */   LocalAudioTrack: function() { return /* binding */ LocalAudioTrack; },\n/* harmony export */   LocalParticipant: function() { return /* binding */ LocalParticipant; },\n/* harmony export */   LocalTrack: function() { return /* binding */ LocalTrack; },\n/* harmony export */   LocalTrackPublication: function() { return /* binding */ LocalTrackPublication; },\n/* harmony export */   LocalTrackRecorder: function() { return /* binding */ LocalTrackRecorder; },\n/* harmony export */   LocalVideoTrack: function() { return /* binding */ LocalVideoTrack; },\n/* harmony export */   LogLevel: function() { return /* binding */ LogLevel; },\n/* harmony export */   LoggerNames: function() { return /* binding */ LoggerNames; },\n/* harmony export */   MediaDeviceFailure: function() { return /* binding */ MediaDeviceFailure; },\n/* harmony export */   Mutex: function() { return /* binding */ _; },\n/* harmony export */   NegotiationError: function() { return /* binding */ NegotiationError; },\n/* harmony export */   Participant: function() { return /* binding */ Participant; },\n/* harmony export */   ParticipantEvent: function() { return /* binding */ ParticipantEvent; },\n/* harmony export */   ParticipantKind: function() { return /* binding */ ParticipantInfo_Kind; },\n/* harmony export */   PublishDataError: function() { return /* binding */ PublishDataError; },\n/* harmony export */   PublishTrackError: function() { return /* binding */ PublishTrackError; },\n/* harmony export */   RemoteAudioTrack: function() { return /* binding */ RemoteAudioTrack; },\n/* harmony export */   RemoteParticipant: function() { return /* binding */ RemoteParticipant; },\n/* harmony export */   RemoteTrack: function() { return /* binding */ RemoteTrack; },\n/* harmony export */   RemoteTrackPublication: function() { return /* binding */ RemoteTrackPublication; },\n/* harmony export */   RemoteVideoTrack: function() { return /* binding */ RemoteVideoTrack; },\n/* harmony export */   Room: function() { return /* binding */ Room; },\n/* harmony export */   RoomEvent: function() { return /* binding */ RoomEvent; },\n/* harmony export */   RpcError: function() { return /* binding */ RpcError; },\n/* harmony export */   ScreenSharePresets: function() { return /* binding */ ScreenSharePresets; },\n/* harmony export */   SignalReconnectError: function() { return /* binding */ SignalReconnectError; },\n/* harmony export */   SignalRequestError: function() { return /* binding */ SignalRequestError; },\n/* harmony export */   SimulatedError: function() { return /* binding */ SimulatedError; },\n/* harmony export */   SubscriptionError: function() { return /* binding */ SubscriptionError; },\n/* harmony export */   TokenSource: function() { return /* binding */ TokenSource; },\n/* harmony export */   TokenSourceConfigurable: function() { return /* binding */ TokenSourceConfigurable; },\n/* harmony export */   TokenSourceFixed: function() { return /* binding */ TokenSourceFixed; },\n/* harmony export */   Track: function() { return /* binding */ Track; },\n/* harmony export */   TrackEvent: function() { return /* binding */ TrackEvent; },\n/* harmony export */   TrackInvalidError: function() { return /* binding */ TrackInvalidError; },\n/* harmony export */   TrackPublication: function() { return /* binding */ TrackPublication; },\n/* harmony export */   TrackType: function() { return /* binding */ TrackType; },\n/* harmony export */   UnexpectedConnectionState: function() { return /* binding */ UnexpectedConnectionState; },\n/* harmony export */   UnsupportedServer: function() { return /* binding */ UnsupportedServer; },\n/* harmony export */   VideoPreset: function() { return /* binding */ VideoPreset; },\n/* harmony export */   VideoPresets: function() { return /* binding */ VideoPresets; },\n/* harmony export */   VideoPresets43: function() { return /* binding */ VideoPresets43; },\n/* harmony export */   VideoQuality: function() { return /* binding */ VideoQuality; },\n/* harmony export */   areTokenSourceFetchOptionsEqual: function() { return /* binding */ areTokenSourceFetchOptionsEqual; },\n/* harmony export */   asEncryptablePacket: function() { return /* binding */ asEncryptablePacket; },\n/* harmony export */   attachToElement: function() { return /* binding */ attachToElement; },\n/* harmony export */   attributes: function() { return /* binding */ attributeTypings; },\n/* harmony export */   audioCodecs: function() { return /* binding */ audioCodecs; },\n/* harmony export */   compareVersions: function() { return /* binding */ compareVersions; },\n/* harmony export */   createAudioAnalyser: function() { return /* binding */ createAudioAnalyser; },\n/* harmony export */   createE2EEKey: function() { return /* binding */ createE2EEKey; },\n/* harmony export */   createKeyMaterialFromBuffer: function() { return /* binding */ createKeyMaterialFromBuffer; },\n/* harmony export */   createKeyMaterialFromString: function() { return /* binding */ createKeyMaterialFromString; },\n/* harmony export */   createLocalAudioTrack: function() { return /* binding */ createLocalAudioTrack; },\n/* harmony export */   createLocalScreenTracks: function() { return /* binding */ createLocalScreenTracks; },\n/* harmony export */   createLocalTracks: function() { return /* binding */ createLocalTracks; },\n/* harmony export */   createLocalVideoTrack: function() { return /* binding */ createLocalVideoTrack; },\n/* harmony export */   decodeTokenPayload: function() { return /* binding */ decodeTokenPayload; },\n/* harmony export */   deriveKeys: function() { return /* binding */ deriveKeys; },\n/* harmony export */   detachTrack: function() { return /* binding */ detachTrack; },\n/* harmony export */   facingModeFromDeviceLabel: function() { return /* binding */ facingModeFromDeviceLabel; },\n/* harmony export */   facingModeFromLocalTrack: function() { return /* binding */ facingModeFromLocalTrack; },\n/* harmony export */   getBrowser: function() { return /* binding */ getBrowser; },\n/* harmony export */   getEmptyAudioStreamTrack: function() { return /* binding */ getEmptyAudioStreamTrack; },\n/* harmony export */   getEmptyVideoStreamTrack: function() { return /* binding */ getEmptyVideoStreamTrack; },\n/* harmony export */   getLogger: function() { return /* binding */ getLogger; },\n/* harmony export */   importKey: function() { return /* binding */ importKey; },\n/* harmony export */   isAudioCodec: function() { return /* binding */ isAudioCodec; },\n/* harmony export */   isAudioTrack: function() { return /* binding */ isAudioTrack; },\n/* harmony export */   isBackupCodec: function() { return /* binding */ isBackupCodec; },\n/* harmony export */   isBackupVideoCodec: function() { return /* binding */ isBackupVideoCodec; },\n/* harmony export */   isBrowserSupported: function() { return /* binding */ isBrowserSupported; },\n/* harmony export */   isE2EESupported: function() { return /* binding */ isE2EESupported; },\n/* harmony export */   isInsertableStreamSupported: function() { return /* binding */ isInsertableStreamSupported; },\n/* harmony export */   isLocalParticipant: function() { return /* binding */ isLocalParticipant; },\n/* harmony export */   isLocalTrack: function() { return /* binding */ isLocalTrack; },\n/* harmony export */   isRemoteParticipant: function() { return /* binding */ isRemoteParticipant; },\n/* harmony export */   isRemoteTrack: function() { return /* binding */ isRemoteTrack; },\n/* harmony export */   isScriptTransformSupported: function() { return /* binding */ isScriptTransformSupported; },\n/* harmony export */   isVideoCodec: function() { return /* binding */ isVideoCodec; },\n/* harmony export */   isVideoFrame: function() { return /* binding */ isVideoFrame; },\n/* harmony export */   isVideoTrack: function() { return /* binding */ isVideoTrack; },\n/* harmony export */   needsRbspUnescaping: function() { return /* binding */ needsRbspUnescaping; },\n/* harmony export */   parseRbsp: function() { return /* binding */ parseRbsp; },\n/* harmony export */   protocolVersion: function() { return /* binding */ protocolVersion; },\n/* harmony export */   ratchet: function() { return /* binding */ ratchet; },\n/* harmony export */   setLogExtension: function() { return /* binding */ setLogExtension; },\n/* harmony export */   setLogLevel: function() { return /* binding */ setLogLevel; },\n/* harmony export */   supportsAV1: function() { return /* binding */ supportsAV1; },\n/* harmony export */   supportsAdaptiveStream: function() { return /* binding */ supportsAdaptiveStream; },\n/* harmony export */   supportsAudioOutputSelection: function() { return /* binding */ supportsAudioOutputSelection; },\n/* harmony export */   supportsDynacast: function() { return /* binding */ supportsDynacast; },\n/* harmony export */   supportsVP9: function() { return /* binding */ supportsVP9; },\n/* harmony export */   version: function() { return /* binding */ version; },\n/* harmony export */   videoCodecs: function() { return /* binding */ videoCodecs; },\n/* harmony export */   writeRbsp: function() { return /* binding */ writeRbsp; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nfunction _mergeNamespaces(n, m){m.forEach(function(e){e&&typeof e!=='string'&&!Array.isArray(e)&&Object.keys(e).forEach(function(k){if(k!=='default'&&!(k in n)){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})});return Object.freeze(n);}var e = Object.defineProperty;\nvar h = (i, s, t) => s in i ? e(i, s, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: t\n}) : i[s] = t;\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n  constructor() {\n    o(this, \"_locking\");\n    o(this, \"_locks\");\n    this._locking = Promise.resolve(), this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let s;\n    const t = new Promise(l => s = () => {\n        this._locks -= 1, l();\n      }),\n      c = this._locking.then(() => s);\n    return this._locking = this._locking.then(() => t), c;\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */\nfunction assert(condition, msg) {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38,\n  FLOAT32_MIN = -34028234663852886e22,\n  UINT32_MAX = 0xffffffff,\n  INT32_MAX = 0x7fffffff,\n  INT32_MIN = -2147483648;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */\nfunction assertInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */\nfunction assertUInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */\nfunction assertFloat32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n  if (!Number.isFinite(arg)) return;\n  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */\nfunction getEnumType(enumObject) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n  const t = enumObject[enumTypeSymbol];\n  assert(t, \"missing enum type on enum object\");\n  return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */\nfunction setEnumType(enumObject, typeName, values, opt) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(v => ({\n    no: v.no,\n    name: v.name,\n    localName: enumObject[v.no]\n  })));\n}\n/**\n * Create a new EnumType with the given values.\n */\nfunction makeEnumType(typeName, values,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n  const names = Object.create(null);\n  const numbers = Object.create(null);\n  const normalValues = [];\n  for (const value of values) {\n    // We do not surface options at this time\n    // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n    const n = normalizeEnumValue(value);\n    normalValues.push(n);\n    names[value.name] = n;\n    numbers[value.no] = n;\n  }\n  return {\n    typeName,\n    values: normalValues,\n    // We do not surface options at this time\n    // options: opt?.options ?? Object.create(null),\n    findName(name) {\n      return names[name];\n    },\n    findNumber(no) {\n      return numbers[no];\n    }\n  };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */\nfunction makeEnum(typeName, values, opt) {\n  const enumObject = {};\n  for (const value of values) {\n    const n = normalizeEnumValue(value);\n    enumObject[n.localName] = n.no;\n    enumObject[n.no] = n.localName;\n  }\n  setEnumType(enumObject, typeName, values);\n  return enumObject;\n}\nfunction normalizeEnumValue(value) {\n  if (\"localName\" in value) {\n    return value;\n  }\n  return Object.assign(Object.assign({}, value), {\n    localName: value.name\n  });\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */\nclass Message {\n  /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */\n  equals(other) {\n    return this.getType().runtime.util.equals(this.getType(), this, other);\n  }\n  /**\n   * Create a deep copy.\n   */\n  clone() {\n    return this.getType().runtime.util.clone(this);\n  }\n  /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */\n  fromBinary(bytes, options) {\n    const type = this.getType(),\n      format = type.runtime.bin,\n      opt = format.makeReadOptions(options);\n    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON value.\n   */\n  fromJson(jsonValue, options) {\n    const type = this.getType(),\n      format = type.runtime.json,\n      opt = format.makeReadOptions(options);\n    format.readMessage(type, jsonValue, opt, this);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON string.\n   */\n  fromJsonString(jsonString, options) {\n    let json;\n    try {\n      json = JSON.parse(jsonString);\n    } catch (e) {\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n    }\n    return this.fromJson(json, options);\n  }\n  /**\n   * Serialize the message to binary data.\n   */\n  toBinary(options) {\n    const type = this.getType(),\n      bin = type.runtime.bin,\n      opt = bin.makeWriteOptions(options),\n      writer = opt.writerFactory();\n    bin.writeMessage(this, writer, opt);\n    return writer.finish();\n  }\n  /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */\n  toJson(options) {\n    const type = this.getType(),\n      json = type.runtime.json,\n      opt = json.makeWriteOptions(options);\n    return json.writeMessage(this, opt);\n  }\n  /**\n   * Serialize the message to a JSON string.\n   */\n  toJsonString(options) {\n    var _a;\n    const value = this.toJson(options);\n    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */\n  toJSON() {\n    return this.toJson({\n      emitDefaultValues: true\n    });\n  }\n  /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */\n  getType() {\n    // Any class that extends Message _must_ provide a complete static\n    // implementation of MessageType.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n    return Object.getPrototypeOf(this).constructor;\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */\nfunction makeMessageType(runtime, typeName, fields, opt) {\n  var _a;\n  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n  const type = {\n    [localName]: function (data) {\n      runtime.util.initFields(this);\n      runtime.util.initPartial(data, this);\n    }\n  }[localName];\n  Object.setPrototypeOf(type.prototype, new Message());\n  Object.assign(type, {\n    runtime,\n    typeName,\n    fields: runtime.util.newFieldList(fields),\n    fromBinary(bytes, options) {\n      return new type().fromBinary(bytes, options);\n    },\n    fromJson(jsonValue, options) {\n      return new type().fromJson(jsonValue, options);\n    },\n    fromJsonString(jsonString, options) {\n      return new type().fromJsonString(jsonString, options);\n    },\n    equals(a, b) {\n      return runtime.util.equals(type, a, b);\n    }\n  });\n  return type;\n}// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nfunction varint64read() {\n  let lowBits = 0;\n  let highBits = 0;\n  for (let shift = 0; shift < 28; shift += 7) {\n    let b = this.buf[this.pos++];\n    lowBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  let middleByte = this.buf[this.pos++];\n  // last four bits of the first 32 bit number\n  lowBits |= (middleByte & 0x0f) << 28;\n  // 3 upper bits are part of the next 32 bit number\n  highBits = (middleByte & 0x70) >> 4;\n  if ((middleByte & 0x80) == 0) {\n    this.assertBounds();\n    return [lowBits, highBits];\n  }\n  for (let shift = 3; shift <= 31; shift += 7) {\n    let b = this.buf[this.pos++];\n    highBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nfunction varint64write(lo, hi, bytes) {\n  for (let i = 0; i < 28; i = i + 7) {\n    const shift = lo >>> i;\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n  const hasMoreBits = !(hi >> 3 == 0);\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n  if (!hasMoreBits) {\n    return;\n  }\n  for (let i = 3; i < 31; i = i + 7) {\n    const shift = hi >>> i;\n    const hasNext = !(shift >>> 7 == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64FromString(dec) {\n  // Check for minus sign.\n  const minus = dec[0] === \"-\";\n  if (minus) {\n    dec = dec.slice(1);\n  }\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\n  // digits to binary. This is safe to do with floating point math because\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n  const base = 1e6;\n  let lowBits = 0;\n  let highBits = 0;\n  function add1e6digit(begin, end) {\n    // Note: Number('') is 0.\n    const digit1e6 = Number(dec.slice(begin, end));\n    highBits *= base;\n    lowBits = lowBits * base + digit1e6;\n    // Carry bits from lowBits to\n    if (lowBits >= TWO_PWR_32_DBL) {\n      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n      lowBits = lowBits % TWO_PWR_32_DBL;\n    }\n  }\n  add1e6digit(-24, -18);\n  add1e6digit(-18, -12);\n  add1e6digit(-12, -6);\n  add1e6digit(-6);\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64ToString(lo, hi) {\n  let bits = newBits(lo, hi);\n  // If we're treating the input as a signed value and the high bit is set, do\n  // a manual two's complement conversion before the decimal conversion.\n  const negative = bits.hi & 0x80000000;\n  if (negative) {\n    bits = negate(bits.lo, bits.hi);\n  }\n  const result = uInt64ToString(bits.lo, bits.hi);\n  return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction uInt64ToString(lo, hi) {\n  ({\n    lo,\n    hi\n  } = toUnsigned(lo, hi));\n  // Skip the expensive conversion if the number is small enough to use the\n  // built-in conversions.\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n  // integer precision.\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n  if (hi <= 0x1FFFFF) {\n    return String(TWO_PWR_32_DBL * hi + lo);\n  }\n  // What this code is doing is essentially converting the input number from\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\n  // only 3 (very large) digits. Those digits are then trivial to convert to\n  // a base-10 string.\n  // The magic numbers used here are -\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n  // Split 32:32 representation into 16:24:24 representation so our\n  // intermediate digits don't overflow.\n  const low = lo & 0xFFFFFF;\n  const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n  const high = hi >> 16 & 0xFFFF;\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\n  // value in a digit at this step is representable as a 48-bit integer, which\n  // can be stored in a 64-bit floating point number.\n  let digitA = low + mid * 6777216 + high * 6710656;\n  let digitB = mid + high * 8147497;\n  let digitC = high * 2;\n  // Apply carries from A to B and from B to C.\n  const base = 10000000;\n  if (digitA >= base) {\n    digitB += Math.floor(digitA / base);\n    digitA %= base;\n  }\n  if (digitB >= base) {\n    digitC += Math.floor(digitB / base);\n    digitB %= base;\n  }\n  // If digitC is 0, then we should have returned in the trivial code path\n  // at the top for non-safe integers. Given this, we can assume both digitB\n  // and digitA need leading zeros.\n  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n  return {\n    lo: lo >>> 0,\n    hi: hi >>> 0\n  };\n}\nfunction newBits(lo, hi) {\n  return {\n    lo: lo | 0,\n    hi: hi | 0\n  };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n  highBits = ~highBits;\n  if (lowBits) {\n    lowBits = ~lowBits + 1;\n  } else {\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n    // adding 1 to that, results in 0x100000000, which leaves\n    // the low bits 0x0 and simply adds one to the high bits.\n    highBits += 1;\n  }\n  return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = digit1e7 => {\n  const partial = String(digit1e7);\n  return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nfunction varint32write(value, bytes) {\n  if (value >= 0) {\n    // write value as varint 32\n    while (value > 0x7f) {\n      bytes.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    bytes.push(value);\n  } else {\n    for (let i = 0; i < 9; i++) {\n      bytes.push(value & 127 | 128);\n      value = value >> 7;\n    }\n    bytes.push(1);\n  }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nfunction varint32read() {\n  let b = this.buf[this.pos++];\n  let result = b & 0x7f;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 7;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 14;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 21;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  // Extract only last 4 bits\n  b = this.buf[this.pos++];\n  result |= (b & 0x0f) << 28;\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n  this.assertBounds();\n  // Result can have 32 bits, convert it to unsigned\n  return result >>> 0;\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n  const dv = new DataView(new ArrayBuffer(8));\n  // note that Safari 14 implements BigInt, but not the DataView methods\n  const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n  if (ok) {\n    const MIN = BigInt(\"-9223372036854775808\"),\n      MAX = BigInt(\"9223372036854775807\"),\n      UMIN = BigInt(\"0\"),\n      UMAX = BigInt(\"18446744073709551615\");\n    return {\n      zero: BigInt(0),\n      supported: true,\n      parse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > MAX || bi < MIN) {\n          throw new Error(\"int64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      uParse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > UMAX || bi < UMIN) {\n          throw new Error(\"uint64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      enc(value) {\n        dv.setBigInt64(0, this.parse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      uEnc(value) {\n        dv.setBigInt64(0, this.uParse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      dec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigInt64(0, true);\n      },\n      uDec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigUint64(0, true);\n      }\n    };\n  }\n  const assertInt64String = value => assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n  const assertUInt64String = value => assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n  return {\n    zero: \"0\",\n    supported: false,\n    parse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return value;\n    },\n    uParse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return value;\n    },\n    enc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return int64FromString(value);\n    },\n    uEnc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return int64FromString(value);\n    },\n    dec(lo, hi) {\n      return int64ToString(lo, hi);\n    },\n    uDec(lo, hi) {\n      return uInt64ToString(lo, hi);\n    }\n  };\n}\nconst protoInt64 = makeInt64Support();// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nvar ScalarType;\n(function (ScalarType) {\n  // 0 is reserved for errors.\n  // Order is weird for historical reasons.\n  ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n  ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n  ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n  ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n  ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n  ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n  ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n  // Tag-delimited aggregate.\n  // Group type is deprecated and not supported in proto3. However, Proto3\n  // implementations should still be able to parse the group wire format and\n  // treat group fields as unknown fields.\n  // TYPE_GROUP = 10,\n  // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n  // New in version 2.\n  ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n  ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n  // TYPE_ENUM = 14,\n  ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n  ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n  ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n  ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */\nvar LongType;\n(function (LongType) {\n  /**\n   * Use JavaScript BigInt.\n   */\n  LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n  /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */\n  LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */\nfunction scalarEquals(type, a, b) {\n  if (a === b) {\n    // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n    return true;\n  }\n  // Special case BYTES - we need to compare each byte individually\n  if (type == ScalarType.BYTES) {\n    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Special case 64-bit integers - we support number, string and bigint representation.\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (type) {\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // Loose comparison will match between 0n, 0 and \"0\".\n      return a == b;\n  }\n  // Anything that hasn't been caught by strict comparison or special cased\n  // BYTES and 64-bit integers is not equal.\n  return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */\nfunction scalarZeroValue(type, longType) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return false;\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      return longType == 0 ? protoInt64.zero : \"0\";\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      return 0.0;\n    case ScalarType.BYTES:\n      return new Uint8Array(0);\n    case ScalarType.STRING:\n      return \"\";\n    default:\n      // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n      // We do not use individual cases to save a few bytes code size.\n      return 0;\n  }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */\nfunction isScalarZeroValue(type, value) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return value === false;\n    case ScalarType.STRING:\n      return value === \"\";\n    case ScalarType.BYTES:\n      return value instanceof Uint8Array && !value.byteLength;\n    default:\n      return value == 0;\n    // Loose comparison matches 0n, 0 and \"0\"\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nvar WireType;\n(function (WireType) {\n  /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n  /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n  /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */\n  WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n  /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */\n  WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n  /**\n   * End of a tag-delimited aggregate.\n   */\n  WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n  /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n  constructor(textEncoder) {\n    /**\n     * Previous fork states.\n     */\n    this.stack = [];\n    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n    this.chunks = [];\n    this.buf = [];\n  }\n  /**\n   * Return all bytes written and reset this writer.\n   */\n  finish() {\n    this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n    let len = 0;\n    for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;\n    let bytes = new Uint8Array(len);\n    let offset = 0;\n    for (let i = 0; i < this.chunks.length; i++) {\n      bytes.set(this.chunks[i], offset);\n      offset += this.chunks[i].length;\n    }\n    this.chunks = [];\n    return bytes;\n  }\n  /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */\n  fork() {\n    this.stack.push({\n      chunks: this.chunks,\n      buf: this.buf\n    });\n    this.chunks = [];\n    this.buf = [];\n    return this;\n  }\n  /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */\n  join() {\n    // get chunk of fork\n    let chunk = this.finish();\n    // restore previous state\n    let prev = this.stack.pop();\n    if (!prev) throw new Error(\"invalid state, fork stack empty\");\n    this.chunks = prev.chunks;\n    this.buf = prev.buf;\n    // write length of chunk as varint\n    this.uint32(chunk.byteLength);\n    return this.raw(chunk);\n  }\n  /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */\n  tag(fieldNo, type) {\n    return this.uint32((fieldNo << 3 | type) >>> 0);\n  }\n  /**\n   * Write a chunk of raw bytes.\n   */\n  raw(chunk) {\n    if (this.buf.length) {\n      this.chunks.push(new Uint8Array(this.buf));\n      this.buf = [];\n    }\n    this.chunks.push(chunk);\n    return this;\n  }\n  /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */\n  uint32(value) {\n    assertUInt32(value);\n    // write value as varint 32, inlined for speed\n    while (value > 0x7f) {\n      this.buf.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    this.buf.push(value);\n    return this;\n  }\n  /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */\n  int32(value) {\n    assertInt32(value);\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `bool` value, a variant.\n   */\n  bool(value) {\n    this.buf.push(value ? 1 : 0);\n    return this;\n  }\n  /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */\n  bytes(value) {\n    this.uint32(value.byteLength); // write length of chunk as varint\n    return this.raw(value);\n  }\n  /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */\n  string(value) {\n    let chunk = this.textEncoder.encode(value);\n    this.uint32(chunk.byteLength); // write length of chunk as varint\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `float` value, 32-bit floating point number.\n   */\n  float(value) {\n    assertFloat32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setFloat32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `double` value, a 64-bit floating point number.\n   */\n  double(value) {\n    let chunk = new Uint8Array(8);\n    new DataView(chunk.buffer).setFloat64(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32(value) {\n    assertUInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setUint32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32(value) {\n    assertInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setInt32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32(value) {\n    assertInt32(value);\n    // zigzag encode\n    value = (value << 1 ^ value >> 31) >>> 0;\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.enc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.uEnc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */\n  int64(value) {\n    let tc = protoInt64.enc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64(value) {\n    let tc = protoInt64.enc(value),\n      // zigzag encode\n      sign = tc.hi >> 31,\n      lo = tc.lo << 1 ^ sign,\n      hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n    varint64write(lo, hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */\n  uint64(value) {\n    let tc = protoInt64.uEnc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n}\nclass BinaryReader {\n  constructor(buf, textDecoder) {\n    this.varint64 = varint64read; // dirty cast for `this`\n    /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */\n    this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n    this.buf = buf;\n    this.len = buf.length;\n    this.pos = 0;\n    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n  }\n  /**\n   * Reads a tag - field number and wire type.\n   */\n  tag() {\n    let tag = this.uint32(),\n      fieldNo = tag >>> 3,\n      wireType = tag & 7;\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n    return [fieldNo, wireType];\n  }\n  /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */\n  skip(wireType, fieldNo) {\n    let start = this.pos;\n    switch (wireType) {\n      case WireType.Varint:\n        while (this.buf[this.pos++] & 0x80) {\n          // ignore\n        }\n        break;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit64:\n        this.pos += 4;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit32:\n        this.pos += 4;\n        break;\n      case WireType.LengthDelimited:\n        let len = this.uint32();\n        this.pos += len;\n        break;\n      case WireType.StartGroup:\n        for (;;) {\n          const [fn, wt] = this.tag();\n          if (wt === WireType.EndGroup) {\n            if (fieldNo !== undefined && fn !== fieldNo) {\n              throw new Error(\"invalid end group tag\");\n            }\n            break;\n          }\n          this.skip(wt, fn);\n        }\n        break;\n      default:\n        throw new Error(\"cant skip wire type \" + wireType);\n    }\n    this.assertBounds();\n    return this.buf.subarray(start, this.pos);\n  }\n  /**\n   * Throws error if position in byte array is out of range.\n   */\n  assertBounds() {\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n  }\n  /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */\n  int32() {\n    return this.uint32() | 0;\n  }\n  /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32() {\n    let zze = this.uint32();\n    // decode zigzag\n    return zze >>> 1 ^ -(zze & 1);\n  }\n  /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */\n  int64() {\n    return protoInt64.dec(...this.varint64());\n  }\n  /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */\n  uint64() {\n    return protoInt64.uDec(...this.varint64());\n  }\n  /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64() {\n    let [lo, hi] = this.varint64();\n    // decode zig zag\n    let s = -(lo & 1);\n    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n    hi = hi >>> 1 ^ s;\n    return protoInt64.dec(lo, hi);\n  }\n  /**\n   * Read a `bool` field, a variant.\n   */\n  bool() {\n    let [lo, hi] = this.varint64();\n    return lo !== 0 || hi !== 0;\n  }\n  /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32() {\n    return this.view.getUint32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32() {\n    return this.view.getInt32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64() {\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64() {\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `float` field, 32-bit floating point number.\n   */\n  float() {\n    return this.view.getFloat32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `double` field, a 64-bit floating point number.\n   */\n  double() {\n    return this.view.getFloat64((this.pos += 8) - 8, true);\n  }\n  /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */\n  bytes() {\n    let len = this.uint32(),\n      start = this.pos;\n    this.pos += len;\n    this.assertBounds();\n    return this.buf.subarray(start, start + len);\n  }\n  /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */\n  string() {\n    return this.textDecoder.decode(this.bytes());\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */\nfunction makeExtension(runtime, typeName, extendee, field) {\n  let fi;\n  return {\n    typeName,\n    extendee,\n    get field() {\n      if (!fi) {\n        const i = typeof field == \"function\" ? field() : field;\n        i.name = typeName.split(\".\").pop();\n        i.jsonName = \"[\".concat(typeName, \"]\");\n        fi = runtime.util.newFieldList([i]).list()[0];\n      }\n      return fi;\n    },\n    runtime\n  };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */\nfunction createExtensionContainer(extension) {\n  const localName = extension.field.localName;\n  const container = Object.create(null);\n  container[localName] = initExtensionField(extension);\n  return [container, () => container[localName]];\n}\nfunction initExtensionField(ext) {\n  const field = ext.field;\n  if (field.repeated) {\n    return [];\n  }\n  if (field.default !== undefined) {\n    return field.default;\n  }\n  switch (field.kind) {\n    case \"enum\":\n      return field.T.values[0].no;\n    case \"scalar\":\n      return scalarZeroValue(field.T, field.L);\n    case \"message\":\n      // eslint-disable-next-line no-case-declarations\n      const T = field.T,\n        value = new T();\n      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n    case \"map\":\n      throw \"map fields are not allowed to be extensions\";\n  }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */\nfunction filterUnknownFields(unknownFields, field) {\n  if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n    // singular scalar fields do not merge, we pick the last\n    for (let i = unknownFields.length - 1; i >= 0; --i) {\n      if (unknownFields[i].no == field.no) {\n        return [unknownFields[i]];\n      }\n    }\n    return [];\n  }\n  return unknownFields.filter(uf => uf.no === field.no);\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\n// lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n  /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */\n  dec(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    if (base64Str[base64Str.length - 2] == \"=\") es -= 2;else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n    let bytes = new Uint8Array(es),\n      bytePos = 0,\n      // position in byte array\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // previous byte\n    for (let i = 0; i < base64Str.length; i++) {\n      b = decTable[base64Str.charCodeAt(i)];\n      if (b === undefined) {\n        switch (base64Str[i]) {\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"=\":\n            groupPos = 0;\n          // reset state when padding found\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"\\n\":\n          case \"\\r\":\n          case \"\\t\":\n          case \" \":\n            continue;\n          // skip white-space, and padding\n          default:\n            throw Error(\"invalid base64 string.\");\n        }\n      }\n      switch (groupPos) {\n        case 0:\n          p = b;\n          groupPos = 1;\n          break;\n        case 1:\n          bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n          p = b;\n          groupPos = 2;\n          break;\n        case 2:\n          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n          p = b;\n          groupPos = 3;\n          break;\n        case 3:\n          bytes[bytePos++] = (p & 3) << 6 | b;\n          groupPos = 0;\n          break;\n      }\n    }\n    if (groupPos == 1) throw Error(\"invalid base64 string.\");\n    return bytes.subarray(0, bytePos);\n  },\n  /**\n   * Encode a byte array to a base64 string.\n   */\n  enc(bytes) {\n    let base64 = \"\",\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n      b = bytes[i];\n      switch (groupPos) {\n        case 0:\n          base64 += encTable[b >> 2];\n          p = (b & 3) << 4;\n          groupPos = 1;\n          break;\n        case 1:\n          base64 += encTable[p | b >> 4];\n          p = (b & 15) << 2;\n          groupPos = 2;\n          break;\n        case 2:\n          base64 += encTable[p | b >> 6];\n          base64 += encTable[b & 63];\n          groupPos = 0;\n          break;\n      }\n    }\n    // add output padding\n    if (groupPos) {\n      base64 += encTable[p];\n      base64 += \"=\";\n      if (groupPos == 1) base64 += \"=\";\n    }\n    return base64;\n  }\n};// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction getExtension(message, extension, options) {\n  assertExtendee(extension, message);\n  const opt = extension.runtime.bin.makeReadOptions(options);\n  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n  const [container, get] = createExtensionContainer(extension);\n  for (const uf of ufs) {\n    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n  }\n  return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction setExtension(message, extension, value, options) {\n  assertExtendee(extension, message);\n  const readOpt = extension.runtime.bin.makeReadOptions(options);\n  const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n  if (hasExtension(message, extension)) {\n    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter(uf => uf.no != extension.field.no);\n    message.getType().runtime.bin.discardUnknownFields(message);\n    for (const uf of ufs) {\n      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n    }\n  }\n  const writer = writeOpt.writerFactory();\n  let f = extension.field;\n  // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n  // We patch the field info to use explicit presence:\n  if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n    f = Object.assign(Object.assign({}, extension.field), {\n      opt: true\n    });\n  }\n  extension.runtime.bin.writeField(f, value, writer, writeOpt);\n  const reader = readOpt.readerFactory(writer.finish());\n  while (reader.pos < reader.len) {\n    const [no, wireType] = reader.tag();\n    const data = reader.skip(wireType, no);\n    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n  }\n}\n/**\n * Check whether an extension is set on a message.\n */\nfunction hasExtension(message, extension) {\n  const messageType = message.getType();\n  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(uf => uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n  assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */\nfunction isFieldSet(field, target) {\n  const localName = field.localName;\n  if (field.repeated) {\n    return target[localName].length > 0;\n  }\n  if (field.oneof) {\n    return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n  }\n  switch (field.kind) {\n    case \"enum\":\n    case \"scalar\":\n      if (field.opt || field.req) {\n        // explicit presence\n        return target[localName] !== undefined;\n      }\n      // implicit presence\n      if (field.kind == \"enum\") {\n        return target[localName] !== field.T.values[0].no;\n      }\n      return !isScalarZeroValue(field.T, target[localName]);\n    case \"message\":\n      return target[localName] !== undefined;\n    case \"map\":\n      return Object.keys(target[localName]).length > 0;\n    // eslint-disable-line @typescript-eslint/no-unsafe-argument\n  }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */\nfunction clearField(field, target) {\n  const localName = field.localName;\n  const implicitPresence = !field.opt && !field.req;\n  if (field.repeated) {\n    target[localName] = [];\n  } else if (field.oneof) {\n    target[field.oneof.localName] = {\n      case: undefined\n    };\n  } else {\n    switch (field.kind) {\n      case \"map\":\n        target[localName] = {};\n        break;\n      case \"enum\":\n        target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n        break;\n      case \"scalar\":\n        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n        break;\n      case \"message\":\n        target[localName] = undefined;\n        break;\n    }\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */\nfunction isMessage(arg, type) {\n  if (arg === null || typeof arg != \"object\") {\n    return false;\n  }\n  if (!Object.getOwnPropertyNames(Message.prototype).every(m => m in arg && typeof arg[m] == \"function\")) {\n    return false;\n  }\n  const actualType = arg.getType();\n  if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n    return false;\n  }\n  return type === undefined ? true : actualType.typeName == type.typeName;\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */\nfunction wrapField(type, value) {\n  if (isMessage(value) || !type.fieldWrapper) {\n    return value;\n  }\n  return type.fieldWrapper.wrapField(value);\n}\n({\n  \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n  \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n  \"google.protobuf.Int64Value\": ScalarType.INT64,\n  \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n  \"google.protobuf.Int32Value\": ScalarType.INT32,\n  \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n  \"google.protobuf.BoolValue\": ScalarType.BOOL,\n  \"google.protobuf.StringValue\": ScalarType.STRING,\n  \"google.protobuf.BytesValue\": ScalarType.BYTES\n});// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */\n// Default options for parsing JSON.\nconst jsonReadDefaults = {\n  ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n  emitDefaultValues: false,\n  enumAsInteger: false,\n  useProtoFieldName: false,\n  prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n  return {\n    makeReadOptions: makeReadOptions$1,\n    makeWriteOptions: makeWriteOptions$1,\n    readMessage(type, json, options, message) {\n      if (json == null || Array.isArray(json) || typeof json != \"object\") {\n        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n      }\n      message = message !== null && message !== void 0 ? message : new type();\n      const oneofSeen = new Map();\n      const registry = options.typeRegistry;\n      for (const [jsonKey, jsonValue] of Object.entries(json)) {\n        const field = type.fields.findJsonName(jsonKey);\n        if (field) {\n          if (field.oneof) {\n            if (jsonValue === null && field.kind == \"scalar\") {\n              // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\n              continue;\n            }\n            const seen = oneofSeen.get(field.oneof);\n            if (seen !== undefined) {\n              throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\n            }\n            oneofSeen.set(field.oneof, jsonKey);\n          }\n          readField$1(message, jsonValue, field, options, type);\n        } else {\n          let found = false;\n          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n            if (ext && ext.extendee.typeName == type.typeName) {\n              found = true;\n              const [container, get] = createExtensionContainer(ext);\n              readField$1(container, jsonValue, ext.field, options, ext);\n              // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n              // so that users can bring their own binary reader and writer factories\n              // if necessary.\n              setExtension(message, ext, get(), options);\n            }\n          }\n          if (!found && !options.ignoreUnknownFields) {\n            throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\n          }\n        }\n      }\n      return message;\n    },\n    writeMessage(message, options) {\n      const type = message.getType();\n      const json = {};\n      let field;\n      try {\n        for (field of type.fields.byNumber()) {\n          if (!isFieldSet(field, message)) {\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (field.req) {\n              throw \"required field not set\";\n            }\n            if (!options.emitDefaultValues) {\n              continue;\n            }\n            if (!canEmitFieldDefaultValue(field)) {\n              continue;\n            }\n          }\n          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n          const jsonValue = writeField$1(field, value, options);\n          if (jsonValue !== undefined) {\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n          }\n        }\n        const registry = options.typeRegistry;\n        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n          for (const uf of type.runtime.bin.listUnknownFields(message)) {\n            const ext = registry.findExtensionFor(type.typeName, uf.no);\n            if (ext && hasExtension(message, ext)) {\n              // We pass on the options as BinaryReadOptions, so that users can bring their own\n              // binary reader factory if necessary.\n              const value = getExtension(message, ext, options);\n              const jsonValue = writeField$1(ext.field, value, options);\n              if (jsonValue !== undefined) {\n                json[ext.field.jsonName] = jsonValue;\n              }\n            }\n          }\n        }\n      } catch (e) {\n        const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n        const r = e instanceof Error ? e.message : String(e);\n        throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n      }\n      return json;\n    },\n    readScalar(type, json, longType) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n    },\n    writeScalar(type, value, emitDefaultValues) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      if (emitDefaultValues || isScalarZeroValue(type, value)) {\n        return writeScalar$1(type, value);\n      }\n      return undefined;\n    },\n    debug: debugJsonValue\n  };\n}\nfunction debugJsonValue(json) {\n  if (json === null) {\n    return \"null\";\n  }\n  switch (typeof json) {\n    case \"object\":\n      return Array.isArray(json) ? \"array\" : \"object\";\n    case \"string\":\n      return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\n    default:\n      return String(json);\n  }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n  let localName = field.localName;\n  if (field.repeated) {\n    assert(field.kind != \"map\");\n    if (jsonValue === null) {\n      return;\n    }\n    if (!Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetArray = target[localName];\n    for (const jsonItem of jsonValue) {\n      if (jsonItem === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n      }\n      switch (field.kind) {\n        case \"message\":\n          targetArray.push(field.T.fromJson(jsonItem, options));\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetArray.push(enumValue);\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n          } catch (e) {\n            let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else if (field.kind == \"map\") {\n    if (jsonValue === null) {\n      return;\n    }\n    if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetMap = target[localName];\n    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\n      if (jsonMapValue === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n      }\n      let key;\n      try {\n        key = readMapKey(field.K, jsonMapKey);\n      } catch (e) {\n        let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n        if (e instanceof Error && e.message.length > 0) {\n          m += \": \".concat(e.message);\n        }\n        throw new Error(m);\n      }\n      switch (field.V.kind) {\n        case \"message\":\n          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetMap[key] = enumValue;\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n          } catch (e) {\n            let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else {\n    if (field.oneof) {\n      target = target[field.oneof.localName] = {\n        case: localName\n      };\n      localName = \"value\";\n    }\n    switch (field.kind) {\n      case \"message\":\n        const messageType = field.T;\n        if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n          return;\n        }\n        let currentValue = target[localName];\n        if (isMessage(currentValue)) {\n          currentValue.fromJson(jsonValue, options);\n        } else {\n          target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n          if (messageType.fieldWrapper && !field.oneof) {\n            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n          }\n        }\n        break;\n      case \"enum\":\n        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n        switch (enumValue) {\n          case tokenNull:\n            clearField(field, target);\n            break;\n          case tokenIgnoredUnknownEnum:\n            break;\n          default:\n            target[localName] = enumValue;\n            break;\n        }\n        break;\n      case \"scalar\":\n        try {\n          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n          switch (scalarValue) {\n            case tokenNull:\n              clearField(field, target);\n              break;\n            default:\n              target[localName] = scalarValue;\n              break;\n          }\n        } catch (e) {\n          let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n          if (e instanceof Error && e.message.length > 0) {\n            m += \": \".concat(e.message);\n          }\n          throw new Error(m);\n        }\n        break;\n    }\n  }\n}\nfunction readMapKey(type, json) {\n  if (type === ScalarType.BOOL) {\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (json) {\n      case \"true\":\n        json = true;\n        break;\n      case \"false\":\n        json = false;\n        break;\n    }\n  }\n  return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n  if (json === null) {\n    if (nullAsZeroValue) {\n      return scalarZeroValue(type, longType);\n    }\n    return tokenNull;\n  }\n  // every valid case in the switch below returns, and every fall\n  // through is regarded as a failure.\n  switch (type) {\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      if (json === \"NaN\") return Number.NaN;\n      if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n      if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n      if (json === \"\") {\n        // empty string is not a number\n        break;\n      }\n      if (typeof json == \"string\" && json.trim().length !== json.length) {\n        // extra whitespace\n        break;\n      }\n      if (typeof json != \"string\" && typeof json != \"number\") {\n        break;\n      }\n      const float = Number(json);\n      if (Number.isNaN(float)) {\n        // not a number\n        break;\n      }\n      if (!Number.isFinite(float)) {\n        // infinity and -infinity are handled by string representation above, so this is an error\n        break;\n      }\n      if (type == ScalarType.FLOAT) assertFloat32(float);\n      return float;\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.UINT32:\n      let int32;\n      if (typeof json == \"number\") int32 = json;else if (typeof json == \"string\" && json.length > 0) {\n        if (json.trim().length === json.length) int32 = Number(json);\n      }\n      if (int32 === undefined) break;\n      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);else assertInt32(int32);\n      return int32;\n    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const long = protoInt64.parse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? long.toString() : long;\n    case ScalarType.FIXED64:\n    case ScalarType.UINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const uLong = protoInt64.uParse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? uLong.toString() : uLong;\n    // bool:\n    case ScalarType.BOOL:\n      if (typeof json !== \"boolean\") break;\n      return json;\n    // string:\n    case ScalarType.STRING:\n      if (typeof json !== \"string\") {\n        break;\n      }\n      // A string must always contain UTF-8 encoded or 7-bit ASCII.\n      // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n      try {\n        encodeURIComponent(json);\n      } catch (e) {\n        throw new Error(\"invalid UTF8\");\n      }\n      return json;\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      if (json === \"\") return new Uint8Array(0);\n      if (typeof json !== \"string\") break;\n      return protoBase64.dec(json);\n  }\n  throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n  if (json === null) {\n    if (type.typeName == \"google.protobuf.NullValue\") {\n      return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n    }\n    return nullAsZeroValue ? type.values[0].no : tokenNull;\n  }\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (typeof json) {\n    case \"number\":\n      if (Number.isInteger(json)) {\n        return json;\n      }\n      break;\n    case \"string\":\n      const value = type.findName(json);\n      if (value !== undefined) {\n        return value.no;\n      }\n      if (ignoreUnknownFields) {\n        return tokenIgnoredUnknownEnum;\n      }\n      break;\n  }\n  throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n  if (field.repeated || field.kind == \"map\") {\n    // maps are {}, repeated fields are []\n    return true;\n  }\n  if (field.oneof) {\n    // oneof fields are never emitted\n    return false;\n  }\n  if (field.kind == \"message\") {\n    // singular message field are allowed to emit JSON null, but we do not\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.opt || field.req) {\n    // the field uses explicit presence, so we cannot emit a zero value\n    return false;\n  }\n  return true;\n}\nfunction writeField$1(field, value, options) {\n  if (field.kind == \"map\") {\n    assert(typeof value == \"object\" && value != null);\n    const jsonObj = {};\n    const entries = Object.entries(value);\n    switch (field.V.kind) {\n      case \"scalar\":\n        for (const [entryKey, entryValue] of entries) {\n          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n        }\n        break;\n      case \"message\":\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = entryValue.toJson(options);\n        }\n        break;\n      case \"enum\":\n        const enumType = field.V.T;\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n        }\n        break;\n    }\n    return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n  }\n  if (field.repeated) {\n    assert(Array.isArray(value));\n    const jsonArr = [];\n    switch (field.kind) {\n      case \"scalar\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeScalar$1(field.T, value[i]));\n        }\n        break;\n      case \"enum\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n        }\n        break;\n      case \"message\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(value[i].toJson(options));\n        }\n        break;\n    }\n    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n  }\n  switch (field.kind) {\n    case \"scalar\":\n      return writeScalar$1(field.T, value);\n    case \"enum\":\n      return writeEnum(field.T, value, options.enumAsInteger);\n    case \"message\":\n      return wrapField(field.T, value).toJson(options);\n  }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n  var _a;\n  assert(typeof value == \"number\");\n  if (type.typeName == \"google.protobuf.NullValue\") {\n    return null;\n  }\n  if (enumAsInteger) {\n    return value;\n  }\n  const val = type.findNumber(value);\n  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n  switch (type) {\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n      assert(typeof value == \"number\");\n      return value;\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.FLOAT:\n    // assertFloat32(value);\n    case ScalarType.DOUBLE:\n      // eslint-disable-line no-fallthrough\n      assert(typeof value == \"number\");\n      if (Number.isNaN(value)) return \"NaN\";\n      if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n      if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n      return value;\n    // string:\n    case ScalarType.STRING:\n      assert(typeof value == \"string\");\n      return value;\n    // bool:\n    case ScalarType.BOOL:\n      assert(typeof value == \"boolean\");\n      return value;\n    // JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n      return value.toString();\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      assert(value instanceof Uint8Array);\n      return protoBase64.enc(value);\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n  readUnknownFields: true,\n  readerFactory: bytes => new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n  writeUnknownFields: true,\n  writerFactory: () => new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n  return {\n    makeReadOptions,\n    makeWriteOptions,\n    listUnknownFields(message) {\n      var _a;\n      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n    },\n    discardUnknownFields(message) {\n      delete message[unknownFieldsSymbol];\n    },\n    writeUnknownFields(message, writer) {\n      const m = message;\n      const c = m[unknownFieldsSymbol];\n      if (c) {\n        for (const f of c) {\n          writer.tag(f.no, f.wireType).raw(f.data);\n        }\n      }\n    },\n    onUnknownField(message, no, wireType, data) {\n      const m = message;\n      if (!Array.isArray(m[unknownFieldsSymbol])) {\n        m[unknownFieldsSymbol] = [];\n      }\n      m[unknownFieldsSymbol].push({\n        no,\n        wireType,\n        data\n      });\n    },\n    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n      const type = message.getType();\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n      let fieldNo, wireType;\n      while (reader.pos < end) {\n        [fieldNo, wireType] = reader.tag();\n        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n          break;\n        }\n        const field = type.fields.find(fieldNo);\n        if (!field) {\n          const data = reader.skip(wireType, fieldNo);\n          if (options.readUnknownFields) {\n            this.onUnknownField(message, fieldNo, wireType, data);\n          }\n          continue;\n        }\n        readField(message, reader, field, wireType, options);\n      }\n      if (delimitedMessageEncoding && (\n      // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n      wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n        throw new Error(\"invalid end group tag\");\n      }\n    },\n    readField,\n    writeMessage(message, writer, options) {\n      const type = message.getType();\n      for (const field of type.fields.byNumber()) {\n        if (!isFieldSet(field, message)) {\n          if (field.req) {\n            throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n          }\n          continue;\n        }\n        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n        writeField(field, value, writer, options);\n      }\n      if (options.writeUnknownFields) {\n        this.writeUnknownFields(message, writer);\n      }\n      return writer;\n    },\n    writeField(field, value, writer, options) {\n      // The behavior of our internal function has changed, it does no longer\n      // accept `undefined` values for singular scalar and map.\n      // For backwards-compatibility, we support the old form that is part of\n      // the public API through the interface BinaryFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      writeField(field, value, writer, options);\n    }\n  };\n}\nfunction readField(target,\n// eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n  let {\n    repeated,\n    localName\n  } = field;\n  if (field.oneof) {\n    target = target[field.oneof.localName];\n    if (target.case != localName) {\n      delete target.value;\n    }\n    target.case = localName;\n    localName = \"value\";\n  }\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      let read = readScalar;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      if (field.kind == \"scalar\" && field.L > 0) {\n        read = readScalarLTString;\n      }\n      if (repeated) {\n        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n        if (isPacked) {\n          let e = reader.uint32() + reader.pos;\n          while (reader.pos < e) {\n            arr.push(read(reader, scalarType));\n          }\n        } else {\n          arr.push(read(reader, scalarType));\n        }\n      } else {\n        target[localName] = read(reader, scalarType);\n      }\n      break;\n    case \"message\":\n      const messageType = field.T;\n      if (repeated) {\n        // safe to assume presence of array, oneof cannot contain repeated values\n        target[localName].push(readMessageField(reader, new messageType(), options, field));\n      } else {\n        if (isMessage(target[localName])) {\n          readMessageField(reader, target[localName], options, field);\n        } else {\n          target[localName] = readMessageField(reader, new messageType(), options, field);\n          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n          }\n        }\n      }\n      break;\n    case \"map\":\n      let [mapKey, mapVal] = readMapEntry(field, reader, options);\n      // safe to assume presence of map object, oneof cannot contain repeated values\n      target[localName][mapKey] = mapVal;\n      break;\n  }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n  const format = message.getType().runtime.bin;\n  const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n  format.readMessage(message, reader, delimited ? field.no : reader.uint32(),\n  // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n  options, delimited);\n  return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n  const length = reader.uint32(),\n    end = reader.pos + length;\n  let key, val;\n  while (reader.pos < end) {\n    const [fieldNo] = reader.tag();\n    switch (fieldNo) {\n      case 1:\n        key = readScalar(reader, field.K);\n        break;\n      case 2:\n        switch (field.V.kind) {\n          case \"scalar\":\n            val = readScalar(reader, field.V.T);\n            break;\n          case \"enum\":\n            val = reader.int32();\n            break;\n          case \"message\":\n            val = readMessageField(reader, new field.V.T(), options, undefined);\n            break;\n        }\n        break;\n    }\n  }\n  if (key === undefined) {\n    key = scalarZeroValue(field.K, LongType.BIGINT);\n  }\n  if (typeof key != \"string\" && typeof key != \"number\") {\n    key = key.toString();\n  }\n  if (val === undefined) {\n    switch (field.V.kind) {\n      case \"scalar\":\n        val = scalarZeroValue(field.V.T, LongType.BIGINT);\n        break;\n      case \"enum\":\n        val = field.V.T.values[0].no;\n        break;\n      case \"message\":\n        val = new field.V.T();\n        break;\n    }\n  }\n  return [key, val];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n  const v = readScalar(reader, type);\n  return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n  switch (type) {\n    case ScalarType.STRING:\n      return reader.string();\n    case ScalarType.BOOL:\n      return reader.bool();\n    case ScalarType.DOUBLE:\n      return reader.double();\n    case ScalarType.FLOAT:\n      return reader.float();\n    case ScalarType.INT32:\n      return reader.int32();\n    case ScalarType.INT64:\n      return reader.int64();\n    case ScalarType.UINT64:\n      return reader.uint64();\n    case ScalarType.FIXED64:\n      return reader.fixed64();\n    case ScalarType.BYTES:\n      return reader.bytes();\n    case ScalarType.FIXED32:\n      return reader.fixed32();\n    case ScalarType.SFIXED32:\n      return reader.sfixed32();\n    case ScalarType.SFIXED64:\n      return reader.sfixed64();\n    case ScalarType.SINT64:\n      return reader.sint64();\n    case ScalarType.UINT32:\n      return reader.uint32();\n    case ScalarType.SINT32:\n      return reader.sint32();\n  }\n}\nfunction writeField(field, value, writer, options) {\n  assert(value !== undefined);\n  const repeated = field.repeated;\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      if (repeated) {\n        assert(Array.isArray(value));\n        if (field.packed) {\n          writePacked(writer, scalarType, field.no, value);\n        } else {\n          for (const item of value) {\n            writeScalar(writer, scalarType, field.no, item);\n          }\n        }\n      } else {\n        writeScalar(writer, scalarType, field.no, value);\n      }\n      break;\n    case \"message\":\n      if (repeated) {\n        assert(Array.isArray(value));\n        for (const item of value) {\n          writeMessageField(writer, options, field, item);\n        }\n      } else {\n        writeMessageField(writer, options, field, value);\n      }\n      break;\n    case \"map\":\n      assert(typeof value == \"object\" && value != null);\n      for (const [key, val] of Object.entries(value)) {\n        writeMapEntry(writer, options, field, key, val);\n      }\n      break;\n  }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n  writer.tag(field.no, WireType.LengthDelimited);\n  writer.fork();\n  // javascript only allows number or string for object properties\n  // we convert from our representation to the protobuf type\n  let keyValue = key;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n  switch (field.K) {\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n      keyValue = Number.parseInt(key);\n      break;\n    case ScalarType.BOOL:\n      assert(key == \"true\" || key == \"false\");\n      keyValue = key == \"true\";\n      break;\n  }\n  // write key, expecting key field number = 1\n  writeScalar(writer, field.K, 1, keyValue);\n  // write value, expecting value field number = 2\n  switch (field.V.kind) {\n    case \"scalar\":\n      writeScalar(writer, field.V.T, 2, value);\n      break;\n    case \"enum\":\n      writeScalar(writer, ScalarType.INT32, 2, value);\n      break;\n    case \"message\":\n      assert(value !== undefined);\n      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n      break;\n  }\n  writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n  const message = wrapField(field.T, value);\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n  assert(value !== undefined);\n  let [wireType, method] = scalarTypeInfo(type);\n  writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n  if (!value.length) {\n    return;\n  }\n  writer.tag(fieldNo, WireType.LengthDelimited).fork();\n  let [, method] = scalarTypeInfo(type);\n  for (let i = 0; i < value.length; i++) {\n    writer[method](value[i]);\n  }\n  writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */\n// TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n  let wireType = WireType.Varint;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n  switch (type) {\n    case ScalarType.BYTES:\n    case ScalarType.STRING:\n      wireType = WireType.LengthDelimited;\n      break;\n    case ScalarType.DOUBLE:\n    case ScalarType.FIXED64:\n    case ScalarType.SFIXED64:\n      wireType = WireType.Bit64;\n      break;\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.FLOAT:\n      wireType = WireType.Bit32;\n      break;\n  }\n  const method = ScalarType[type].toLowerCase();\n  return [wireType, method];\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\nfunction makeUtilCommon() {\n  return {\n    setEnumType,\n    initPartial(source, target) {\n      if (source === undefined) {\n        return;\n      }\n      const type = target.getType();\n      for (const member of type.fields.byMember()) {\n        const localName = member.localName,\n          t = target,\n          s = source;\n        if (s[localName] == null) {\n          // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence\n          continue;\n        }\n        switch (member.kind) {\n          case \"oneof\":\n            const sk = s[localName].case;\n            if (sk === undefined) {\n              continue;\n            }\n            const sourceField = member.findField(sk);\n            let val = s[localName].value;\n            if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n              val = new sourceField.T(val);\n            } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n              val = toU8Arr(val);\n            }\n            t[localName] = {\n              case: sk,\n              value: val\n            };\n            break;\n          case \"scalar\":\n          case \"enum\":\n            let copy = s[localName];\n            if (member.T === ScalarType.BYTES) {\n              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n            }\n            t[localName] = copy;\n            break;\n          case \"map\":\n            switch (member.V.kind) {\n              case \"scalar\":\n              case \"enum\":\n                if (member.V.T === ScalarType.BYTES) {\n                  for (const [k, v] of Object.entries(s[localName])) {\n                    t[localName][k] = toU8Arr(v);\n                  }\n                } else {\n                  Object.assign(t[localName], s[localName]);\n                }\n                break;\n              case \"message\":\n                const messageType = member.V.T;\n                for (const k of Object.keys(s[localName])) {\n                  let val = s[localName][k];\n                  if (!messageType.fieldWrapper) {\n                    // We only take partial input for messages that are not a wrapper type.\n                    // For those messages, we recursively normalize the partial input.\n                    val = new messageType(val);\n                  }\n                  t[localName][k] = val;\n                }\n                break;\n            }\n            break;\n          case \"message\":\n            const mt = member.T;\n            if (member.repeated) {\n              t[localName] = s[localName].map(val => isMessage(val, mt) ? val : new mt(val));\n            } else {\n              const val = s[localName];\n              if (mt.fieldWrapper) {\n                if (\n                // We can't use BytesValue.typeName as that will create a circular import\n                mt.typeName === \"google.protobuf.BytesValue\") {\n                  t[localName] = toU8Arr(val);\n                } else {\n                  t[localName] = val;\n                }\n              } else {\n                t[localName] = isMessage(val, mt) ? val : new mt(val);\n              }\n            }\n            break;\n        }\n      }\n    },\n    // TODO use isFieldSet() here to support future field presence\n    equals(type, a, b) {\n      if (a === b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      return type.fields.byMember().every(m => {\n        const va = a[m.localName];\n        const vb = b[m.localName];\n        if (m.repeated) {\n          if (va.length !== vb.length) {\n            return false;\n          }\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n          switch (m.kind) {\n            case \"message\":\n              return va.every((a, i) => m.T.equals(a, vb[i]));\n            case \"scalar\":\n              return va.every((a, i) => scalarEquals(m.T, a, vb[i]));\n            case \"enum\":\n              return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));\n          }\n          throw new Error(\"repeated cannot contain \".concat(m.kind));\n        }\n        switch (m.kind) {\n          case \"message\":\n            let a = va;\n            let b = vb;\n            if (m.T.fieldWrapper) {\n              if (a !== undefined && !isMessage(a)) {\n                a = m.T.fieldWrapper.wrapField(a);\n              }\n              if (b !== undefined && !isMessage(b)) {\n                b = m.T.fieldWrapper.wrapField(b);\n              }\n            }\n            return m.T.equals(a, b);\n          case \"enum\":\n            return scalarEquals(ScalarType.INT32, va, vb);\n          case \"scalar\":\n            return scalarEquals(m.T, va, vb);\n          case \"oneof\":\n            if (va.case !== vb.case) {\n              return false;\n            }\n            const s = m.findField(va.case);\n            if (s === undefined) {\n              return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n            switch (s.kind) {\n              case \"message\":\n                return s.T.equals(va.value, vb.value);\n              case \"enum\":\n                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n              case \"scalar\":\n                return scalarEquals(s.T, va.value, vb.value);\n            }\n            throw new Error(\"oneof cannot contain \".concat(s.kind));\n          case \"map\":\n            const keys = Object.keys(va).concat(Object.keys(vb));\n            switch (m.V.kind) {\n              case \"message\":\n                const messageType = m.V.T;\n                return keys.every(k => messageType.equals(va[k], vb[k]));\n              case \"enum\":\n                return keys.every(k => scalarEquals(ScalarType.INT32, va[k], vb[k]));\n              case \"scalar\":\n                const scalarType = m.V.T;\n                return keys.every(k => scalarEquals(scalarType, va[k], vb[k]));\n            }\n            break;\n        }\n      });\n    },\n    // TODO use isFieldSet() here to support future field presence\n    clone(message) {\n      const type = message.getType(),\n        target = new type(),\n        any = target;\n      for (const member of type.fields.byMember()) {\n        const source = message[member.localName];\n        let copy;\n        if (member.repeated) {\n          copy = source.map(cloneSingularField);\n        } else if (member.kind == \"map\") {\n          copy = any[member.localName];\n          for (const [key, v] of Object.entries(source)) {\n            copy[key] = cloneSingularField(v);\n          }\n        } else if (member.kind == \"oneof\") {\n          const f = member.findField(source.case);\n          copy = f ? {\n            case: source.case,\n            value: cloneSingularField(source.value)\n          } : {\n            case: undefined\n          };\n        } else {\n          copy = cloneSingularField(source);\n        }\n        any[member.localName] = copy;\n      }\n      for (const uf of type.runtime.bin.listUnknownFields(message)) {\n        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n      }\n      return target;\n    }\n  };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n  if (value === undefined) {\n    return value;\n  }\n  if (isMessage(value)) {\n    return value.clone();\n  }\n  if (value instanceof Uint8Array) {\n    const c = new Uint8Array(value.byteLength);\n    c.set(value);\n    return c;\n  }\n  return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n  return input instanceof Uint8Array ? input : new Uint8Array(input);\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n  return {\n    syntax,\n    json: makeJsonFormat(),\n    bin: makeBinaryFormat(),\n    util: Object.assign(Object.assign({}, makeUtilCommon()), {\n      newFieldList,\n      initFields\n    }),\n    makeMessageType(typeName, fields, opt) {\n      return makeMessageType(this, typeName, fields, opt);\n    },\n    makeEnum,\n    makeEnumType,\n    getEnumType,\n    makeExtension(typeName, extendee, field) {\n      return makeExtension(this, typeName, extendee, field);\n    }\n  };\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n  constructor(fields, normalizer) {\n    this._fields = fields;\n    this._normalizer = normalizer;\n  }\n  findJsonName(jsonName) {\n    if (!this.jsonNames) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.jsonName] = t[f.name] = f;\n      }\n      this.jsonNames = t;\n    }\n    return this.jsonNames[jsonName];\n  }\n  find(fieldNo) {\n    if (!this.numbers) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.no] = f;\n      }\n      this.numbers = t;\n    }\n    return this.numbers[fieldNo];\n  }\n  list() {\n    if (!this.all) {\n      this.all = this._normalizer(this._fields);\n    }\n    return this.all;\n  }\n  byNumber() {\n    if (!this.numbersAsc) {\n      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);\n    }\n    return this.numbersAsc;\n  }\n  byMember() {\n    if (!this.members) {\n      this.members = [];\n      const a = this.members;\n      let o;\n      for (const f of this.list()) {\n        if (f.oneof) {\n          if (f.oneof !== o) {\n            o = f.oneof;\n            a.push(o);\n          }\n        } else {\n          a.push(f);\n        }\n      }\n    }\n    return this.members;\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */\n/**\n * Returns the name of a field in generated code.\n */\nfunction localFieldName(protoName, inOneof) {\n  const name = protoCamelCase(protoName);\n  if (inOneof) {\n    // oneof member names are not properties, but values of the `case` property.\n    return name;\n  }\n  return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */\nfunction localOneofName(protoName) {\n  return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */\nconst fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */\nfunction protoCamelCase(snakeCase) {\n  let capNext = false;\n  const b = [];\n  for (let i = 0; i < snakeCase.length; i++) {\n    let c = snakeCase.charAt(i);\n    switch (c) {\n      case \"_\":\n        capNext = true;\n        break;\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        b.push(c);\n        capNext = false;\n        break;\n      default:\n        if (capNext) {\n          capNext = false;\n          c = c.toUpperCase();\n        }\n        b.push(c);\n        break;\n    }\n  }\n  return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst reservedObjectProperties = new Set([\n// names reserved by JavaScript\n\"constructor\", \"toString\", \"toJSON\", \"valueOf\"]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */\nconst reservedMessageProperties = new Set([\n// names reserved by the runtime\n\"getType\", \"clone\", \"equals\", \"fromBinary\", \"fromJson\", \"fromJsonString\", \"toBinary\", \"toJson\", \"toJsonString\",\n// names reserved by the runtime for the future\n\"toObject\"]);\nconst fallback = name => \"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */\nconst safeMessageProperty = name => {\n  if (reservedMessageProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst safeObjectProperty = name => {\n  if (reservedObjectProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n  constructor(name) {\n    this.kind = \"oneof\";\n    this.repeated = false;\n    this.packed = false;\n    this.opt = false;\n    this.req = false;\n    this.default = undefined;\n    this.fields = [];\n    this.name = name;\n    this.localName = localOneofName(name);\n  }\n  addField(field) {\n    assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n    this.fields.push(field);\n  }\n  findField(localName) {\n    if (!this._lookup) {\n      this._lookup = Object.create(null);\n      for (let i = 0; i < this.fields.length; i++) {\n        this._lookup[this.fields[i].localName] = this.fields[i];\n      }\n    }\n    return this._lookup[localName];\n  }\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */\nfunction normalizeFieldInfos(fieldInfos, packedByDefault) {\n  var _a, _b, _c, _d, _e, _f;\n  const r = [];\n  let o;\n  for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos) {\n    const f = field;\n    f.localName = localFieldName(field.name, field.oneof !== undefined);\n    f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n    if (field.kind == \"scalar\") {\n      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n    }\n    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n    if (field.packed === undefined) {\n      {\n        f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n      }\n    }\n    // We do not surface options at this time\n    // f.options = field.options ?? emptyReadonlyObject;\n    if (field.oneof !== undefined) {\n      const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n      if (!o || o.name != ooname) {\n        o = new InternalOneofInfo(ooname);\n      }\n      f.oneof = o;\n      o.addField(f);\n    }\n    r.push(f);\n  }\n  return r;\n}// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */\nconst proto3 = makeProtoRuntime(\"proto3\", fields => {\n  return new InternalFieldList(fields, source => normalizeFieldInfos(source));\n},\n// TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\ntarget => {\n  for (const member of target.getType().fields.byMember()) {\n    if (member.opt) {\n      continue;\n    }\n    const name = member.localName,\n      t = target;\n    if (member.repeated) {\n      t[name] = [];\n      continue;\n    }\n    switch (member.kind) {\n      case \"oneof\":\n        t[name] = {\n          case: undefined\n        };\n        break;\n      case \"enum\":\n        t[name] = 0;\n        break;\n      case \"map\":\n        t[name] = {};\n        break;\n      case \"scalar\":\n        t[name] = scalarZeroValue(member.T, member.L);\n        break;\n    }\n  }\n});// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */\nclass Timestamp extends Message {\n  constructor(data) {\n    super();\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */\n    this.seconds = protoInt64.zero;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */\n    this.nanos = 0;\n    proto3.util.initPartial(data, this);\n  }\n  fromJson(json, options) {\n    if (typeof json !== \"string\") {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n    }\n    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n    if (!matches) {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    }\n    const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n    if (Number.isNaN(ms)) {\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    }\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n      throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    }\n    this.seconds = protoInt64.parse(ms / 1000);\n    this.nanos = 0;\n    if (matches[7]) {\n      this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n    }\n    return this;\n  }\n  toJson(options) {\n    const ms = Number(this.seconds) * 1000;\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    }\n    if (this.nanos < 0) {\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n    }\n    let z = \"Z\";\n    if (this.nanos > 0) {\n      const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n      if (nanosStr.substring(3) === \"000000\") {\n        z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n      } else if (nanosStr.substring(6) === \"000\") {\n        z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n      } else {\n        z = \".\" + nanosStr + \"Z\";\n      }\n    }\n    return new Date(ms).toISOString().replace(\".000Z\", z);\n  }\n  toDate() {\n    return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n  }\n  static now() {\n    return Timestamp.fromDate(new Date());\n  }\n  static fromDate(date) {\n    const ms = date.getTime();\n    return new Timestamp({\n      seconds: protoInt64.parse(Math.floor(ms / 1000)),\n      nanos: ms % 1000 * 1000000\n    });\n  }\n  static fromBinary(bytes, options) {\n    return new Timestamp().fromBinary(bytes, options);\n  }\n  static fromJson(jsonValue, options) {\n    return new Timestamp().fromJson(jsonValue, options);\n  }\n  static fromJsonString(jsonString, options) {\n    return new Timestamp().fromJsonString(jsonString, options);\n  }\n  static equals(a, b) {\n    return proto3.util.equals(Timestamp, a, b);\n  }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"seconds\",\n  kind: \"scalar\",\n  T: 3 /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"nanos\",\n  kind: \"scalar\",\n  T: 5 /* ScalarType.INT32 */\n}]);const MetricsBatch = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricsBatch\", () => [{\n  no: 1,\n  name: \"timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"normalized_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"str_data\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"time_series\",\n  kind: \"message\",\n  T: TimeSeriesMetric,\n  repeated: true\n}, {\n  no: 5,\n  name: \"events\",\n  kind: \"message\",\n  T: EventMetric,\n  repeated: true\n}]);\nconst TimeSeriesMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimeSeriesMetric\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"samples\",\n  kind: \"message\",\n  T: MetricSample,\n  repeated: true\n}, {\n  no: 5,\n  name: \"rid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst MetricSample = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricSample\", () => [{\n  no: 1,\n  name: \"timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"normalized_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"value\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}]);\nconst EventMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.EventMetric\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"start_timestamp_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 5,\n  name: \"end_timestamp_ms\",\n  kind: \"scalar\",\n  T: 3,\n  opt: true\n}, {\n  no: 6,\n  name: \"normalized_start_timestamp\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 7,\n  name: \"normalized_end_timestamp\",\n  kind: \"message\",\n  T: Timestamp,\n  opt: true\n}, {\n  no: 8,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"rid\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst AudioCodec = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioCodec\", [{\n  no: 0,\n  name: \"DEFAULT_AC\"\n}, {\n  no: 1,\n  name: \"OPUS\"\n}, {\n  no: 2,\n  name: \"AAC\"\n}, {\n  no: 3,\n  name: \"AC_MP3\"\n}]);\nconst VideoCodec = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoCodec\", [{\n  no: 0,\n  name: \"DEFAULT_VC\"\n}, {\n  no: 1,\n  name: \"H264_BASELINE\"\n}, {\n  no: 2,\n  name: \"H264_MAIN\"\n}, {\n  no: 3,\n  name: \"H264_HIGH\"\n}, {\n  no: 4,\n  name: \"VP8\"\n}]);\nconst ImageCodec = /* @__PURE__ */proto3.makeEnum(\"livekit.ImageCodec\", [{\n  no: 0,\n  name: \"IC_DEFAULT\"\n}, {\n  no: 1,\n  name: \"IC_JPEG\"\n}]);\nconst BackupCodecPolicy$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.BackupCodecPolicy\", [{\n  no: 0,\n  name: \"PREFER_REGRESSION\"\n}, {\n  no: 1,\n  name: \"SIMULCAST\"\n}, {\n  no: 2,\n  name: \"REGRESSION\"\n}]);\nconst TrackType = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackType\", [{\n  no: 0,\n  name: \"AUDIO\"\n}, {\n  no: 1,\n  name: \"VIDEO\"\n}, {\n  no: 2,\n  name: \"DATA\"\n}]);\nconst TrackSource = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackSource\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"CAMERA\"\n}, {\n  no: 2,\n  name: \"MICROPHONE\"\n}, {\n  no: 3,\n  name: \"SCREEN_SHARE\"\n}, {\n  no: 4,\n  name: \"SCREEN_SHARE_AUDIO\"\n}]);\nconst VideoQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoQuality\", [{\n  no: 0,\n  name: \"LOW\"\n}, {\n  no: 1,\n  name: \"MEDIUM\"\n}, {\n  no: 2,\n  name: \"HIGH\"\n}, {\n  no: 3,\n  name: \"OFF\"\n}]);\nconst ConnectionQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.ConnectionQuality\", [{\n  no: 0,\n  name: \"POOR\"\n}, {\n  no: 1,\n  name: \"GOOD\"\n}, {\n  no: 2,\n  name: \"EXCELLENT\"\n}, {\n  no: 3,\n  name: \"LOST\"\n}]);\nconst ClientConfigSetting = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientConfigSetting\", [{\n  no: 0,\n  name: \"UNSET\"\n}, {\n  no: 1,\n  name: \"DISABLED\"\n}, {\n  no: 2,\n  name: \"ENABLED\"\n}]);\nconst DisconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.DisconnectReason\", [{\n  no: 0,\n  name: \"UNKNOWN_REASON\"\n}, {\n  no: 1,\n  name: \"CLIENT_INITIATED\"\n}, {\n  no: 2,\n  name: \"DUPLICATE_IDENTITY\"\n}, {\n  no: 3,\n  name: \"SERVER_SHUTDOWN\"\n}, {\n  no: 4,\n  name: \"PARTICIPANT_REMOVED\"\n}, {\n  no: 5,\n  name: \"ROOM_DELETED\"\n}, {\n  no: 6,\n  name: \"STATE_MISMATCH\"\n}, {\n  no: 7,\n  name: \"JOIN_FAILURE\"\n}, {\n  no: 8,\n  name: \"MIGRATION\"\n}, {\n  no: 9,\n  name: \"SIGNAL_CLOSE\"\n}, {\n  no: 10,\n  name: \"ROOM_CLOSED\"\n}, {\n  no: 11,\n  name: \"USER_UNAVAILABLE\"\n}, {\n  no: 12,\n  name: \"USER_REJECTED\"\n}, {\n  no: 13,\n  name: \"SIP_TRUNK_FAILURE\"\n}, {\n  no: 14,\n  name: \"CONNECTION_TIMEOUT\"\n}, {\n  no: 15,\n  name: \"MEDIA_FAILURE\"\n}]);\nconst ReconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.ReconnectReason\", [{\n  no: 0,\n  name: \"RR_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"RR_SIGNAL_DISCONNECTED\"\n}, {\n  no: 2,\n  name: \"RR_PUBLISHER_FAILED\"\n}, {\n  no: 3,\n  name: \"RR_SUBSCRIBER_FAILED\"\n}, {\n  no: 4,\n  name: \"RR_SWITCH_CANDIDATE\"\n}]);\nconst SubscriptionError = /* @__PURE__ */proto3.makeEnum(\"livekit.SubscriptionError\", [{\n  no: 0,\n  name: \"SE_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"SE_CODEC_UNSUPPORTED\"\n}, {\n  no: 2,\n  name: \"SE_TRACK_NOTFOUND\"\n}]);\nconst AudioTrackFeature = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioTrackFeature\", [{\n  no: 0,\n  name: \"TF_STEREO\"\n}, {\n  no: 1,\n  name: \"TF_NO_DTX\"\n}, {\n  no: 2,\n  name: \"TF_AUTO_GAIN_CONTROL\"\n}, {\n  no: 3,\n  name: \"TF_ECHO_CANCELLATION\"\n}, {\n  no: 4,\n  name: \"TF_NOISE_SUPPRESSION\"\n}, {\n  no: 5,\n  name: \"TF_ENHANCED_NOISE_CANCELLATION\"\n}, {\n  no: 6,\n  name: \"TF_PRECONNECT_BUFFER\"\n}]);\nconst Room$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.Room\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"empty_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 14,\n  name: \"departure_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"max_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"creation_time\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 15,\n  name: \"creation_time_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 6,\n  name: \"turn_password\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"enabled_codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 8,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"num_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"num_publishers\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 10,\n  name: \"active_recording\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}]);\nconst Codec = /* @__PURE__ */proto3.makeMessageType(\"livekit.Codec\", () => [{\n  no: 1,\n  name: \"mime\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"fmtp_line\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ParticipantPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantPermission\", () => [{\n  no: 1,\n  name: \"can_subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"can_publish\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"can_publish_data\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"can_publish_sources\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource),\n  repeated: true\n}, {\n  no: 7,\n  name: \"hidden\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"recorder\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 10,\n  name: \"can_update_metadata\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 11,\n  name: \"agent\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 12,\n  name: \"can_subscribe_metrics\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst ParticipantInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_State)\n}, {\n  no: 4,\n  name: \"tracks\",\n  kind: \"message\",\n  T: TrackInfo,\n  repeated: true\n}, {\n  no: 5,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"joined_at\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 17,\n  name: \"joined_at_ms\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 9,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"permission\",\n  kind: \"message\",\n  T: ParticipantPermission\n}, {\n  no: 12,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"is_publisher\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_Kind)\n}, {\n  no: 15,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 16,\n  name: \"disconnect_reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DisconnectReason)\n}, {\n  no: 18,\n  name: \"kind_details\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_KindDetail),\n  repeated: true\n}]);\nconst ParticipantInfo_State = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.State\", [{\n  no: 0,\n  name: \"JOINING\"\n}, {\n  no: 1,\n  name: \"JOINED\"\n}, {\n  no: 2,\n  name: \"ACTIVE\"\n}, {\n  no: 3,\n  name: \"DISCONNECTED\"\n}]);\nconst ParticipantInfo_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [{\n  no: 0,\n  name: \"STANDARD\"\n}, {\n  no: 1,\n  name: \"INGRESS\"\n}, {\n  no: 2,\n  name: \"EGRESS\"\n}, {\n  no: 3,\n  name: \"SIP\"\n}, {\n  no: 4,\n  name: \"AGENT\"\n}, {\n  no: 7,\n  name: \"CONNECTOR\"\n}]);\nconst ParticipantInfo_KindDetail = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [{\n  no: 0,\n  name: \"CLOUD_AGENT\"\n}, {\n  no: 1,\n  name: \"FORWARDED\"\n}]);\nconst Encryption_Type = /* @__PURE__ */proto3.makeEnum(\"livekit.Encryption.Type\", [{\n  no: 0,\n  name: \"NONE\"\n}, {\n  no: 1,\n  name: \"GCM\"\n}, {\n  no: 2,\n  name: \"CUSTOM\"\n}]);\nconst SimulcastCodecInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", () => [{\n  no: 1,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 5,\n  name: \"video_layer_mode\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoLayer_Mode)\n}, {\n  no: 6,\n  name: \"sdp_cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst TrackInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 3,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"simulcast\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 10,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 11,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"codecs\",\n  kind: \"message\",\n  T: SimulcastCodecInfo,\n  repeated: true\n}, {\n  no: 14,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 15,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 16,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 17,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 18,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}, {\n  no: 19,\n  name: \"audio_features\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioTrackFeature),\n  repeated: true\n}, {\n  no: 20,\n  name: \"backup_codec_policy\",\n  kind: \"enum\",\n  T: proto3.getEnumType(BackupCodecPolicy$1)\n}]);\nconst VideoLayer = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoLayer\", () => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"bitrate\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"ssrc\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"spatial_layer\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 7,\n  name: \"rid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst VideoLayer_Mode = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoLayer.Mode\", [{\n  no: 0,\n  name: \"MODE_UNUSED\"\n}, {\n  no: 1,\n  name: \"ONE_SPATIAL_LAYER_PER_STREAM\"\n}, {\n  no: 2,\n  name: \"MULTIPLE_SPATIAL_LAYERS_PER_STREAM\"\n}, {\n  no: 3,\n  name: \"ONE_SPATIAL_LAYER_PER_STREAM_INCOMPLETE_RTCP_SR\"\n}]);\nconst DataPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataPacket\", () => [{\n  no: 1,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DataPacket_Kind)\n}, {\n  no: 4,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"destination_identities\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"user\",\n  kind: \"message\",\n  T: UserPacket,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"speaker\",\n  kind: \"message\",\n  T: ActiveSpeakerUpdate,\n  oneof: \"value\"\n}, {\n  no: 6,\n  name: \"sip_dtmf\",\n  kind: \"message\",\n  T: SipDTMF,\n  oneof: \"value\"\n}, {\n  no: 7,\n  name: \"transcription\",\n  kind: \"message\",\n  T: Transcription,\n  oneof: \"value\"\n}, {\n  no: 8,\n  name: \"metrics\",\n  kind: \"message\",\n  T: MetricsBatch,\n  oneof: \"value\"\n}, {\n  no: 9,\n  name: \"chat_message\",\n  kind: \"message\",\n  T: ChatMessage,\n  oneof: \"value\"\n}, {\n  no: 10,\n  name: \"rpc_request\",\n  kind: \"message\",\n  T: RpcRequest,\n  oneof: \"value\"\n}, {\n  no: 11,\n  name: \"rpc_ack\",\n  kind: \"message\",\n  T: RpcAck,\n  oneof: \"value\"\n}, {\n  no: 12,\n  name: \"rpc_response\",\n  kind: \"message\",\n  T: RpcResponse,\n  oneof: \"value\"\n}, {\n  no: 13,\n  name: \"stream_header\",\n  kind: \"message\",\n  T: DataStream_Header,\n  oneof: \"value\"\n}, {\n  no: 14,\n  name: \"stream_chunk\",\n  kind: \"message\",\n  T: DataStream_Chunk,\n  oneof: \"value\"\n}, {\n  no: 15,\n  name: \"stream_trailer\",\n  kind: \"message\",\n  T: DataStream_Trailer,\n  oneof: \"value\"\n}, {\n  no: 18,\n  name: \"encrypted_packet\",\n  kind: \"message\",\n  T: EncryptedPacket,\n  oneof: \"value\"\n}, {\n  no: 16,\n  name: \"sequence\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 17,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst DataPacket_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.DataPacket.Kind\", [{\n  no: 0,\n  name: \"RELIABLE\"\n}, {\n  no: 1,\n  name: \"LOSSY\"\n}]);\nconst EncryptedPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.EncryptedPacket\", () => [{\n  no: 1,\n  name: \"encryption_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 2,\n  name: \"iv\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 3,\n  name: \"key_index\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"encrypted_value\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}]);\nconst EncryptedPacketPayload = /* @__PURE__ */proto3.makeMessageType(\"livekit.EncryptedPacketPayload\", () => [{\n  no: 1,\n  name: \"user\",\n  kind: \"message\",\n  T: UserPacket,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"chat_message\",\n  kind: \"message\",\n  T: ChatMessage,\n  oneof: \"value\"\n}, {\n  no: 4,\n  name: \"rpc_request\",\n  kind: \"message\",\n  T: RpcRequest,\n  oneof: \"value\"\n}, {\n  no: 5,\n  name: \"rpc_ack\",\n  kind: \"message\",\n  T: RpcAck,\n  oneof: \"value\"\n}, {\n  no: 6,\n  name: \"rpc_response\",\n  kind: \"message\",\n  T: RpcResponse,\n  oneof: \"value\"\n}, {\n  no: 7,\n  name: \"stream_header\",\n  kind: \"message\",\n  T: DataStream_Header,\n  oneof: \"value\"\n}, {\n  no: 8,\n  name: \"stream_chunk\",\n  kind: \"message\",\n  T: DataStream_Chunk,\n  oneof: \"value\"\n}, {\n  no: 9,\n  name: \"stream_trailer\",\n  kind: \"message\",\n  T: DataStream_Trailer,\n  oneof: \"value\"\n}]);\nconst ActiveSpeakerUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", () => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: true\n}]);\nconst SpeakerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakerInfo\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"level\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}, {\n  no: 3,\n  name: \"active\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst UserPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.UserPacket\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 3,\n  name: \"destination_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 6,\n  name: \"destination_identities\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"topic\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 8,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 9,\n  name: \"start_time\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 10,\n  name: \"end_time\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 11,\n  name: \"nonce\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}]);\nconst SipDTMF = /* @__PURE__ */proto3.makeMessageType(\"livekit.SipDTMF\", () => [{\n  no: 3,\n  name: \"code\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"digit\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst Transcription = /* @__PURE__ */proto3.makeMessageType(\"livekit.Transcription\", () => [{\n  no: 2,\n  name: \"transcribed_participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"track_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"segments\",\n  kind: \"message\",\n  T: TranscriptionSegment,\n  repeated: true\n}]);\nconst TranscriptionSegment = /* @__PURE__ */proto3.makeMessageType(\"livekit.TranscriptionSegment\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"text\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"start_time\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 4,\n  name: \"end_time\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 5,\n  name: \"final\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 6,\n  name: \"language\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ChatMessage = /* @__PURE__ */proto3.makeMessageType(\"livekit.ChatMessage\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 3,\n  name: \"edit_timestamp\",\n  kind: \"scalar\",\n  T: 3,\n  opt: true\n}, {\n  no: 4,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"deleted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 6,\n  name: \"generated\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst RpcRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcRequest\", () => [{\n  no: 1,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"method\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"response_timeout_ms\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst RpcAck = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcAck\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst RpcResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcResponse\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 9,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"error\",\n  kind: \"message\",\n  T: RpcError$1,\n  oneof: \"value\"\n}]);\nconst RpcError$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcError\", () => [{\n  no: 1,\n  name: \"code\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"data\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ParticipantTracks = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantTracks\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}]);\nconst ServerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ServerInfo\", () => [{\n  no: 1,\n  name: \"edition\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ServerInfo_Edition)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"node_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"debug_info\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"agent_protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nconst ServerInfo_Edition = /* @__PURE__ */proto3.makeEnum(\"livekit.ServerInfo.Edition\", [{\n  no: 0,\n  name: \"Standard\"\n}, {\n  no: 1,\n  name: \"Cloud\"\n}]);\nconst ClientInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientInfo\", () => [{\n  no: 1,\n  name: \"sdk\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientInfo_SDK)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"os\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"os_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"device_model\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"browser\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"browser_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"address\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"network\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 11,\n  name: \"other_sdks\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ClientInfo_SDK = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientInfo.SDK\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"JS\"\n}, {\n  no: 2,\n  name: \"SWIFT\"\n}, {\n  no: 3,\n  name: \"ANDROID\"\n}, {\n  no: 4,\n  name: \"FLUTTER\"\n}, {\n  no: 5,\n  name: \"GO\"\n}, {\n  no: 6,\n  name: \"UNITY\"\n}, {\n  no: 7,\n  name: \"REACT_NATIVE\"\n}, {\n  no: 8,\n  name: \"RUST\"\n}, {\n  no: 9,\n  name: \"PYTHON\"\n}, {\n  no: 10,\n  name: \"CPP\"\n}, {\n  no: 11,\n  name: \"UNITY_WEB\"\n}, {\n  no: 12,\n  name: \"NODE\"\n}, {\n  no: 13,\n  name: \"UNREAL\"\n}, {\n  no: 14,\n  name: \"ESP32\"\n}]);\nconst ClientConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientConfiguration\", () => [{\n  no: 1,\n  name: \"video\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 2,\n  name: \"screen\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 3,\n  name: \"resume_connection\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}, {\n  no: 4,\n  name: \"disabled_codecs\",\n  kind: \"message\",\n  T: DisabledCodecs\n}, {\n  no: 5,\n  name: \"force_relay\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nconst VideoConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoConfiguration\", () => [{\n  no: 1,\n  name: \"hardware_encoder\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nconst DisabledCodecs = /* @__PURE__ */proto3.makeMessageType(\"livekit.DisabledCodecs\", () => [{\n  no: 1,\n  name: \"codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 2,\n  name: \"publish\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}]);\nconst TimedVersion = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimedVersion\", () => [{\n  no: 1,\n  name: \"unix_micro\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"ticks\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nconst DataStream_OperationType = /* @__PURE__ */proto3.makeEnum(\"livekit.DataStream.OperationType\", [{\n  no: 0,\n  name: \"CREATE\"\n}, {\n  no: 1,\n  name: \"UPDATE\"\n}, {\n  no: 2,\n  name: \"DELETE\"\n}, {\n  no: 3,\n  name: \"REACTION\"\n}]);\nconst DataStream_TextHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.TextHeader\", () => [{\n  no: 1,\n  name: \"operation_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DataStream_OperationType)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 3,\n  name: \"reply_to_stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"attached_stream_ids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 5,\n  name: \"generated\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}], {\n  localName: \"DataStream_TextHeader\"\n});\nconst DataStream_ByteHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", () => [{\n  no: 1,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}], {\n  localName: \"DataStream_ByteHeader\"\n});\nconst DataStream_Header = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Header\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 3,\n  name: \"topic\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"total_length\",\n  kind: \"scalar\",\n  T: 4,\n  opt: true\n}, {\n  no: 7,\n  name: \"encryption_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 8,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 9,\n  name: \"text_header\",\n  kind: \"message\",\n  T: DataStream_TextHeader,\n  oneof: \"content_header\"\n}, {\n  no: 10,\n  name: \"byte_header\",\n  kind: \"message\",\n  T: DataStream_ByteHeader,\n  oneof: \"content_header\"\n}], {\n  localName: \"DataStream_Header\"\n});\nconst DataStream_Chunk = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Chunk\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"chunk_index\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 3,\n  name: \"content\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 4,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 5,\n  name: \"iv\",\n  kind: \"scalar\",\n  T: 12,\n  opt: true\n}], {\n  localName: \"DataStream_Chunk\"\n});\nconst DataStream_Trailer = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Trailer\", () => [{\n  no: 1,\n  name: \"stream_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}], {\n  localName: \"DataStream_Trailer\"\n});\nconst FilterParams = /* @__PURE__ */proto3.makeMessageType(\"livekit.FilterParams\", () => [{\n  no: 1,\n  name: \"include_events\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"exclude_events\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}]);\nconst WebhookConfig = /* @__PURE__ */proto3.makeMessageType(\"livekit.WebhookConfig\", () => [{\n  no: 1,\n  name: \"url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"signing_key\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"filter_params\",\n  kind: \"message\",\n  T: FilterParams\n}]);\nconst SubscribedAudioCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedAudioCodec\", () => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"enabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst RoomAgentDispatch = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomAgentDispatch\", () => [{\n  no: 1,\n  name: \"agent_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst EncodedFileType = /* @__PURE__ */proto3.makeEnum(\"livekit.EncodedFileType\", [{\n  no: 0,\n  name: \"DEFAULT_FILETYPE\"\n}, {\n  no: 1,\n  name: \"MP4\"\n}, {\n  no: 2,\n  name: \"OGG\"\n}, {\n  no: 3,\n  name: \"MP3\"\n}]);\nconst SegmentedFileProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.SegmentedFileProtocol\", [{\n  no: 0,\n  name: \"DEFAULT_SEGMENTED_FILE_PROTOCOL\"\n}, {\n  no: 1,\n  name: \"HLS_PROTOCOL\"\n}]);\nconst SegmentedFileSuffix = /* @__PURE__ */proto3.makeEnum(\"livekit.SegmentedFileSuffix\", [{\n  no: 0,\n  name: \"INDEX\"\n}, {\n  no: 1,\n  name: \"TIMESTAMP\"\n}]);\nconst ImageFileSuffix = /* @__PURE__ */proto3.makeEnum(\"livekit.ImageFileSuffix\", [{\n  no: 0,\n  name: \"IMAGE_SUFFIX_INDEX\"\n}, {\n  no: 1,\n  name: \"IMAGE_SUFFIX_TIMESTAMP\"\n}, {\n  no: 2,\n  name: \"IMAGE_SUFFIX_NONE_OVERWRITE\"\n}]);\nconst StreamProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.StreamProtocol\", [{\n  no: 0,\n  name: \"DEFAULT_PROTOCOL\"\n}, {\n  no: 1,\n  name: \"RTMP\"\n}, {\n  no: 2,\n  name: \"SRT\"\n}]);\nconst AudioMixing = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioMixing\", [{\n  no: 0,\n  name: \"DEFAULT_MIXING\"\n}, {\n  no: 1,\n  name: \"DUAL_CHANNEL_AGENT\"\n}, {\n  no: 2,\n  name: \"DUAL_CHANNEL_ALTERNATE\"\n}]);\nconst EncodingOptionsPreset = /* @__PURE__ */proto3.makeEnum(\"livekit.EncodingOptionsPreset\", [{\n  no: 0,\n  name: \"H264_720P_30\"\n}, {\n  no: 1,\n  name: \"H264_720P_60\"\n}, {\n  no: 2,\n  name: \"H264_1080P_30\"\n}, {\n  no: 3,\n  name: \"H264_1080P_60\"\n}, {\n  no: 4,\n  name: \"PORTRAIT_H264_720P_30\"\n}, {\n  no: 5,\n  name: \"PORTRAIT_H264_720P_60\"\n}, {\n  no: 6,\n  name: \"PORTRAIT_H264_1080P_30\"\n}, {\n  no: 7,\n  name: \"PORTRAIT_H264_1080P_60\"\n}]);\nconst RoomCompositeEgressRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomCompositeEgressRequest\", () => [{\n  no: 1,\n  name: \"room_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"layout\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"audio_only\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 15,\n  name: \"audio_mixing\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioMixing)\n}, {\n  no: 4,\n  name: \"video_only\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 5,\n  name: \"custom_base_url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"file\",\n  kind: \"message\",\n  T: EncodedFileOutput,\n  oneof: \"output\"\n}, {\n  no: 7,\n  name: \"stream\",\n  kind: \"message\",\n  T: StreamOutput,\n  oneof: \"output\"\n}, {\n  no: 10,\n  name: \"segments\",\n  kind: \"message\",\n  T: SegmentedFileOutput,\n  oneof: \"output\"\n}, {\n  no: 8,\n  name: \"preset\",\n  kind: \"enum\",\n  T: proto3.getEnumType(EncodingOptionsPreset),\n  oneof: \"options\"\n}, {\n  no: 9,\n  name: \"advanced\",\n  kind: \"message\",\n  T: EncodingOptions,\n  oneof: \"options\"\n}, {\n  no: 11,\n  name: \"file_outputs\",\n  kind: \"message\",\n  T: EncodedFileOutput,\n  repeated: true\n}, {\n  no: 12,\n  name: \"stream_outputs\",\n  kind: \"message\",\n  T: StreamOutput,\n  repeated: true\n}, {\n  no: 13,\n  name: \"segment_outputs\",\n  kind: \"message\",\n  T: SegmentedFileOutput,\n  repeated: true\n}, {\n  no: 14,\n  name: \"image_outputs\",\n  kind: \"message\",\n  T: ImageOutput,\n  repeated: true\n}, {\n  no: 16,\n  name: \"webhooks\",\n  kind: \"message\",\n  T: WebhookConfig,\n  repeated: true\n}]);\nconst EncodedFileOutput = /* @__PURE__ */proto3.makeMessageType(\"livekit.EncodedFileOutput\", () => [{\n  no: 1,\n  name: \"file_type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(EncodedFileType)\n}, {\n  no: 2,\n  name: \"filepath\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"disable_manifest\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"s3\",\n  kind: \"message\",\n  T: S3Upload,\n  oneof: \"output\"\n}, {\n  no: 4,\n  name: \"gcp\",\n  kind: \"message\",\n  T: GCPUpload,\n  oneof: \"output\"\n}, {\n  no: 5,\n  name: \"azure\",\n  kind: \"message\",\n  T: AzureBlobUpload,\n  oneof: \"output\"\n}, {\n  no: 7,\n  name: \"aliOSS\",\n  kind: \"message\",\n  T: AliOSSUpload,\n  oneof: \"output\"\n}]);\nconst SegmentedFileOutput = /* @__PURE__ */proto3.makeMessageType(\"livekit.SegmentedFileOutput\", () => [{\n  no: 1,\n  name: \"protocol\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SegmentedFileProtocol)\n}, {\n  no: 2,\n  name: \"filename_prefix\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"playlist_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 11,\n  name: \"live_playlist_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"segment_duration\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 10,\n  name: \"filename_suffix\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SegmentedFileSuffix)\n}, {\n  no: 8,\n  name: \"disable_manifest\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 5,\n  name: \"s3\",\n  kind: \"message\",\n  T: S3Upload,\n  oneof: \"output\"\n}, {\n  no: 6,\n  name: \"gcp\",\n  kind: \"message\",\n  T: GCPUpload,\n  oneof: \"output\"\n}, {\n  no: 7,\n  name: \"azure\",\n  kind: \"message\",\n  T: AzureBlobUpload,\n  oneof: \"output\"\n}, {\n  no: 9,\n  name: \"aliOSS\",\n  kind: \"message\",\n  T: AliOSSUpload,\n  oneof: \"output\"\n}]);\nconst ImageOutput = /* @__PURE__ */proto3.makeMessageType(\"livekit.ImageOutput\", () => [{\n  no: 1,\n  name: \"capture_interval\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"filename_prefix\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"filename_suffix\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ImageFileSuffix)\n}, {\n  no: 6,\n  name: \"image_codec\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ImageCodec)\n}, {\n  no: 7,\n  name: \"disable_manifest\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"s3\",\n  kind: \"message\",\n  T: S3Upload,\n  oneof: \"output\"\n}, {\n  no: 9,\n  name: \"gcp\",\n  kind: \"message\",\n  T: GCPUpload,\n  oneof: \"output\"\n}, {\n  no: 10,\n  name: \"azure\",\n  kind: \"message\",\n  T: AzureBlobUpload,\n  oneof: \"output\"\n}, {\n  no: 11,\n  name: \"aliOSS\",\n  kind: \"message\",\n  T: AliOSSUpload,\n  oneof: \"output\"\n}]);\nconst S3Upload = /* @__PURE__ */proto3.makeMessageType(\"livekit.S3Upload\", () => [{\n  no: 1,\n  name: \"access_key\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"secret\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 11,\n  name: \"session_token\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"assume_role_arn\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"assume_role_external_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"endpoint\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"bucket\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"force_path_style\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"metadata\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 8,\n  name: \"tagging\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"content_disposition\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"proxy\",\n  kind: \"message\",\n  T: ProxyConfig\n}]);\nconst GCPUpload = /* @__PURE__ */proto3.makeMessageType(\"livekit.GCPUpload\", () => [{\n  no: 1,\n  name: \"credentials\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"bucket\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"proxy\",\n  kind: \"message\",\n  T: ProxyConfig\n}]);\nconst AzureBlobUpload = /* @__PURE__ */proto3.makeMessageType(\"livekit.AzureBlobUpload\", () => [{\n  no: 1,\n  name: \"account_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"account_key\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"container_name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst AliOSSUpload = /* @__PURE__ */proto3.makeMessageType(\"livekit.AliOSSUpload\", () => [{\n  no: 1,\n  name: \"access_key\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"secret\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"endpoint\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"bucket\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ProxyConfig = /* @__PURE__ */proto3.makeMessageType(\"livekit.ProxyConfig\", () => [{\n  no: 1,\n  name: \"url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"username\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"password\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst StreamOutput = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamOutput\", () => [{\n  no: 1,\n  name: \"protocol\",\n  kind: \"enum\",\n  T: proto3.getEnumType(StreamProtocol)\n}, {\n  no: 2,\n  name: \"urls\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}]);\nconst EncodingOptions = /* @__PURE__ */proto3.makeMessageType(\"livekit.EncodingOptions\", () => [{\n  no: 1,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 2,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 3,\n  name: \"depth\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"framerate\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 5,\n  name: \"audio_codec\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioCodec)\n}, {\n  no: 6,\n  name: \"audio_bitrate\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 11,\n  name: \"audio_quality\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 7,\n  name: \"audio_frequency\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 8,\n  name: \"video_codec\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoCodec)\n}, {\n  no: 9,\n  name: \"video_bitrate\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 12,\n  name: \"video_quality\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 10,\n  name: \"key_frame_interval\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}]);\nconst AutoParticipantEgress = /* @__PURE__ */proto3.makeMessageType(\"livekit.AutoParticipantEgress\", () => [{\n  no: 1,\n  name: \"preset\",\n  kind: \"enum\",\n  T: proto3.getEnumType(EncodingOptionsPreset),\n  oneof: \"options\"\n}, {\n  no: 2,\n  name: \"advanced\",\n  kind: \"message\",\n  T: EncodingOptions,\n  oneof: \"options\"\n}, {\n  no: 3,\n  name: \"file_outputs\",\n  kind: \"message\",\n  T: EncodedFileOutput,\n  repeated: true\n}, {\n  no: 4,\n  name: \"segment_outputs\",\n  kind: \"message\",\n  T: SegmentedFileOutput,\n  repeated: true\n}]);\nconst AutoTrackEgress = /* @__PURE__ */proto3.makeMessageType(\"livekit.AutoTrackEgress\", () => [{\n  no: 1,\n  name: \"filepath\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"disable_manifest\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"s3\",\n  kind: \"message\",\n  T: S3Upload,\n  oneof: \"output\"\n}, {\n  no: 3,\n  name: \"gcp\",\n  kind: \"message\",\n  T: GCPUpload,\n  oneof: \"output\"\n}, {\n  no: 4,\n  name: \"azure\",\n  kind: \"message\",\n  T: AzureBlobUpload,\n  oneof: \"output\"\n}, {\n  no: 6,\n  name: \"aliOSS\",\n  kind: \"message\",\n  T: AliOSSUpload,\n  oneof: \"output\"\n}]);\nconst RoomEgress = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomEgress\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: RoomCompositeEgressRequest\n}, {\n  no: 3,\n  name: \"participant\",\n  kind: \"message\",\n  T: AutoParticipantEgress\n}, {\n  no: 2,\n  name: \"tracks\",\n  kind: \"message\",\n  T: AutoTrackEgress\n}]);\nconst RoomConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomConfiguration\", () => [{\n  no: 1,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"empty_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"departure_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"max_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"egress\",\n  kind: \"message\",\n  T: RoomEgress\n}, {\n  no: 7,\n  name: \"min_playout_delay\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 8,\n  name: \"max_playout_delay\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 9,\n  name: \"sync_streams\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 10,\n  name: \"agents\",\n  kind: \"message\",\n  T: RoomAgentDispatch,\n  repeated: true\n}]);\nconst SignalTarget = /* @__PURE__ */proto3.makeEnum(\"livekit.SignalTarget\", [{\n  no: 0,\n  name: \"PUBLISHER\"\n}, {\n  no: 1,\n  name: \"SUBSCRIBER\"\n}]);\nconst StreamState = /* @__PURE__ */proto3.makeEnum(\"livekit.StreamState\", [{\n  no: 0,\n  name: \"ACTIVE\"\n}, {\n  no: 1,\n  name: \"PAUSED\"\n}]);\nconst CandidateProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.CandidateProtocol\", [{\n  no: 0,\n  name: \"UDP\"\n}, {\n  no: 1,\n  name: \"TCP\"\n}, {\n  no: 2,\n  name: \"TLS\"\n}]);\nconst SignalRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalRequest\", () => [{\n  no: 1,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"add_track\",\n  kind: \"message\",\n  T: AddTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription,\n  oneof: \"message\"\n}, {\n  no: 7,\n  name: \"track_setting\",\n  kind: \"message\",\n  T: UpdateTrackSettings,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"update_layers\",\n  kind: \"message\",\n  T: UpdateVideoLayers,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"subscription_permission\",\n  kind: \"message\",\n  T: SubscriptionPermission,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"sync_state\",\n  kind: \"message\",\n  T: SyncState,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"simulate\",\n  kind: \"message\",\n  T: SimulateScenario,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"ping\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"update_metadata\",\n  kind: \"message\",\n  T: UpdateParticipantMetadata,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"ping_req\",\n  kind: \"message\",\n  T: Ping,\n  oneof: \"message\"\n}, {\n  no: 17,\n  name: \"update_audio_track\",\n  kind: \"message\",\n  T: UpdateLocalAudioTrack,\n  oneof: \"message\"\n}, {\n  no: 18,\n  name: \"update_video_track\",\n  kind: \"message\",\n  T: UpdateLocalVideoTrack,\n  oneof: \"message\"\n}]);\nconst SignalResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalResponse\", () => [{\n  no: 1,\n  name: \"join\",\n  kind: \"message\",\n  T: JoinResponse,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"update\",\n  kind: \"message\",\n  T: ParticipantUpdate,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"track_published\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 9,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"speakers_changed\",\n  kind: \"message\",\n  T: SpeakersChanged,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"room_update\",\n  kind: \"message\",\n  T: RoomUpdate,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"connection_quality\",\n  kind: \"message\",\n  T: ConnectionQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"stream_state_update\",\n  kind: \"message\",\n  T: StreamStateUpdate,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"subscribed_quality_update\",\n  kind: \"message\",\n  T: SubscribedQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"subscription_permission_update\",\n  kind: \"message\",\n  T: SubscriptionPermissionUpdate,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"refresh_token\",\n  kind: \"scalar\",\n  T: 9,\n  oneof: \"message\"\n}, {\n  no: 17,\n  name: \"track_unpublished\",\n  kind: \"message\",\n  T: TrackUnpublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 18,\n  name: \"pong\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 19,\n  name: \"reconnect\",\n  kind: \"message\",\n  T: ReconnectResponse,\n  oneof: \"message\"\n}, {\n  no: 20,\n  name: \"pong_resp\",\n  kind: \"message\",\n  T: Pong,\n  oneof: \"message\"\n}, {\n  no: 21,\n  name: \"subscription_response\",\n  kind: \"message\",\n  T: SubscriptionResponse,\n  oneof: \"message\"\n}, {\n  no: 22,\n  name: \"request_response\",\n  kind: \"message\",\n  T: RequestResponse,\n  oneof: \"message\"\n}, {\n  no: 23,\n  name: \"track_subscribed\",\n  kind: \"message\",\n  T: TrackSubscribed,\n  oneof: \"message\"\n}, {\n  no: 24,\n  name: \"room_moved\",\n  kind: \"message\",\n  T: RoomMovedResponse,\n  oneof: \"message\"\n}, {\n  no: 25,\n  name: \"media_sections_requirement\",\n  kind: \"message\",\n  T: MediaSectionsRequirement,\n  oneof: \"message\"\n}, {\n  no: 26,\n  name: \"subscribed_audio_codec_update\",\n  kind: \"message\",\n  T: SubscribedAudioCodecUpdate,\n  oneof: \"message\"\n}]);\nconst SimulcastCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodec\", () => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 5,\n  name: \"video_layer_mode\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoLayer_Mode)\n}]);\nconst AddTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.AddTrackRequest\", () => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 4,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 9,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}, {\n  no: 10,\n  name: \"simulcast_codecs\",\n  kind: \"message\",\n  T: SimulcastCodec,\n  repeated: true\n}, {\n  no: 11,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 15,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 16,\n  name: \"backup_codec_policy\",\n  kind: \"enum\",\n  T: proto3.getEnumType(BackupCodecPolicy$1)\n}, {\n  no: 17,\n  name: \"audio_features\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioTrackFeature),\n  repeated: true\n}]);\nconst TrickleRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrickleRequest\", () => [{\n  no: 1,\n  name: \"candidateInit\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}, {\n  no: 3,\n  name: \"final\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst MuteTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.MuteTrackRequest\", () => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst JoinResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.JoinResponse\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}, {\n  no: 2,\n  name: \"participant\",\n  kind: \"message\",\n  T: ParticipantInfo\n}, {\n  no: 3,\n  name: \"other_participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: true\n}, {\n  no: 4,\n  name: \"server_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: true\n}, {\n  no: 6,\n  name: \"subscriber_primary\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"alternative_url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}, {\n  no: 9,\n  name: \"server_region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"ping_timeout\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 11,\n  name: \"ping_interval\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 12,\n  name: \"server_info\",\n  kind: \"message\",\n  T: ServerInfo\n}, {\n  no: 13,\n  name: \"sif_trailer\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 14,\n  name: \"enabled_publish_codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: true\n}, {\n  no: 15,\n  name: \"fast_publish\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst ReconnectResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.ReconnectResponse\", () => [{\n  no: 1,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: true\n}, {\n  no: 2,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}, {\n  no: 3,\n  name: \"server_info\",\n  kind: \"message\",\n  T: ServerInfo\n}, {\n  no: 4,\n  name: \"last_message_seq\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst TrackPublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPublishedResponse\", () => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track\",\n  kind: \"message\",\n  T: TrackInfo\n}]);\nconst TrackUnpublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SessionDescription = /* @__PURE__ */proto3.makeMessageType(\"livekit.SessionDescription\", () => [{\n  no: 1,\n  name: \"type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"sdp\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"mid_to_track_id\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}]);\nconst ParticipantUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantUpdate\", () => [{\n  no: 1,\n  name: \"participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: true\n}]);\nconst UpdateSubscription = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateSubscription\", () => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"participant_tracks\",\n  kind: \"message\",\n  T: ParticipantTracks,\n  repeated: true\n}]);\nconst UpdateTrackSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateTrackSettings\", () => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 3,\n  name: \"disabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 4,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"fps\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 8,\n  name: \"priority\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst UpdateLocalAudioTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"features\",\n  kind: \"enum\",\n  T: proto3.getEnumType(AudioTrackFeature),\n  repeated: true\n}]);\nconst UpdateLocalVideoTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst LeaveRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.LeaveRequest\", () => [{\n  no: 1,\n  name: \"can_reconnect\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DisconnectReason)\n}, {\n  no: 3,\n  name: \"action\",\n  kind: \"enum\",\n  T: proto3.getEnumType(LeaveRequest_Action)\n}, {\n  no: 4,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionSettings\n}]);\nconst LeaveRequest_Action = /* @__PURE__ */proto3.makeEnum(\"livekit.LeaveRequest.Action\", [{\n  no: 0,\n  name: \"DISCONNECT\"\n}, {\n  no: 1,\n  name: \"RESUME\"\n}, {\n  no: 2,\n  name: \"RECONNECT\"\n}]);\nconst UpdateVideoLayers = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateVideoLayers\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: true\n}]);\nconst UpdateParticipantMetadata = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", () => [{\n  no: 1,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 4,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst ICEServer = /* @__PURE__ */proto3.makeMessageType(\"livekit.ICEServer\", () => [{\n  no: 1,\n  name: \"urls\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 2,\n  name: \"username\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"credential\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SpeakersChanged = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakersChanged\", () => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: true\n}]);\nconst RoomUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomUpdate\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}]);\nconst ConnectionQualityInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ConnectionQuality$1)\n}, {\n  no: 3,\n  name: \"score\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}]);\nconst ConnectionQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", () => [{\n  no: 1,\n  name: \"updates\",\n  kind: \"message\",\n  T: ConnectionQualityInfo,\n  repeated: true\n}]);\nconst StreamStateInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateInfo\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(StreamState)\n}]);\nconst StreamStateUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateUpdate\", () => [{\n  no: 1,\n  name: \"stream_states\",\n  kind: \"message\",\n  T: StreamStateInfo,\n  repeated: true\n}]);\nconst SubscribedQuality = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQuality\", () => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"enabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst SubscribedCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedCodec\", () => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: true\n}]);\nconst SubscribedQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"subscribed_qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: true\n}, {\n  no: 3,\n  name: \"subscribed_codecs\",\n  kind: \"message\",\n  T: SubscribedCodec,\n  repeated: true\n}]);\nconst SubscribedAudioCodecUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedAudioCodecUpdate\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"subscribed_audio_codecs\",\n  kind: \"message\",\n  T: SubscribedAudioCodec,\n  repeated: true\n}]);\nconst TrackPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPermission\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"all_tracks\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 4,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst SubscriptionPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermission\", () => [{\n  no: 1,\n  name: \"all_participants\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"track_permissions\",\n  kind: \"message\",\n  T: TrackPermission,\n  repeated: true\n}]);\nconst SubscriptionPermissionUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", () => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"allowed\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst RoomMovedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomMovedResponse\", () => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}, {\n  no: 2,\n  name: \"token\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"participant\",\n  kind: \"message\",\n  T: ParticipantInfo\n}, {\n  no: 4,\n  name: \"other_participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: true\n}]);\nconst SyncState = /* @__PURE__ */proto3.makeMessageType(\"livekit.SyncState\", () => [{\n  no: 1,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 2,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription\n}, {\n  no: 3,\n  name: \"publish_tracks\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  repeated: true\n}, {\n  no: 4,\n  name: \"data_channels\",\n  kind: \"message\",\n  T: DataChannelInfo,\n  repeated: true\n}, {\n  no: 5,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 6,\n  name: \"track_sids_disabled\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: true\n}, {\n  no: 7,\n  name: \"datachannel_receive_states\",\n  kind: \"message\",\n  T: DataChannelReceiveState,\n  repeated: true\n}]);\nconst DataChannelReceiveState = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelReceiveState\", () => [{\n  no: 1,\n  name: \"publisher_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"last_seq\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst DataChannelInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelInfo\", () => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}]);\nconst SimulateScenario = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulateScenario\", () => [{\n  no: 1,\n  name: \"speaker_update\",\n  kind: \"scalar\",\n  T: 5,\n  oneof: \"scenario\"\n}, {\n  no: 2,\n  name: \"node_failure\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 3,\n  name: \"migration\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 4,\n  name: \"server_leave\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 5,\n  name: \"switch_candidate_protocol\",\n  kind: \"enum\",\n  T: proto3.getEnumType(CandidateProtocol),\n  oneof: \"scenario\"\n}, {\n  no: 6,\n  name: \"subscriber_bandwidth\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"scenario\"\n}, {\n  no: 7,\n  name: \"disconnect_signal_on_resume\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 8,\n  name: \"disconnect_signal_on_resume_no_messages\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 9,\n  name: \"leave_request_full_reconnect\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}]);\nconst Ping = /* @__PURE__ */proto3.makeMessageType(\"livekit.Ping\", () => [{\n  no: 1,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"rtt\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst Pong = /* @__PURE__ */proto3.makeMessageType(\"livekit.Pong\", () => [{\n  no: 1,\n  name: \"last_ping_timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst RegionSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionSettings\", () => [{\n  no: 1,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionInfo,\n  repeated: true\n}]);\nconst RegionInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionInfo\", () => [{\n  no: 1,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"distance\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nconst SubscriptionResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionResponse\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"err\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SubscriptionError)\n}]);\nconst RequestResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RequestResponse\", () => [{\n  no: 1,\n  name: \"request_id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(RequestResponse_Reason)\n}, {\n  no: 3,\n  name: \"message\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"request\"\n}, {\n  no: 5,\n  name: \"add_track\",\n  kind: \"message\",\n  T: AddTrackRequest,\n  oneof: \"request\"\n}, {\n  no: 6,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"request\"\n}, {\n  no: 7,\n  name: \"update_metadata\",\n  kind: \"message\",\n  T: UpdateParticipantMetadata,\n  oneof: \"request\"\n}, {\n  no: 8,\n  name: \"update_audio_track\",\n  kind: \"message\",\n  T: UpdateLocalAudioTrack,\n  oneof: \"request\"\n}, {\n  no: 9,\n  name: \"update_video_track\",\n  kind: \"message\",\n  T: UpdateLocalVideoTrack,\n  oneof: \"request\"\n}]);\nconst RequestResponse_Reason = /* @__PURE__ */proto3.makeEnum(\"livekit.RequestResponse.Reason\", [{\n  no: 0,\n  name: \"OK\"\n}, {\n  no: 1,\n  name: \"NOT_FOUND\"\n}, {\n  no: 2,\n  name: \"NOT_ALLOWED\"\n}, {\n  no: 3,\n  name: \"LIMIT_EXCEEDED\"\n}, {\n  no: 4,\n  name: \"QUEUED\"\n}, {\n  no: 5,\n  name: \"UNSUPPORTED_TYPE\"\n}, {\n  no: 6,\n  name: \"UNCLASSIFIED_ERROR\"\n}]);\nconst TrackSubscribed = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackSubscribed\", () => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nconst ConnectionSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionSettings\", () => [{\n  no: 1,\n  name: \"auto_subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"adaptive_stream\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"subscriber_allow_pause\",\n  kind: \"scalar\",\n  T: 8,\n  opt: true\n}, {\n  no: 4,\n  name: \"disable_ice_lite\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nconst JoinRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.JoinRequest\", () => [{\n  no: 1,\n  name: \"client_info\",\n  kind: \"message\",\n  T: ClientInfo\n}, {\n  no: 2,\n  name: \"connection_settings\",\n  kind: \"message\",\n  T: ConnectionSettings\n}, {\n  no: 3,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"participant_attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 5,\n  name: \"add_track_requests\",\n  kind: \"message\",\n  T: AddTrackRequest,\n  repeated: true\n}, {\n  no: 6,\n  name: \"publisher_offer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 7,\n  name: \"reconnect\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"reconnect_reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ReconnectReason)\n}, {\n  no: 9,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"sync_state\",\n  kind: \"message\",\n  T: SyncState\n}]);\nconst WrappedJoinRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.WrappedJoinRequest\", () => [{\n  no: 1,\n  name: \"compression\",\n  kind: \"enum\",\n  T: proto3.getEnumType(WrappedJoinRequest_Compression)\n}, {\n  no: 2,\n  name: \"join_request\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}]);\nconst WrappedJoinRequest_Compression = /* @__PURE__ */proto3.makeEnum(\"livekit.WrappedJoinRequest.Compression\", [{\n  no: 0,\n  name: \"NONE\"\n}, {\n  no: 1,\n  name: \"GZIP\"\n}]);\nconst MediaSectionsRequirement = /* @__PURE__ */proto3.makeMessageType(\"livekit.MediaSectionsRequirement\", () => [{\n  no: 1,\n  name: \"num_audios\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 2,\n  name: \"num_videos\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nconst TokenSourceRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.TokenSourceRequest\", () => [{\n  no: 1,\n  name: \"room_name\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 2,\n  name: \"participant_name\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 3,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 4,\n  name: \"participant_metadata\",\n  kind: \"scalar\",\n  T: 9,\n  opt: true\n}, {\n  no: 5,\n  name: \"participant_attributes\",\n  kind: \"map\",\n  K: 9,\n  V: {\n    kind: \"scalar\",\n    T: 9\n    /* ScalarType.STRING */\n  }\n}, {\n  no: 6,\n  name: \"room_config\",\n  kind: \"message\",\n  T: RoomConfiguration,\n  opt: true\n}]);\nconst TokenSourceResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TokenSourceResponse\", () => [{\n  no: 1,\n  name: \"server_url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"participant_token\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}var loglevel$1 = {exports: {}};/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\nvar loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n  if (hasRequiredLoglevel) return loglevel$1.exports;\n  hasRequiredLoglevel = 1;\n  (function (module) {\n    (function (root, definition) {\n\n      if (module.exports) {\n        module.exports = definition();\n      } else {\n        root.log = definition();\n      }\n    })(loglevel, function () {\n\n      // Slightly dubious tricks to cut down minimized file size\n      var noop = function () {};\n      var undefinedType = \"undefined\";\n      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n      var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n      var _loggersByName = {};\n      var defaultLogger = null;\n\n      // Cross-browser bind equivalent that works at least back to IE6\n      function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n          return method.bind(obj);\n        } else {\n          try {\n            return Function.prototype.bind.call(method, obj);\n          } catch (e) {\n            // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n            return function () {\n              return Function.prototype.apply.apply(method, [obj, arguments]);\n            };\n          }\n        }\n      }\n\n      // Trace() doesn't print the message in IE, so for that case we need to wrap it\n      function traceForIE() {\n        if (console.log) {\n          if (console.log.apply) {\n            console.log.apply(console, arguments);\n          } else {\n            // In old IE, native console methods themselves don't have apply().\n            Function.prototype.apply.apply(console.log, [console, arguments]);\n          }\n        }\n        if (console.trace) console.trace();\n      }\n\n      // Build the best logging method possible for this env\n      // Wherever possible we want to bind, not wrap, to preserve stack traces\n      function realMethod(methodName) {\n        if (methodName === 'debug') {\n          methodName = 'log';\n        }\n        if (typeof console === undefinedType) {\n          return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n          return traceForIE;\n        } else if (console[methodName] !== undefined) {\n          return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n          return bindMethod(console, 'log');\n        } else {\n          return noop;\n        }\n      }\n\n      // These private functions always need `this` to be set properly\n\n      function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n          var methodName = logMethods[i];\n          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n          return \"No console available for logging\";\n        }\n      }\n\n      // In old IE versions, the console isn't present until you first open it.\n      // We build realMethod() replacements here that regenerate logging methods\n      function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n          if (typeof console !== undefinedType) {\n            replaceLoggingMethods.call(this);\n            this[methodName].apply(this, arguments);\n          }\n        };\n      }\n\n      // By default, we use closely bound real methods wherever possible, and\n      // otherwise we wait for a console to appear, and then try again.\n      function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n      }\n      function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */\n        var inheritedLevel;\n        /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */\n        var defaultLevel;\n        /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */\n        var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n          storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n          storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage[storageKey] = levelName;\n            return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n          var storedLevel;\n          if (typeof window === undefinedType || !storageKey) return;\n          try {\n            storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n            try {\n              var cookie = window.document.cookie;\n              var cookieName = encodeURIComponent(storageKey);\n              var location = cookie.indexOf(cookieName + \"=\");\n              if (location !== -1) {\n                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n              }\n            } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n            storedLevel = undefined;\n          }\n          return storedLevel;\n        }\n        function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n            level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n            return level;\n          } else {\n            throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n        }\n\n        /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */\n\n        self.name = name;\n        self.levels = {\n          \"TRACE\": 0,\n          \"DEBUG\": 1,\n          \"INFO\": 2,\n          \"WARN\": 3,\n          \"ERROR\": 4,\n          \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n        };\n        self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {\n            // defaults to true\n            persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n            self.setLevel(level, false);\n          }\n        };\n        self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function (persist) {\n          self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function (persist) {\n          self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function () {\n          if (defaultLogger !== self) {\n            inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n          if (defaultLogger === self) {\n            for (var childName in _loggersByName) {\n              _loggersByName[childName].rebuild();\n            }\n          }\n        };\n\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n      }\n\n      /*\n       *\n       * Top-level API\n       *\n       */\n\n      defaultLogger = new Logger();\n      defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n      };\n\n      // Grab the current global log variable in case of overwrite\n      var _log = typeof window !== undefinedType ? window.log : undefined;\n      defaultLogger.noConflict = function () {\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\n          window.log = _log;\n        }\n        return defaultLogger;\n      };\n      defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n      };\n\n      // ES6 default export, for compatibility\n      defaultLogger['default'] = defaultLogger;\n      return defaultLogger;\n    });\n  })(loglevel$1);\n  return loglevel$1.exports;\n}var loglevelExports = requireLoglevel();var LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function (LoggerNames) {\n  LoggerNames[\"Default\"] = \"livekit\";\n  LoggerNames[\"Room\"] = \"livekit-room\";\n  LoggerNames[\"TokenSource\"] = \"livekit-token-source\";\n  LoggerNames[\"Participant\"] = \"livekit-participant\";\n  LoggerNames[\"Track\"] = \"livekit-track\";\n  LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n  LoggerNames[\"Engine\"] = \"livekit-engine\";\n  LoggerNames[\"Signal\"] = \"livekit-signal\";\n  LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n  LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n  LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger('livekit');\nconst livekitLoggers = Object.values(LoggerNames).map(name => loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */\nfunction getLogger(name) {\n  const logger = loglevelExports.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger;\n}\nfunction setLogLevel(level, loggerName) {\n  if (loggerName) {\n    loglevelExports.getLogger(loggerName).setLevel(level);\n  } else {\n    for (const logger of livekitLoggers) {\n      logger.setLevel(level);\n    }\n  }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */\nfunction setLogExtension(extension, logger) {\n  const loggers = logger ? [logger] : livekitLoggers;\n  loggers.forEach(logR => {\n    const originalFactory = logR.methodFactory;\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\n      const logLevel = LogLevel[methodName];\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n      return (msg, context) => {\n        if (context) rawMethod(msg, context);else rawMethod(msg);\n        if (needLog) {\n          extension(logLevel, msg, context);\n        }\n      };\n    };\n    logR.setLevel(logR.getLevel());\n  });\n}\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');const maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\nclass DefaultReconnectPolicy {\n  constructor(retryDelays) {\n    this._retryDelays = retryDelays !== undefined ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\n  }\n  nextRetryDelayInMs(context) {\n    if (context.retryCount >= this._retryDelays.length) return null;\n    const retryDelay = this._retryDelays[context.retryCount];\n    if (context.retryCount <= 1) return retryDelay;\n    return retryDelay + Math.random() * 1000;\n  }\n}/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};var events = {exports: {}};var hasRequiredEvents;\nfunction requireEvents() {\n  if (hasRequiredEvents) return events.exports;\n  hasRequiredEvents = 1;\n  var R = typeof Reflect === 'object' ? Reflect : null;\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n  var ReflectOwnKeys;\n  if (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n  } else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n  } else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target);\n    };\n  }\n  function ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n  }\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n  };\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n  events.exports = EventEmitter;\n  events.exports.once = once;\n\n  // Backwards-compat with node 0.10.x\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._eventsCount = 0;\n  EventEmitter.prototype._maxListeners = undefined;\n\n  // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n  var defaultMaxListeners = 10;\n  function checkListener(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n  }\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function () {\n      return defaultMaxListeners;\n    },\n    set: function (arg) {\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n      }\n      defaultMaxListeners = arg;\n    }\n  });\n  EventEmitter.init = function () {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n  };\n\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n    this._maxListeners = n;\n    return this;\n  };\n  function _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n  };\n  EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      var er;\n      if (args.length > 0) er = args[0];\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') {\n      ReflectApply(handler, this, args);\n    } else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n    }\n    return true;\n  };\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n      events = target._events = Object.create(null);\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n      if (events.newListener !== undefined) {\n        target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n        // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n        events = target._events;\n      }\n      existing = events[type];\n    }\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n\n      // Check for listener leak\n      m = _getMaxListeners(target);\n      if (m > 0 && existing.length > m && !existing.warned) {\n        existing.warned = true;\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        ProcessEmitWarning(w);\n      }\n    }\n    return target;\n  }\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  };\n  function onceWrapper() {\n    if (!this.fired) {\n      this.target.removeListener(this.type, this.wrapFn);\n      this.fired = true;\n      if (arguments.length === 0) return this.listener.call(this.target);\n      return this.listener.apply(this.target, arguments);\n    }\n  }\n  function _onceWrap(target, type, listener) {\n    var state = {\n      fired: false,\n      wrapFn: undefined,\n      target: target,\n      type: type,\n      listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n  }\n  EventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  // Emits a 'removeListener' event if and only if the listener was removed.\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\n        delete events[type];\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n      for (i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener || list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n      if (position < 0) return this;\n      if (position === 0) list.shift();else {\n        spliceOne(list, position);\n      }\n      if (list.length === 1) events[type] = list[0];\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n      if (arguments.length === 0) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n      } else if (events[type] !== undefined) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n      }\n      return this;\n    }\n\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n      var keys = Object.keys(events);\n      var key;\n      for (i = 0; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n        this.removeAllListeners(key);\n      }\n      this.removeAllListeners('removeListener');\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n      return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') {\n      this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n      // LIFO order\n      for (i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n    return this;\n  };\n  function _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n  }\n  EventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n  };\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n  };\n  EventEmitter.listenerCount = function (emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount.call(emitter, type);\n    }\n  };\n  EventEmitter.prototype.listenerCount = listenerCount;\n  function listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n      var evlistener = events[type];\n      if (typeof evlistener === 'function') {\n        return 1;\n      } else if (evlistener !== undefined) {\n        return evlistener.length;\n      }\n    }\n    return 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n  };\n  function arrayClone(arr, n) {\n    var copy = new Array(n);\n    for (var i = 0; i < n; ++i) copy[i] = arr[i];\n    return copy;\n  }\n  function spliceOne(list, index) {\n    for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n    list.pop();\n  }\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n  }\n  function once(emitter, name) {\n    return new Promise(function (resolve, reject) {\n      function errorListener(err) {\n        emitter.removeListener(name, resolver);\n        reject(err);\n      }\n      function resolver() {\n        if (typeof emitter.removeListener === 'function') {\n          emitter.removeListener('error', errorListener);\n        }\n        resolve([].slice.call(arguments));\n      }\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\n        once: true\n      });\n      if (name !== 'error') {\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\n          once: true\n        });\n      }\n    });\n  }\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n  }\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n      if (flags.once) {\n        emitter.once(name, listener);\n      } else {\n        emitter.on(name, listener);\n      }\n    } else if (typeof emitter.addEventListener === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we do not listen for `error` events here.\n      emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) {\n          emitter.removeEventListener(name, wrapListener);\n        }\n        listener(arg);\n      });\n    } else {\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n  }\n  return events.exports;\n}var eventsExports = requireEvents();/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseFloat(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = e => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  // Returned result object.\n  const result = {\n    browser: null,\n    version: null\n  };\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n  const {\n    navigator\n  } = window;\n\n  // Prefer navigator.userAgentData.\n  if (navigator.userAgentData && navigator.userAgentData.brands) {\n    const chromium = navigator.userAgentData.brands.find(brand => {\n      return brand.brand === 'Chromium';\n    });\n    if (chromium) {\n      return {\n        browser: 'chrome',\n        version: parseInt(chromium.version, 10)\n      };\n    }\n  }\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = parseInt(extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1));\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = parseInt(extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2));\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = parseInt(extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1));\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n    // Only for internal usage.\n    result._safariVersion = extractVersion(navigator.userAgent, /Version\\/(\\d+(\\.?\\d+))/, 1);\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject$1(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject$1(data)) {\n    return data;\n  }\n  return Object.keys(data).reduce(function (accumulator, key) {\n    const isObj = isObject$1(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nconst logging = log;\nfunction shimGetUserMedia$2(window, browserDetails) {\n  const navigator = window && window.navigator;\n  if (!navigator.mediaDevices) {\n    return;\n  }\n  const constraintsToChrome_ = function (c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = typeof c[key] === 'object' ? c[key] : {\n        ideal: c[key]\n      };\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function (prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n  const shimConstraints_ = function (constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function (obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === 'object' ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n  const shimError_ = function (e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nfunction shimOnTrack$1(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => filterStats(result, receiver.track, false));\n    };\n  }\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nfunction shimPeerConnection$1(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window, browserDetails) {\n  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}var chromeShim=/*#__PURE__*/Object.freeze({__proto__:null,fixNegotiationNeeded:fixNegotiationNeeded,shimAddTrackRemoveTrack:shimAddTrackRemoveTrack,shimAddTrackRemoveTrackWithNative:shimAddTrackRemoveTrackWithNative,shimGetSendersWithDtmf:shimGetSendersWithDtmf,shimGetUserMedia:shimGetUserMedia$2,shimMediaStream:shimMediaStream,shimOnTrack:shimOnTrack$1,shimPeerConnection:shimPeerConnection$1,shimSenderReceiverGetStats:shimSenderReceiverGetStats});/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimGetUserMedia$1(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function (obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function () {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n      err.name = 'NotFoundError';\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\n      if (browserDetails.version < 53 && !onSucc) {\n        // Shim only promise getStats with spec-hyphens in type names\n        // Leave callback version alone; misc old uses of forEach before Map\n        try {\n          stats.forEach(stat => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          }\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n  };\n}\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(sender => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      // WebIDL input coercion and validation\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n      if (sendEncodings === undefined) {\n        sendEncodings = [];\n      }\n      sendEncodings = [...sendEncodings];\n      const shouldPerformCheck = sendEncodings.length > 0;\n      if (shouldPerformCheck) {\n        // If sendEncodings params are provided, validate grammar\n        sendEncodings.forEach(encodingParam => {\n          if ('rid' in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError('Invalid RID value provided.');\n            }\n          }\n          if ('scaleResolutionDownBy' in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\n            }\n          }\n          if ('maxFramerate' in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError('max_framerate must be >= 0.0');\n            }\n          }\n        });\n      }\n      const transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        // Check if the init options were applied. If not we do this in an\n        // asynchronous way and save the promise reference in a global object.\n        // This is an ugly hack, but at the same time is way more robust than\n        // checking the sender parameters before and after the createOffer\n        // Also note that after the createoffer we are not 100% sure that\n        // the params were asynchronously applied so we might miss the\n        // opportunity to recreate offer.\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n        if (!('encodings' in params) ||\n        // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = sendEncodings;\n          sender.sendEncodings = sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n      if (!('encodings' in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}var firefoxShim=/*#__PURE__*/Object.freeze({__proto__:null,shimAddTransceiver:shimAddTransceiver,shimCreateAnswer:shimCreateAnswer,shimCreateOffer:shimCreateOffer,shimGetDisplayMedia:shimGetDisplayMedia,shimGetParameters:shimGetParameters,shimGetUserMedia:shimGetUserMedia$1,shimOnTrack:shimOnTrack,shimPeerConnection:shimPeerConnection,shimRTCDataChannel:shimRTCDataChannel,shimReceiverGetStats:shimReceiverGetStats,shimRemoveStream:shimRemoveStream,shimSenderGetStats:shimSenderGetStats});/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\n    };\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      if (streams) {\n        streams.forEach(stream => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach(sender => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = e => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(stream => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  let withCallback = function (description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n  withCallback = function (description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n  withCallback = function (candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = constraints => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({}, constraints, {\n      video: compactObject(constraints.video)\n    });\n  }\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (server.urls === undefined && server.url) {\n          deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver('audio', {\n          direction: 'recvonly'\n        });\n      }\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver('video', {\n          direction: 'recvonly'\n        });\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}var safariShim=/*#__PURE__*/Object.freeze({__proto__:null,shimAudioContext:shimAudioContext,shimCallbacksAPI:shimCallbacksAPI,shimConstraints:shimConstraints,shimCreateOfferLegacy:shimCreateOfferLegacy,shimGetUserMedia:shimGetUserMedia,shimLocalStreamsAPI:shimLocalStreamsAPI,shimRTCIceServerUrls:shimRTCIceServerUrls,shimRemoteStreamsAPI:shimRemoteStreamsAPI,shimTrackEventTransceiver:shimTrackEventTransceiver});var sdp$1 = {exports: {}};/* eslint-env node */\nvar hasRequiredSdp;\nfunction requireSdp() {\n  if (hasRequiredSdp) return sdp$1.exports;\n  hasRequiredSdp = 1;\n  (function (module) {\n\n    // SDP helpers.\n    const SDPUtils = {};\n\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function () {\n      return Math.random().toString(36).substring(2, 12);\n    };\n\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function (blob) {\n      return blob.trim().split('\\n').map(line => line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function (blob) {\n      const parts = blob.split('\\nm=');\n      return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n    };\n\n    // Returns the session description.\n    SDPUtils.getDescription = function (blob) {\n      const sections = SDPUtils.splitSections(blob);\n      return sections && sections[0];\n    };\n\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function (blob) {\n      const sections = SDPUtils.splitSections(blob);\n      sections.shift();\n      return sections;\n    };\n\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function (blob, prefix) {\n      return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n    };\n\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function (line) {\n      let parts;\n      // Parse both variants.\n      if (line.indexOf('a=candidate:') === 0) {\n        parts = line.substring(12).split(' ');\n      } else {\n        parts = line.substring(10).split(' ');\n      }\n      const candidate = {\n        foundation: parts[0],\n        component: {\n          1: 'rtp',\n          2: 'rtcp'\n        }[parts[1]] || parts[1],\n        protocol: parts[2].toLowerCase(),\n        priority: parseInt(parts[3], 10),\n        ip: parts[4],\n        address: parts[4],\n        // address is an alias for ip.\n        port: parseInt(parts[5], 10),\n        // skip parts[6] == 'typ'\n        type: parts[7]\n      };\n      for (let i = 8; i < parts.length; i += 2) {\n        switch (parts[i]) {\n          case 'raddr':\n            candidate.relatedAddress = parts[i + 1];\n            break;\n          case 'rport':\n            candidate.relatedPort = parseInt(parts[i + 1], 10);\n            break;\n          case 'tcptype':\n            candidate.tcpType = parts[i + 1];\n            break;\n          case 'ufrag':\n            candidate.ufrag = parts[i + 1]; // for backward compatibility.\n            candidate.usernameFragment = parts[i + 1];\n            break;\n          default:\n            // extension handling, in particular ufrag. Don't overwrite.\n            if (candidate[parts[i]] === undefined) {\n              candidate[parts[i]] = parts[i + 1];\n            }\n            break;\n        }\n      }\n      return candidate;\n    };\n\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function (candidate) {\n      const sdp = [];\n      sdp.push(candidate.foundation);\n      const component = candidate.component;\n      if (component === 'rtp') {\n        sdp.push(1);\n      } else if (component === 'rtcp') {\n        sdp.push(2);\n      } else {\n        sdp.push(component);\n      }\n      sdp.push(candidate.protocol.toUpperCase());\n      sdp.push(candidate.priority);\n      sdp.push(candidate.address || candidate.ip);\n      sdp.push(candidate.port);\n      const type = candidate.type;\n      sdp.push('typ');\n      sdp.push(type);\n      if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n        sdp.push('raddr');\n        sdp.push(candidate.relatedAddress);\n        sdp.push('rport');\n        sdp.push(candidate.relatedPort);\n      }\n      if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n        sdp.push('tcptype');\n        sdp.push(candidate.tcpType);\n      }\n      if (candidate.usernameFragment || candidate.ufrag) {\n        sdp.push('ufrag');\n        sdp.push(candidate.usernameFragment || candidate.ufrag);\n      }\n      return 'candidate:' + sdp.join(' ');\n    };\n\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function (line) {\n      return line.substring(14).split(' ');\n    };\n\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function (line) {\n      let parts = line.substring(9).split(' ');\n      const parsed = {\n        payloadType: parseInt(parts.shift(), 10) // was: id\n      };\n      parts = parts[0].split('/');\n      parsed.name = parts[0];\n      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n      // legacy alias, got renamed back to channels in ORTC.\n      parsed.numChannels = parsed.channels;\n      return parsed;\n    };\n\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function (codec) {\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      const channels = codec.channels || codec.numChannels || 1;\n      return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n    };\n\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function (line) {\n      const parts = line.substring(9).split(' ');\n      return {\n        id: parseInt(parts[0], 10),\n        direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n        uri: parts[1],\n        attributes: parts.slice(2).join(' ')\n      };\n    };\n\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function (headerExtension) {\n      return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n    };\n\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function (line) {\n      const parsed = {};\n      let kv;\n      const parts = line.substring(line.indexOf(' ') + 1).split(';');\n      for (let j = 0; j < parts.length; j++) {\n        kv = parts[j].trim().split('=');\n        parsed[kv[0].trim()] = kv[1];\n      }\n      return parsed;\n    };\n\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function (codec) {\n      let line = '';\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      if (codec.parameters && Object.keys(codec.parameters).length) {\n        const params = [];\n        Object.keys(codec.parameters).forEach(param => {\n          if (codec.parameters[param] !== undefined) {\n            params.push(param + '=' + codec.parameters[param]);\n          } else {\n            params.push(param);\n          }\n        });\n        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n      }\n      return line;\n    };\n\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function (line) {\n      const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n      return {\n        type: parts.shift(),\n        parameter: parts.join(' ')\n      };\n    };\n\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function (codec) {\n      let lines = '';\n      let pt = codec.payloadType;\n      if (codec.preferredPayloadType !== undefined) {\n        pt = codec.preferredPayloadType;\n      }\n      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n        // FIXME: special handling for trr-int?\n        codec.rtcpFeedback.forEach(fb => {\n          lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n        });\n      }\n      return lines;\n    };\n\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function (line) {\n      const sp = line.indexOf(' ');\n      const parts = {\n        ssrc: parseInt(line.substring(7, sp), 10)\n      };\n      const colon = line.indexOf(':', sp);\n      if (colon > -1) {\n        parts.attribute = line.substring(sp + 1, colon);\n        parts.value = line.substring(colon + 1);\n      } else {\n        parts.attribute = line.substring(sp + 1);\n      }\n      return parts;\n    };\n\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function (line) {\n      const parts = line.substring(13).split(' ');\n      return {\n        semantics: parts.shift(),\n        ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n      };\n    };\n\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function (mediaSection) {\n      const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n      if (mid) {\n        return mid.substring(6);\n      }\n    };\n\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function (line) {\n      const parts = line.substring(14).split(' ');\n      return {\n        algorithm: parts[0].toLowerCase(),\n        // algorithm is case-sensitive in Edge.\n        value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n      };\n    };\n\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n      // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n      return {\n        role: 'auto',\n        fingerprints: lines.map(SDPUtils.parseFingerprint)\n      };\n    };\n\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function (params, setupType) {\n      let sdp = 'a=setup:' + setupType + '\\r\\n';\n      params.fingerprints.forEach(fp => {\n        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n      });\n      return sdp;\n    };\n\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function (line) {\n      const parts = line.substring(9).split(' ');\n      return {\n        tag: parseInt(parts[0], 10),\n        cryptoSuite: parts[1],\n        keyParams: parts[2],\n        sessionParams: parts.slice(3)\n      };\n    };\n    SDPUtils.writeCryptoLine = function (parameters) {\n      return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n    };\n\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function (keyParams) {\n      if (keyParams.indexOf('inline:') !== 0) {\n        return null;\n      }\n      const parts = keyParams.substring(7).split('|');\n      return {\n        keyMethod: 'inline',\n        keySalt: parts[0],\n        lifeTime: parts[1],\n        mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n        mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n      };\n    };\n    SDPUtils.writeCryptoKeyParams = function (keyParams) {\n      return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n    };\n\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n      return lines.map(SDPUtils.parseCryptoLine);\n    };\n\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n      const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n      const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n      if (!(ufrag && pwd)) {\n        return null;\n      }\n      return {\n        usernameFragment: ufrag.substring(12),\n        password: pwd.substring(10)\n      };\n    };\n\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function (params) {\n      let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n      if (params.iceLite) {\n        sdp += 'a=ice-lite\\r\\n';\n      }\n      return sdp;\n    };\n\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function (mediaSection) {\n      const description = {\n        codecs: [],\n        headerExtensions: [],\n        fecMechanisms: [],\n        rtcp: []\n      };\n      const lines = SDPUtils.splitLines(mediaSection);\n      const mline = lines[0].split(' ');\n      description.profile = mline[2];\n      for (let i = 3; i < mline.length; i++) {\n        // find all codecs from mline[3..]\n        const pt = mline[i];\n        const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n        if (rtpmapline) {\n          const codec = SDPUtils.parseRtpMap(rtpmapline);\n          const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n          // Only the first a=fmtp:<pt> is considered.\n          codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n          codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n          description.codecs.push(codec);\n          // parse FEC mechanisms from rtpmap lines.\n          switch (codec.name.toUpperCase()) {\n            case 'RED':\n            case 'ULPFEC':\n              description.fecMechanisms.push(codec.name.toUpperCase());\n              break;\n          }\n        }\n      }\n      SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n        description.headerExtensions.push(SDPUtils.parseExtmap(line));\n      });\n      const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n      description.codecs.forEach(codec => {\n        wildcardRtcpFb.forEach(fb => {\n          const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n          });\n          if (!duplicate) {\n            codec.rtcpFeedback.push(fb);\n          }\n        });\n      });\n      // FIXME: parse rtcp.\n      return description;\n    };\n\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function (kind, caps) {\n      let sdp = '';\n\n      // Build the mline.\n      sdp += 'm=' + kind + ' ';\n      sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n      sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n      sdp += caps.codecs.map(codec => {\n        if (codec.preferredPayloadType !== undefined) {\n          return codec.preferredPayloadType;\n        }\n        return codec.payloadType;\n      }).join(' ') + '\\r\\n';\n      sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n      sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n      caps.codecs.forEach(codec => {\n        sdp += SDPUtils.writeRtpMap(codec);\n        sdp += SDPUtils.writeFmtp(codec);\n        sdp += SDPUtils.writeRtcpFb(codec);\n      });\n      let maxptime = 0;\n      caps.codecs.forEach(codec => {\n        if (codec.maxptime > maxptime) {\n          maxptime = codec.maxptime;\n        }\n      });\n      if (maxptime > 0) {\n        sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n      }\n      if (caps.headerExtensions) {\n        caps.headerExtensions.forEach(extension => {\n          sdp += SDPUtils.writeExtmap(extension);\n        });\n      }\n      // FIXME: write fecMechanisms.\n      return sdp;\n    };\n\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n      const encodingParameters = [];\n      const description = SDPUtils.parseRtpParameters(mediaSection);\n      const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n      const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n      // filter a=ssrc:... cname:, ignore PlanB-msid\n      const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n      let secondarySsrc;\n      const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n        const parts = line.substring(17).split(' ');\n        return parts.map(part => parseInt(part, 10));\n      });\n      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n        secondarySsrc = flows[0][1];\n      }\n      description.codecs.forEach(codec => {\n        if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n          let encParam = {\n            ssrc: primarySsrc,\n            codecPayloadType: parseInt(codec.parameters.apt, 10)\n          };\n          if (primarySsrc && secondarySsrc) {\n            encParam.rtx = {\n              ssrc: secondarySsrc\n            };\n          }\n          encodingParameters.push(encParam);\n          if (hasRed) {\n            encParam = JSON.parse(JSON.stringify(encParam));\n            encParam.fec = {\n              ssrc: primarySsrc,\n              mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n            };\n            encodingParameters.push(encParam);\n          }\n        }\n      });\n      if (encodingParameters.length === 0 && primarySsrc) {\n        encodingParameters.push({\n          ssrc: primarySsrc\n        });\n      }\n\n      // we support both b=AS and b=TIAS but interpret AS as TIAS.\n      let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n      if (bandwidth.length) {\n        if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n          bandwidth = parseInt(bandwidth[0].substring(7), 10);\n        } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n          // use formula from JSEP to convert b=AS to TIAS value.\n          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n        } else {\n          bandwidth = undefined;\n        }\n        encodingParameters.forEach(params => {\n          params.maxBitrate = bandwidth;\n        });\n      }\n      return encodingParameters;\n    };\n\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function (mediaSection) {\n      const rtcpParameters = {};\n\n      // Gets the first SSRC. Note that with RTX there might be multiple\n      // SSRCs.\n      const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n      if (remoteSsrc) {\n        rtcpParameters.cname = remoteSsrc.value;\n        rtcpParameters.ssrc = remoteSsrc.ssrc;\n      }\n\n      // Edge uses the compound attribute instead of reducedSize\n      // compound is !reducedSize\n      const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n      rtcpParameters.reducedSize = rsize.length > 0;\n      rtcpParameters.compound = rsize.length === 0;\n\n      // parses the rtcp-mux attrbute.\n      // Note that Edge does not support unmuxed RTCP.\n      const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n      rtcpParameters.mux = mux.length > 0;\n      return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function (rtcpParameters) {\n      let sdp = '';\n      if (rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n      if (rtcpParameters.mux) {\n        sdp += 'a=rtcp-mux\\r\\n';\n      }\n      if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n        sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n      }\n      return sdp;\n    };\n\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function (mediaSection) {\n      let parts;\n      const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n      if (spec.length === 1) {\n        parts = spec[0].substring(7).split(' ');\n        return {\n          stream: parts[0],\n          track: parts[1]\n        };\n      }\n      const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n      if (planB.length > 0) {\n        parts = planB[0].value.split(' ');\n        return {\n          stream: parts[0],\n          track: parts[1]\n        };\n      }\n    };\n\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function (mediaSection) {\n      const mline = SDPUtils.parseMLine(mediaSection);\n      const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n      let maxMessageSize;\n      if (maxSizeLine.length > 0) {\n        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n      }\n      if (isNaN(maxMessageSize)) {\n        maxMessageSize = 65536;\n      }\n      const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n      if (sctpPort.length > 0) {\n        return {\n          port: parseInt(sctpPort[0].substring(12), 10),\n          protocol: mline.fmt,\n          maxMessageSize\n        };\n      }\n      const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n      if (sctpMapLines.length > 0) {\n        const parts = sctpMapLines[0].substring(10).split(' ');\n        return {\n          port: parseInt(parts[0], 10),\n          protocol: parts[1],\n          maxMessageSize\n        };\n      }\n    };\n\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function (media, sctp) {\n      let output = [];\n      if (media.protocol !== 'DTLS/SCTP') {\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n      } else {\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n      }\n      if (sctp.maxMessageSize !== undefined) {\n        output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n      }\n      return output.join('');\n    };\n\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function () {\n      return Math.random().toString().substr(2, 22);\n    };\n\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n      let sessionId;\n      const version = sessVer !== undefined ? sessVer : 2;\n      if (sessId) {\n        sessionId = sessId;\n      } else {\n        sessionId = SDPUtils.generateSessionId();\n      }\n      const user = sessUser || 'thisisadapterortc';\n      // FIXME: sess-id should be an NTP timestamp.\n      return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n    };\n\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function (mediaSection, sessionpart) {\n      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n      const lines = SDPUtils.splitLines(mediaSection);\n      for (let i = 0; i < lines.length; i++) {\n        switch (lines[i]) {\n          case 'a=sendrecv':\n          case 'a=sendonly':\n          case 'a=recvonly':\n          case 'a=inactive':\n            return lines[i].substring(2);\n          // FIXME: What should happen here?\n        }\n      }\n      if (sessionpart) {\n        return SDPUtils.getDirection(sessionpart);\n      }\n      return 'sendrecv';\n    };\n    SDPUtils.getKind = function (mediaSection) {\n      const lines = SDPUtils.splitLines(mediaSection);\n      const mline = lines[0].split(' ');\n      return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function (mediaSection) {\n      return mediaSection.split(' ', 2)[1] === '0';\n    };\n    SDPUtils.parseMLine = function (mediaSection) {\n      const lines = SDPUtils.splitLines(mediaSection);\n      const parts = lines[0].substring(2).split(' ');\n      return {\n        kind: parts[0],\n        port: parseInt(parts[1], 10),\n        protocol: parts[2],\n        fmt: parts.slice(3).join(' ')\n      };\n    };\n    SDPUtils.parseOLine = function (mediaSection) {\n      const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n      const parts = line.substring(2).split(' ');\n      return {\n        username: parts[0],\n        sessionId: parts[1],\n        sessionVersion: parseInt(parts[2], 10),\n        netType: parts[3],\n        addressType: parts[4],\n        address: parts[5]\n      };\n    };\n\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function (blob) {\n      if (typeof blob !== 'string' || blob.length === 0) {\n        return false;\n      }\n      const lines = SDPUtils.splitLines(blob);\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n          return false;\n        }\n        // TODO: check the modifier a bit more.\n      }\n      return true;\n    };\n\n    // Expose public methods.\n    {\n      module.exports = SDPUtils;\n    }\n  })(sdp$1);\n  return sdp$1.exports;\n}var sdpExports = requireSdp();\nvar SDPUtils = /*@__PURE__*/getDefaultExportFromCjs(sdpExports);var sdp=/*#__PURE__*/_mergeNamespaces({__proto__:null,default:SDPUtils},[sdpExports]);/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key, {\n            value: parsedCandidate[key]\n          });\n        }\n      }\n\n      // Override serializer to not serialize the extra attributes.\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\nfunction shimRTCIceCandidateRelayProtocol(window) {\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === 'relay') {\n        // This is a libwebrtc-specific mapping of local type preference\n        // to relayProtocol.\n        e.candidate.relayProtocol = {\n          0: 'tls',\n          1: 'tcp',\n          2: 'udp'\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n  const sctpInDescription = function (description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n  const getRemoteFirefoxVersion = function (description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n    const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    // Chrome decided to not expose .sctp in plan-b mode.\n    // As usual, adapter.js has to do an 'ugly worakaround'\n    // to cover up the mess.\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n      if (sdpSemantics === 'plan-b') {\n        Object.defineProperty(this, 'sctp', {\n          get() {\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\n          },\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n      // Get the maximum message size the local peer is capable of sending\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n      // Get the maximum message size of the remote peer.\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n      // Determine final maximum message size\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n      const sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\n    const origMethod = proto[method];\n    proto[method] = function () {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails._safariVersion >= 13.1) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter(line => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n    // in older versions.\n    // Native support for ignoring exists for Chrome M77+.\n    // Safari ignores as well, exact version unknown but works in the same\n    // version that also ignores addIceCandidate(null).\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    }\n    // The remaining steps should technically happen when SLD comes off the\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\n    // this is too difficult to shim. Instead, this shim only covers the\n    // common case where the operations chain is empty. This is imperfect, but\n    // should cover many cases. Rationale: Even if we can't reduce the glare\n    // window to zero on imperfect implementations, there's value in tapping\n    // into the perfect negotiation pattern that several browsers support.\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case 'stable':\n        case 'have-local-offer':\n        case 'have-remote-pranswer':\n          desc.type = 'offer';\n          break;\n        default:\n          desc.type = 'answer';\n          break;\n      }\n    }\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\n  };\n}var commonShim=/*#__PURE__*/Object.freeze({__proto__:null,removeExtmapAllowMixed:removeExtmapAllowMixed,shimAddIceCandidateNullOrEmpty:shimAddIceCandidateNullOrEmpty,shimConnectionState:shimConnectionState,shimMaxMessageSize:shimMaxMessageSize,shimParameterlessSetLocalDescription:shimParameterlessSetLocalDescription,shimRTCIceCandidate:shimRTCIceCandidate,shimRTCIceCandidateRelayProtocol:shimRTCIceCandidateRelayProtocol,shimSendThrowTypeError:shimSendThrowTypeError});/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n// Shimming starts here.\nfunction adapterFactory() {\n  let {\n    window\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  // Utils.\n  const logging = log;\n  const browserDetails = detectBrowser(window);\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion: extractVersion,\n    disableLog: disableLog,\n    disableWarnings: disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      // Must be called before shimPeerConnection.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimGetUserMedia$2(window, browserDetails);\n      shimMediaStream(window);\n      shimPeerConnection$1(window, browserDetails);\n      shimOnTrack$1(window);\n      shimAddTrackRemoveTrack(window, browserDetails);\n      shimGetSendersWithDtmf(window);\n      shimSenderReceiverGetStats(window);\n      fixNegotiationNeeded(window, browserDetails);\n      shimRTCIceCandidate(window);\n      shimRTCIceCandidateRelayProtocol(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      // Must be called before shimPeerConnection.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimGetUserMedia$1(window, browserDetails);\n      shimPeerConnection(window, browserDetails);\n      shimOnTrack(window);\n      shimRemoveStream(window);\n      shimSenderGetStats(window);\n      shimReceiverGetStats(window);\n      shimRTCDataChannel(window);\n      shimAddTransceiver(window);\n      shimGetParameters(window);\n      shimCreateOffer(window);\n      shimCreateAnswer(window);\n      shimRTCIceCandidate(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n\n      // Must be called before shimCallbackAPI.\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      shimParameterlessSetLocalDescription(window);\n      shimRTCIceServerUrls(window);\n      shimCreateOfferLegacy(window);\n      shimCallbacksAPI(window);\n      shimLocalStreamsAPI(window);\n      shimRemoteStreamsAPI(window);\n      shimTrackEventTransceiver(window);\n      shimGetUserMedia(window);\n      shimAudioContext(window);\n      shimRTCIceCandidate(window);\n      shimRTCIceCandidateRelayProtocol(window);\n      shimMaxMessageSize(window, browserDetails);\n      shimSendThrowTypeError(window);\n      removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n  return adapter;\n}/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nadapterFactory({\n  window: typeof window === 'undefined' ? undefined : window\n});// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */\nfunction getBrowser(userAgent) {\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\n    return;\n  }\n  const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n  if (browserDetails === undefined || force) {\n    const browser = browsersList.find(_ref => {\n      let {\n        test\n      } = _ref;\n      return test.test(ua);\n    });\n    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n  }\n  return browserDetails;\n}\nconst browsersList = [{\n  test: /firefox|iceweasel|fxios/i,\n  describe(ua) {\n    const browser = {\n      name: 'Firefox',\n      version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, {\n  test: /chrom|crios|crmo/i,\n  describe(ua) {\n    const browser = {\n      name: 'Chrome',\n      version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, /* Safari */\n{\n  test: /safari|applewebkit/i,\n  describe(ua) {\n    const browser = {\n      name: 'Safari',\n      version: getMatch(commonVersionIdentifier, ua),\n      os: ua.includes('mobile/') ? 'iOS' : 'macOS',\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}];\nfunction getMatch(exp, ua) {\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const match = ua.match(exp);\n  return match && match.length >= id && match[id] || '';\n}\nfunction getOSVersion(ua) {\n  return ua.includes('mac os') ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, '.') : undefined;\n}var version$1 = \"2.16.1\";const version = version$1;\nconst protocolVersion = 16;class LivekitError extends Error {\n  constructor(code, message) {\n    super(message || 'an error has occured');\n    this.name = 'LiveKitError';\n    this.code = code;\n  }\n}\nclass SimulatedError extends LivekitError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Simulated failure';\n    super(-1, message);\n    this.name = 'simulated';\n  }\n}\nvar ConnectionErrorReason;\n(function (ConnectionErrorReason) {\n  ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n  ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n  ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n  ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n  ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n  ConnectionErrorReason[ConnectionErrorReason[\"Timeout\"] = 5] = \"Timeout\";\n  ConnectionErrorReason[ConnectionErrorReason[\"WebSocket\"] = 6] = \"WebSocket\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nclass ConnectionError extends LivekitError {\n  constructor(message, reason, status, context) {\n    super(1, message);\n    this.name = 'ConnectionError';\n    this.status = status;\n    this.reason = reason;\n    this.context = context;\n    this.reasonName = ConnectionErrorReason[reason];\n  }\n  static notAllowed(message, status, context) {\n    return new ConnectionError(message, ConnectionErrorReason.NotAllowed, status, context);\n  }\n  static timeout(message) {\n    return new ConnectionError(message, ConnectionErrorReason.Timeout);\n  }\n  static leaveRequest(message, context) {\n    return new ConnectionError(message, ConnectionErrorReason.LeaveRequest, undefined, context);\n  }\n  static internal(message, context) {\n    return new ConnectionError(message, ConnectionErrorReason.InternalError, undefined, context);\n  }\n  static cancelled(message) {\n    return new ConnectionError(message, ConnectionErrorReason.Cancelled);\n  }\n  static serverUnreachable(message, status) {\n    return new ConnectionError(message, ConnectionErrorReason.ServerUnreachable, status);\n  }\n  static websocket(message, status, reason) {\n    return new ConnectionError(message, ConnectionErrorReason.WebSocket, status, reason);\n  }\n}\nclass DeviceUnsupportedError extends LivekitError {\n  constructor(message) {\n    super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\n    this.name = 'DeviceUnsupportedError';\n  }\n}\nclass TrackInvalidError extends LivekitError {\n  constructor(message) {\n    super(20, message !== null && message !== void 0 ? message : 'track is invalid');\n    this.name = 'TrackInvalidError';\n  }\n}\nclass UnsupportedServer extends LivekitError {\n  constructor(message) {\n    super(10, message !== null && message !== void 0 ? message : 'unsupported server');\n    this.name = 'UnsupportedServer';\n  }\n}\nclass UnexpectedConnectionState extends LivekitError {\n  constructor(message) {\n    super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\n    this.name = 'UnexpectedConnectionState';\n  }\n}\nclass NegotiationError extends LivekitError {\n  constructor(message) {\n    super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\n    this.name = 'NegotiationError';\n  }\n}\nclass PublishDataError extends LivekitError {\n  constructor(message) {\n    super(14, message !== null && message !== void 0 ? message : 'unable to publish data');\n    this.name = 'PublishDataError';\n  }\n}\nclass PublishTrackError extends LivekitError {\n  constructor(message, status) {\n    super(15, message);\n    this.name = 'PublishTrackError';\n    this.status = status;\n  }\n}\nclass SignalRequestError extends LivekitError {\n  constructor(message, reason) {\n    super(15, message);\n    this.name = 'SignalRequestError';\n    this.reason = reason;\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\n  }\n}\n// NOTE: matches with https://github.com/livekit/client-sdk-swift/blob/f37bbd260d61e165084962db822c79f995f1a113/Sources/LiveKit/DataStream/StreamError.swift#L17\nvar DataStreamErrorReason;\n(function (DataStreamErrorReason) {\n  // Unable to open a stream with the same ID more than once.\n  DataStreamErrorReason[DataStreamErrorReason[\"AlreadyOpened\"] = 0] = \"AlreadyOpened\";\n  // Stream closed abnormally by remote participant.\n  DataStreamErrorReason[DataStreamErrorReason[\"AbnormalEnd\"] = 1] = \"AbnormalEnd\";\n  // Incoming chunk data could not be decoded.\n  DataStreamErrorReason[DataStreamErrorReason[\"DecodeFailed\"] = 2] = \"DecodeFailed\";\n  // Read length exceeded total length specified in stream header.\n  DataStreamErrorReason[DataStreamErrorReason[\"LengthExceeded\"] = 3] = \"LengthExceeded\";\n  // Read length less than total length specified in stream header.\n  DataStreamErrorReason[DataStreamErrorReason[\"Incomplete\"] = 4] = \"Incomplete\";\n  // Unable to register a stream handler more than once.\n  DataStreamErrorReason[DataStreamErrorReason[\"HandlerAlreadyRegistered\"] = 7] = \"HandlerAlreadyRegistered\";\n  // Encryption type mismatch.\n  DataStreamErrorReason[DataStreamErrorReason[\"EncryptionTypeMismatch\"] = 8] = \"EncryptionTypeMismatch\";\n})(DataStreamErrorReason || (DataStreamErrorReason = {}));\nclass DataStreamError extends LivekitError {\n  constructor(message, reason) {\n    super(16, message);\n    this.name = 'DataStreamError';\n    this.reason = reason;\n    this.reasonName = DataStreamErrorReason[reason];\n  }\n}\nclass SignalReconnectError extends LivekitError {\n  constructor(message) {\n    super(18, message);\n    this.name = 'SignalReconnectError';\n  }\n}\nvar MediaDeviceFailure;\n(function (MediaDeviceFailure) {\n  // user rejected permissions\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n  // device is not available\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function (MediaDeviceFailure) {\n  function getFailure(error) {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n  MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */\nclass CriticalTimers {}\nCriticalTimers.setTimeout = function () {\n  return setTimeout(...arguments);\n};\nCriticalTimers.setInterval =\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nfunction () {\n  return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function () {\n  return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function () {\n  return clearInterval(...arguments);\n};/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */\nvar RoomEvent;\n(function (RoomEvent) {\n  /**\n   * When the connection to the server has been established\n   */\n  RoomEvent[\"Connected\"] = \"connected\";\n  /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */\n  RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n  /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */\n  RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n  /**\n   * Fires when a reconnection has been successful.\n   */\n  RoomEvent[\"Reconnected\"] = \"reconnected\";\n  /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */\n  RoomEvent[\"Disconnected\"] = \"disconnected\";\n  /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */\n  RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n  /**\n   * When participant has been moved to a different room by the service request.\n   * The behavior looks like the participant has been disconnected and reconnected to a different room\n   * seamlessly without connection state transition.\n   * A new token will be provided for reconnecting to the new room if needed.\n   *\n   * args: ([[room: string, token: string]])\n   */\n  RoomEvent[\"Moved\"] = \"moved\";\n  /**\n   * When input or output devices on the machine have changed.\n   */\n  RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n  /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n  /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */\n  RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n  /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */\n  RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n  /**\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\n   *\n   * args: (participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantActive\"] = \"participantActive\";\n  /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */\n  RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n  /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */\n  RoomEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from a participant's track.\n   * @beta\n   */\n  RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */\n  RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */\n  RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n  /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */\n  RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n  /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */\n  RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /**\n   * Signal connected, can publish tracks.\n   */\n  RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n  /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */\n  RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n  RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n  /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */\n  RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n  RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n  /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */\n  RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /**\n   * fired when the client receives connection metrics from other participants\n   */\n  RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function (ParticipantEvent) {\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */\n  ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * A local track has been constrained by cpu.\n   * This event is useful to know when to reduce the capture resolution of the track.\n   *\n   * This event is emitted on the local participant.\n   *\n   * args: ([[LocalVideoTrack]], [[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackCpuConstrained\"] = \"localTrackCpuConstrained\";\n  /**\n   * @internal\n   */\n  ParticipantEvent[\"LocalSenderCreated\"] = \"localSenderCreated\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */\n  ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */\n  ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */\n  ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */\n  ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */\n  ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */\n  ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */\n  ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  /**\n   * a local track has been constrained by cpu\n   */\n  ParticipantEvent[\"TrackCpuConstrained\"] = \"trackCpuConstrained\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */\n  ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /** @internal */\n  ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */\n  ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n  /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */\n  ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /** only emitted on local participant */\n  ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n  /**\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\n   */\n  ParticipantEvent[\"Active\"] = \"active\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */\nvar EngineEvent;\n(function (EngineEvent) {\n  EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n  EngineEvent[\"Connected\"] = \"connected\";\n  EngineEvent[\"Disconnected\"] = \"disconnected\";\n  EngineEvent[\"Resuming\"] = \"resuming\";\n  EngineEvent[\"Resumed\"] = \"resumed\";\n  EngineEvent[\"Restarting\"] = \"restarting\";\n  EngineEvent[\"Restarted\"] = \"restarted\";\n  EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n  EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n  EngineEvent[\"Closing\"] = \"closing\";\n  EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n  EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n  EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n  EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n  EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n  EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n  EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n  EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n  EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n  EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n  EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n  EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n  EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n  EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  EngineEvent[\"Offline\"] = \"offline\";\n  EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n  EngineEvent[\"SignalConnected\"] = \"signalConnected\";\n  EngineEvent[\"RoomMoved\"] = \"roomMoved\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function (TrackEvent) {\n  TrackEvent[\"Message\"] = \"message\";\n  TrackEvent[\"Muted\"] = \"muted\";\n  TrackEvent[\"Unmuted\"] = \"unmuted\";\n  /**\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"Restarted\"] = \"restarted\";\n  TrackEvent[\"Ended\"] = \"ended\";\n  TrackEvent[\"Subscribed\"] = \"subscribed\";\n  TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n  TrackEvent[\"CpuConstrained\"] = \"cpuConstrained\";\n  /** @internal */\n  TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n  /** @internal */\n  TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n  /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */\n  TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n  /** @internal */\n  TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n  /** @internal */\n  TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n  /** @internal */\n  TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n  /** @internal */\n  TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n  /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n  /**\n   * @beta\n   */\n  TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * @experimental\n   */\n  TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"PreConnectBufferFlushed\"] = \"preConnectBufferFlushed\";\n})(TrackEvent || (TrackEvent = {}));function cloneDeep(value) {\n  if (typeof value === 'undefined') {\n    return value;\n  }\n  if (typeof structuredClone === 'function') {\n    if (typeof value === 'object' && value !== null) {\n      // ensure that the value is not a proxy by spreading it\n      return structuredClone(Object.assign({}, value));\n    }\n    return structuredClone(value);\n  } else {\n    return JSON.parse(JSON.stringify(value));\n  }\n}class VideoPreset {\n  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {\n    if (typeof widthOrOptions === 'object') {\n      this.width = widthOrOptions.width;\n      this.height = widthOrOptions.height;\n      this.aspectRatio = widthOrOptions.aspectRatio;\n      this.encoding = {\n        maxBitrate: widthOrOptions.maxBitrate,\n        maxFramerate: widthOrOptions.maxFramerate,\n        priority: widthOrOptions.priority\n      };\n    } else if (height !== undefined && maxBitrate !== undefined) {\n      this.width = widthOrOptions;\n      this.height = height;\n      this.aspectRatio = widthOrOptions / height;\n      this.encoding = {\n        maxBitrate,\n        maxFramerate,\n        priority\n      };\n    } else {\n      throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');\n    }\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.aspectRatio\n    };\n  }\n}\n// `red` is not technically a codec, but treated as one in signalling protocol\nconst audioCodecs = ['opus', 'red'];\nconst backupVideoCodecs = ['vp8', 'h264'];\nconst videoCodecs = ['vp8', 'h264', 'vp9', 'av1', 'h265'];\nfunction isBackupVideoCodec(codec) {\n  return !!backupVideoCodecs.find(backup => backup === codec);\n}\n/** @deprecated Use {@link isBackupVideoCodec} instead */\nconst isBackupCodec = isBackupVideoCodec;\nvar BackupCodecPolicy;\n(function (BackupCodecPolicy) {\n  // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\n  BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\n  // multi-codec simulcast, publish both primary and backup codec at the same time\n  BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\n  // always use backup codec only\n  BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\nvar AudioPresets;\n(function (AudioPresets) {\n  AudioPresets.telephone = {\n    maxBitrate: 12000\n  };\n  AudioPresets.speech = {\n    maxBitrate: 24000\n  };\n  AudioPresets.music = {\n    maxBitrate: 48000\n  };\n  AudioPresets.musicStereo = {\n    maxBitrate: 64000\n  };\n  AudioPresets.musicHighQuality = {\n    maxBitrate: 96000\n  };\n  AudioPresets.musicHighQualityStereo = {\n    maxBitrate: 128000\n  };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */\nconst VideoPresets = {\n  h90: new VideoPreset(160, 90, 90000, 20),\n  h180: new VideoPreset(320, 180, 160000, 20),\n  h216: new VideoPreset(384, 216, 180000, 20),\n  h360: new VideoPreset(640, 360, 450000, 20),\n  h540: new VideoPreset(960, 540, 800000, 25),\n  h720: new VideoPreset(1280, 720, 1700000, 30),\n  h1080: new VideoPreset(1920, 1080, 3000000, 30),\n  h1440: new VideoPreset(2560, 1440, 5000000, 30),\n  h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */\nconst VideoPresets43 = {\n  h120: new VideoPreset(160, 120, 70000, 20),\n  h180: new VideoPreset(240, 180, 125000, 20),\n  h240: new VideoPreset(320, 240, 140000, 20),\n  h360: new VideoPreset(480, 360, 330000, 20),\n  h480: new VideoPreset(640, 480, 500000, 20),\n  h540: new VideoPreset(720, 540, 600000, 25),\n  h720: new VideoPreset(960, 720, 1300000, 30),\n  h1080: new VideoPreset(1440, 1080, 2300000, 30),\n  h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n  h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\n  h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\n  h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\n  h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\n  h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\n  h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\n  h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\n  // original resolution, without resizing\n  original: new VideoPreset(0, 0, 7000000, 30, 'medium')\n};function mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n  var _a, _b;\n  var _c, _d;\n  const {\n    optionsWithoutProcessor,\n    audioProcessor,\n    videoProcessor\n  } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\n  const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\n  const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\n  const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\n  if (clonedOptions.audio === true) clonedOptions.audio = {};\n  if (clonedOptions.video === true) clonedOptions.video = {};\n  // use defaults\n  if (clonedOptions.audio) {\n    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\n    (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n      ideal: 'default'\n    };\n    if (audioProcessor || defaultAudioProcessor) {\n      clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\n    }\n  }\n  if (clonedOptions.video) {\n    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\n    (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n      ideal: 'default'\n    };\n    if (videoProcessor || defaultVideoProcessor) {\n      clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\n    }\n  }\n  return clonedOptions;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n  Object.keys(objectToMerge).forEach(key => {\n    if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n  });\n  return mainObject;\n}\nfunction constraintsForOptions(options) {\n  var _a, _b;\n  var _c, _d;\n  const constraints = {};\n  if (options.video) {\n    // default video options\n    if (typeof options.video === 'object') {\n      const videoOptions = {};\n      const target = videoOptions;\n      const source = options.video;\n      Object.keys(source).forEach(key => {\n        switch (key) {\n          case 'resolution':\n            // flatten VideoResolution fields\n            mergeObjectWithoutOverwriting(target, source.resolution);\n            break;\n          default:\n            target[key] = source[key];\n        }\n      });\n      constraints.video = videoOptions;\n      (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n        ideal: 'default'\n      };\n    } else {\n      constraints.video = options.video ? {\n        deviceId: {\n          ideal: 'default'\n        }\n      } : false;\n    }\n  } else {\n    constraints.video = false;\n  }\n  if (options.audio) {\n    if (typeof options.audio === 'object') {\n      constraints.audio = options.audio;\n      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n        ideal: 'default'\n      };\n    } else {\n      constraints.audio = {\n        deviceId: {\n          ideal: 'default'\n        }\n      };\n    }\n  } else {\n    constraints.audio = false;\n  }\n  return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */\nfunction detectSilence(track_1) {\n  return __awaiter(this, arguments, void 0, function (track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return function* () {\n      const ctx = getNewAudioContext();\n      if (ctx) {\n        const analyser = ctx.createAnalyser();\n        analyser.fftSize = 2048;\n        const bufferLength = analyser.frequencyBinCount;\n        const dataArray = new Uint8Array(bufferLength);\n        const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\n        source.connect(analyser);\n        yield sleep(timeOffset);\n        analyser.getByteTimeDomainData(dataArray);\n        const someNoise = dataArray.some(sample => sample !== 128 && sample !== 0);\n        ctx.close();\n        return !someNoise;\n      }\n      return false;\n    }();\n  });\n}\n/**\n * @internal\n */\nfunction getNewAudioContext() {\n  var _a;\n  const AudioContext =\n  // @ts-ignore\n  typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n  if (AudioContext) {\n    const audioContext = new AudioContext({\n      latencyHint: 'interactive'\n    });\n    // If the audio context is suspended, we need to resume it when the user clicks on the page\n    if (audioContext.state === 'suspended' && typeof window !== 'undefined' && ((_a = window.document) === null || _a === void 0 ? void 0 : _a.body)) {\n      const handleResume = () => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n          if (audioContext.state === 'suspended') {\n            yield audioContext.resume();\n          }\n        } catch (e) {\n          console.warn('Error trying to auto-resume audio context', e);\n        } finally {\n          (_a = window.document.body) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', handleResume);\n        }\n      });\n      // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/statechange_event\n      audioContext.addEventListener('statechange', () => {\n        var _a;\n        if (audioContext.state === 'closed') {\n          (_a = window.document.body) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', handleResume);\n        }\n      });\n      window.document.body.addEventListener('click', handleResume);\n    }\n    return audioContext;\n  }\n}\n/**\n * @internal\n */\nfunction kindToSource(kind) {\n  if (kind === 'audioinput') {\n    return Track.Source.Microphone;\n  } else if (kind === 'videoinput') {\n    return Track.Source.Camera;\n  } else {\n    return Track.Source.Unknown;\n  }\n}\n/**\n * @internal\n */\nfunction sourceToKind(source) {\n  if (source === Track.Source.Microphone) {\n    return 'audioinput';\n  } else if (source === Track.Source.Camera) {\n    return 'videoinput';\n  } else {\n    return undefined;\n  }\n}\n/**\n * @internal\n */\nfunction screenCaptureToDisplayMediaStreamOptions(options) {\n  var _a, _b;\n  let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n  // treat 0 as uncapped\n  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n    videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\n    if (isSafari()) {\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n        width: {\n          max: options.resolution.width\n        },\n        height: {\n          max: options.resolution.height\n        },\n        frameRate: options.resolution.frameRate\n      });\n    } else {\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n        width: {\n          ideal: options.resolution.width\n        },\n        height: {\n          ideal: options.resolution.height\n        },\n        frameRate: options.resolution.frameRate\n      });\n    }\n  }\n  return {\n    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n    video: videoConstraints,\n    // @ts-expect-error support for experimental display media features\n    controller: options.controller,\n    selfBrowserSurface: options.selfBrowserSurface,\n    surfaceSwitching: options.surfaceSwitching,\n    systemAudio: options.systemAudio,\n    preferCurrentTab: options.preferCurrentTab\n  };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n  return mimeType.split('/')[1].toLowerCase();\n}\nfunction getTrackPublicationInfo(tracks) {\n  const infos = [];\n  tracks.forEach(track => {\n    if (track.track !== undefined) {\n      infos.push(new TrackPublishedResponse({\n        cid: track.track.mediaStreamID,\n        track: track.trackInfo\n      }));\n    }\n  });\n  return infos;\n}\nfunction getLogContextFromTrack(track) {\n  if ('mediaStreamTrack' in track) {\n    return {\n      trackID: track.sid,\n      source: track.source,\n      muted: track.isMuted,\n      enabled: track.mediaStreamTrack.enabled,\n      kind: track.kind,\n      streamID: track.mediaStreamID,\n      streamTrackID: track.mediaStreamTrack.id\n    };\n  } else {\n    return {\n      trackID: track.trackSid,\n      enabled: track.isEnabled,\n      muted: track.isMuted,\n      trackInfo: Object.assign({\n        mimeType: track.mimeType,\n        name: track.trackName,\n        encrypted: track.isEncrypted,\n        kind: track.kind,\n        source: track.source\n      }, track.track ? getLogContextFromTrack(track.track) : {})\n    };\n  }\n}\nfunction supportsSynchronizationSources() {\n  return typeof RTCRtpReceiver !== 'undefined' && 'getSynchronizationSources' in RTCRtpReceiver;\n}\nfunction diffAttributes(oldValues, newValues) {\n  var _a;\n  if (oldValues === undefined) {\n    oldValues = {};\n  }\n  if (newValues === undefined) {\n    newValues = {};\n  }\n  const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];\n  const diff = {};\n  for (const key of allKeys) {\n    if (oldValues[key] !== newValues[key]) {\n      diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : '';\n    }\n  }\n  return diff;\n}\n/** @internal */\nfunction extractProcessorsFromOptions(options) {\n  const newOptions = Object.assign({}, options);\n  let audioProcessor;\n  let videoProcessor;\n  if (typeof newOptions.audio === 'object' && newOptions.audio.processor) {\n    audioProcessor = newOptions.audio.processor;\n    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\n      processor: undefined\n    });\n  }\n  if (typeof newOptions.video === 'object' && newOptions.video.processor) {\n    videoProcessor = newOptions.video.processor;\n    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\n      processor: undefined\n    });\n  }\n  return {\n    audioProcessor,\n    videoProcessor,\n    optionsWithoutProcessor: cloneDeep(newOptions)\n  };\n}\nfunction getTrackSourceFromProto(source) {\n  switch (source) {\n    case TrackSource.CAMERA:\n      return Track.Source.Camera;\n    case TrackSource.MICROPHONE:\n      return Track.Source.Microphone;\n    case TrackSource.SCREEN_SHARE:\n      return Track.Source.ScreenShare;\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return Track.Source.ScreenShareAudio;\n    default:\n      return Track.Source.Unknown;\n  }\n}\nfunction areDimensionsSmaller(a, b) {\n  return a.width * a.height < b.width * b.height;\n}\nfunction layerDimensionsFor(trackInfo, quality) {\n  var _a;\n  return (_a = trackInfo.layers) === null || _a === void 0 ? void 0 : _a.find(l => l.quality === quality);\n}const BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function (VideoQuality) {\n  VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n  VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n  VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n  /**\n   * indicates current state of stream, it'll indicate `paused` if the track\n   * has been paused by congestion controller\n   */\n  get streamState() {\n    return this._streamState;\n  }\n  /** @internal */\n  setStreamState(value) {\n    this._streamState = value;\n  }\n  constructor(mediaTrack, kind) {\n    let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a;\n    super();\n    this.attachedElements = [];\n    this.isMuted = false;\n    this._streamState = Track.StreamState.Active;\n    this.isInBackground = false;\n    this._currentBitrate = 0;\n    this.log = livekitLogger;\n    this.appVisibilityChangedListener = () => {\n      if (this.backgroundTimeout) {\n        clearTimeout(this.backgroundTimeout);\n      }\n      // delay app visibility update if it goes to hidden\n      // update immediately if it comes back to focus\n      if (document.visibilityState === 'hidden') {\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n      } else {\n        this.handleAppVisibilityChanged();\n      }\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n    this.loggerContextCb = loggerOptions.loggerContextCb;\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this._mediaStreamTrack = mediaTrack;\n    this._mediaStreamID = mediaTrack.id;\n    this.source = Track.Source.Unknown;\n  }\n  get logContext() {\n    var _a;\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(element) {\n    let elementType = 'audio';\n    if (this.kind === Track.Kind.Video) {\n      elementType = 'video';\n    }\n    if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n      this.addAppVisibilityListener();\n    }\n    if (!element) {\n      if (elementType === 'audio') {\n        recycledElements.forEach(e => {\n          if (e.parentElement === null && !element) {\n            element = e;\n          }\n        });\n        if (element) {\n          // remove it from pool\n          recycledElements.splice(recycledElements.indexOf(element), 1);\n        }\n      }\n      if (!element) {\n        element = document.createElement(elementType);\n      }\n    }\n    if (!this.attachedElements.includes(element)) {\n      this.attachedElements.push(element);\n    }\n    // even if we believe it's already attached to the element, it's possible\n    // the element's srcObject was set to something else out of band.\n    // we'll want to re-attach it in that case\n    attachToElement(this.mediaStreamTrack, element);\n    // handle auto playback failures\n    const allMediaStreamTracks = element.srcObject.getTracks();\n    const hasAudio = allMediaStreamTracks.some(tr => tr.kind === 'audio');\n    // manually play media to detect auto playback status\n    element.play().then(() => {\n      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n    }).catch(e => {\n      if (e.name === 'NotAllowedError') {\n        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n      } else if (e.name === 'AbortError') {\n        // commonly triggered by another `play` request, only log for debugging purposes\n        livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\n      } else {\n        livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\n      }\n      // If audio playback isn't allowed make sure we still play back the video\n      if (hasAudio && element && allMediaStreamTracks.some(tr => tr.kind === 'video') && e.name === 'NotAllowedError') {\n        element.muted = true;\n        element.play().catch(() => {\n          // catch for Safari, exceeded options at this point to automatically play the media element\n        });\n      }\n    });\n    this.emit(TrackEvent.ElementAttached, element);\n    return element;\n  }\n  detach(element) {\n    try {\n      // detach from a single element\n      if (element) {\n        detachTrack(this.mediaStreamTrack, element);\n        const idx = this.attachedElements.indexOf(element);\n        if (idx >= 0) {\n          this.attachedElements.splice(idx, 1);\n          this.recycleElement(element);\n          this.emit(TrackEvent.ElementDetached, element);\n        }\n        return element;\n      }\n      const detached = [];\n      this.attachedElements.forEach(elm => {\n        detachTrack(this.mediaStreamTrack, elm);\n        detached.push(elm);\n        this.recycleElement(elm);\n        this.emit(TrackEvent.ElementDetached, elm);\n      });\n      // remove all tracks\n      this.attachedElements = [];\n      return detached;\n    } finally {\n      if (this.attachedElements.length === 0) {\n        this.removeAppVisibilityListener();\n      }\n    }\n  }\n  stop() {\n    this.stopMonitor();\n    this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = true;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = false;\n  }\n  /* @internal */\n  stopMonitor() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n    if (this.timeSyncHandle) {\n      cancelAnimationFrame(this.timeSyncHandle);\n    }\n  }\n  /** @internal */\n  updateLoggerOptions(loggerOptions) {\n    if (loggerOptions.loggerName) {\n      this.log = getLogger(loggerOptions.loggerName);\n    }\n    if (loggerOptions.loggerContextCb) {\n      this.loggerContextCb = loggerOptions.loggerContextCb;\n    }\n  }\n  recycleElement(element) {\n    if (element instanceof HTMLAudioElement) {\n      // we only need to re-use a single element\n      let shouldCache = true;\n      element.pause();\n      recycledElements.forEach(e => {\n        if (!e.parentElement) {\n          shouldCache = false;\n        }\n      });\n      if (shouldCache) {\n        recycledElements.push(element);\n      }\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === 'hidden';\n      if (!this.isInBackground && this.kind === Track.Kind.Video) {\n        setTimeout(() => this.attachedElements.forEach(el => el.play().catch(() => {\n          /** catch clause necessary for Safari */\n        })), 0);\n      }\n    });\n  }\n  addAppVisibilityListener() {\n    if (isWeb()) {\n      this.isInBackground = document.visibilityState === 'hidden';\n      document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\n    } else {\n      this.isInBackground = false;\n    }\n  }\n  removeAppVisibilityListener() {\n    if (isWeb()) {\n      document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\n    }\n  }\n}\nfunction attachToElement(track, element) {\n  let mediaStream;\n  if (element.srcObject instanceof MediaStream) {\n    mediaStream = element.srcObject;\n  } else {\n    mediaStream = new MediaStream();\n  }\n  // check if track matches existing track\n  let existingTracks;\n  if (track.kind === 'audio') {\n    existingTracks = mediaStream.getAudioTracks();\n  } else {\n    existingTracks = mediaStream.getVideoTracks();\n  }\n  if (!existingTracks.includes(track)) {\n    existingTracks.forEach(et => {\n      mediaStream.removeTrack(et);\n    });\n    mediaStream.addTrack(track);\n  }\n  if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n    // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n    // when a video starts that has the `autoplay` attribute is set.\n    // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n    element.autoplay = true;\n  }\n  // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n  element.muted = mediaStream.getAudioTracks().length === 0;\n  if (element instanceof HTMLVideoElement) {\n    element.playsInline = true;\n  }\n  // avoid flicker\n  if (element.srcObject !== mediaStream) {\n    element.srcObject = mediaStream;\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n      // Firefox also has a timing issue where video doesn't actually get attached unless\n      // performed out-of-band\n      // Safari 15 has a bug where in certain layouts, video element renders\n      // black until the page is resized or other changes take place.\n      // Resetting the src triggers it to render.\n      // https://developer.apple.com/forums/thread/690523\n      setTimeout(() => {\n        element.srcObject = mediaStream;\n        // Safari 15 sometimes fails to start a video\n        // when the window is backgrounded before the first frame is drawn\n        // manually calling play here seems to fix that\n        element.play().catch(() => {\n          /** do nothing */\n        });\n      }, 0);\n    }\n  }\n}\n/** @internal */\nfunction detachTrack(track, element) {\n  if (element.srcObject instanceof MediaStream) {\n    const mediaStream = element.srcObject;\n    mediaStream.removeTrack(track);\n    if (mediaStream.getTracks().length > 0) {\n      element.srcObject = mediaStream;\n    } else {\n      element.srcObject = null;\n    }\n  }\n}\n(function (Track) {\n  let Kind;\n  (function (Kind) {\n    Kind[\"Audio\"] = \"audio\";\n    Kind[\"Video\"] = \"video\";\n    Kind[\"Unknown\"] = \"unknown\";\n  })(Kind = Track.Kind || (Track.Kind = {}));\n  let Source;\n  (function (Source) {\n    Source[\"Camera\"] = \"camera\";\n    Source[\"Microphone\"] = \"microphone\";\n    Source[\"ScreenShare\"] = \"screen_share\";\n    Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n    Source[\"Unknown\"] = \"unknown\";\n  })(Source = Track.Source || (Track.Source = {}));\n  let StreamState$1;\n  (function (StreamState) {\n    StreamState[\"Active\"] = \"active\";\n    StreamState[\"Paused\"] = \"paused\";\n    StreamState[\"Unknown\"] = \"unknown\";\n  })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n  /** @internal */\n  function kindToProto(k) {\n    switch (k) {\n      case Kind.Audio:\n        return TrackType.AUDIO;\n      case Kind.Video:\n        return TrackType.VIDEO;\n      default:\n        // FIXME this was UNRECOGNIZED before\n        return TrackType.DATA;\n    }\n  }\n  Track.kindToProto = kindToProto;\n  /** @internal */\n  function kindFromProto(t) {\n    switch (t) {\n      case TrackType.AUDIO:\n        return Kind.Audio;\n      case TrackType.VIDEO:\n        return Kind.Video;\n      default:\n        return Kind.Unknown;\n    }\n  }\n  Track.kindFromProto = kindFromProto;\n  /** @internal */\n  function sourceToProto(s) {\n    switch (s) {\n      case Source.Camera:\n        return TrackSource.CAMERA;\n      case Source.Microphone:\n        return TrackSource.MICROPHONE;\n      case Source.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case Source.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNKNOWN;\n    }\n  }\n  Track.sourceToProto = sourceToProto;\n  /** @internal */\n  function sourceFromProto(s) {\n    switch (s) {\n      case TrackSource.CAMERA:\n        return Source.Camera;\n      case TrackSource.MICROPHONE:\n        return Source.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return Source.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return Source.ScreenShareAudio;\n      default:\n        return Source.Unknown;\n    }\n  }\n  Track.sourceFromProto = sourceFromProto;\n  /** @internal */\n  function streamStateFromProto(s) {\n    switch (s) {\n      case StreamState.ACTIVE:\n        return StreamState$1.Active;\n      case StreamState.PAUSED:\n        return StreamState$1.Paused;\n      default:\n        return StreamState$1.Unknown;\n    }\n  }\n  Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));const separator = '|';\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\nfunction unpackStreamId(packed) {\n  const parts = packed.split(separator);\n  if (parts.length > 1) {\n    return [parts[0], packed.substr(parts[0].length + 1)];\n  }\n  return [packed, ''];\n}\nfunction sleep(duration) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise(resolve => CriticalTimers.setTimeout(resolve, duration));\n  });\n}\n/** @internal */\nfunction supportsTransceiver() {\n  return 'addTransceiver' in RTCPeerConnection.prototype;\n}\n/** @internal */\nfunction supportsAddTrack() {\n  return 'addTrack' in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n  return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n  return supportsTransceiver();\n}\nfunction supportsAV1() {\n  if (!('getCapabilities' in RTCRtpSender)) {\n    return false;\n  }\n  if (isSafari() || isFireFox()) {\n    // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n    // Firefox does support AV1, but SVC publishing is not supported\n    return false;\n  }\n  const capabilities = RTCRtpSender.getCapabilities('video');\n  let hasAV1 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType.toLowerCase() === 'video/av1') {\n        hasAV1 = true;\n        break;\n      }\n    }\n  }\n  return hasAV1;\n}\nfunction supportsVP9() {\n  if (!('getCapabilities' in RTCRtpSender)) {\n    return false;\n  }\n  if (isFireFox()) {\n    // technically speaking FireFox supports VP9, but SVC publishing is broken\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n    return false;\n  }\n  if (isSafari()) {\n    const browser = getBrowser();\n    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\n      // Safari 16 and below does not support VP9\n      return false;\n    }\n    if ((browser === null || browser === void 0 ? void 0 : browser.os) === 'iOS' && (browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, '16') < 0) {\n      // Safari 16 and below on iOS does not support VP9 we need the iOS check to account for other browsers running webkit under the hood\n      return false;\n    }\n  }\n  const capabilities = RTCRtpSender.getCapabilities('video');\n  let hasVP9 = false;\n  if (capabilities) {\n    for (const codec of capabilities.codecs) {\n      if (codec.mimeType.toLowerCase() === 'video/vp9') {\n        hasVP9 = true;\n        break;\n      }\n    }\n  }\n  return hasVP9;\n}\nfunction isSVCCodec(codec) {\n  return codec === 'av1' || codec === 'vp9';\n}\nfunction supportsSetSinkId(elm) {\n  if (!document || isSafariBased()) {\n    return false;\n  }\n  if (!elm) {\n    elm = document.createElement('audio');\n  }\n  return 'setSinkId' in elm;\n}\n/**\n * Checks whether or not setting an audio output via {@link Room#setActiveDevice}\n * is supported for the current browser.\n */\nfunction supportsAudioOutputSelection() {\n  // Note: this is method publicly exported under a user friendly name and currently only proxying `supportsSetSinkId`\n  return supportsSetSinkId();\n}\nfunction isBrowserSupported() {\n  if (typeof RTCPeerConnection === 'undefined') {\n    return false;\n  }\n  return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\n}\nfunction isChromiumBased() {\n  const browser = getBrowser();\n  return !!browser && browser.name === 'Chrome' && browser.os !== 'iOS';\n}\nfunction isSafari() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\n}\nfunction isSafariBased() {\n  const b = getBrowser();\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' || (b === null || b === void 0 ? void 0 : b.os) === 'iOS';\n}\nfunction isSafari17Based() {\n  const b = getBrowser();\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.') || (b === null || b === void 0 ? void 0 : b.os) === 'iOS' && !!(b === null || b === void 0 ? void 0 : b.osVersion) && compareVersions(b.osVersion, '17') >= 0;\n}\nfunction isSafariSvcApi(browser) {\n  if (!browser) {\n    browser = getBrowser();\n  }\n  // Safari 18.4 requires legacy svc api and scaleResolutionDown to be set\n  return (browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '18.3') > 0 || (browser === null || browser === void 0 ? void 0 : browser.os) === 'iOS' && !!(browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, '18.3') > 0;\n}\nfunction isMobile() {\n  var _a, _b;\n  if (!isWeb()) return false;\n  return (\n    // @ts-expect-error `userAgentData` is not yet part of typescript\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)\n  );\n}\nfunction isE2EESimulcastSupported() {\n  const browser = getBrowser();\n  const supportedSafariVersion = '17.2'; // see https://bugs.webkit.org/show_bug.cgi?id=257803\n  if (browser) {\n    if (browser.name !== 'Safari' && browser.os !== 'iOS') {\n      return true;\n    } else if (browser.os === 'iOS' && browser.osVersion && compareVersions(browser.osVersion, supportedSafariVersion) >= 0) {\n      return true;\n    } else if (browser.name === 'Safari' && compareVersions(browser.version, supportedSafariVersion) >= 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\nfunction isWeb() {\n  return typeof document !== 'undefined';\n}\nfunction isReactNative() {\n  // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n  return navigator.product == 'ReactNative';\n}\nfunction isCloud(serverUrl) {\n  return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\n}\nfunction extractProjectFromUrl(serverUrl) {\n  if (!isCloud(serverUrl)) {\n    return null;\n  }\n  return serverUrl.hostname.split('.')[0];\n}\nfunction getLKReactNativeInfo() {\n  // global defined only for ReactNative.\n  // @ts-ignore\n  if (global && global.LiveKitReactNativeGlobal) {\n    // @ts-ignore\n    return global.LiveKitReactNativeGlobal;\n  }\n  return undefined;\n}\nfunction getReactNativeOs() {\n  if (!isReactNative()) {\n    return undefined;\n  }\n  let info = getLKReactNativeInfo();\n  if (info) {\n    return info.platform;\n  }\n  return undefined;\n}\nfunction getDevicePixelRatio() {\n  if (isWeb()) {\n    return window.devicePixelRatio;\n  }\n  if (isReactNative()) {\n    let info = getLKReactNativeInfo();\n    if (info) {\n      return info.devicePixelRatio;\n    }\n  }\n  return 1;\n}\n/**\n * @param v1 - The first version string to compare.\n * @param v2 - The second version string to compare.\n * @returns A number indicating the order of the versions:\n *   - 1 if v1 is greater than v2\n *   - -1 if v1 is less than v2\n *   - 0 if v1 and v2 are equal\n */\nfunction compareVersions(v1, v2) {\n  const parts1 = v1.split('.');\n  const parts2 = v2.split('.');\n  const k = Math.min(parts1.length, parts2.length);\n  for (let i = 0; i < k; ++i) {\n    const p1 = parseInt(parts1[i], 10);\n    const p2 = parseInt(parts2[i], 10);\n    if (p1 > p2) return 1;\n    if (p1 < p2) return -1;\n    if (i === k - 1 && p1 === p2) return 0;\n  }\n  if (v1 === '' && v2 !== '') {\n    return -1;\n  } else if (v2 === '') {\n    return 1;\n  }\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleResize(entry);\n  }\n}\nfunction ioDispatchCallback(entries) {\n  for (const entry of entries) {\n    entry.target.handleVisibilityChanged(entry);\n  }\n}\nlet resizeObserver = null;\nconst getResizeObserver = () => {\n  if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n  return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = () => {\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n      root: null,\n      rootMargin: '0px'\n    });\n  }\n  return intersectionObserver;\n};\nfunction getClientInfo() {\n  var _a;\n  const info = new ClientInfo({\n    sdk: ClientInfo_SDK.JS,\n    protocol: protocolVersion,\n    version\n  });\n  if (isReactNative()) {\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\n  }\n  return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n  if (!emptyVideoStreamTrack) {\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\n  }\n  return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n  let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n  let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const canvas = document.createElement('canvas');\n  // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n  if (paintContent && ctx) {\n    ctx.beginPath();\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fillStyle = 'grey';\n    ctx.fill();\n  }\n  // @ts-ignore\n  const dummyStream = canvas.captureStream();\n  const [dummyTrack] = dummyStream.getTracks();\n  if (!dummyTrack) {\n    throw Error('Could not get empty media stream video track');\n  }\n  dummyTrack.enabled = enabled;\n  return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n  if (!emptyAudioStreamTrack) {\n    // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n    const ctx = new AudioContext();\n    const oscillator = ctx.createOscillator();\n    const gain = ctx.createGain();\n    gain.gain.setValueAtTime(0, 0);\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(gain);\n    gain.connect(dst);\n    oscillator.start();\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n    if (!emptyAudioStreamTrack) {\n      throw Error('Could not get empty media stream audio track');\n    }\n    emptyAudioStreamTrack.enabled = false;\n  }\n  return emptyAudioStreamTrack.clone();\n}\nclass Future {\n  get isResolved() {\n    return this._isResolved;\n  }\n  constructor(futureBase, onFinally) {\n    this._isResolved = false;\n    this.onFinally = onFinally;\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      this.resolve = resolve;\n      this.reject = reject;\n      if (futureBase) {\n        yield futureBase(resolve, reject);\n      }\n    })).finally(() => {\n      var _a;\n      this._isResolved = true;\n      (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */\nfunction createAudioAnalyser(track, options) {\n  const opts = Object.assign({\n    cloneTrack: false,\n    fftSize: 2048,\n    smoothingTimeConstant: 0.8,\n    minDecibels: -100,\n    maxDecibels: -80\n  }, options);\n  const audioContext = getNewAudioContext();\n  if (!audioContext) {\n    throw new Error('Audio Context not supported on this browser');\n  }\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\n  const analyser = audioContext.createAnalyser();\n  analyser.minDecibels = opts.minDecibels;\n  analyser.maxDecibels = opts.maxDecibels;\n  analyser.fftSize = opts.fftSize;\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n  mediaStreamSource.connect(analyser);\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\n  /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */\n  const calculateVolume = () => {\n    analyser.getByteFrequencyData(dataArray);\n    let sum = 0;\n    for (const amplitude of dataArray) {\n      sum += Math.pow(amplitude / 255, 2);\n    }\n    const volume = Math.sqrt(sum / dataArray.length);\n    return volume;\n  };\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n    yield audioContext.close();\n    if (opts.cloneTrack) {\n      streamTrack.stop();\n    }\n  });\n  return {\n    calculateVolume,\n    analyser,\n    cleanup\n  };\n}\nfunction isAudioCodec(maybeCodec) {\n  return audioCodecs.includes(maybeCodec);\n}\nfunction isVideoCodec(maybeCodec) {\n  return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n  if (typeof constraint === 'string' || typeof constraint === 'number') {\n    return constraint;\n  }\n  if (Array.isArray(constraint)) {\n    return constraint[0];\n  }\n  if (constraint.exact !== undefined) {\n    if (Array.isArray(constraint.exact)) {\n      return constraint.exact[0];\n    }\n    return constraint.exact;\n  }\n  if (constraint.ideal !== undefined) {\n    if (Array.isArray(constraint.ideal)) {\n      return constraint.ideal[0];\n    }\n    return constraint.ideal;\n  }\n  throw Error('could not unwrap constraint');\n}\nfunction toWebsocketUrl(url) {\n  if (url.startsWith('http')) {\n    return url.replace(/^(http)/, 'ws');\n  }\n  return url;\n}\nfunction toHttpUrl(url) {\n  if (url.startsWith('ws')) {\n    return url.replace(/^(ws)/, 'http');\n  }\n  return url;\n}\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\n  return transcription.segments.map(_ref => {\n    let {\n      id,\n      text,\n      language,\n      startTime,\n      endTime,\n      final\n    } = _ref;\n    var _a;\n    const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\n    const lastReceivedTime = Date.now();\n    if (final) {\n      firstReceivedTimesMap.delete(id);\n    } else {\n      firstReceivedTimesMap.set(id, firstReceivedTime);\n    }\n    return {\n      id,\n      text,\n      startTime: Number.parseInt(startTime.toString()),\n      endTime: Number.parseInt(endTime.toString()),\n      final,\n      language,\n      firstReceivedTime,\n      lastReceivedTime\n    };\n  });\n}\nfunction extractChatMessage(msg) {\n  const {\n    id,\n    timestamp,\n    message,\n    editTimestamp\n  } = msg;\n  return {\n    id,\n    timestamp: Number.parseInt(timestamp.toString()),\n    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\n    message\n  };\n}\nfunction getDisconnectReasonFromConnectionError(e) {\n  switch (e.reason) {\n    case ConnectionErrorReason.LeaveRequest:\n      return e.context;\n    case ConnectionErrorReason.Cancelled:\n      return DisconnectReason.CLIENT_INITIATED;\n    case ConnectionErrorReason.NotAllowed:\n      return DisconnectReason.USER_REJECTED;\n    case ConnectionErrorReason.ServerUnreachable:\n      return DisconnectReason.JOIN_FAILURE;\n    default:\n      return DisconnectReason.UNKNOWN_REASON;\n  }\n}\n/** convert bigints to numbers preserving undefined values */\nfunction bigIntToNumber(value) {\n  return value !== undefined ? Number(value) : undefined;\n}\n/** convert numbers to bigints preserving undefined values */\nfunction numberToBigInt(value) {\n  return value !== undefined ? BigInt(value) : undefined;\n}\nfunction isLocalTrack(track) {\n  return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\n}\nfunction isAudioTrack(track) {\n  return !!track && track.kind == Track.Kind.Audio;\n}\nfunction isVideoTrack(track) {\n  return !!track && track.kind == Track.Kind.Video;\n}\nfunction isLocalVideoTrack(track) {\n  return isLocalTrack(track) && isVideoTrack(track);\n}\nfunction isLocalAudioTrack(track) {\n  return isLocalTrack(track) && isAudioTrack(track);\n}\nfunction isRemoteTrack(track) {\n  return !!track && !track.isLocal;\n}\nfunction isRemotePub(pub) {\n  return !!pub && !pub.isLocal;\n}\nfunction isRemoteVideoTrack(track) {\n  return isRemoteTrack(track) && isVideoTrack(track);\n}\nfunction isLocalParticipant(p) {\n  return p.isLocal;\n}\nfunction isRemoteParticipant(p) {\n  return !p.isLocal;\n}\nfunction splitUtf8(s, n) {\n  // adapted from https://stackoverflow.com/a/6043797\n  const result = [];\n  let encoded = new TextEncoder().encode(s);\n  while (encoded.length > n) {\n    let k = n;\n    while (k > 0) {\n      const byte = encoded[k];\n      if (byte !== undefined && (byte & 0xc0) !== 0x80) {\n        break;\n      }\n      k--;\n    }\n    result.push(encoded.slice(0, k));\n    encoded = encoded.slice(k);\n  }\n  if (encoded.length > 0) {\n    result.push(encoded);\n  }\n  return result;\n}\nfunction extractMaxAgeFromRequestHeaders(headers) {\n  var _a;\n  const cacheControl = headers.get('Cache-Control');\n  if (cacheControl) {\n    const maxAge = (_a = cacheControl.match(/(?:^|[,\\s])max-age=(\\d+)/)) === null || _a === void 0 ? void 0 : _a[1];\n    if (maxAge) {\n      return parseInt(maxAge, 10);\n    }\n  }\n  return undefined;\n}function createRtcUrl(url, searchParams) {\n  const urlObj = new URL(toWebsocketUrl(url));\n  searchParams.forEach((value, key) => {\n    urlObj.searchParams.set(key, value);\n  });\n  return appendUrlPath(urlObj, 'rtc');\n}\nfunction createValidateUrl(rtcWsUrl) {\n  const urlObj = new URL(toHttpUrl(rtcWsUrl));\n  return appendUrlPath(urlObj, 'validate');\n}\nfunction ensureTrailingSlash(path) {\n  return path.endsWith('/') ? path : \"\".concat(path, \"/\");\n}\nfunction appendUrlPath(urlObj, path) {\n  urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\n  return urlObj.toString();\n}\nfunction parseSignalResponse(value) {\n  if (typeof value === 'string') {\n    return SignalResponse.fromJson(JSON.parse(value), {\n      ignoreUnknownFields: true\n    });\n  } else if (value instanceof ArrayBuffer) {\n    return SignalResponse.fromBinary(new Uint8Array(value));\n  }\n  throw new Error(\"could not decode websocket message: \".concat(typeof value));\n}\nfunction getAbortReasonAsString(signal) {\n  let defaultMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unknown reason';\n  if (!(signal instanceof AbortSignal)) {\n    return defaultMessage;\n  }\n  const reason = signal.reason;\n  switch (typeof reason) {\n    case 'string':\n      return reason;\n    case 'object':\n      return reason instanceof Error ? reason.message : defaultMessage;\n    default:\n      return 'toString' in reason ? reason.toString() : defaultMessage;\n  }\n}const ENCRYPTION_ALGORITHM = 'AES-GCM';\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = 'lk_e2ee';\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n  keyringSize: 16\n};var KeyProviderEvent;\n(function (KeyProviderEvent) {\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\n  /** Event for requesting to ratchet the key used to encrypt the stream */\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n  /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or\n   *  following a `RatchetRequest`, will contain the ratcheted key material */\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function (KeyHandlerEvent) {\n  /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted\n   * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function (EncryptionEvent) {\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function (CryptorEvent) {\n  CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));function isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n  // @ts-ignore\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\nfunction isInsertableStreamSupported() {\n  return typeof window.RTCRtpSender !== 'undefined' &&\n  // @ts-ignore\n  typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\n}\nfunction isVideoFrame(frame) {\n  return 'type' in frame;\n}\nfunction importKey(keyBytes_1) {\n  return __awaiter(this, arguments, void 0, function (keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n    return function* () {\n      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n      return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\n    }();\n  });\n}\nfunction createKeyMaterialFromString(password) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let enc = new TextEncoder();\n    const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveBits', 'deriveKey']);\n    return keyMaterial;\n  });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, ['deriveBits', 'deriveKey']);\n    return keyMaterial;\n  });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128)\n      };\n    case 'PBKDF2':\n      {\n        return {\n          name: 'PBKDF2',\n          salt: encodedSalt,\n          hash: 'SHA-256',\n          iterations: 100000\n        };\n      }\n    default:\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n  }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nfunction deriveKeys(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128\n    }, false, ['encrypt', 'decrypt']);\n    return {\n      material,\n      encryptionKey\n    };\n  });\n}\nfunction createE2EEKey() {\n  return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nfunction ratchet(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n  });\n}\nfunction needsRbspUnescaping(frameData) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\nfunction parseRbsp(stream) {\n  const dataOut = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length;) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n  const dataOut = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\nfunction asEncryptablePacket(packet) {\n  var _a, _b, _c, _d, _e;\n  if (((_a = packet.value) === null || _a === void 0 ? void 0 : _a.case) !== 'sipDtmf' && ((_b = packet.value) === null || _b === void 0 ? void 0 : _b.case) !== 'metrics' && ((_c = packet.value) === null || _c === void 0 ? void 0 : _c.case) !== 'speaker' && ((_d = packet.value) === null || _d === void 0 ? void 0 : _d.case) !== 'transcription' && ((_e = packet.value) === null || _e === void 0 ? void 0 : _e.case) !== 'encryptedPacket') {\n    return new EncryptedPacketPayload({\n      value: packet.value\n    });\n  }\n  return undefined;\n}/**\n * @experimental\n */\nclass BaseKeyProvider extends eventsExports.EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * Callback being invoked after a key has been ratcheted.\n     * Can happen when:\n     * - A decryption failure occurs and the key is auto-ratcheted\n     * - A ratchet request is sent (see {@link ratchetKey()})\n     * @param ratchetResult Contains the ratcheted chain key (exportable to other participants) and the derived new key material.\n     * @param participantId\n     * @param keyIndex\n     */\n    this.onKeyRatcheted = (ratchetResult, participantId, keyIndex) => {\n      livekitLogger.debug('key ratcheted event received', {\n        ratchetResult,\n        participantId,\n        keyIndex\n      });\n    };\n    this.keyInfoMap = new Map();\n    this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n    this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n  }\n  /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */\n  onSetEncryptionKey(key, participantIdentity, keyIndex) {\n    const keyInfo = {\n      key,\n      participantIdentity,\n      keyIndex\n    };\n    if (!this.options.sharedKey && !participantIdentity) {\n      throw new Error('participant identity needs to be passed for encryption key if sharedKey option is false');\n    }\n    this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n    this.emit(KeyProviderEvent.SetKey, keyInfo);\n  }\n  getKeys() {\n    return Array.from(this.keyInfoMap.values());\n  }\n  getOptions() {\n    return this.options;\n  }\n  ratchetKey(participantIdentity, keyIndex) {\n    this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n  }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */\nclass ExternalE2EEKeyProvider extends BaseKeyProvider {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const opts = Object.assign(Object.assign({}, options), {\n      sharedKey: true,\n      // for a shared key provider failing to decrypt for a specific participant\n      // should not mark the key as invalid, so we accept wrong keys forever\n      // and won't try to auto-ratchet\n      ratchetWindowSize: 0,\n      failureTolerance: -1\n    });\n    super(opts);\n  }\n  /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */\n  setKey(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n      this.onSetEncryptionKey(derivedKey);\n    });\n  }\n}var CryptorErrorReason;\n(function (CryptorErrorReason) {\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n  constructor(message) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n    let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n    super(40, message);\n    this.reason = reason;\n    this.participantIdentity = participantIdentity;\n  }\n}/**\n * @experimental\n */\nclass E2EEManager extends eventsExports.EventEmitter {\n  constructor(options, dcEncryptionEnabled) {\n    super();\n    this.decryptDataRequests = new Map();\n    this.encryptDataRequests = new Map();\n    this.onWorkerMessage = ev => {\n      var _a, _b;\n      const {\n        kind,\n        data\n      } = ev.data;\n      switch (kind) {\n        case 'error':\n          livekitLogger.error(data.error.message);\n          // If error has uuid, it's from an async operation (encrypt/decrypt)\n          // Reject the corresponding future\n          if (data.uuid) {\n            const decryptFuture = this.decryptDataRequests.get(data.uuid);\n            if (decryptFuture === null || decryptFuture === void 0 ? void 0 : decryptFuture.reject) {\n              decryptFuture.reject(data.error);\n              break; // Don't emit general error if it's handled by future\n            }\n            const encryptFuture = this.encryptDataRequests.get(data.uuid);\n            if (encryptFuture === null || encryptFuture === void 0 ? void 0 : encryptFuture.reject) {\n              encryptFuture.reject(data.error);\n              break; // Don't emit general error if it's handled by future\n            }\n          }\n          // Emit general error event for unhandled errors\n          this.emit(EncryptionEvent.EncryptionError, data.error, data.participantIdentity);\n          break;\n        case 'initAck':\n          if (data.enabled) {\n            this.keyProvider.getKeys().forEach(keyInfo => {\n              this.postKey(keyInfo);\n            });\n          }\n          break;\n        case 'enable':\n          if (data.enabled) {\n            this.keyProvider.getKeys().forEach(keyInfo => {\n              this.postKey(keyInfo);\n            });\n          }\n          if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n            this.encryptionEnabled = data.enabled;\n          } else if (data.participantIdentity) {\n            const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n            if (!participant) {\n              throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n            }\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n          }\n          break;\n        case 'ratchetKey':\n          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.ratchetResult, data.participantIdentity, data.keyIndex);\n          break;\n        case 'decryptDataResponse':\n          const decryptFuture = this.decryptDataRequests.get(data.uuid);\n          if (decryptFuture === null || decryptFuture === void 0 ? void 0 : decryptFuture.resolve) {\n            decryptFuture.resolve(data);\n          }\n          break;\n        case 'encryptDataResponse':\n          const encryptFuture = this.encryptDataRequests.get(data.uuid);\n          if (encryptFuture === null || encryptFuture === void 0 ? void 0 : encryptFuture.resolve) {\n            encryptFuture.resolve(data);\n          }\n          break;\n      }\n    };\n    this.onWorkerError = ev => {\n      livekitLogger.error('e2ee worker encountered an error:', {\n        error: ev.error\n      });\n      this.emit(EncryptionEvent.EncryptionError, ev.error, undefined);\n    };\n    this.keyProvider = options.keyProvider;\n    this.worker = options.worker;\n    this.encryptionEnabled = false;\n    this.dataChannelEncryptionEnabled = dcEncryptionEnabled;\n  }\n  get isEnabled() {\n    return this.encryptionEnabled;\n  }\n  get isDataChannelEncryptionEnabled() {\n    return this.isEnabled && this.dataChannelEncryptionEnabled;\n  }\n  /**\n   * @internal\n   */\n  setup(room) {\n    if (!isE2EESupported()) {\n      throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\n    }\n    livekitLogger.info('setting up e2ee');\n    if (room !== this.room) {\n      this.room = room;\n      this.setupEventListeners(room, this.keyProvider);\n      // this.worker = new Worker('');\n      const msg = {\n        kind: 'init',\n        data: {\n          keyProviderOptions: this.keyProvider.getOptions(),\n          loglevel: workerLogger.getLevel()\n        }\n      };\n      if (this.worker) {\n        livekitLogger.info(\"initializing worker\", {\n          worker: this.worker\n        });\n        this.worker.onmessage = this.onWorkerMessage;\n        this.worker.onerror = this.onWorkerError;\n        this.worker.postMessage(msg);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  setParticipantCryptorEnabled(enabled, participantIdentity) {\n    livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n    this.postEnable(enabled, participantIdentity);\n  }\n  /**\n   * @internal\n   */\n  setSifTrailer(trailer) {\n    if (!trailer || trailer.length === 0) {\n      livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n    } else {\n      this.postSifTrailer(trailer);\n    }\n  }\n  setupEngine(engine) {\n    engine.on(EngineEvent.RTPVideoMapUpdate, rtpMap => {\n      this.postRTPMap(rtpMap);\n    });\n  }\n  setupEventListeners(room, keyProvider) {\n    room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n    room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Connected) {\n        room.remoteParticipants.forEach(participant => {\n          participant.trackPublications.forEach(pub => {\n            this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n          });\n        });\n      }\n    }).on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {\n      var _a;\n      const msg = {\n        kind: 'removeTransform',\n        data: {\n          participantIdentity: participant.identity,\n          trackId: track.mediaStreamID\n        }\n      };\n      (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n    }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {\n      this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n    }).on(RoomEvent.SignalConnected, () => {\n      if (!this.room) {\n        throw new TypeError(\"expected room to be present on signal connect\");\n      }\n      keyProvider.getKeys().forEach(keyInfo => {\n        this.postKey(keyInfo);\n      });\n      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n    });\n    room.localParticipant.on(ParticipantEvent.LocalSenderCreated, (sender, track) => __awaiter(this, void 0, void 0, function* () {\n      this.setupE2EESender(track, sender);\n    }));\n    room.localParticipant.on(ParticipantEvent.LocalTrackPublished, publication => {\n      // Safari doesn't support retrieving payload information on RTCEncodedVideoFrame, so we need to update the codec manually once we have the trackInfo from the server\n      if (!isVideoTrack(publication.track) || !isSafariBased()) {\n        return;\n      }\n      const msg = {\n        kind: 'updateCodec',\n        data: {\n          trackId: publication.track.mediaStreamID,\n          codec: mimeTypeToVideoCodecString(publication.trackInfo.codecs[0].mimeType),\n          participantIdentity: this.room.localParticipant.identity\n        }\n      };\n      this.worker.postMessage(msg);\n    });\n    keyProvider.on(KeyProviderEvent.SetKey, keyInfo => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));\n  }\n  encryptData(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.worker) {\n        throw Error('could not encrypt data, worker is missing');\n      }\n      const uuid = crypto.randomUUID();\n      const msg = {\n        kind: 'encryptDataRequest',\n        data: {\n          uuid,\n          payload: data,\n          participantIdentity: this.room.localParticipant.identity\n        }\n      };\n      const future = new Future();\n      future.onFinally = () => {\n        this.encryptDataRequests.delete(uuid);\n      };\n      this.encryptDataRequests.set(uuid, future);\n      this.worker.postMessage(msg);\n      return future.promise;\n    });\n  }\n  handleEncryptedData(payload, iv, participantIdentity, keyIndex) {\n    if (!this.worker) {\n      throw Error('could not handle encrypted data, worker is missing');\n    }\n    const uuid = crypto.randomUUID();\n    const msg = {\n      kind: 'decryptDataRequest',\n      data: {\n        uuid,\n        payload,\n        iv,\n        participantIdentity,\n        keyIndex\n      }\n    };\n    const future = new Future();\n    future.onFinally = () => {\n      this.decryptDataRequests.delete(uuid);\n    };\n    this.decryptDataRequests.set(uuid, future);\n    this.worker.postMessage(msg);\n    return future.promise;\n  }\n  postRatchetRequest(participantIdentity, keyIndex) {\n    if (!this.worker) {\n      throw Error('could not ratchet key, worker is missing');\n    }\n    const msg = {\n      kind: 'ratchetRequest',\n      data: {\n        participantIdentity: participantIdentity,\n        keyIndex\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postKey(_ref) {\n    let {\n      key,\n      participantIdentity,\n      keyIndex\n    } = _ref;\n    var _a;\n    if (!this.worker) {\n      throw Error('could not set key, worker is missing');\n    }\n    const msg = {\n      kind: 'setKey',\n      data: {\n        participantIdentity: participantIdentity,\n        isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n        key,\n        keyIndex\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postEnable(enabled, participantIdentity) {\n    if (this.worker) {\n      const enableMsg = {\n        kind: 'enable',\n        data: {\n          enabled,\n          participantIdentity\n        }\n      };\n      this.worker.postMessage(enableMsg);\n    } else {\n      throw new ReferenceError('failed to enable e2ee, worker is not ready');\n    }\n  }\n  postRTPMap(map) {\n    var _a;\n    if (!this.worker) {\n      throw TypeError('could not post rtp map, worker is missing');\n    }\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n      throw TypeError('could not post rtp map, local participant identity is missing');\n    }\n    const msg = {\n      kind: 'setRTPMap',\n      data: {\n        map,\n        participantIdentity: this.room.localParticipant.identity\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  postSifTrailer(trailer) {\n    if (!this.worker) {\n      throw Error('could not post SIF trailer, worker is missing');\n    }\n    const msg = {\n      kind: 'setSifTrailer',\n      data: {\n        trailer\n      }\n    };\n    this.worker.postMessage(msg);\n  }\n  setupE2EEReceiver(track, remoteId, trackInfo) {\n    if (!track.receiver) {\n      return;\n    }\n    if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\n      throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\n    }\n    this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n  }\n  setupE2EESender(track, sender) {\n    if (!isLocalTrack(track) || !sender) {\n      if (!sender) livekitLogger.warn('early return because sender is not ready');\n      return;\n    }\n    this.handleSender(sender, track.mediaStreamID, undefined);\n  }\n  /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */\n  handleReceiver(receiver, trackId, participantIdentity, codec) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.worker) {\n        return;\n      }\n      if (isScriptTransformSupported() &&\n      // Chrome occasionally throws an `InvalidState` error when using script transforms directly after introducing this API in 141.\n      // Disabling it for Chrome based browsers until the API has stabilized\n      !isChromiumBased()) {\n        const options = {\n          kind: 'decode',\n          participantIdentity,\n          trackId,\n          codec\n        };\n        // @ts-ignore\n        receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n      } else {\n        if (E2EE_FLAG in receiver && codec) {\n          // only update codec\n          const msg = {\n            kind: 'updateCodec',\n            data: {\n              trackId,\n              codec,\n              participantIdentity: participantIdentity\n            }\n          };\n          this.worker.postMessage(msg);\n          return;\n        }\n        // @ts-ignore\n        let writable = receiver.writableStream;\n        // @ts-ignore\n        let readable = receiver.readableStream;\n        if (!writable || !readable) {\n          // @ts-ignore\n          const receiverStreams = receiver.createEncodedStreams();\n          // @ts-ignore\n          receiver.writableStream = receiverStreams.writable;\n          writable = receiverStreams.writable;\n          // @ts-ignore\n          receiver.readableStream = receiverStreams.readable;\n          readable = receiverStreams.readable;\n        }\n        const msg = {\n          kind: 'decode',\n          data: {\n            readableStream: readable,\n            writableStream: writable,\n            trackId: trackId,\n            codec,\n            participantIdentity: participantIdentity,\n            isReuse: E2EE_FLAG in receiver\n          }\n        };\n        this.worker.postMessage(msg, [readable, writable]);\n      }\n      // @ts-ignore\n      receiver[E2EE_FLAG] = true;\n    });\n  }\n  /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */\n  handleSender(sender, trackId, codec) {\n    var _a;\n    if (E2EE_FLAG in sender || !this.worker) {\n      return;\n    }\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\n      throw TypeError('local identity needs to be known in order to set up encrypted sender');\n    }\n    if (isScriptTransformSupported() &&\n    // Chrome occasionally throws an `InvalidState` error when using script transforms directly after introducing this API in 141.\n    // Disabling it for Chrome based browsers until the API has stabilized\n    !isChromiumBased()) {\n      livekitLogger.info('initialize script transform');\n      const options = {\n        kind: 'encode',\n        participantIdentity: this.room.localParticipant.identity,\n        trackId,\n        codec\n      };\n      // @ts-ignore\n      sender.transform = new RTCRtpScriptTransform(this.worker, options);\n    } else {\n      livekitLogger.info('initialize encoded streams');\n      // @ts-ignore\n      const senderStreams = sender.createEncodedStreams();\n      const msg = {\n        kind: 'encode',\n        data: {\n          readableStream: senderStreams.readable,\n          writableStream: senderStreams.writable,\n          codec,\n          trackId,\n          participantIdentity: this.room.localParticipant.identity,\n          isReuse: false\n        }\n      };\n      this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);\n    }\n    // @ts-ignore\n    sender[E2EE_FLAG] = true;\n  }\n}const CONNECTION_BACKOFF_MIN_MS = 500;\nconst CONNECTION_BACKOFF_MAX_MS = 15000;\n/**\n * BackOffStrategy implements exponential backoff for connection failures.\n *\n * When severe connection failures occur (e.g., network issues, server unavailability),\n * this strategy introduces increasing delays between reconnection attempts to avoid\n * overwhelming the server and to give transient issues time to resolve.\n *\n * This strategy is only applied to LiveKit Cloud projects. It identifies\n * projects by extracting the project name from the connection URL and tracks failures\n * per project. Self-hosted deployments (URLs without a project identifier) are not\n * subject to backoff delays.\n *\n * The class is implemented as a singleton to maintain consistent backoff state across\n * the entire application lifecycle instead of room instance lifecycle.\n */\nclass BackOffStrategy {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  constructor() {\n    this.failedConnectionAttempts = new Map();\n    this.backOffPromises = new Map();\n  }\n  static getInstance() {\n    if (!this._instance) {\n      this._instance = new BackOffStrategy();\n    }\n    return this._instance;\n  }\n  addFailedConnectionAttempt(urlString) {\n    var _a;\n    const url = new URL(urlString);\n    const projectName = extractProjectFromUrl(url);\n    if (!projectName) {\n      return;\n    }\n    let failureCount = (_a = this.failedConnectionAttempts.get(projectName)) !== null && _a !== void 0 ? _a : 0;\n    this.failedConnectionAttempts.set(projectName, failureCount + 1);\n    this.backOffPromises.set(projectName, sleep(Math.min(CONNECTION_BACKOFF_MIN_MS * Math.pow(2, failureCount), CONNECTION_BACKOFF_MAX_MS)));\n  }\n  getBackOffPromise(urlString) {\n    const url = new URL(urlString);\n    const projectName = url && extractProjectFromUrl(url);\n    const backoffPromise = projectName && this.backOffPromises.get(projectName);\n    return backoffPromise || Promise.resolve();\n  }\n  resetFailedConnectionAttempts(urlString) {\n    const url = new URL(urlString);\n    const projectName = url && extractProjectFromUrl(url);\n    if (projectName) {\n      this.failedConnectionAttempts.set(projectName, 0);\n      this.backOffPromises.set(projectName, Promise.resolve());\n    }\n  }\n  resetAll() {\n    this.backOffPromises.clear();\n    this.failedConnectionAttempts.clear();\n  }\n}\nBackOffStrategy._instance = null;const defaultId = 'default';\nclass DeviceManager {\n  constructor() {\n    this._previousDevices = [];\n  }\n  static getInstance() {\n    if (this.instance === undefined) {\n      this.instance = new DeviceManager();\n    }\n    return this.instance;\n  }\n  get previousDevices() {\n    return this._previousDevices;\n  }\n  getDevices(kind_1) {\n    return __awaiter(this, arguments, void 0, function (kind) {\n      var _this = this;\n      let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a;\n        if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n          livekitLogger.debug('awaiting getUserMedia promise');\n          try {\n            if (kind) {\n              yield DeviceManager.userMediaPromiseMap.get(kind);\n            } else {\n              yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n            }\n          } catch (e) {\n            livekitLogger.warn('error waiting for media permissons');\n          }\n        }\n        let devices = yield navigator.mediaDevices.enumerateDevices();\n        if (requestPermissions &&\n        // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n        !(isSafari() && _this.hasDeviceInUse(kind))) {\n          const isDummyDeviceOrEmpty = devices.filter(d => d.kind === kind).length === 0 || devices.some(device => {\n            const noLabel = device.label === '';\n            const isRelevant = kind ? device.kind === kind : true;\n            return noLabel && isRelevant;\n          });\n          if (isDummyDeviceOrEmpty) {\n            const permissionsToAcquire = {\n              video: kind !== 'audioinput' && kind !== 'audiooutput',\n              audio: kind !== 'videoinput' && {\n                deviceId: {\n                  ideal: 'default'\n                }\n              }\n            };\n            const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n            devices = yield navigator.mediaDevices.enumerateDevices();\n            stream.getTracks().forEach(track => {\n              track.stop();\n            });\n          }\n        }\n        _this._previousDevices = devices;\n        if (kind) {\n          devices = devices.filter(device => device.kind === kind);\n        }\n        return devices;\n      }();\n    });\n  }\n  normalizeDeviceId(kind, deviceId, groupId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (deviceId !== defaultId) {\n        return deviceId;\n      }\n      // resolve actual device id if it's 'default': Chrome returns it when no\n      // device has been chosen\n      const devices = yield this.getDevices(kind);\n      const defaultDevice = devices.find(d => d.deviceId === defaultId);\n      if (!defaultDevice) {\n        livekitLogger.warn('could not reliably determine default device');\n        return undefined;\n      }\n      const device = devices.find(d => d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\n      if (!device) {\n        livekitLogger.warn('could not reliably determine default device');\n        return undefined;\n      }\n      return device === null || device === void 0 ? void 0 : device.deviceId;\n    });\n  }\n  hasDeviceInUse(kind) {\n    return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n  }\n}\nDeviceManager.mediaDeviceKinds = ['audioinput', 'audiooutput', 'videoinput'];\nDeviceManager.userMediaPromiseMap = new Map();var QueueTaskStatus;\n(function (QueueTaskStatus) {\n  QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n  QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n  QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n  constructor() {\n    this.pendingTasks = new Map();\n    this.taskMutex = new _();\n    this.nextTaskIndex = 0;\n  }\n  run(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskInfo = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(taskInfo.id, taskInfo);\n      const unlock = yield this.taskMutex.lock();\n      try {\n        taskInfo.executedAt = Date.now();\n        taskInfo.status = QueueTaskStatus.RUNNING;\n        return yield task();\n      } finally {\n        taskInfo.status = QueueTaskStatus.COMPLETED;\n        this.pendingTasks.delete(taskInfo.id);\n        unlock();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {}));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}/**\n * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) with [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)\n *\n * @see https://web.dev/websocketstream/\n */\nclass WebSocketStream {\n  get readyState() {\n    return this.ws.readyState;\n  }\n  constructor(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b;\n    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n      throw new DOMException('This operation was aborted', 'AbortError');\n    }\n    this.url = url;\n    const ws = new WebSocket(url, (_b = options.protocols) !== null && _b !== void 0 ? _b : []);\n    ws.binaryType = 'arraybuffer';\n    this.ws = ws;\n    const closeWithInfo = function () {\n      let {\n        closeCode: code,\n        reason\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return ws.close(code, reason);\n    };\n    this.opened = new Promise((resolve, reject) => {\n      ws.onopen = () => {\n        resolve({\n          readable: new ReadableStream({\n            start(controller) {\n              ws.onmessage = _ref => {\n                let {\n                  data\n                } = _ref;\n                return controller.enqueue(data);\n              };\n              ws.onerror = e => controller.error(e);\n            },\n            cancel: closeWithInfo\n          }),\n          writable: new WritableStream({\n            write(chunk) {\n              ws.send(chunk);\n            },\n            abort() {\n              ws.close();\n            },\n            close: closeWithInfo\n          }),\n          protocol: ws.protocol,\n          extensions: ws.extensions\n        });\n        ws.removeEventListener('error', reject);\n      };\n      ws.addEventListener('error', reject);\n    });\n    this.closed = new Promise((resolve, reject) => {\n      const rejectHandler = () => __awaiter(this, void 0, void 0, function* () {\n        const closePromise = new Promise(res => {\n          if (ws.readyState === WebSocket.CLOSED) return;else {\n            ws.addEventListener('close', closeEv => {\n              res(closeEv);\n            }, {\n              once: true\n            });\n          }\n        });\n        const reason = yield Promise.race([sleep(250), closePromise]);\n        if (!reason) {\n          reject(new Error('Encountered unspecified websocket error without a timely close event'));\n        } else {\n          // if we can infer the close reason from the close event then resolve the promise, we don't need to throw\n          resolve(reason);\n        }\n      });\n      ws.onclose = _ref2 => {\n        let {\n          code,\n          reason\n        } = _ref2;\n        resolve({\n          closeCode: code,\n          reason\n        });\n        ws.removeEventListener('error', rejectHandler);\n      };\n      ws.addEventListener('error', rejectHandler);\n    });\n    if (options.signal) {\n      options.signal.onabort = () => ws.close();\n    }\n    this.close = closeWithInfo;\n  }\n}const passThroughQueueSignals = ['syncState', 'trickle', 'offer', 'answer', 'simulate', 'leave'];\nfunction canPassThroughQueue(req) {\n  const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n  livekitLogger.trace('request allowed to bypass queue:', {\n    canPass,\n    req\n  });\n  return canPass;\n}\nvar SignalConnectionState;\n(function (SignalConnectionState) {\n  SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n  SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** specifies how much time (in ms) we allow for the ws to close its connection gracefully before continuing */\nconst MAX_WS_CLOSE_TIME = 250;\n/** @internal */\nclass SignalClient {\n  get currentState() {\n    return this.state;\n  }\n  get isDisconnected() {\n    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n  }\n  get isEstablishingConnection() {\n    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n  }\n  getNextRequestId() {\n    this._requestId += 1;\n    return this._requestId;\n  }\n  constructor() {\n    let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    /** signal rtt in milliseconds */\n    this.rtt = 0;\n    this.state = SignalConnectionState.DISCONNECTED;\n    this.log = livekitLogger;\n    this._requestId = 0;\n    /** @internal */\n    this.resetCallbacks = () => {\n      this.onAnswer = undefined;\n      this.onLeave = undefined;\n      this.onLocalTrackPublished = undefined;\n      this.onLocalTrackUnpublished = undefined;\n      this.onNegotiateRequested = undefined;\n      this.onOffer = undefined;\n      this.onRemoteMuteChanged = undefined;\n      this.onSubscribedQualityUpdate = undefined;\n      this.onTokenRefresh = undefined;\n      this.onTrickle = undefined;\n      this.onClose = undefined;\n      this.onMediaSectionsRequirement = undefined;\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n    this.loggerContextCb = loggerOptions.loggerContextCb;\n    this.useJSON = useJSON;\n    this.requestQueue = new AsyncQueue();\n    this.queuedRequests = [];\n    this.closingLock = new _();\n    this.connectionLock = new _();\n    this.state = SignalConnectionState.DISCONNECTED;\n  }\n  get logContext() {\n    var _a, _b;\n    return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // during a full reconnect, we'd want to start the sequence even if currently\n      // connected\n      this.state = SignalConnectionState.CONNECTING;\n      this.options = opts;\n      const res = yield this.connect(url, token, opts, abortSignal);\n      return res;\n    });\n  }\n  reconnect(url, token, sid, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) {\n        this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\n        return;\n      }\n      this.state = SignalConnectionState.RECONNECTING;\n      // clear ping interval and restart it once reconnected\n      this.clearPingInterval();\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n        reconnect: true,\n        sid,\n        reconnectReason: reason\n      }));\n      return res;\n    });\n  }\n  connect(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.connectionLock.lock();\n      this.connectOptions = opts;\n      const clientInfo = getClientInfo();\n      const params = opts.singlePeerConnection ? createJoinRequestConnectionParams(token, clientInfo, opts) : createConnectionParams(token, clientInfo, opts);\n      const rtcUrl = createRtcUrl(url, params);\n      const validateUrl = createValidateUrl(rtcUrl);\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n          let alreadyAborted = false;\n          const abortHandler = eventOrError => __awaiter(this, void 0, void 0, function* () {\n            if (alreadyAborted) {\n              return;\n            }\n            alreadyAborted = true;\n            const target = eventOrError instanceof Event ? eventOrError.currentTarget : eventOrError;\n            const reason = getAbortReasonAsString(target, 'Abort handler called');\n            // send leave if we have an active stream writer (connection is open)\n            if (this.streamWriter && !this.isDisconnected) {\n              this.sendLeave().then(() => this.close(reason)).catch(e => {\n                this.log.error(e);\n                this.close();\n              });\n            } else {\n              this.close();\n            }\n            cleanupAbortHandlers();\n            reject(ConnectionError.cancelled(reason));\n          });\n          abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\n          const cleanupAbortHandlers = () => {\n            clearTimeout(wsTimeout);\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n          };\n          const wsTimeout = setTimeout(() => {\n            abortHandler(ConnectionError.timeout('room connection has timed out (signal)'));\n          }, opts.websocketTimeout);\n          const handleSignalConnected = (connection, firstMessage) => {\n            this.handleSignalConnected(connection, wsTimeout, firstMessage);\n          };\n          const redactedUrl = new URL(rtcUrl);\n          if (redactedUrl.searchParams.has('access_token')) {\n            redactedUrl.searchParams.set('access_token', '<redacted>');\n          }\n          this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\n            reconnect: opts.reconnect,\n            reconnectReason: opts.reconnectReason\n          }, this.logContext));\n          if (this.ws) {\n            yield this.close(false);\n          }\n          this.ws = new WebSocketStream(rtcUrl);\n          try {\n            this.ws.closed.then(closeInfo => {\n              var _a;\n              if (this.isEstablishingConnection) {\n                reject(ConnectionError.internal(\"Websocket got closed during a (re)connection attempt: \".concat(closeInfo.reason)));\n              }\n              if (closeInfo.closeCode !== 1000) {\n                this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                  reason: closeInfo.reason,\n                  code: closeInfo.closeCode,\n                  wasClean: closeInfo.closeCode === 1000,\n                  state: this.state\n                }));\n                if (this.state === SignalConnectionState.CONNECTED) {\n                  this.handleOnClose((_a = closeInfo.reason) !== null && _a !== void 0 ? _a : 'Unexpected WS error');\n                }\n              }\n              return;\n            }).catch(reason => {\n              if (this.isEstablishingConnection) {\n                reject(ConnectionError.internal(\"Websocket error during a (re)connection attempt: \".concat(reason)));\n              }\n            });\n            const connection = yield this.ws.opened.catch(reason => __awaiter(this, void 0, void 0, function* () {\n              if (this.state !== SignalConnectionState.CONNECTED) {\n                this.state = SignalConnectionState.DISCONNECTED;\n                clearTimeout(wsTimeout);\n                const error = yield this.handleConnectionError(reason, validateUrl);\n                reject(error);\n                return;\n              }\n              // other errors, handle\n              this.handleWSError(reason);\n              reject(reason);\n              return;\n            }));\n            clearTimeout(wsTimeout);\n            if (!connection) {\n              return;\n            }\n            const signalReader = connection.readable.getReader();\n            this.streamWriter = connection.writable.getWriter();\n            const firstMessage = yield signalReader.read();\n            signalReader.releaseLock();\n            if (!firstMessage.value) {\n              throw ConnectionError.internal('no message received as first message');\n            }\n            const firstSignalResponse = parseSignalResponse(firstMessage.value);\n            // Validate the first message\n            const validation = this.validateFirstMessage(firstSignalResponse, (_a = opts.reconnect) !== null && _a !== void 0 ? _a : false);\n            if (!validation.isValid) {\n              reject(validation.error);\n              return;\n            }\n            // Handle join response - set up ping configuration\n            if (((_b = firstSignalResponse.message) === null || _b === void 0 ? void 0 : _b.case) === 'join') {\n              this.pingTimeoutDuration = firstSignalResponse.message.value.pingTimeout;\n              this.pingIntervalDuration = firstSignalResponse.message.value.pingInterval;\n              if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\n                  timeout: this.pingTimeoutDuration,\n                  interval: this.pingIntervalDuration\n                }));\n              }\n            }\n            // Handle successful connection\n            const firstMessageToProcess = validation.shouldProcessFirstMessage ? firstSignalResponse : undefined;\n            handleSignalConnected(connection, firstMessageToProcess);\n            resolve(validation.response);\n          } catch (e) {\n            reject(e);\n          } finally {\n            cleanupAbortHandlers();\n          }\n        } finally {\n          unlock();\n        }\n      }));\n    });\n  }\n  startReadingLoop(signalReader, firstMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (firstMessage) {\n        this.handleSignalResponse(firstMessage);\n      }\n      while (true) {\n        if (this.signalLatency) {\n          yield sleep(this.signalLatency);\n        }\n        const {\n          done,\n          value\n        } = yield signalReader.read();\n        if (done) {\n          break;\n        }\n        const resp = parseSignalResponse(value);\n        this.handleSignalResponse(resp);\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this = this;\n      let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Close method called on signal client';\n      return function* () {\n        if ([SignalConnectionState.DISCONNECTING || SignalConnectionState.DISCONNECTED].includes(_this.state)) {\n          _this.log.debug(\"ignoring signal close as it's already in disconnecting state\");\n          return;\n        }\n        const unlock = yield _this.closingLock.lock();\n        try {\n          _this.clearPingInterval();\n          if (updateState) {\n            _this.state = SignalConnectionState.DISCONNECTING;\n          }\n          if (_this.ws) {\n            _this.ws.close({\n              closeCode: 1000,\n              reason\n            });\n            // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n            const closePromise = _this.ws.closed;\n            _this.ws = undefined;\n            _this.streamWriter = undefined;\n            yield Promise.race([closePromise, sleep(MAX_WS_CLOSE_TIME)]);\n          }\n        } catch (e) {\n          _this.log.debug('websocket error while closing', Object.assign(Object.assign({}, _this.logContext), {\n            error: e\n          }));\n        } finally {\n          if (updateState) {\n            _this.state = SignalConnectionState.DISCONNECTED;\n          }\n          unlock();\n        }\n      }();\n    });\n  }\n  // initial offer after joining\n  sendOffer(offer, offerId) {\n    this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\n      offerSdp: offer.sdp\n    }));\n    this.sendRequest({\n      case: 'offer',\n      value: toProtoSessionDescription(offer, offerId)\n    });\n  }\n  // answer a server-initiated offer\n  sendAnswer(answer, offerId) {\n    this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\n      answerSdp: answer.sdp\n    }));\n    return this.sendRequest({\n      case: 'answer',\n      value: toProtoSessionDescription(answer, offerId)\n    });\n  }\n  sendIceCandidate(candidate, target) {\n    this.log.debug('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\n      candidate\n    }));\n    return this.sendRequest({\n      case: 'trickle',\n      value: new TrickleRequest({\n        candidateInit: JSON.stringify(candidate),\n        target\n      })\n    });\n  }\n  sendMuteTrack(trackSid, muted) {\n    return this.sendRequest({\n      case: 'mute',\n      value: new MuteTrackRequest({\n        sid: trackSid,\n        muted\n      })\n    });\n  }\n  sendAddTrack(req) {\n    return this.sendRequest({\n      case: 'addTrack',\n      value: req\n    });\n  }\n  sendUpdateLocalMetadata(metadata_1, name_1) {\n    return __awaiter(this, arguments, void 0, function (metadata, name) {\n      var _this2 = this;\n      let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return function* () {\n        const requestId = _this2.getNextRequestId();\n        yield _this2.sendRequest({\n          case: 'updateMetadata',\n          value: new UpdateParticipantMetadata({\n            requestId,\n            metadata,\n            name,\n            attributes\n          })\n        });\n        return requestId;\n      }();\n    });\n  }\n  sendUpdateTrackSettings(settings) {\n    this.sendRequest({\n      case: 'trackSetting',\n      value: settings\n    });\n  }\n  sendUpdateSubscription(sub) {\n    return this.sendRequest({\n      case: 'subscription',\n      value: sub\n    });\n  }\n  sendSyncState(sync) {\n    return this.sendRequest({\n      case: 'syncState',\n      value: sync\n    });\n  }\n  sendUpdateVideoLayers(trackSid, layers) {\n    return this.sendRequest({\n      case: 'updateLayers',\n      value: new UpdateVideoLayers({\n        trackSid,\n        layers\n      })\n    });\n  }\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n    return this.sendRequest({\n      case: 'subscriptionPermission',\n      value: new SubscriptionPermission({\n        allParticipants,\n        trackPermissions\n      })\n    });\n  }\n  sendSimulateScenario(scenario) {\n    return this.sendRequest({\n      case: 'simulate',\n      value: scenario\n    });\n  }\n  sendPing() {\n    /** send both of ping and pingReq for compatibility to old and new server */\n    return Promise.all([this.sendRequest({\n      case: 'ping',\n      value: protoInt64.parse(Date.now())\n    }), this.sendRequest({\n      case: 'pingReq',\n      value: new Ping({\n        timestamp: protoInt64.parse(Date.now()),\n        rtt: protoInt64.parse(this.rtt)\n      })\n    })]);\n  }\n  sendUpdateLocalAudioTrack(trackSid, features) {\n    return this.sendRequest({\n      case: 'updateAudioTrack',\n      value: new UpdateLocalAudioTrack({\n        trackSid,\n        features\n      })\n    });\n  }\n  sendLeave() {\n    return this.sendRequest({\n      case: 'leave',\n      value: new LeaveRequest({\n        reason: DisconnectReason.CLIENT_INITIATED,\n        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\n        action: LeaveRequest_Action.DISCONNECT\n      })\n    });\n  }\n  sendRequest(message_1) {\n    return __awaiter(this, arguments, void 0, function (message) {\n      var _this3 = this;\n      let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return function* () {\n        // capture all requests while reconnecting and put them in a queue\n        // unless the request originates from the queue, then don't enqueue again\n        const canQueue = !fromQueue && !canPassThroughQueue(message);\n        if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\n          _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {\n            yield this.sendRequest(message, true);\n          }));\n          return;\n        }\n        // make sure previously queued requests are being sent first\n        if (!fromQueue) {\n          yield _this3.requestQueue.flush();\n        }\n        if (_this3.signalLatency) {\n          yield sleep(_this3.signalLatency);\n        }\n        if (_this3.isDisconnected) {\n          // Skip requests if the signal layer is disconnected\n          // This can happen if an event is sent in the mist of room.connect() initializing\n          _this3.log.debug(\"skipping signal request (type: \".concat(message.case, \") - SignalClient disconnected\"));\n          return;\n        }\n        if (!_this3.streamWriter) {\n          _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\n          return;\n        }\n        const req = new SignalRequest({\n          message\n        });\n        try {\n          if (_this3.useJSON) {\n            yield _this3.streamWriter.write(req.toJsonString());\n          } else {\n            yield _this3.streamWriter.write(req.toBinary());\n          }\n        } catch (e) {\n          _this3.log.error('error sending signal message', Object.assign(Object.assign({}, _this3.logContext), {\n            error: e\n          }));\n        }\n      }();\n    });\n  }\n  handleSignalResponse(res) {\n    var _a, _b;\n    const msg = res.message;\n    if (msg == undefined) {\n      this.log.debug('received unsupported message', this.logContext);\n      return;\n    }\n    let pingHandled = false;\n    if (msg.case === 'answer') {\n      const sd = fromProtoSessionDescription(msg.value);\n      if (this.onAnswer) {\n        this.onAnswer(sd, msg.value.id, msg.value.midToTrackId);\n      }\n    } else if (msg.case === 'offer') {\n      const sd = fromProtoSessionDescription(msg.value);\n      if (this.onOffer) {\n        this.onOffer(sd, msg.value.id, msg.value.midToTrackId);\n      }\n    } else if (msg.case === 'trickle') {\n      const candidate = JSON.parse(msg.value.candidateInit);\n      if (this.onTrickle) {\n        this.onTrickle(candidate, msg.value.target);\n      }\n    } else if (msg.case === 'update') {\n      if (this.onParticipantUpdate) {\n        this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n      }\n    } else if (msg.case === 'trackPublished') {\n      if (this.onLocalTrackPublished) {\n        this.onLocalTrackPublished(msg.value);\n      }\n    } else if (msg.case === 'speakersChanged') {\n      if (this.onSpeakersChanged) {\n        this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n      }\n    } else if (msg.case === 'leave') {\n      if (this.onLeave) {\n        this.onLeave(msg.value);\n      }\n    } else if (msg.case === 'mute') {\n      if (this.onRemoteMuteChanged) {\n        this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n      }\n    } else if (msg.case === 'roomUpdate') {\n      if (this.onRoomUpdate && msg.value.room) {\n        this.onRoomUpdate(msg.value.room);\n      }\n    } else if (msg.case === 'connectionQuality') {\n      if (this.onConnectionQuality) {\n        this.onConnectionQuality(msg.value);\n      }\n    } else if (msg.case === 'streamStateUpdate') {\n      if (this.onStreamStateUpdate) {\n        this.onStreamStateUpdate(msg.value);\n      }\n    } else if (msg.case === 'subscribedQualityUpdate') {\n      if (this.onSubscribedQualityUpdate) {\n        this.onSubscribedQualityUpdate(msg.value);\n      }\n    } else if (msg.case === 'subscriptionPermissionUpdate') {\n      if (this.onSubscriptionPermissionUpdate) {\n        this.onSubscriptionPermissionUpdate(msg.value);\n      }\n    } else if (msg.case === 'refreshToken') {\n      if (this.onTokenRefresh) {\n        this.onTokenRefresh(msg.value);\n      }\n    } else if (msg.case === 'trackUnpublished') {\n      if (this.onLocalTrackUnpublished) {\n        this.onLocalTrackUnpublished(msg.value);\n      }\n    } else if (msg.case === 'subscriptionResponse') {\n      if (this.onSubscriptionError) {\n        this.onSubscriptionError(msg.value);\n      }\n    } else if (msg.case === 'pong') ; else if (msg.case === 'pongResp') {\n      this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n      this.resetPingTimeout();\n      pingHandled = true;\n    } else if (msg.case === 'requestResponse') {\n      if (this.onRequestResponse) {\n        this.onRequestResponse(msg.value);\n      }\n    } else if (msg.case === 'trackSubscribed') {\n      if (this.onLocalTrackSubscribed) {\n        this.onLocalTrackSubscribed(msg.value.trackSid);\n      }\n    } else if (msg.case === 'roomMoved') {\n      if (this.onTokenRefresh) {\n        this.onTokenRefresh(msg.value.token);\n      }\n      if (this.onRoomMoved) {\n        this.onRoomMoved(msg.value);\n      }\n    } else if (msg.case === 'mediaSectionsRequirement') {\n      if (this.onMediaSectionsRequirement) {\n        this.onMediaSectionsRequirement(msg.value);\n      }\n    } else {\n      this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\n        msgCase: msg.case\n      }));\n    }\n    if (!pingHandled) {\n      this.resetPingTimeout();\n    }\n  }\n  setReconnected() {\n    while (this.queuedRequests.length > 0) {\n      const req = this.queuedRequests.shift();\n      if (req) {\n        this.requestQueue.run(req);\n      }\n    }\n  }\n  handleOnClose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === SignalConnectionState.DISCONNECTED) return;\n      const onCloseCallback = this.onClose;\n      yield this.close(undefined, reason);\n      this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n        reason\n      }));\n      if (onCloseCallback) {\n        onCloseCallback(reason);\n      }\n    });\n  }\n  handleWSError(error) {\n    this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\n      error\n    }));\n  }\n  /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */\n  resetPingTimeout() {\n    this.clearPingTimeout();\n    if (!this.pingTimeoutDuration) {\n      this.log.warn('ping timeout duration not set', this.logContext);\n      return;\n    }\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\n      this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n      this.handleOnClose('ping timeout');\n    }, this.pingTimeoutDuration * 1000);\n  }\n  /**\n   * Clears ping timeout (does not start a new timeout)\n   */\n  clearPingTimeout() {\n    if (this.pingTimeout) {\n      CriticalTimers.clearTimeout(this.pingTimeout);\n    }\n  }\n  startPingInterval() {\n    this.clearPingInterval();\n    this.resetPingTimeout();\n    if (!this.pingIntervalDuration) {\n      this.log.warn('ping interval duration not set', this.logContext);\n      return;\n    }\n    this.log.debug('start ping interval', this.logContext);\n    this.pingInterval = CriticalTimers.setInterval(() => {\n      this.sendPing();\n    }, this.pingIntervalDuration * 1000);\n  }\n  clearPingInterval() {\n    this.log.debug('clearing ping interval', this.logContext);\n    this.clearPingTimeout();\n    if (this.pingInterval) {\n      CriticalTimers.clearInterval(this.pingInterval);\n    }\n  }\n  /**\n   * Handles the successful connection to the signal server\n   * @param connection The WebSocket connection\n   * @param timeoutHandle The timeout handle to clear\n   * @param firstMessage Optional first message to process\n   * @internal\n   */\n  handleSignalConnected(connection, timeoutHandle, firstMessage) {\n    this.state = SignalConnectionState.CONNECTED;\n    clearTimeout(timeoutHandle);\n    this.startPingInterval();\n    this.startReadingLoop(connection.readable.getReader(), firstMessage);\n  }\n  /**\n   * Validates the first message received from the signal server\n   * @param firstSignalResponse The first signal response received\n   * @param isReconnect Whether this is a reconnection attempt\n   * @returns Validation result with response or error\n   * @internal\n   */\n  validateFirstMessage(firstSignalResponse, isReconnect) {\n    var _a, _b, _c, _d, _e;\n    if (((_a = firstSignalResponse.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\n      return {\n        isValid: true,\n        response: firstSignalResponse.message.value\n      };\n    } else if (this.state === SignalConnectionState.RECONNECTING && ((_b = firstSignalResponse.message) === null || _b === void 0 ? void 0 : _b.case) !== 'leave') {\n      if (((_c = firstSignalResponse.message) === null || _c === void 0 ? void 0 : _c.case) === 'reconnect') {\n        return {\n          isValid: true,\n          response: firstSignalResponse.message.value\n        };\n      } else {\n        // in reconnecting, any message received means signal reconnected and we still need to process it\n        this.log.debug('declaring signal reconnected without reconnect response received', this.logContext);\n        return {\n          isValid: true,\n          response: undefined,\n          shouldProcessFirstMessage: true\n        };\n      }\n    } else if (this.isEstablishingConnection && ((_d = firstSignalResponse.message) === null || _d === void 0 ? void 0 : _d.case) === 'leave') {\n      return {\n        isValid: false,\n        error: ConnectionError.leaveRequest('Received leave request while trying to (re)connect', firstSignalResponse.message.value.reason)\n      };\n    } else if (!isReconnect) {\n      // non-reconnect case, should receive join response first\n      return {\n        isValid: false,\n        error: ConnectionError.internal(\"did not receive join response, got \".concat((_e = firstSignalResponse.message) === null || _e === void 0 ? void 0 : _e.case, \" instead\"))\n      };\n    }\n    return {\n      isValid: false,\n      error: ConnectionError.internal('Unexpected first message')\n    };\n  }\n  /**\n   * Handles WebSocket connection errors by validating with the server\n   * @param reason The error that occurred\n   * @param validateUrl The URL to validate the connection with\n   * @returns A ConnectionError with appropriate reason and status\n   * @internal\n   */\n  handleConnectionError(reason, validateUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const resp = yield fetch(validateUrl);\n        if (resp.status.toFixed(0).startsWith('4')) {\n          const msg = yield resp.text();\n          return ConnectionError.notAllowed(msg, resp.status);\n        } else if (reason instanceof ConnectionError) {\n          return reason;\n        } else {\n          return ConnectionError.internal(\"Encountered unknown websocket error during connection: \".concat(reason), {\n            status: resp.status,\n            statusText: resp.statusText\n          });\n        }\n      } catch (e) {\n        return e instanceof ConnectionError ? e : ConnectionError.serverUnreachable(e instanceof Error ? e.message : 'server was not reachable');\n      }\n    });\n  }\n}\nfunction fromProtoSessionDescription(sd) {\n  const rsd = {\n    type: 'offer',\n    sdp: sd.sdp\n  };\n  switch (sd.type) {\n    case 'answer':\n    case 'offer':\n    case 'pranswer':\n    case 'rollback':\n      rsd.type = sd.type;\n      break;\n  }\n  return rsd;\n}\nfunction toProtoSessionDescription(rsd, id) {\n  const sd = new SessionDescription({\n    sdp: rsd.sdp,\n    type: rsd.type,\n    id\n  });\n  return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n  var _a;\n  const params = new URLSearchParams();\n  params.set('access_token', token);\n  // opts\n  if (opts.reconnect) {\n    params.set('reconnect', '1');\n    if (opts.sid) {\n      params.set('sid', opts.sid);\n    }\n  }\n  params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\n  // ClientInfo\n  params.set('sdk', isReactNative() ? 'reactnative' : 'js');\n  params.set('version', info.version);\n  params.set('protocol', info.protocol.toString());\n  if (info.deviceModel) {\n    params.set('device_model', info.deviceModel);\n  }\n  if (info.os) {\n    params.set('os', info.os);\n  }\n  if (info.osVersion) {\n    params.set('os_version', info.osVersion);\n  }\n  if (info.browser) {\n    params.set('browser', info.browser);\n  }\n  if (info.browserVersion) {\n    params.set('browser_version', info.browserVersion);\n  }\n  if (opts.adaptiveStream) {\n    params.set('adaptive_stream', '1');\n  }\n  if (opts.reconnectReason) {\n    params.set('reconnect_reason', opts.reconnectReason.toString());\n  }\n  // @ts-ignore\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n    // @ts-ignore\n    params.set('network', navigator.connection.type);\n  }\n  return params;\n}\nfunction createJoinRequestConnectionParams(token, info, opts) {\n  const params = new URLSearchParams();\n  params.set('access_token', token);\n  const joinRequest = new JoinRequest({\n    clientInfo: info,\n    connectionSettings: new ConnectionSettings({\n      autoSubscribe: !!opts.autoSubscribe,\n      adaptiveStream: !!opts.adaptiveStream\n    }),\n    reconnect: !!opts.reconnect,\n    participantSid: opts.sid ? opts.sid : undefined\n  });\n  if (opts.reconnectReason) {\n    joinRequest.reconnectReason = opts.reconnectReason;\n  }\n  const wrappedJoinRequest = new WrappedJoinRequest({\n    joinRequest: joinRequest.toBinary()\n  });\n  params.set('join_request', btoa(new TextDecoder('utf-8').decode(wrappedJoinRequest.toBinary())));\n  return params;\n}class DataPacketBuffer {\n  constructor() {\n    this.buffer = [];\n    this._totalSize = 0;\n  }\n  push(item) {\n    this.buffer.push(item);\n    this._totalSize += item.data.byteLength;\n  }\n  pop() {\n    const item = this.buffer.shift();\n    if (item) {\n      this._totalSize -= item.data.byteLength;\n    }\n    return item;\n  }\n  getAll() {\n    return this.buffer.slice();\n  }\n  popToSequence(sequence) {\n    while (this.buffer.length > 0) {\n      const first = this.buffer[0];\n      if (first.sequence <= sequence) {\n        this.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  alignBufferedAmount(bufferedAmount) {\n    while (this.buffer.length > 0) {\n      const first = this.buffer[0];\n      if (this._totalSize - first.data.byteLength <= bufferedAmount) {\n        break;\n      }\n      this.pop();\n    }\n  }\n  get length() {\n    return this.buffer.length;\n  }\n}class TTLMap {\n  /**\n   * @param ttl ttl of the key (ms)\n   */\n  constructor(ttl) {\n    this._map = new Map();\n    this._lastCleanup = 0;\n    this.ttl = ttl;\n  }\n  set(key, value) {\n    const now = Date.now();\n    if (now - this._lastCleanup > this.ttl / 2) {\n      this.cleanup();\n    }\n    const expiresAt = now + this.ttl;\n    this._map.set(key, {\n      value,\n      expiresAt\n    });\n    return this;\n  }\n  get(key) {\n    const entry = this._map.get(key);\n    if (!entry) return undefined;\n    if (entry.expiresAt < Date.now()) {\n      this._map.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n  has(key) {\n    const entry = this._map.get(key);\n    if (!entry) return false;\n    if (entry.expiresAt < Date.now()) {\n      this._map.delete(key);\n      return false;\n    }\n    return true;\n  }\n  delete(key) {\n    return this._map.delete(key);\n  }\n  clear() {\n    this._map.clear();\n  }\n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this._map.entries()) {\n      if (entry.expiresAt < now) {\n        this._map.delete(key);\n      }\n    }\n    this._lastCleanup = now;\n  }\n  get size() {\n    this.cleanup();\n    return this._map.size;\n  }\n  forEach(callback) {\n    this.cleanup();\n    for (const [key, entry] of this._map.entries()) {\n      if (entry.expiresAt >= Date.now()) {\n        callback(entry.value, key, this.asValueMap());\n      }\n    }\n  }\n  map(callback) {\n    this.cleanup();\n    const result = [];\n    const valueMap = this.asValueMap();\n    for (const [key, value] of valueMap.entries()) {\n      result.push(callback(value, key, valueMap));\n    }\n    return result;\n  }\n  asValueMap() {\n    const result = new Map();\n    for (const [key, entry] of this._map.entries()) {\n      if (entry.expiresAt >= Date.now()) {\n        result.set(key, entry.value);\n      }\n    }\n    return result;\n  }\n}var lib = {};var parser = {};var grammar = {exports: {}};var hasRequiredGrammar;\nfunction requireGrammar() {\n  if (hasRequiredGrammar) return grammar.exports;\n  hasRequiredGrammar = 1;\n  var grammar$1 = grammar.exports = {\n    v: [{\n      name: 'version',\n      reg: /^(\\d*)$/\n    }],\n    o: [{\n      // o=- 20518 0 IN IP4 203.0.113.1\n      // NB: sessionId will be a String in most cases because it is huge\n      name: 'origin',\n      reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n      names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n      format: '%s %s %d %s IP%d %s'\n    }],\n    // default parsing of these only (though some of these feel outdated)\n    s: [{\n      name: 'name'\n    }],\n    i: [{\n      name: 'description'\n    }],\n    u: [{\n      name: 'uri'\n    }],\n    e: [{\n      name: 'email'\n    }],\n    p: [{\n      name: 'phone'\n    }],\n    z: [{\n      name: 'timezones'\n    }],\n    // TODO: this one can actually be parsed properly...\n    r: [{\n      name: 'repeats'\n    }],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [{\n      // t=0 0\n      name: 'timing',\n      reg: /^(\\d*) (\\d*)/,\n      names: ['start', 'stop'],\n      format: '%d %d'\n    }],\n    c: [{\n      // c=IN IP4 10.47.197.26\n      name: 'connection',\n      reg: /^IN IP(\\d) (\\S*)/,\n      names: ['version', 'ip'],\n      format: 'IN IP%d %s'\n    }],\n    b: [{\n      // b=AS:4000\n      push: 'bandwidth',\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n      names: ['type', 'limit'],\n      format: '%s:%s'\n    }],\n    m: [{\n      // m=video 51744 RTP/AVP 126 97 98 34 31\n      // NB: special - pushes to session\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\n      reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n      names: ['type', 'port', 'protocol', 'payloads'],\n      format: '%s %d %s %s'\n    }],\n    a: [{\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n      }\n    }, {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    }, {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    }, {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n      }\n    }, {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    }, {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n      }\n    }, {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    }, {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    }, {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n      }\n    }, {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    }, {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    }, {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    }, {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    }, {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    }, {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    }, {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    }, {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    }, {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    }, {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    }, {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    }, {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push: 'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n        str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += o.tcptype != null ? ' tcptype %s' : '%v';\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n        str += o['network-id'] != null ? ' network-id %d' : '%v';\n        str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n        return str;\n      }\n    }, {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    }, {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    }, {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    }, {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    }, {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    }, {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    }, {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    }, {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    }, {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    }, {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n      }\n    }, {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    }, {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    }, {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n      // a=imageattr:97\n      '^imageattr:(\\\\d+|\\\\*)' +\n      // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n      '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n      // recv [x=330,y=250]\n      '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    }, {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n      // a=simulcast:\n      '^simulcast:' +\n      // send 1,2,3;~4,~5\n      '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n      // space + recv 6;~7,~8\n      '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n      // end\n      '$'),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    }, {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    }, {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    }, {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    }, {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    }, {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    }, {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    }, {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    }, {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push: 'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    }, {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name: 'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += o.id != null ? 'id=%s %s' : '%v%s';\n        str += o.mediaClockValue != null ? '=%s' : '';\n        str += o.rateNumerator != null ? ' rate=%s' : '';\n        str += o.rateDenominator != null ? '/%s' : '';\n        return str;\n      }\n    }, {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    }, {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    }, {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    }, {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    }, {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    }, {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }]\n  };\n\n  // set sensible defaults to avoid polluting the grammar with boring details\n  Object.keys(grammar$1).forEach(function (key) {\n    var objs = grammar$1[key];\n    objs.forEach(function (obj) {\n      if (!obj.reg) {\n        obj.reg = /(.*)/;\n      }\n      if (!obj.format) {\n        obj.format = '%s';\n      }\n    });\n  });\n  return grammar.exports;\n}var hasRequiredParser;\nfunction requireParser() {\n  if (hasRequiredParser) return parser;\n  hasRequiredParser = 1;\n  (function (exports$1) {\n    var toIntIfInt = function (v) {\n      return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function (match, location, names, rawName) {\n      if (rawName && !names) {\n        location[rawName] = toIntIfInt(match[1]);\n      } else {\n        for (var i = 0; i < names.length; i += 1) {\n          if (match[i + 1] != null) {\n            location[names[i]] = toIntIfInt(match[i + 1]);\n          }\n        }\n      }\n    };\n    var parseReg = function (obj, location, content) {\n      var needsBlank = obj.name && obj.names;\n      if (obj.push && !location[obj.push]) {\n        location[obj.push] = [];\n      } else if (needsBlank && !location[obj.name]) {\n        location[obj.name] = {};\n      }\n      var keyLocation = obj.push ? {} :\n      // blank object that will be pushed\n      needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n      if (obj.push) {\n        location[obj.push].push(keyLocation);\n      }\n    };\n    var grammar = requireGrammar();\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports$1.parse = function (sdp) {\n      var session = {},\n        media = [],\n        location = session; // points at where properties go under (one of the above)\n\n      // parse lines we understand\n      sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n        var type = l[0];\n        var content = l.slice(2);\n        if (type === 'm') {\n          media.push({\n            rtp: [],\n            fmtp: []\n          });\n          location = media[media.length - 1]; // point at latest media line\n        }\n        for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n          var obj = grammar[type][j];\n          if (obj.reg.test(content)) {\n            return parseReg(obj, location, content);\n          }\n        }\n      });\n      session.media = media; // link it up\n      return session;\n    };\n    var paramReducer = function (acc, expr) {\n      var s = expr.split(/=(.+)/, 2);\n      if (s.length === 2) {\n        acc[s[0]] = toIntIfInt(s[1]);\n      } else if (s.length === 1 && expr.length > 1) {\n        acc[s[0]] = undefined;\n      }\n      return acc;\n    };\n    exports$1.parseParams = function (str) {\n      return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports$1.parseFmtpConfig = exports$1.parseParams;\n    exports$1.parsePayloads = function (str) {\n      return str.toString().split(' ').map(Number);\n    };\n    exports$1.parseRemoteCandidates = function (str) {\n      var candidates = [];\n      var parts = str.split(' ').map(toIntIfInt);\n      for (var i = 0; i < parts.length; i += 3) {\n        candidates.push({\n          component: parts[i],\n          ip: parts[i + 1],\n          port: parts[i + 2]\n        });\n      }\n      return candidates;\n    };\n    exports$1.parseImageAttributes = function (str) {\n      return str.split(' ').map(function (item) {\n        return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n      });\n    };\n    exports$1.parseSimulcastStreamList = function (str) {\n      return str.split(';').map(function (stream) {\n        return stream.split(',').map(function (format) {\n          var scid,\n            paused = false;\n          if (format[0] !== '~') {\n            scid = toIntIfInt(format);\n          } else {\n            scid = toIntIfInt(format.substring(1, format.length));\n            paused = true;\n          }\n          return {\n            scid: scid,\n            paused: paused\n          };\n        });\n      });\n    };\n  })(parser);\n  return parser;\n}var writer;\nvar hasRequiredWriter;\nfunction requireWriter() {\n  if (hasRequiredWriter) return writer;\n  hasRequiredWriter = 1;\n  var grammar = requireGrammar();\n\n  // customized util.format - discards excess arguments and can void middle ones\n  var formatRegExp = /%[sdv%]/g;\n  var format = function (formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function (x) {\n      if (i >= len) {\n        return x; // missing argument\n      }\n      var arg = args[i];\n      i += 1;\n      switch (x) {\n        case '%%':\n          return '%';\n        case '%s':\n          return String(arg);\n        case '%d':\n          return Number(arg);\n        case '%v':\n          return '';\n      }\n    });\n    // NB: we discard excess arguments - they are typically undefined from makeLine\n  };\n  var makeLine = function (type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [type + '=' + str];\n    if (obj.names) {\n      for (var i = 0; i < obj.names.length; i += 1) {\n        var n = obj.names[i];\n        if (obj.name) {\n          args.push(location[obj.name][n]);\n        } else {\n          // for mLine and push attributes\n          args.push(location[obj.names[i]]);\n        }\n      }\n    } else {\n      args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n  };\n\n  // RFC specified order\n  // TODO: extend this with all the rest\n  var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\n  var defaultInnerOrder = ['i', 'c', 'b', 'a'];\n  writer = function (session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n      session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n      session.name = ' '; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function (mLine) {\n      if (mLine.payloads == null) {\n        mLine.payloads = '';\n      }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in session && session[obj.name] != null) {\n          sdp.push(makeLine(type, obj, session));\n        } else if (obj.push in session && session[obj.push] != null) {\n          session[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function (mLine) {\n      sdp.push(makeLine('m', grammar.m[0], mLine));\n      innerOrder.forEach(function (type) {\n        grammar[type].forEach(function (obj) {\n          if (obj.name in mLine && mLine[obj.name] != null) {\n            sdp.push(makeLine(type, obj, mLine));\n          } else if (obj.push in mLine && mLine[obj.push] != null) {\n            mLine[obj.push].forEach(function (el) {\n              sdp.push(makeLine(type, obj, el));\n            });\n          }\n        });\n      });\n    });\n    return sdp.join('\\r\\n') + '\\r\\n';\n  };\n  return writer;\n}var hasRequiredLib;\nfunction requireLib() {\n  if (hasRequiredLib) return lib;\n  hasRequiredLib = 1;\n  var parser = requireParser();\n  var writer = requireWriter();\n  var grammar = requireGrammar();\n  lib.grammar = grammar;\n  lib.write = writer;\n  lib.parse = parser.parse;\n  lib.parseParams = parser.parseParams;\n  lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n  lib.parsePayloads = parser.parsePayloads;\n  lib.parseRemoteCandidates = parser.parseRemoteCandidates;\n  lib.parseImageAttributes = parser.parseImageAttributes;\n  lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n  return lib;\n}var libExports = requireLib();function r(r, e, n) {\n  var i, t, o;\n  void 0 === e && (e = 50), void 0 === n && (n = {});\n  var a = null != (i = n.isImmediate) && i,\n    u = null != (t = n.callback) && t,\n    c = n.maxWait,\n    v = Date.now(),\n    l = [];\n  function f() {\n    if (void 0 !== c) {\n      var r = Date.now() - v;\n      if (r + e >= c) return c - r;\n    }\n    return e;\n  }\n  var d = function () {\n    var e = [].slice.call(arguments),\n      n = this;\n    return new Promise(function (i, t) {\n      var c = a && void 0 === o;\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function () {\n        if (o = void 0, v = Date.now(), !a) {\n          var i = r.apply(n, e);\n          u && u(i), l.forEach(function (r) {\n            return (0, r.resolve)(i);\n          }), l = [];\n        }\n      }, f()), c) {\n        var d = r.apply(n, e);\n        return u && u(d), i(d);\n      }\n      l.push({\n        resolve: i,\n        reject: t\n      });\n    });\n  };\n  return d.cancel = function (r) {\n    void 0 !== o && clearTimeout(o), l.forEach(function (e) {\n      return (0, e.reject)(r);\n    }), l = [];\n  }, d;\n}/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/\nconst startBitrateForSVC = 0.7;\nconst debounceInterval = 20;\nconst PCEvents = {\n  NegotiationStarted: 'negotiationStarted',\n  NegotiationComplete: 'negotiationComplete',\n  RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\n};\n/** @internal */\nclass PCTransport extends eventsExports.EventEmitter {\n  get pc() {\n    if (!this._pc) {\n      this._pc = this.createPC();\n    }\n    return this._pc;\n  }\n  constructor(config) {\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    super();\n    this.log = livekitLogger;\n    this.ddExtID = 0;\n    this.latestOfferId = 0;\n    this.pendingCandidates = [];\n    this.restartingIce = false;\n    this.renegotiate = false;\n    this.trackBitrates = [];\n    this.remoteStereoMids = [];\n    this.remoteNackMids = [];\n    // debounced negotiate interface\n    this.negotiate = r(onError => __awaiter(this, void 0, void 0, function* () {\n      this.emit(PCEvents.NegotiationStarted);\n      try {\n        yield this.createAndSendOffer();\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          throw e;\n        }\n      }\n    }), debounceInterval);\n    this.close = () => {\n      if (!this._pc) {\n        return;\n      }\n      this._pc.close();\n      this._pc.onconnectionstatechange = null;\n      this._pc.oniceconnectionstatechange = null;\n      this._pc.onicegatheringstatechange = null;\n      this._pc.ondatachannel = null;\n      this._pc.onnegotiationneeded = null;\n      this._pc.onsignalingstatechange = null;\n      this._pc.onicecandidate = null;\n      this._pc.ondatachannel = null;\n      this._pc.ontrack = null;\n      this._pc.onconnectionstatechange = null;\n      this._pc.oniceconnectionstatechange = null;\n      this._pc = null;\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n    this.loggerOptions = loggerOptions;\n    this.config = config;\n    this._pc = this.createPC();\n    this.offerLock = new _();\n  }\n  createPC() {\n    const pc = new RTCPeerConnection(this.config);\n    pc.onicecandidate = ev => {\n      var _a;\n      if (!ev.candidate) return;\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n    };\n    pc.onicecandidateerror = ev => {\n      var _a;\n      (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    pc.oniceconnectionstatechange = () => {\n      var _a;\n      (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n    };\n    pc.onsignalingstatechange = () => {\n      var _a;\n      (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n    };\n    pc.onconnectionstatechange = () => {\n      var _a;\n      (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n    };\n    pc.ondatachannel = ev => {\n      var _a;\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    pc.ontrack = ev => {\n      var _a;\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    return pc;\n  }\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  get isICEConnected() {\n    return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\n  }\n  addIceCandidate(candidate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pc.remoteDescription && !this.restartingIce) {\n        return this.pc.addIceCandidate(candidate);\n      }\n      this.pendingCandidates.push(candidate);\n    });\n  }\n  setRemoteDescription(sd, offerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (sd.type === 'answer' && this.latestOfferId > 0 && offerId > 0 && offerId !== this.latestOfferId) {\n        this.log.warn('ignoring answer for old offer', Object.assign(Object.assign({}, this.logContext), {\n          offerId,\n          latestOfferId: this.latestOfferId\n        }));\n        return false;\n      }\n      let mungedSDP = undefined;\n      if (sd.type === 'offer') {\n        let {\n          stereoMids,\n          nackMids\n        } = extractStereoAndNackAudioFromOffer(sd);\n        this.remoteStereoMids = stereoMids;\n        this.remoteNackMids = nackMids;\n      } else if (sd.type === 'answer') {\n        const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\n        sdpParsed.media.forEach(media => {\n          const mid = getMidString(media.mid);\n          if (media.type === 'audio') {\n            // munge sdp for opus bitrate settings\n            this.trackBitrates.some(trackbr => {\n              if (!trackbr.transceiver || mid != trackbr.transceiver.mid) {\n                return false;\n              }\n              let codecPayload = 0;\n              media.rtp.some(rtp => {\n                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                  codecPayload = rtp.payload;\n                  return true;\n                }\n                return false;\n              });\n              if (codecPayload === 0) {\n                return true;\n              }\n              let fmtpFound = false;\n              for (const fmtp of media.fmtp) {\n                if (fmtp.payload === codecPayload) {\n                  fmtp.config = fmtp.config.split(';').filter(attr => !attr.includes('maxaveragebitrate')).join(';');\n                  if (trackbr.maxbr > 0) {\n                    fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                  }\n                  fmtpFound = true;\n                  break;\n                }\n              }\n              if (!fmtpFound) {\n                if (trackbr.maxbr > 0) {\n                  media.fmtp.push({\n                    payload: codecPayload,\n                    config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                  });\n                }\n              }\n              return true;\n            });\n          }\n        });\n        mungedSDP = libExports.write(sdpParsed);\n      }\n      yield this.setMungedSDP(sd, mungedSDP, true);\n      this.pendingCandidates.forEach(candidate => {\n        this.pc.addIceCandidate(candidate);\n      });\n      this.pendingCandidates = [];\n      this.restartingIce = false;\n      if (this.renegotiate) {\n        this.renegotiate = false;\n        yield this.createAndSendOffer();\n      } else if (sd.type === 'answer') {\n        this.emit(PCEvents.NegotiationComplete);\n        if (sd.sdp) {\n          const sdpParsed = libExports.parse(sd.sdp);\n          sdpParsed.media.forEach(media => {\n            if (media.type === 'video') {\n              this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n            }\n          });\n        }\n      }\n      return true;\n    });\n  }\n  createAndSendOffer(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.offerLock.lock();\n      try {\n        if (this.onOffer === undefined) {\n          return;\n        }\n        if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n          this.log.debug('restarting ICE', this.logContext);\n          this.restartingIce = true;\n        }\n        if (this._pc && this._pc.signalingState === 'have-local-offer') {\n          // we're waiting for the peer to accept our offer, so we'll just wait\n          // the only exception to this is when ICE restart is needed\n          const currentSD = this._pc.remoteDescription;\n          if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n            // TODO: handle when ICE restart is needed but we don't have a remote description\n            // the best thing to do is to recreate the peerconnection\n            yield this._pc.setRemoteDescription(currentSD);\n          } else {\n            this.renegotiate = true;\n            return;\n          }\n        } else if (!this._pc || this._pc.signalingState === 'closed') {\n          this.log.warn('could not createOffer with closed peer connection', this.logContext);\n          return;\n        }\n        // actually negotiate\n        this.log.debug('starting to negotiate', this.logContext);\n        // increase the offer id at the start to ensure the offer is always > 0 so that we can use 0 as a default value for legacy behavior\n        const offerId = this.latestOfferId + 1;\n        this.latestOfferId = offerId;\n        const offer = yield this.pc.createOffer(options);\n        this.log.debug('original offer', Object.assign({\n          sdp: offer.sdp\n        }, this.logContext));\n        const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n        sdpParsed.media.forEach(media => {\n          ensureIPAddrMatchVersion(media);\n          if (media.type === 'audio') {\n            ensureAudioNackAndStereo(media, ['all'], []);\n          } else if (media.type === 'video') {\n            this.trackBitrates.some(trackbr => {\n              if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                return false;\n              }\n              let codecPayload = 0;\n              media.rtp.some(rtp => {\n                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                  codecPayload = rtp.payload;\n                  return true;\n                }\n                return false;\n              });\n              if (codecPayload === 0) {\n                return true;\n              }\n              if (isSVCCodec(trackbr.codec) && !isSafari()) {\n                this.ensureVideoDDExtensionForSVC(media, sdpParsed);\n              }\n              // mung sdp for bitrate setting that can't apply by sendEncoding\n              if (!isSVCCodec(trackbr.codec)) {\n                return true;\n              }\n              const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\n              for (const fmtp of media.fmtp) {\n                if (fmtp.payload === codecPayload) {\n                  // if another track's fmtp already is set, we cannot override the bitrate\n                  // this has the unfortunate consequence of being forced to use the\n                  // initial track's bitrate for all tracks\n                  if (!fmtp.config.includes('x-google-start-bitrate')) {\n                    fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\n                  }\n                  break;\n                }\n              }\n              return true;\n            });\n          }\n        });\n        if (this.latestOfferId > offerId) {\n          this.log.warn('latestOfferId mismatch', Object.assign(Object.assign({}, this.logContext), {\n            latestOfferId: this.latestOfferId,\n            offerId\n          }));\n          return;\n        }\n        yield this.setMungedSDP(offer, libExports.write(sdpParsed));\n        this.onOffer(offer, this.latestOfferId);\n      } finally {\n        unlock();\n      }\n    });\n  }\n  createAndSetAnswer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const answer = yield this.pc.createAnswer();\n      const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\n      sdpParsed.media.forEach(media => {\n        ensureIPAddrMatchVersion(media);\n        if (media.type === 'audio') {\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n        }\n      });\n      yield this.setMungedSDP(answer, libExports.write(sdpParsed));\n      return answer;\n    });\n  }\n  createDataChannel(label, dataChannelDict) {\n    return this.pc.createDataChannel(label, dataChannelDict);\n  }\n  addTransceiver(mediaStreamTrack, transceiverInit) {\n    return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n  }\n  addTransceiverOfKind(kind, transceiverInit) {\n    return this.pc.addTransceiver(kind, transceiverInit);\n  }\n  addTrack(track) {\n    if (!this._pc) {\n      throw new UnexpectedConnectionState('PC closed, cannot add track');\n    }\n    return this._pc.addTrack(track);\n  }\n  setTrackCodecBitrate(info) {\n    this.trackBitrates.push(info);\n  }\n  setConfiguration(rtcConfig) {\n    var _a;\n    if (!this._pc) {\n      throw new UnexpectedConnectionState('PC closed, cannot configure');\n    }\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n  }\n  canRemoveTrack() {\n    var _a;\n    return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n  }\n  removeTrack(sender) {\n    var _a;\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n  }\n  getConnectionState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getICEConnectionState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getSignallingState() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\n  }\n  getTransceivers() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n  }\n  getSenders() {\n    var _a, _b;\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n  }\n  getLocalDescription() {\n    var _a;\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n  }\n  getRemoteDescription() {\n    var _a;\n    return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n  }\n  getStats() {\n    return this.pc.getStats();\n  }\n  getConnectedAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this._pc) {\n        return;\n      }\n      let selectedCandidatePairId = '';\n      const candidatePairs = new Map();\n      // id -> candidate ip\n      const candidates = new Map();\n      const stats = yield this._pc.getStats();\n      stats.forEach(v => {\n        switch (v.type) {\n          case 'transport':\n            selectedCandidatePairId = v.selectedCandidatePairId;\n            break;\n          case 'candidate-pair':\n            if (selectedCandidatePairId === '' && v.selected) {\n              selectedCandidatePairId = v.id;\n            }\n            candidatePairs.set(v.id, v);\n            break;\n          case 'remote-candidate':\n            candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n            break;\n        }\n      });\n      if (selectedCandidatePairId === '') {\n        return undefined;\n      }\n      const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n      if (selectedID === undefined) {\n        return undefined;\n      }\n      return candidates.get(selectedID);\n    });\n  }\n  setMungedSDP(sd, munged, remote) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (munged) {\n        const originalSdp = sd.sdp;\n        sd.sdp = munged;\n        try {\n          this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\n          if (remote) {\n            yield this.pc.setRemoteDescription(sd);\n          } else {\n            yield this.pc.setLocalDescription(sd);\n          }\n          return;\n        } catch (e) {\n          this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n            error: e,\n            sdp: munged\n          }));\n          sd.sdp = originalSdp;\n        }\n      }\n      try {\n        if (remote) {\n          yield this.pc.setRemoteDescription(sd);\n        } else {\n          yield this.pc.setLocalDescription(sd);\n        }\n      } catch (e) {\n        let msg = 'unknown error';\n        if (e instanceof Error) {\n          msg = e.message;\n        } else if (typeof e === 'string') {\n          msg = e;\n        }\n        const fields = {\n          error: msg,\n          sdp: sd.sdp\n        };\n        if (!remote && this.pc.remoteDescription) {\n          fields.remoteSdp = this.pc.remoteDescription;\n        }\n        this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n          fields\n        }));\n        throw new NegotiationError(msg);\n      }\n    });\n  }\n  ensureVideoDDExtensionForSVC(media, sdp) {\n    var _a, _b;\n    const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some(ext => {\n      if (ext.uri === ddExtensionURI) {\n        return true;\n      }\n      return false;\n    });\n    if (!ddFound) {\n      if (this.ddExtID === 0) {\n        let maxID = 0;\n        sdp.media.forEach(m => {\n          var _a;\n          if (m.type !== 'video') {\n            return;\n          }\n          (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach(ext => {\n            if (ext.value > maxID) {\n              maxID = ext.value;\n            }\n          });\n        });\n        this.ddExtID = maxID + 1;\n      }\n      (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\n        value: this.ddExtID,\n        uri: ddExtensionURI\n      });\n    }\n  }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n  // sdp-transform types don't include number however the parser outputs mids as numbers in some cases\n  const mid = getMidString(media.mid);\n  // found opus codec to add nack fb\n  let opusPayload = 0;\n  media.rtp.some(rtp => {\n    if (rtp.codec === 'opus') {\n      opusPayload = rtp.payload;\n      return true;\n    }\n    return false;\n  });\n  // add nack rtcpfb if not exist\n  if (opusPayload > 0) {\n    if (!media.rtcpFb) {\n      media.rtcpFb = [];\n    }\n    if (nackMids.includes(mid) && !media.rtcpFb.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\n      media.rtcpFb.push({\n        payload: opusPayload,\n        type: 'nack'\n      });\n    }\n    if (stereoMids.includes(mid) || stereoMids.length === 1 && stereoMids[0] === 'all') {\n      media.fmtp.some(fmtp => {\n        if (fmtp.payload === opusPayload) {\n          if (!fmtp.config.includes('stereo=1')) {\n            fmtp.config += ';stereo=1';\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n  var _a;\n  const stereoMids = [];\n  const nackMids = [];\n  const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n  let opusPayload = 0;\n  sdpParsed.media.forEach(media => {\n    var _a;\n    const mid = getMidString(media.mid);\n    if (media.type === 'audio') {\n      media.rtp.some(rtp => {\n        if (rtp.codec === 'opus') {\n          opusPayload = rtp.payload;\n          return true;\n        }\n        return false;\n      });\n      if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\n        nackMids.push(mid);\n      }\n      media.fmtp.some(fmtp => {\n        if (fmtp.payload === opusPayload) {\n          if (fmtp.config.includes('sprop-stereo=1')) {\n            stereoMids.push(mid);\n          }\n          return true;\n        }\n        return false;\n      });\n    }\n  });\n  return {\n    stereoMids,\n    nackMids\n  };\n}\nfunction ensureIPAddrMatchVersion(media) {\n  // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\n  // in edge case and return error when set sdp.This is not a\n  // sdk error but correct it if the issue detected.\n  if (media.connection) {\n    const isV6 = media.connection.ip.indexOf(':') >= 0;\n    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\n      // fallback to dummy address\n      media.connection.ip = '0.0.0.0';\n      media.connection.version = 4;\n    }\n  }\n}\nfunction getMidString(mid) {\n  return typeof mid === 'number' ? mid.toFixed(0) : mid;\n}const defaultVideoCodec = 'vp8';\nconst publishDefaults = {\n  audioPreset: AudioPresets.music,\n  dtx: true,\n  red: true,\n  forceStereo: false,\n  simulcast: true,\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n  stopMicTrackOnMute: false,\n  videoCodec: defaultVideoCodec,\n  backupCodec: true,\n  preConnectBuffer: false\n};\nconst audioDefaults = {\n  deviceId: {\n    ideal: 'default'\n  },\n  autoGainControl: true,\n  echoCancellation: true,\n  noiseSuppression: true,\n  voiceIsolation: true\n};\nconst videoDefaults = {\n  deviceId: {\n    ideal: 'default'\n  },\n  resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n  adaptiveStream: false,\n  dynacast: false,\n  stopLocalTrackOnUnpublish: true,\n  reconnectPolicy: new DefaultReconnectPolicy(),\n  disconnectOnPageLeave: true,\n  webAudioMix: false,\n  singlePeerConnection: false\n};\nconst roomConnectOptionDefaults = {\n  autoSubscribe: true,\n  maxRetries: 1,\n  peerConnectionTimeout: 15000,\n  websocketTimeout: 15000\n};var PCTransportState;\n(function (PCTransportState) {\n  PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n  PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n  PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n  PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n  PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n  get needsPublisher() {\n    return this.isPublisherConnectionRequired;\n  }\n  get needsSubscriber() {\n    return this.isSubscriberConnectionRequired;\n  }\n  get currentState() {\n    return this.state;\n  }\n  constructor(rtcConfig, mode, loggerOptions) {\n    var _a;\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.log = livekitLogger;\n    this.updateState = () => {\n      var _a, _b;\n      const previousState = this.state;\n      const connectionStates = this.requiredTransports.map(tr => tr.getConnectionState());\n      if (connectionStates.every(st => st === 'connected')) {\n        this.state = PCTransportState.CONNECTED;\n      } else if (connectionStates.some(st => st === 'failed')) {\n        this.state = PCTransportState.FAILED;\n      } else if (connectionStates.some(st => st === 'connecting')) {\n        this.state = PCTransportState.CONNECTING;\n      } else if (connectionStates.every(st => st === 'closed')) {\n        this.state = PCTransportState.CLOSED;\n      } else if (connectionStates.some(st => st === 'closed')) {\n        this.state = PCTransportState.CLOSING;\n      } else if (connectionStates.every(st => st === 'new')) {\n        this.state = PCTransportState.NEW;\n      }\n      if (previousState !== this.state) {\n        this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n        (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.getConnectionState());\n      }\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n    this.loggerOptions = loggerOptions;\n    this.isPublisherConnectionRequired = mode !== 'subscriber-primary';\n    this.isSubscriberConnectionRequired = mode === 'subscriber-primary';\n    this.publisher = new PCTransport(rtcConfig, loggerOptions);\n    if (mode !== 'publisher-only') {\n      this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n      this.subscriber.onConnectionStateChange = this.updateState;\n      this.subscriber.onIceConnectionStateChange = this.updateState;\n      this.subscriber.onSignalingStatechange = this.updateState;\n      this.subscriber.onIceCandidate = candidate => {\n        var _a;\n        (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n      };\n      // in subscriber primary mode, server side opens sub data channels.\n      this.subscriber.onDataChannel = ev => {\n        var _a;\n        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n      };\n      this.subscriber.onTrack = ev => {\n        var _a;\n        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n      };\n    }\n    this.publisher.onConnectionStateChange = this.updateState;\n    this.publisher.onIceConnectionStateChange = this.updateState;\n    this.publisher.onSignalingStatechange = this.updateState;\n    this.publisher.onIceCandidate = candidate => {\n      var _a;\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n    };\n    this.publisher.onTrack = ev => {\n      var _a;\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n    };\n    this.publisher.onOffer = (offer, offerId) => {\n      var _a;\n      (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer, offerId);\n    };\n    this.state = PCTransportState.NEW;\n    this.connectionLock = new _();\n    this.remoteOfferLock = new _();\n  }\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  requirePublisher() {\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.isPublisherConnectionRequired = require;\n    this.updateState();\n  }\n  createAndSendPublisherOffer(options) {\n    return this.publisher.createAndSendOffer(options);\n  }\n  setPublisherAnswer(sd, offerId) {\n    return this.publisher.setRemoteDescription(sd, offerId);\n  }\n  removeTrack(sender) {\n    return this.publisher.removeTrack(sender);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\n        const publisher = this.publisher;\n        for (const sender of publisher.getSenders()) {\n          try {\n            // TODO: react-native-webrtc doesn't have removeTrack yet.\n            if (publisher.canRemoveTrack()) {\n              publisher.removeTrack(sender);\n            }\n          } catch (e) {\n            this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\n              error: e\n            }));\n          }\n        }\n      }\n      yield Promise.all([this.publisher.close(), (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.close()]);\n      this.updateState();\n    });\n  }\n  triggerIceRestart() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.subscriber) {\n        this.subscriber.restartingIce = true;\n      }\n      // only restart publisher if it's needed\n      if (this.needsPublisher) {\n        yield this.createAndSendPublisherOffer({\n          iceRestart: true\n        });\n      }\n    });\n  }\n  addIceCandidate(candidate, target) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (target === SignalTarget.PUBLISHER) {\n        yield this.publisher.addIceCandidate(candidate);\n      } else {\n        yield (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.addIceCandidate(candidate);\n      }\n    });\n  }\n  createSubscriberAnswerFromOffer(sd, offerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: sd.type,\n        sdp: sd.sdp,\n        signalingState: (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.getSignallingState().toString()\n      }));\n      const unlock = yield this.remoteOfferLock.lock();\n      try {\n        const success = yield (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.setRemoteDescription(sd, offerId);\n        if (!success) {\n          return undefined;\n        }\n        // answer the offer\n        const answer = yield (_c = this.subscriber) === null || _c === void 0 ? void 0 : _c.createAndSetAnswer();\n        return answer;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  updateConfiguration(config, iceRestart) {\n    var _a;\n    this.publisher.setConfiguration(config);\n    (_a = this.subscriber) === null || _a === void 0 ? void 0 : _a.setConfiguration(config);\n    if (iceRestart) {\n      this.triggerIceRestart();\n    }\n  }\n  ensurePCTransportConnection(abortController, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.connectionLock.lock();\n      try {\n        if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\n          this.log.debug('negotiation required, start negotiating', this.logContext);\n          this.publisher.negotiate();\n        }\n        yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map(transport => this.ensureTransportConnected(transport, abortController, timeout)));\n      } finally {\n        unlock();\n      }\n    });\n  }\n  negotiate(abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        const negotiationTimeout = setTimeout(() => {\n          reject('negotiation timed out');\n        }, this.peerConnectionTimeout);\n        const abortHandler = () => {\n          clearTimeout(negotiationTimeout);\n          reject('negotiation aborted');\n        };\n        abortController.signal.addEventListener('abort', abortHandler);\n        this.publisher.once(PCEvents.NegotiationStarted, () => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          this.publisher.once(PCEvents.NegotiationComplete, () => {\n            clearTimeout(negotiationTimeout);\n            resolve();\n          });\n        });\n        yield this.publisher.negotiate(e => {\n          clearTimeout(negotiationTimeout);\n          reject(e);\n        });\n      }));\n    });\n  }\n  addPublisherTransceiver(track, transceiverInit) {\n    return this.publisher.addTransceiver(track, transceiverInit);\n  }\n  addPublisherTransceiverOfKind(kind, transceiverInit) {\n    return this.publisher.addTransceiverOfKind(kind, transceiverInit);\n  }\n  getMidForReceiver(receiver) {\n    const transceivers = this.subscriber ? this.subscriber.getTransceivers() : this.publisher.getTransceivers();\n    const matchingTransceiver = transceivers.find(transceiver => transceiver.receiver === receiver);\n    return matchingTransceiver === null || matchingTransceiver === void 0 ? void 0 : matchingTransceiver.mid;\n  }\n  addPublisherTrack(track) {\n    return this.publisher.addTrack(track);\n  }\n  createPublisherDataChannel(label, dataChannelDict) {\n    return this.publisher.createDataChannel(label, dataChannelDict);\n  }\n  /**\n   * Returns the first required transport's address if no explicit target is specified\n   */\n  getConnectedAddress(target) {\n    if (target === SignalTarget.PUBLISHER) {\n      return this.publisher.getConnectedAddress();\n    } else if (target === SignalTarget.SUBSCRIBER) {\n      return this.publisher.getConnectedAddress();\n    }\n    return this.requiredTransports[0].getConnectedAddress();\n  }\n  get requiredTransports() {\n    const transports = [];\n    if (this.isPublisherConnectionRequired) {\n      transports.push(this.publisher);\n    }\n    if (this.isSubscriberConnectionRequired && this.subscriber) {\n      transports.push(this.subscriber);\n    }\n    return transports;\n  }\n  ensureTransportConnected(pcTransport_1, abortController_1) {\n    return __awaiter(this, arguments, void 0, function (pcTransport, abortController) {\n      var _this = this;\n      let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n      return function* () {\n        const connectionState = pcTransport.getConnectionState();\n        if (connectionState === 'connected') {\n          return;\n        }\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\n          const abortHandler = () => {\n            this.log.warn('abort transport connection', this.logContext);\n            CriticalTimers.clearTimeout(connectTimeout);\n            reject(ConnectionError.cancelled('room connection has been cancelled'));\n          };\n          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n            abortHandler();\n          }\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\n          const connectTimeout = CriticalTimers.setTimeout(() => {\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n            reject(ConnectionError.internal('could not establish pc connection'));\n          }, timeout);\n          while (this.state !== PCTransportState.CONNECTED) {\n            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n              reject(ConnectionError.cancelled('room connection has been cancelled'));\n              return;\n            }\n          }\n          CriticalTimers.clearTimeout(connectTimeout);\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n          resolve();\n        }));\n      }();\n    });\n  }\n}const DEFAULT_MAX_AGE_MS = 5000;\nconst STOP_REFETCH_DELAY_MS = 30000;\nclass RegionUrlProvider {\n  static fetchRegionSettings(serverUrl, token, signal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield RegionUrlProvider.fetchLock.lock();\n      try {\n        const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(serverUrl), \"/regions\"), {\n          headers: {\n            authorization: \"Bearer \".concat(token)\n          },\n          signal\n        });\n        if (regionSettingsResponse.ok) {\n          const maxAge = extractMaxAgeFromRequestHeaders(regionSettingsResponse.headers);\n          const maxAgeInMs = maxAge ? maxAge * 1000 : DEFAULT_MAX_AGE_MS;\n          const regionSettings = yield regionSettingsResponse.json();\n          return {\n            regionSettings,\n            updatedAtInMs: Date.now(),\n            maxAgeInMs\n          };\n        } else {\n          if (regionSettingsResponse.status === 401) {\n            throw ConnectionError.notAllowed(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status);\n          } else {\n            throw ConnectionError.internal(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText));\n          }\n        }\n      } catch (e) {\n        if (e instanceof ConnectionError) {\n          // rethrow connection errors\n          throw e;\n        } else if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n          throw ConnectionError.cancelled(\"Region fetching was aborted\");\n        } else {\n          // wrap other errors as connection errors\n          throw ConnectionError.serverUnreachable(\"Could not fetch region settings, \".concat(e instanceof Error ? \"\".concat(e.name, \": \").concat(e.message) : e));\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  static scheduleRefetch(url, token, maxAgeInMs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const timeout = RegionUrlProvider.settingsTimeouts.get(url.hostname);\n      clearTimeout(timeout);\n      RegionUrlProvider.settingsTimeouts.set(url.hostname, setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const newSettings = yield RegionUrlProvider.fetchRegionSettings(url, token);\n          RegionUrlProvider.updateCachedRegionSettings(url, token, newSettings);\n        } catch (error) {\n          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n            livekitLogger.debug('token is not valid, cancelling auto region refresh');\n            return;\n          }\n          livekitLogger.debug('auto refetching of region settings failed', {\n            error\n          });\n          // continue retrying with the same max age\n          RegionUrlProvider.scheduleRefetch(url, token, maxAgeInMs);\n        }\n      }), maxAgeInMs));\n    });\n  }\n  static updateCachedRegionSettings(url, token, settings) {\n    RegionUrlProvider.cache.set(url.hostname, settings);\n    RegionUrlProvider.scheduleRefetch(url, token, settings.maxAgeInMs);\n  }\n  static stopRefetch(hostname) {\n    const timeout = RegionUrlProvider.settingsTimeouts.get(hostname);\n    if (timeout) {\n      clearTimeout(timeout);\n      RegionUrlProvider.settingsTimeouts.delete(hostname);\n    }\n  }\n  static scheduleCleanup(hostname) {\n    let tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n    if (!tracker) {\n      return;\n    }\n    // Cancel any existing cleanup timeout\n    if (tracker.cleanupTimeout) {\n      clearTimeout(tracker.cleanupTimeout);\n    }\n    // Schedule cleanup to stop refetch after delay\n    tracker.cleanupTimeout = setTimeout(() => {\n      const currentTracker = RegionUrlProvider.connectionTrackers.get(hostname);\n      if (currentTracker && currentTracker.connectionCount === 0) {\n        livekitLogger.debug('stopping region refetch after disconnect delay', {\n          hostname\n        });\n        RegionUrlProvider.stopRefetch(hostname);\n      }\n      if (currentTracker) {\n        currentTracker.cleanupTimeout = undefined;\n      }\n    }, STOP_REFETCH_DELAY_MS);\n  }\n  static cancelCleanup(hostname) {\n    const tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n    if (tracker === null || tracker === void 0 ? void 0 : tracker.cleanupTimeout) {\n      clearTimeout(tracker.cleanupTimeout);\n      tracker.cleanupTimeout = undefined;\n    }\n  }\n  notifyConnected() {\n    const hostname = this.serverUrl.hostname;\n    let tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n    if (!tracker) {\n      tracker = {\n        connectionCount: 0\n      };\n      RegionUrlProvider.connectionTrackers.set(hostname, tracker);\n    }\n    tracker.connectionCount++;\n    // Cancel any scheduled cleanup since we have an active connection\n    RegionUrlProvider.cancelCleanup(hostname);\n  }\n  notifyDisconnected() {\n    const hostname = this.serverUrl.hostname;\n    const tracker = RegionUrlProvider.connectionTrackers.get(hostname);\n    if (!tracker) {\n      return;\n    }\n    tracker.connectionCount = Math.max(0, tracker.connectionCount - 1);\n    // If no more connections, schedule cleanup\n    if (tracker.connectionCount === 0) {\n      RegionUrlProvider.scheduleCleanup(hostname);\n    }\n  }\n  constructor(url, token) {\n    this.attemptedRegions = [];\n    this.serverUrl = new URL(url);\n    this.token = token;\n  }\n  updateToken(token) {\n    this.token = token;\n  }\n  isCloud() {\n    return isCloud(this.serverUrl);\n  }\n  getServerUrl() {\n    return this.serverUrl;\n  }\n  /** @internal */\n  fetchRegionSettings(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return RegionUrlProvider.fetchRegionSettings(this.serverUrl, this.token, abortSignal);\n    });\n  }\n  getNextBestRegionUrl(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCloud()) {\n        throw Error('region availability is only supported for LiveKit Cloud domains');\n      }\n      let cachedSettings = RegionUrlProvider.cache.get(this.serverUrl.hostname);\n      if (!cachedSettings || Date.now() - cachedSettings.updatedAtInMs > cachedSettings.maxAgeInMs) {\n        cachedSettings = yield this.fetchRegionSettings(abortSignal);\n        RegionUrlProvider.updateCachedRegionSettings(this.serverUrl, this.token, cachedSettings);\n      }\n      const regionsLeft = cachedSettings.regionSettings.regions.filter(region => !this.attemptedRegions.find(attempted => attempted.url === region.url));\n      if (regionsLeft.length > 0) {\n        const nextRegion = regionsLeft[0];\n        this.attemptedRegions.push(nextRegion);\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n        return nextRegion.url;\n      } else {\n        return null;\n      }\n    });\n  }\n  resetAttempts() {\n    this.attemptedRegions = [];\n  }\n  setServerReportedRegions(settings) {\n    RegionUrlProvider.updateCachedRegionSettings(this.serverUrl, this.token, settings);\n  }\n}\nRegionUrlProvider.cache = new Map();\nRegionUrlProvider.settingsTimeouts = new Map();\nRegionUrlProvider.connectionTrackers = new Map();\nRegionUrlProvider.fetchLock = new _();\nfunction getCloudConfigUrl(serverUrl) {\n  return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\n}// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Specialized error handling for RPC methods.\n *\n * Instances of this type, when thrown in a method handler, will have their `message`\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\n *\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\n */\nclass RpcError extends Error {\n  /**\n   * Creates an error object with the given code and message, plus an optional data payload.\n   *\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\n   *\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\n   */\n  constructor(code, message, data) {\n    super(message);\n    this.code = code;\n    this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\n    this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\n  }\n  /**\n   * @internal\n   */\n  static fromProto(proto) {\n    return new RpcError(proto.code, proto.message, proto.data);\n  }\n  /**\n   * @internal\n   */\n  toProto() {\n    return new RpcError$1({\n      code: this.code,\n      message: this.message,\n      data: this.data\n    });\n  }\n  /**\n   * Creates an error object from the code, with an auto-populated message.\n   *\n   * @internal\n   */\n  static builtIn(key, data) {\n    return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\n  }\n}\nRpcError.MAX_MESSAGE_BYTES = 256;\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\nRpcError.ErrorCode = {\n  APPLICATION_ERROR: 1500,\n  CONNECTION_TIMEOUT: 1501,\n  RESPONSE_TIMEOUT: 1502,\n  RECIPIENT_DISCONNECTED: 1503,\n  RESPONSE_PAYLOAD_TOO_LARGE: 1504,\n  SEND_FAILED: 1505,\n  UNSUPPORTED_METHOD: 1400,\n  RECIPIENT_NOT_FOUND: 1401,\n  REQUEST_PAYLOAD_TOO_LARGE: 1402,\n  UNSUPPORTED_SERVER: 1403,\n  UNSUPPORTED_VERSION: 1404\n};\n/**\n * @internal\n */\nRpcError.ErrorMessage = {\n  APPLICATION_ERROR: 'Application error in method handler',\n  CONNECTION_TIMEOUT: 'Connection timeout',\n  RESPONSE_TIMEOUT: 'Response timeout',\n  RECIPIENT_DISCONNECTED: 'Recipient disconnected',\n  RESPONSE_PAYLOAD_TOO_LARGE: 'Response payload too large',\n  SEND_FAILED: 'Failed to send',\n  UNSUPPORTED_METHOD: 'Method not supported at destination',\n  RECIPIENT_NOT_FOUND: 'Recipient not found',\n  REQUEST_PAYLOAD_TOO_LARGE: 'Request payload too large',\n  UNSUPPORTED_SERVER: 'RPC not supported by server',\n  UNSUPPORTED_VERSION: 'Unsupported RPC version'\n};\n/*\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\n */\nconst MAX_PAYLOAD_BYTES = 15360; // 15 KB\n/**\n * @internal\n */\nfunction byteLength(str) {\n  const encoder = new TextEncoder();\n  return encoder.encode(str).length;\n}\n/**\n * @internal\n */\nfunction truncateBytes(str, maxBytes) {\n  if (byteLength(str) <= maxBytes) {\n    return str;\n  }\n  let low = 0;\n  let high = str.length;\n  const encoder = new TextEncoder();\n  while (low < high) {\n    const mid = Math.floor((low + high + 1) / 2);\n    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return str.slice(0, low);\n}const monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n  if (!prevStats) {\n    return 0;\n  }\n  let bytesNow;\n  let bytesPrev;\n  if ('bytesReceived' in currentStats) {\n    bytesNow = currentStats.bytesReceived;\n    bytesPrev = prevStats.bytesReceived;\n  } else if ('bytesSent' in currentStats) {\n    bytesNow = currentStats.bytesSent;\n    bytesPrev = prevStats.bytesSent;\n  }\n  if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n    return 0;\n  }\n  return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}// Check if MediaRecorder is available\nconst isMediaRecorderAvailable = typeof MediaRecorder !== 'undefined';\n// Fallback class for environments without MediaRecorder\nclass FallbackRecorder {\n  constructor() {\n    throw new Error('MediaRecorder is not available in this environment');\n  }\n}\n// Use conditional inheritance to avoid parse-time errors\nconst RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;\nclass LocalTrackRecorder extends RecorderBase {\n  constructor(track, options) {\n    if (!isMediaRecorderAvailable) {\n      throw new Error('MediaRecorder is not available in this environment');\n    }\n    super(new MediaStream([track.mediaStreamTrack]), options);\n    let dataListener;\n    let streamController;\n    const isClosed = () => streamController === undefined;\n    const onStop = () => {\n      this.removeEventListener('dataavailable', dataListener);\n      this.removeEventListener('stop', onStop);\n      this.removeEventListener('error', onError);\n      streamController === null || streamController === void 0 ? void 0 : streamController.close();\n      streamController = undefined;\n    };\n    const onError = event => {\n      streamController === null || streamController === void 0 ? void 0 : streamController.error(event);\n      this.removeEventListener('dataavailable', dataListener);\n      this.removeEventListener('stop', onStop);\n      this.removeEventListener('error', onError);\n      streamController = undefined;\n    };\n    this.byteStream = new ReadableStream({\n      start: controller => {\n        streamController = controller;\n        dataListener = event => __awaiter(this, void 0, void 0, function* () {\n          let data;\n          if (event.data.arrayBuffer) {\n            const arrayBuffer = yield event.data.arrayBuffer();\n            data = new Uint8Array(arrayBuffer);\n            // @ts-expect-error react-native passes over Uint8Arrays directly\n          } else if (event.data.byteArray) {\n            // @ts-expect-error\n            data = event.data.byteArray;\n          } else {\n            throw new Error('no data available!');\n          }\n          if (isClosed()) {\n            return;\n          }\n          controller.enqueue(data);\n        });\n        this.addEventListener('dataavailable', dataListener);\n      },\n      cancel: () => {\n        onStop();\n      }\n    });\n    this.addEventListener('stop', onStop);\n    this.addEventListener('error', onError);\n  }\n}\n// Helper function to check if recording is supported\nfunction isRecordingSupported() {\n  return isMediaRecorderAvailable;\n}const DEFAULT_DIMENSIONS_TIMEOUT = 1000;\nconst PRE_CONNECT_BUFFER_TIMEOUT = 10000;\nclass LocalTrack extends Track {\n  /** @internal */\n  get sender() {\n    return this._sender;\n  }\n  /** @internal */\n  set sender(sender) {\n    this._sender = sender;\n  }\n  get constraints() {\n    return this._constraints;\n  }\n  get hasPreConnectBuffer() {\n    return !!this.localTrackRecorder;\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, kind, constraints) {\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n    super(mediaTrack, kind, loggerOptions);\n    this.manuallyStopped = false;\n    this._isUpstreamPaused = false;\n    this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\n    this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.pauseUpstream();\n    }), 5000);\n    this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {\n      this.debouncedTrackMuteHandler.cancel('unmute');\n      yield this.resumeUpstream();\n    });\n    this.handleEnded = () => {\n      if (this.isInBackground) {\n        this.reacquireTrack = true;\n      }\n      this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n      this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n      this.emit(TrackEvent.Ended, this);\n    };\n    this.reacquireTrack = false;\n    this.providedByUser = userProvidedTrack;\n    this.muteLock = new _();\n    this.pauseUpstreamLock = new _();\n    this.trackChangeLock = new _();\n    this.trackChangeLock.lock().then(unlock => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.setMediaStreamTrack(mediaTrack, true);\n      } finally {\n        unlock();\n      }\n    }));\n    // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n    this._constraints = mediaTrack.getConstraints();\n    if (constraints) {\n      this._constraints = constraints;\n    }\n  }\n  get id() {\n    return this._mediaStreamTrack.id;\n  }\n  get dimensions() {\n    if (this.kind !== Track.Kind.Video) {\n      return undefined;\n    }\n    const {\n      width,\n      height\n    } = this._mediaStreamTrack.getSettings();\n    if (width && height) {\n      return {\n        width,\n        height\n      };\n    }\n    return undefined;\n  }\n  get isUpstreamPaused() {\n    return this._isUpstreamPaused;\n  }\n  get isUserProvided() {\n    return this.providedByUser;\n  }\n  get mediaStreamTrack() {\n    var _a, _b;\n    return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n  }\n  get isLocal() {\n    return true;\n  }\n  /**\n   * @internal\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\n   */\n  getSourceTrackSettings() {\n    return this._mediaStreamTrack.getSettings();\n  }\n  setMediaStreamTrack(newTrack, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (newTrack === this._mediaStreamTrack && !force) {\n        return;\n      }\n      if (this._mediaStreamTrack) {\n        // detach\n        this.attachedElements.forEach(el => {\n          detachTrack(this._mediaStreamTrack, el);\n        });\n        this.debouncedTrackMuteHandler.cancel('new-track');\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n      }\n      this.mediaStream = new MediaStream([newTrack]);\n      if (newTrack) {\n        newTrack.addEventListener('ended', this.handleEnded);\n        // when underlying track emits mute, it indicates that the device is unable\n        // to produce media. In this case we'll need to signal with remote that\n        // the track is \"muted\"\n        // note this is different from LocalTrack.mute because we do not want to\n        // touch MediaStreamTrack.enabled\n        newTrack.addEventListener('mute', this.handleTrackMuteEvent);\n        newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\n        this._constraints = newTrack.getConstraints();\n      }\n      let processedTrack;\n      if (this.processor && newTrack) {\n        this.log.debug('restarting processor', this.logContext);\n        if (this.kind === 'unknown') {\n          throw TypeError('cannot set processor on track of unknown kind');\n        }\n        if (this.processorElement) {\n          attachToElement(newTrack, this.processorElement);\n          // ensure the processorElement itself stays muted\n          this.processorElement.muted = true;\n        }\n        yield this.processor.restart({\n          track: newTrack,\n          kind: this.kind,\n          element: this.processorElement\n        });\n        processedTrack = this.processor.processedTrack;\n      }\n      if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n        yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n      }\n      // if `newTrack` is different from the existing track, stop the\n      // older track just before replacing it\n      if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n        this._mediaStreamTrack.stop();\n      }\n      this._mediaStreamTrack = newTrack;\n      if (newTrack) {\n        // sync muted state with the enabled state of the newly provided track\n        this._mediaStreamTrack.enabled = !this.isMuted;\n        // when a valid track is replace, we'd want to start producing\n        yield this.resumeUpstream();\n        this.attachedElements.forEach(el => {\n          attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n        });\n      }\n    });\n  }\n  waitForDimensions() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this = this;\n      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_DIMENSIONS_TIMEOUT;\n      return function* () {\n        var _a;\n        if (_this.kind === Track.Kind.Audio) {\n          throw new Error('cannot get dimensions for audio tracks');\n        }\n        if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\n          // browsers report wrong initial resolution on iOS.\n          // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n          yield sleep(10);\n        }\n        const started = Date.now();\n        while (Date.now() - started < timeout) {\n          const dims = _this.dimensions;\n          if (dims) {\n            return dims;\n          }\n          yield sleep(50);\n        }\n        throw new TrackInvalidError('unable to get track dimensions after timeout');\n      }();\n    });\n  }\n  setDeviceId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n        return true;\n      }\n      this._constraints.deviceId = deviceId;\n      // when track is muted, underlying media stream track is stopped and\n      // will be restarted later\n      if (this.isMuted) {\n        return true;\n      }\n      yield this.restartTrack();\n      return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n    });\n  }\n  /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */\n  getDeviceId() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this2 = this;\n      let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        // screen share doesn't have a usable device id\n        if (_this2.source === Track.Source.ScreenShare) {\n          return;\n        }\n        const {\n          deviceId,\n          groupId\n        } = _this2._mediaStreamTrack.getSettings();\n        const kind = _this2.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\n        return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\n      }();\n    });\n  }\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(true);\n      return this;\n    });\n  }\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setTrackMuted(false);\n      return this;\n    });\n  }\n  replaceTrack(track, userProvidedOrOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.trackChangeLock.lock();\n      try {\n        if (!this.sender) {\n          throw new TrackInvalidError('unable to replace an unpublished track');\n        }\n        let userProvidedTrack;\n        let stopProcessor;\n        if (typeof userProvidedOrOptions === 'boolean') {\n          userProvidedTrack = userProvidedOrOptions;\n        } else if (userProvidedOrOptions !== undefined) {\n          userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\n          stopProcessor = userProvidedOrOptions.stopProcessor;\n        }\n        this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\n        this.log.debug('replace MediaStreamTrack', this.logContext);\n        yield this.setMediaStreamTrack(track);\n        // this must be synced *after* setting mediaStreamTrack above, since it relies\n        // on the previous state in order to cleanup\n        if (stopProcessor && this.processor) {\n          yield this.internalStopProcessor();\n        }\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  restart(constraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.manuallyStopped = false;\n      const unlock = yield this.trackChangeLock.lock();\n      try {\n        if (!constraints) {\n          constraints = this._constraints;\n        }\n        const {\n            deviceId,\n            facingMode\n          } = constraints,\n          otherConstraints = __rest(constraints, [\"deviceId\", \"facingMode\"]);\n        this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\n          constraints\n        }));\n        const streamConstraints = {\n          audio: false,\n          video: false\n        };\n        if (this.kind === Track.Kind.Video) {\n          streamConstraints.video = deviceId || facingMode ? {\n            deviceId,\n            facingMode\n          } : true;\n        } else {\n          streamConstraints.audio = deviceId ? Object.assign({\n            deviceId\n          }, otherConstraints) : true;\n        }\n        // these steps are duplicated from setMediaStreamTrack because we must stop\n        // the previous tracks before new tracks can be acquired\n        this.attachedElements.forEach(el => {\n          detachTrack(this.mediaStreamTrack, el);\n        });\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        // on Safari, the old audio track must be stopped before attempting to acquire\n        // the new track, otherwise the new track will stop with\n        // 'A MediaStreamTrack ended due to a capture failure`\n        this._mediaStreamTrack.stop();\n        // create new track and attach\n        const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n        const newTrack = mediaStream.getTracks()[0];\n        if (this.kind === Track.Kind.Video) {\n          // we already captured the audio track with the constraints, so we only need to apply the video constraints\n          yield newTrack.applyConstraints(otherConstraints);\n        }\n        newTrack.addEventListener('ended', this.handleEnded);\n        this.log.debug('re-acquired MediaStreamTrack', this.logContext);\n        yield this.setMediaStreamTrack(newTrack);\n        this._constraints = constraints;\n        this.emit(TrackEvent.Restarted, this);\n        if (this.manuallyStopped) {\n          this.log.warn('track was stopped during a restart, stopping restarted track', this.logContext);\n          this.stop();\n        }\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  setTrackMuted(muted) {\n    this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n      return;\n    }\n    this.isMuted = muted;\n    this._mediaStreamTrack.enabled = !muted;\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n  }\n  get needsReAcquisition() {\n    return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile()) return;\n      this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n        this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n        yield this.restart();\n        this.reacquireTrack = false;\n      }\n    });\n  }\n  stop() {\n    var _a;\n    this.manuallyStopped = true;\n    super.stop();\n    this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n    this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n    this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n    (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.processor = undefined;\n  }\n  /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === true) {\n          return;\n        }\n        if (!this.sender) {\n          this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = true;\n        this.emit(TrackEvent.UpstreamPaused, this);\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\n          // https://bugs.webkit.org/show_bug.cgi?id=184911\n          throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\n        }\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n          yield this.sender.replaceTrack(null);\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === false) {\n          return;\n        }\n        if (!this.sender) {\n          this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = false;\n        this.emit(TrackEvent.UpstreamResumed, this);\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\n          // this operation is noop if mediastreamtrack is already being sent\n          yield this.sender.replaceTrack(this.mediaStreamTrack);\n        }\n      } finally {\n        unlock();\n      }\n    });\n  }\n  /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return;\n      }\n      const statsReport = yield this.sender.getStats();\n      return statsReport;\n    });\n  }\n  /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */\n  setProcessor(processor_1) {\n    return __awaiter(this, arguments, void 0, function (processor) {\n      var _this3 = this;\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a;\n        const unlock = yield _this3.trackChangeLock.lock();\n        try {\n          _this3.log.debug('setting up processor', _this3.logContext);\n          const processorElement = document.createElement(_this3.kind);\n          const processorOptions = {\n            kind: _this3.kind,\n            track: _this3._mediaStreamTrack,\n            element: processorElement,\n            audioContext: _this3.audioContext\n          };\n          yield processor.init(processorOptions);\n          _this3.log.debug('processor initialized', _this3.logContext);\n          if (_this3.processor) {\n            yield _this3.internalStopProcessor();\n          }\n          if (_this3.kind === 'unknown') {\n            throw TypeError('cannot set processor on track of unknown kind');\n          }\n          attachToElement(_this3._mediaStreamTrack, processorElement);\n          processorElement.muted = true;\n          processorElement.play().catch(error => {\n            if (error instanceof DOMException && error.name === 'AbortError') {\n              // This happens on Safari when the processor is restarted, try again after a delay\n              _this3.log.warn('failed to play processor element, retrying', Object.assign(Object.assign({}, _this3.logContext), {\n                error\n              }));\n              setTimeout(() => {\n                processorElement.play().catch(err => {\n                  _this3.log.error('failed to play processor element', Object.assign(Object.assign({}, _this3.logContext), {\n                    err\n                  }));\n                });\n              }, 100);\n            } else {\n              _this3.log.error('failed to play processor element', Object.assign(Object.assign({}, _this3.logContext), {\n                error\n              }));\n            }\n          });\n          _this3.processor = processor;\n          _this3.processorElement = processorElement;\n          if (_this3.processor.processedTrack) {\n            for (const el of _this3.attachedElements) {\n              if (el !== _this3.processorElement && showProcessedStreamLocally) {\n                detachTrack(_this3._mediaStreamTrack, el);\n                attachToElement(_this3.processor.processedTrack, el);\n              }\n            }\n            yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\n          }\n          _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\n        } finally {\n          unlock();\n        }\n      }();\n    });\n  }\n  getProcessor() {\n    return this.processor;\n  }\n  /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   */\n  stopProcessor() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this4 = this;\n      let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        const unlock = yield _this4.trackChangeLock.lock();\n        try {\n          yield _this4.internalStopProcessor(keepElement);\n        } finally {\n          unlock();\n        }\n      }();\n    });\n  }\n  /**\n   * @internal\n   * This method assumes the caller has acquired a trackChangeLock already.\n   * The public facing method for stopping the processor is `stopProcessor` and it wraps this method in the trackChangeLock.\n   */\n  internalStopProcessor() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this5 = this;\n      let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return function* () {\n        var _a, _b;\n        if (!_this5.processor) return;\n        _this5.log.debug('stopping processor', _this5.logContext);\n        (_a = _this5.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n        yield _this5.processor.destroy();\n        _this5.processor = undefined;\n        if (!keepElement) {\n          (_b = _this5.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n          _this5.processorElement = undefined;\n        }\n        // apply original track constraints in case the processor changed them\n        yield _this5._mediaStreamTrack.applyConstraints(_this5._constraints);\n        // force re-setting of the mediaStreamTrack on the sender\n        yield _this5.setMediaStreamTrack(_this5._mediaStreamTrack, true);\n        _this5.emit(TrackEvent.TrackProcessorUpdate);\n      }();\n    });\n  }\n  /** @internal */\n  startPreConnectBuffer() {\n    let timeslice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    if (!isRecordingSupported()) {\n      this.log.warn('MediaRecorder is not available, cannot start preconnect buffer', this.logContext);\n      return;\n    }\n    if (!this.localTrackRecorder) {\n      let mimeType = 'audio/webm;codecs=opus';\n      if (!MediaRecorder.isTypeSupported(mimeType)) {\n        // iOS currently only supports video/mp4 as a mime type - even for audio.\n        mimeType = 'video/mp4';\n      }\n      this.localTrackRecorder = new LocalTrackRecorder(this, {\n        mimeType\n      });\n    } else {\n      this.log.warn('preconnect buffer already started');\n      return;\n    }\n    this.localTrackRecorder.start(timeslice);\n    this.autoStopPreConnectBuffer = setTimeout(() => {\n      this.log.warn('preconnect buffer timed out, stopping recording automatically', this.logContext);\n      this.stopPreConnectBuffer();\n    }, PRE_CONNECT_BUFFER_TIMEOUT);\n  }\n  /** @internal */\n  stopPreConnectBuffer() {\n    clearTimeout(this.autoStopPreConnectBuffer);\n    if (this.localTrackRecorder) {\n      this.localTrackRecorder.stop();\n      this.localTrackRecorder = undefined;\n    }\n  }\n  /** @internal */\n  getPreConnectBuffer() {\n    var _a;\n    return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.byteStream;\n  }\n  getPreConnectBufferMimeType() {\n    var _a;\n    return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.mimeType;\n  }\n}class LocalAudioTrack extends LocalTrack {\n  /**\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\n   */\n  get enhancedNoiseCancellation() {\n    return this.isKrispNoiseFilterEnabled;\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n    /** @internal */\n    this.stopOnMute = false;\n    this.isKrispNoiseFilterEnabled = false;\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n        return;\n      }\n      if (stats && this.prevStats) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.handleKrispNoiseFilterEnable = () => {\n      this.isKrispNoiseFilterEnabled = true;\n      this.log.debug(\"Krisp noise filter enabled\", this.logContext);\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\n    };\n    this.handleKrispNoiseFilterDisable = () => {\n      this.isKrispNoiseFilterEnabled = false;\n      this.log.debug(\"Krisp noise filter disabled\", this.logContext);\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\n    };\n    this.audioContext = audioContext;\n    this.checkForSilence();\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.isMuted) {\n          this.log.debug('Track already muted', this.logContext);\n          return this;\n        }\n        // disabled special handling as it will cause BT headsets to switch communication modes\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n          this.log.debug('stopping mic track', this.logContext);\n          // also stop the track, so that microphone indicator is turned off\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (!this.isMuted) {\n          this.log.debug('Track already unmuted', this.logContext);\n          return this;\n        }\n        const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\n          this.log.debug('reacquiring mic track', this.logContext);\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          audio: options\n        });\n        if (typeof streamConstraints.audio !== 'boolean') {\n          constraints = streamConstraints.audio;\n        }\n      }\n      yield this.restart(constraints);\n    });\n  }\n  restart(constraints) {\n    const _super = Object.create(null, {\n      restart: {\n        get: () => super.restart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const track = yield _super.restart.call(this, constraints);\n      this.checkForSilence();\n      return track;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    if (!isWeb()) {\n      return;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  setProcessor(processor) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const unlock = yield this.trackChangeLock.lock();\n      try {\n        if (!isReactNative() && !this.audioContext) {\n          throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\n        }\n        if (this.processor) {\n          yield this.internalStopProcessor();\n        }\n        const processorOptions = {\n          kind: this.kind,\n          track: this._mediaStreamTrack,\n          // RN won't have or use AudioContext\n          audioContext: this.audioContext\n        };\n        this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n        yield processor.init(processorOptions);\n        this.processor = processor;\n        if (this.processor.processedTrack) {\n          yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n          this.processor.processedTrack.addEventListener('enable-lk-krisp-noise-filter', this.handleKrispNoiseFilterEnable);\n          this.processor.processedTrack.addEventListener('disable-lk-krisp-noise-filter', this.handleKrispNoiseFilterDisable);\n        }\n        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\n      } finally {\n        unlock();\n      }\n    });\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n  }\n  getSenderStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return undefined;\n      }\n      const stats = yield this.sender.getStats();\n      let audioStats;\n      stats.forEach(v => {\n        if (v.type === 'outbound-rtp') {\n          audioStats = {\n            type: 'audio',\n            streamId: v.id,\n            packetsSent: v.packetsSent,\n            packetsLost: v.packetsLost,\n            bytesSent: v.bytesSent,\n            timestamp: v.timestamp,\n            roundTripTime: v.roundTripTime,\n            jitter: v.jitter\n          };\n        }\n      });\n      return audioStats;\n    });\n  }\n  checkForSilence() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackIsSilent = yield detectSilence(this);\n      if (trackIsSilent) {\n        if (!this.isMuted) {\n          this.log.debug('silence detected on local audio track', this.logContext);\n        }\n        this.emit(TrackEvent.AudioSilenceDetected);\n      }\n      return trackIsSilent;\n    });\n  }\n}/** @internal */\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n  switch (mediaStreamTrack.kind) {\n    case 'audio':\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n    case 'video':\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n    default:\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n  }\n}\n/* @internal */\nconst presets169 = Object.values(VideoPresets);\n/* @internal */\nconst presets43 = Object.values(VideoPresets43);\n/* @internal */\nconst presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */\nconst defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\n/* @internal */\nconst defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\n/* @internal */\nconst computeDefaultScreenShareSimulcastPresets = fromPreset => {\n  const layers = [{\n    scaleResolutionDownBy: 2,\n    fps: fromPreset.encoding.maxFramerate\n  }];\n  return layers.map(t => {\n    var _a, _b;\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n  });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = ['q', 'h', 'f'];\n/* @internal */\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\n  var _a, _b;\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n  if (isScreenShare) {\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n  }\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n    // when we aren't simulcasting or svc, will need to return a single encoding without\n    // capping bandwidth. we always require a encoding for dynacast\n    return [{}];\n  }\n  if (!videoEncoding) {\n    // find the right encoding based on width/height\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n    livekitLogger.debug('using video encoding', videoEncoding);\n  }\n  const sourceFramerate = videoEncoding.maxFramerate;\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\n    const sm = new ScalabilityMode(scalabilityMode);\n    const encodings = [];\n    if (sm.spatial > 3) {\n      throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n    }\n    // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\n    // that SVC mode should be used. Safari still works this way.\n    // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\n    // before M113.\n    // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\n    const browser = getBrowser();\n    if (isSafariBased() ||\n    // Even tho RN runs M114, it does not produce SVC layers when a single encoding\n    // is provided. So we'll use the legacy SVC specification for now.\n    // TODO: when we upstream libwebrtc, this will need additional verification\n    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '113') < 0) {\n      const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\n      // safari 18.4 uses a different svc API that requires scaleResolutionDownBy to be set.\n      const requireScale = isSafariSvcApi(browser);\n      for (let i = 0; i < sm.spatial; i += 1) {\n        // in legacy SVC, scaleResolutionDownBy cannot be set\n        encodings.push({\n          rid: videoRids[2 - i],\n          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\n          maxFramerate: original.encoding.maxFramerate,\n          scaleResolutionDownBy: requireScale ? Math.pow(2, i) : undefined\n        });\n      }\n      // legacy SVC, scalabilityMode is set only on the first encoding\n      /* @ts-ignore */\n      encodings[0].scalabilityMode = scalabilityMode;\n    } else {\n      encodings.push({\n        maxBitrate: videoEncoding.maxBitrate,\n        maxFramerate: original.encoding.maxFramerate,\n        /* @ts-ignore */\n        scalabilityMode: scalabilityMode\n      });\n    }\n    if (original.encoding.priority) {\n      encodings[0].priority = original.encoding.priority;\n      encodings[0].networkPriority = original.encoding.priority;\n    }\n    livekitLogger.debug(\"using svc encoding\", {\n      encodings\n    });\n    return encodings;\n  }\n  if (!useSimulcast) {\n    return [videoEncoding];\n  }\n  let presets = [];\n  if (isScreenShare) {\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n  } else {\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n  }\n  let midPreset;\n  if (presets.length > 0) {\n    const lowPreset = presets[0];\n    if (presets.length > 1) {\n      [, midPreset] = presets;\n    }\n    // NOTE:\n    //   1. Ordering of these encodings is important. Chrome seems\n    //      to use the index into encodings to decide which layer\n    //      to disable when CPU constrained.\n    //      So encodings should be ordered in increasing spatial\n    //      resolution order.\n    //   2. livekit-server translates rids into layers. So, all encodings\n    //      should have the base layer `q` and then more added\n    //      based on other conditions.\n    const size = Math.max(width, height);\n    if (size >= 960 && midPreset) {\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);\n    }\n    if (size >= 480) {\n      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);\n    }\n  }\n  return encodingsFromPresets(width, height, [original]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n  var _a, _b, _c, _d;\n  // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n    // backup codec publishing is disabled\n    return;\n  }\n  if (videoCodec !== opts.backupCodec.codec) {\n    livekitLogger.warn('requested a different codec than specified as backup', {\n      serverRequested: videoCodec,\n      backup: opts.backupCodec.codec\n    });\n  }\n  opts.videoCodec = videoCodec;\n  // use backup encoding setting as videoEncoding for backup codec publishing\n  opts.videoEncoding = opts.backupCodec.encoding;\n  const settings = track.mediaStreamTrack.getSettings();\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n  // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\n  if (track.source === Track.Source.ScreenShare && opts.simulcast) {\n    opts.simulcast = false;\n  }\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n  return encodings;\n}\n/* @internal */\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\n  const presets = presetsForResolution(isScreenShare, width, height);\n  let {\n    encoding\n  } = presets[0];\n  // handle portrait by swapping dimensions\n  const size = Math.max(width, height);\n  for (let i = 0; i < presets.length; i += 1) {\n    const preset = presets[i];\n    encoding = preset.encoding;\n    if (preset.width >= size) {\n      break;\n    }\n  }\n  // presets are based on the assumption of vp8 as a codec\n  // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n  // users should override these with ones that are optimized for their use case\n  // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n  // bitrate for non-SVC codecs does not include other simulcast layers.\n  if (codec) {\n    switch (codec) {\n      case 'av1':\n      case 'h265':\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\n        break;\n      case 'vp9':\n        encoding = Object.assign({}, encoding);\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\n        break;\n    }\n  }\n  return encoding;\n}\n/* @internal */\nfunction presetsForResolution(isScreenShare, width, height) {\n  if (isScreenShare) {\n    return presetsScreenShare;\n  }\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n    return presets169;\n  }\n  return presets43;\n}\n/* @internal */\nfunction defaultSimulcastLayers(isScreenShare, original) {\n  if (isScreenShare) {\n    return computeDefaultScreenShareSimulcastPresets(original);\n  }\n  const {\n    width,\n    height\n  } = original;\n  const aspect = width > height ? width / height : height / width;\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n    return defaultSimulcastPresets169;\n  }\n  return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\n  const encodings = [];\n  presets.forEach((preset, idx) => {\n    if (idx >= videoRids.length) {\n      return;\n    }\n    const size = Math.min(width, height);\n    const rid = videoRids[idx];\n    const encoding = {\n      rid,\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n      maxBitrate: preset.encoding.maxBitrate\n    };\n    // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\n    // original encoding doesn't get bumped unintentionally by any of the other layers\n    const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\n    if (maxFramerate) {\n      encoding.maxFramerate = maxFramerate;\n    }\n    const canSetPriority = isFireFox() || idx === 0;\n    if (preset.encoding.priority && canSetPriority) {\n      encoding.priority = preset.encoding.priority;\n      encoding.networkPriority = preset.encoding.priority;\n    }\n    encodings.push(encoding);\n  });\n  // RN ios simulcast requires all same framerates.\n  if (isReactNative() && getReactNativeOs() === 'ios') {\n    let topFramerate = undefined;\n    encodings.forEach(encoding => {\n      if (!topFramerate) {\n        topFramerate = encoding.maxFramerate;\n      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n        topFramerate = encoding.maxFramerate;\n      }\n    });\n    let notifyOnce = true;\n    encodings.forEach(encoding => {\n      var _a;\n      if (encoding.maxFramerate != topFramerate) {\n        if (notifyOnce) {\n          notifyOnce = false;\n          livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n        }\n        livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\n        encoding.maxFramerate = topFramerate;\n      }\n    });\n  }\n  return encodings;\n}\n/** @internal */\nfunction sortPresets(presets) {\n  if (!presets) return;\n  return presets.sort((a, b) => {\n    const {\n      encoding: aEnc\n    } = a;\n    const {\n      encoding: bEnc\n    } = b;\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\n      return 1;\n    }\n    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n    }\n    return 0;\n  });\n}\n/** @internal */\nclass ScalabilityMode {\n  constructor(scalabilityMode) {\n    const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n    if (!results) {\n      throw new Error('invalid scalability mode');\n    }\n    this.spatial = parseInt(results[1]);\n    this.temporal = parseInt(results[2]);\n    if (results.length > 3) {\n      switch (results[3]) {\n        case 'h':\n        case '_KEY':\n        case '_KEY_SHIFT':\n          this.suffix = results[3];\n      }\n    }\n  }\n  toString() {\n    var _a;\n    return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\n  }\n}\nfunction getDefaultDegradationPreference(track) {\n  // a few of reasons we have different default paths:\n  // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\n  // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\n  if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\n    return 'maintain-resolution';\n  } else {\n    return 'balanced';\n  }\n}const refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n  get sender() {\n    return this._sender;\n  }\n  set sender(sender) {\n    this._sender = sender;\n    if (this.degradationPreference) {\n      this.setDegradationPreference(this.degradationPreference);\n    }\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(mediaTrack, constraints) {\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n    /* @internal */\n    this.simulcastCodecs = new Map();\n    this.degradationPreference = 'balanced';\n    this.isCpuConstrained = false;\n    this.optimizeForPerformance = false;\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let stats;\n      try {\n        stats = yield this.getSenderStats();\n      } catch (e) {\n        this.log.error('could not get video sender stats', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n        return;\n      }\n      const statsMap = new Map(stats.map(s => [s.rid, s]));\n      const isCpuConstrained = stats.some(s => s.qualityLimitationReason === 'cpu');\n      if (isCpuConstrained !== this.isCpuConstrained) {\n        this.isCpuConstrained = isCpuConstrained;\n        if (this.isCpuConstrained) {\n          this.emit(TrackEvent.CpuConstrained);\n        }\n      }\n      if (this.prevStats) {\n        let totalBitrate = 0;\n        statsMap.forEach((s, key) => {\n          var _a;\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n          totalBitrate += computeBitrate(s, prev);\n        });\n        this._currentBitrate = totalBitrate;\n      }\n      this.prevStats = statsMap;\n    });\n    this.senderLock = new _();\n  }\n  get isSimulcast() {\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\n      return true;\n    }\n    return false;\n  }\n  /* @internal */\n  startMonitor(signalClient) {\n    var _a;\n    this.signalClient = signalClient;\n    if (!isWeb()) {\n      return;\n    }\n    // save original encodings\n    // TODO : merge simulcast tracks stats\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n    if (params) {\n      this.encodings = params.encodings;\n    }\n    if (this.monitorInterval) {\n      return;\n    }\n    this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency);\n  }\n  stop() {\n    this._mediaStreamTrack.getConstraints();\n    this.simulcastCodecs.forEach(trackInfo => {\n      trackInfo.mediaStreamTrack.stop();\n    });\n    super.stop();\n  }\n  pauseUpstream() {\n    const _super = Object.create(null, {\n      pauseUpstream: {\n        get: () => super.pauseUpstream\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d;\n      yield _super.pauseUpstream.call(this);\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  resumeUpstream() {\n    const _super = Object.create(null, {\n      resumeUpstream: {\n        get: () => super.resumeUpstream\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_2, _b, _c;\n      var _d;\n      yield _super.resumeUpstream.call(this);\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  mute() {\n    const _super = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (this.isMuted) {\n          this.log.debug('Track already muted', this.logContext);\n          return this;\n        }\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          this.log.debug('stopping camera track', this.logContext);\n          // also stop the track, so that camera indicator is turned off\n          this._mediaStreamTrack.stop();\n        }\n        yield _super.mute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  unmute() {\n    const _super = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.muteLock.lock();\n      try {\n        if (!this.isMuted) {\n          this.log.debug('Track already unmuted', this.logContext);\n          return this;\n        }\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\n          this.log.debug('reacquiring camera track', this.logContext);\n          yield this.restartTrack();\n        }\n        yield _super.unmute.call(this);\n        return this;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  setTrackMuted(muted) {\n    super.setTrackMuted(muted);\n    for (const sc of this.simulcastCodecs.values()) {\n      sc.mediaStreamTrack.enabled = !muted;\n    }\n  }\n  getSenderStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return [];\n      }\n      const items = [];\n      const stats = yield this.sender.getStats();\n      stats.forEach(v => {\n        var _a;\n        if (v.type === 'outbound-rtp') {\n          const vs = {\n            type: 'video',\n            streamId: v.id,\n            frameHeight: v.frameHeight,\n            frameWidth: v.frameWidth,\n            framesPerSecond: v.framesPerSecond,\n            framesSent: v.framesSent,\n            firCount: v.firCount,\n            pliCount: v.pliCount,\n            nackCount: v.nackCount,\n            packetsSent: v.packetsSent,\n            bytesSent: v.bytesSent,\n            qualityLimitationReason: v.qualityLimitationReason,\n            qualityLimitationDurations: v.qualityLimitationDurations,\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\n            rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\n            targetBitrate: v.targetBitrate,\n            timestamp: v.timestamp\n          };\n          //locate the appropriate remote-inbound-rtp item\n          const r = stats.get(v.remoteId);\n          if (r) {\n            vs.jitter = r.jitter;\n            vs.packetsLost = r.packetsLost;\n            vs.roundTripTime = r.roundTripTime;\n          }\n          items.push(vs);\n        }\n      });\n      // make sure highest res layer is always first\n      items.sort((a, b) => {\n        var _a, _b;\n        return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\n      });\n      return items;\n    });\n  }\n  setPublishingQuality(maxQuality) {\n    const qualities = [];\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\n      qualities.push(new SubscribedQuality({\n        quality: q,\n        enabled: q <= maxQuality\n      }));\n    }\n    this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n    this.setPublishingLayers(isSVCCodec(this.codec), qualities);\n  }\n  restartTrack(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, e_3, _b, _c;\n      var _d;\n      let constraints;\n      if (options) {\n        const streamConstraints = constraintsForOptions({\n          video: options\n        });\n        if (typeof streamConstraints.video !== 'boolean') {\n          constraints = streamConstraints.video;\n        }\n      }\n      yield this.restart(constraints);\n      // reset cpu constrained state after track is restarted\n      this.isCpuConstrained = false;\n      try {\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\n          _c = _g.value;\n          _e = false;\n          const sc = _c;\n          if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== 'closed') {\n            sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n            yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  setProcessor(processor_1) {\n    const _super = Object.create(null, {\n      setProcessor: {\n        get: () => super.setProcessor\n      }\n    });\n    return __awaiter(this, arguments, void 0, function (processor) {\n      var _this = this;\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\n        if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n          try {\n            for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {\n              _c = _h.value;\n              _f = false;\n              const sc = _c;\n              yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      }();\n    });\n  }\n  setDegradationPreference(preference) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.degradationPreference = preference;\n      if (this.sender) {\n        try {\n          this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\n          const params = this.sender.getParameters();\n          params.degradationPreference = preference;\n          this.sender.setParameters(params);\n        } catch (e) {\n          this.log.warn(\"failed to set degradationPreference\", Object.assign({\n            error: e\n          }, this.logContext));\n        }\n      }\n    });\n  }\n  addSimulcastTrack(codec, encodings) {\n    if (this.simulcastCodecs.has(codec)) {\n      this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\n      return;\n    }\n    const simulcastCodecInfo = {\n      codec,\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\n      sender: undefined,\n      encodings\n    };\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\n    return simulcastCodecInfo;\n  }\n  setSimulcastTrackSender(codec, sender) {\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n    if (!simulcastCodecInfo) {\n      return;\n    }\n    simulcastCodecInfo.sender = sender;\n    // browser will reenable disabled codec/layers after new codec has been published,\n    // so refresh subscribedCodecs after publish a new codec\n    setTimeout(() => {\n      if (this.subscribedCodecs) {\n        this.setPublishingCodecs(this.subscribedCodecs);\n      }\n    }, refreshSubscribedCodecAfterNewCodec);\n  }\n  /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */\n  setPublishingCodecs(codecs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, codecs_1, codecs_1_1;\n      var _b, e_5, _c, _d;\n      this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\n        codecs,\n        currentCodec: this.codec\n      }));\n      // only enable simulcast codec for preference codec setted\n      if (!this.codec && codecs.length > 0) {\n        yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);\n        return [];\n      }\n      this.subscribedCodecs = codecs;\n      const newCodecs = [];\n      try {\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {\n          _d = codecs_1_1.value;\n          _a = false;\n          const codec = _d;\n          if (!this.codec || this.codec === codec.codec) {\n            yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);\n          } else {\n            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n            this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n              simulcastCodecInfo\n            }));\n            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n              for (const q of codec.qualities) {\n                if (q.enabled) {\n                  newCodecs.push(codec.codec);\n                  break;\n                }\n              }\n            } else if (simulcastCodecInfo.encodings) {\n              this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n              yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, isSVCCodec(codec.codec), this.log, this.logContext);\n            }\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      return newCodecs;\n    });\n  }\n  /**\n   * @internal\n   * Sets layers that should be publishing\n   */\n  setPublishingLayers(isSvc, qualities) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.optimizeForPerformance) {\n        this.log.info('skipping setPublishingLayers due to optimized publishing performance', Object.assign(Object.assign({}, this.logContext), {\n          qualities\n        }));\n        return;\n      }\n      this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\n        qualities\n      }));\n      if (!this.sender || !this.encodings) {\n        return;\n      }\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, isSvc, this.log, this.logContext);\n    });\n  }\n  /**\n   * Designed for lower powered devices, reduces video publishing quality and disables simulcast.\n   * @experimental\n   */\n  prioritizePerformance() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        throw new Error('sender not found');\n      }\n      const unlock = yield this.senderLock.lock();\n      try {\n        this.optimizeForPerformance = true;\n        const params = this.sender.getParameters();\n        params.encodings = params.encodings.map((e, idx) => {\n          var _a;\n          return Object.assign(Object.assign({}, e), {\n            active: idx === 0,\n            scaleResolutionDownBy: Math.max(1, Math.ceil(((_a = this.mediaStreamTrack.getSettings().height) !== null && _a !== void 0 ? _a : 360) / 360)),\n            scalabilityMode: idx === 0 && isSVCCodec(this.codec) ? 'L1T3' : undefined,\n            maxFramerate: idx === 0 ? 15 : 0,\n            maxBitrate: idx === 0 ? e.maxBitrate : 0\n          });\n        });\n        this.log.debug('setting performance optimised encodings', Object.assign(Object.assign({}, this.logContext), {\n          encodings: params.encodings\n        }));\n        this.encodings = params.encodings;\n        yield this.sender.setParameters(params);\n      } catch (e) {\n        this.log.error('failed to set performance optimised encodings', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n        this.optimizeForPerformance = false;\n      } finally {\n        unlock();\n      }\n    });\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!isMobile()) return;\n      if (this.isInBackground && this.source === Track.Source.Camera) {\n        this._mediaStreamTrack.enabled = false;\n      }\n    });\n  }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, isSVC, log, logContext) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const unlock = yield senderLock.lock();\n    log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\n      sender,\n      qualities,\n      senderEncodings\n    }));\n    try {\n      const params = sender.getParameters();\n      const {\n        encodings\n      } = params;\n      if (!encodings) {\n        return;\n      }\n      if (encodings.length !== senderEncodings.length) {\n        log.warn('cannot set publishing layers, encodings mismatch', Object.assign(Object.assign({}, logContext), {\n          encodings,\n          senderEncodings\n        }));\n        return;\n      }\n      let hasChanged = false;\n      /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */\n      const closableSpatial = false;\n      /* @ts-ignore */\n      if (closableSpatial && encodings[0].scalabilityMode) ; else {\n        if (isSVC) {\n          const hasEnabledEncoding = qualities.some(q => q.enabled);\n          if (hasEnabledEncoding) {\n            qualities.forEach(q => q.enabled = true);\n          }\n        }\n        // simulcast dynacast encodings\n        encodings.forEach((encoding, idx) => {\n          var _a;\n          let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\n          if (rid === '') {\n            rid = 'q';\n          }\n          const quality = videoQualityForRid(rid);\n          const subscribedQuality = qualities.find(q => q.quality === quality);\n          if (!subscribedQuality) {\n            return;\n          }\n          if (encoding.active !== subscribedQuality.enabled) {\n            hasChanged = true;\n            encoding.active = subscribedQuality.enabled;\n            log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\n            // FireFox does not support setting encoding.active to false, so we\n            // have a workaround of lowering its bitrate and resolution to the min.\n            if (isFireFox()) {\n              if (subscribedQuality.enabled) {\n                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                /* @ts-ignore */\n                encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n              } else {\n                encoding.scaleResolutionDownBy = 4;\n                encoding.maxBitrate = 10;\n                /* @ts-ignore */\n                encoding.maxFrameRate = 2;\n              }\n            }\n          }\n        });\n      }\n      if (hasChanged) {\n        params.encodings = encodings;\n        log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n          encodings: params.encodings\n        }));\n        yield sender.setParameters(params);\n      }\n    } finally {\n      unlock();\n    }\n  });\n}\nfunction videoQualityForRid(rid) {\n  switch (rid) {\n    case 'f':\n      return VideoQuality.HIGH;\n    case 'h':\n      return VideoQuality.MEDIUM;\n    case 'q':\n      return VideoQuality.LOW;\n    default:\n      return VideoQuality.HIGH;\n  }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n  // default to a single layer, HQ\n  if (!encodings) {\n    return [new VideoLayer({\n      quality: VideoQuality.HIGH,\n      width,\n      height,\n      bitrate: 0,\n      ssrc: 0\n    })];\n  }\n  if (svc) {\n    // svc layers\n    /* @ts-ignore */\n    const encodingSM = encodings[0].scalabilityMode;\n    const sm = new ScalabilityMode(encodingSM);\n    const layers = [];\n    const resRatio = sm.suffix == 'h' ? 1.5 : 2;\n    const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\n    for (let i = 0; i < sm.spatial; i += 1) {\n      layers.push(new VideoLayer({\n        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\n        width: Math.ceil(width / Math.pow(resRatio, i)),\n        height: Math.ceil(height / Math.pow(resRatio, i)),\n        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\n        ssrc: 0\n      }));\n    }\n    return layers;\n  }\n  return encodings.map(encoding => {\n    var _a, _b, _c;\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\n    return new VideoLayer({\n      quality,\n      width: Math.ceil(width / scale),\n      height: Math.ceil(height / scale),\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n      ssrc: 0\n    });\n  });\n}const lossyDataChannel = '_lossy';\nconst reliableDataChannel = '_reliable';\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = 'leave-reconnect';\nconst reliabeReceiveStateTTL = 30000;\nconst lossyDataChannelBufferThresholdMin = 8 * 1024;\nconst lossyDataChannelBufferThresholdMax = 256 * 1024;\nvar PCState;\n(function (PCState) {\n  PCState[PCState[\"New\"] = 0] = \"New\";\n  PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n  PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n  PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n  PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */\nclass RTCEngine extends eventsExports.EventEmitter {\n  get isClosed() {\n    return this._isClosed;\n  }\n  get pendingReconnect() {\n    return !!this.reconnectTimeout;\n  }\n  constructor(options) {\n    var _a;\n    super();\n    this.options = options;\n    this.rtcConfig = {};\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n    this.fullReconnectOnNext = false;\n    /**\n     * @internal\n     */\n    this.latestRemoteOfferId = 0;\n    this.subscriberPrimary = false;\n    this.pcState = PCState.New;\n    this._isClosed = true;\n    this.pendingTrackResolvers = {};\n    this.reconnectAttempts = 0;\n    this.reconnectStart = 0;\n    this.attemptingReconnect = false;\n    /** keeps track of how often an initial join connection has been tried */\n    this.joinAttempts = 0;\n    /** specifies how often an initial join connection is allowed to retry */\n    this.maxJoinAttempts = 1;\n    this.shouldFailNext = false;\n    this.log = livekitLogger;\n    this.reliableDataSequence = 1;\n    this.reliableMessageBuffer = new DataPacketBuffer();\n    this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);\n    this.lossyDataStatCurrentBytes = 0;\n    this.lossyDataStatByterate = 0;\n    this.lossyDataDropCount = 0;\n    this.midToTrackId = {};\n    /** used to indicate whether the browser is currently waiting to reconnect */\n    this.isWaitingForNetworkReconnect = false;\n    this.handleDataChannel = _a => __awaiter(this, [_a], void 0, function (_ref) {\n      var _this = this;\n      let {\n        channel\n      } = _ref;\n      return function* () {\n        if (!channel) {\n          return;\n        }\n        if (channel.label === reliableDataChannel) {\n          _this.reliableDCSub = channel;\n        } else if (channel.label === lossyDataChannel) {\n          _this.lossyDCSub = channel;\n        } else {\n          return;\n        }\n        _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\n        channel.onmessage = _this.handleDataMessage;\n      }();\n    });\n    this.handleDataMessage = message => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e;\n      // make sure to respect incoming data message order by processing message events one after the other\n      const unlock = yield this.dataProcessLock.lock();\n      try {\n        // decode\n        let buffer;\n        if (message.data instanceof ArrayBuffer) {\n          buffer = message.data;\n        } else if (message.data instanceof Blob) {\n          buffer = yield message.data.arrayBuffer();\n        } else {\n          this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\n            data: message.data\n          }));\n          return;\n        }\n        const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n        if (dp.sequence > 0 && dp.participantSid !== '') {\n          const lastSeq = this.reliableReceivedState.get(dp.participantSid);\n          if (lastSeq && dp.sequence <= lastSeq) {\n            // ignore duplicate or out-of-order packets in reliable channel\n            return;\n          }\n          this.reliableReceivedState.set(dp.participantSid, dp.sequence);\n        }\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === 'speaker') {\n          // dispatch speaker updates\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n        } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'encryptedPacket') {\n          if (!this.e2eeManager) {\n            this.log.error('Received encrypted packet but E2EE not set up', this.logContext);\n            return;\n          }\n          const decryptedData = yield (_c = this.e2eeManager) === null || _c === void 0 ? void 0 : _c.handleEncryptedData(dp.value.value.encryptedValue, dp.value.value.iv, dp.participantIdentity, dp.value.value.keyIndex);\n          const decryptedPacket = EncryptedPacketPayload.fromBinary(decryptedData.payload);\n          const newDp = new DataPacket({\n            value: decryptedPacket.value,\n            participantIdentity: dp.participantIdentity,\n            participantSid: dp.participantSid\n          });\n          if (((_d = newDp.value) === null || _d === void 0 ? void 0 : _d.case) === 'user') {\n            // compatibility\n            applyUserDataCompat(newDp, newDp.value.value);\n          }\n          this.emit(EngineEvent.DataPacketReceived, newDp, dp.value.value.encryptionType);\n        } else {\n          if (((_e = dp.value) === null || _e === void 0 ? void 0 : _e.case) === 'user') {\n            // compatibility\n            applyUserDataCompat(dp, dp.value.value);\n          }\n          this.emit(EngineEvent.DataPacketReceived, dp, Encryption_Type.NONE);\n        }\n      } finally {\n        unlock();\n      }\n    });\n    this.handleDataError = event => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\n      if (event instanceof ErrorEvent && event.error) {\n        const {\n          error\n        } = event.error;\n        this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n          error\n        }));\n      } else {\n        this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n          event\n        }));\n      }\n    };\n    this.handleBufferedAmountLow = event => {\n      const channel = event.currentTarget;\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n      this.updateAndEmitDCBufferStatus(channelKind);\n    };\n    // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n    // continues to work, we can reconnect to websocket to continue the session\n    // after a number of retries, we'll close and give up permanently\n    this.handleDisconnect = (connection, disconnectReason) => {\n      if (this._isClosed) {\n        return;\n      }\n      this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n      if (this.reconnectAttempts === 0) {\n        // only reset start time on the first try\n        this.reconnectStart = Date.now();\n      }\n      const disconnect = duration => {\n        this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n        this.emit(EngineEvent.Disconnected);\n        this.close();\n      };\n      const duration = Date.now() - this.reconnectStart;\n      let delay = this.getNextRetryDelay({\n        elapsedMs: duration,\n        retryCount: this.reconnectAttempts\n      });\n      if (delay === null) {\n        disconnect(duration);\n        return;\n      }\n      if (connection === leaveReconnect) {\n        delay = 0;\n      }\n      this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n      this.clearReconnectTimeout();\n      if (this.token && this.regionUrlProvider) {\n        // token may have been refreshed, we do not want to recreate the regionUrlProvider\n        // since the current engine may have inherited a regional url\n        this.regionUrlProvider.updateToken(this.token);\n      }\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = undefined), delay);\n    };\n    this.waitForRestarted = () => {\n      return new Promise((resolve, reject) => {\n        if (this.pcState === PCState.Connected) {\n          resolve();\n        }\n        const onRestarted = () => {\n          this.off(EngineEvent.Disconnected, onDisconnected);\n          resolve();\n        };\n        const onDisconnected = () => {\n          this.off(EngineEvent.Restarted, onRestarted);\n          reject();\n        };\n        this.once(EngineEvent.Restarted, onRestarted);\n        this.once(EngineEvent.Disconnected, onDisconnected);\n      });\n    };\n    this.updateAndEmitDCBufferStatus = kind => {\n      if (kind === DataPacket_Kind.RELIABLE) {\n        const dc = this.dataChannelForKind(kind);\n        if (dc) {\n          this.reliableMessageBuffer.alignBufferedAmount(dc.bufferedAmount);\n        }\n      }\n      const status = this.isBufferStatusLow(kind);\n      if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\n        this.dcBufferStatus.set(kind, status);\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n      }\n    };\n    this.isBufferStatusLow = kind => {\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n      }\n    };\n    this.handleBrowserOnLine = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.url) {\n        return;\n      }\n      const hasNetworkConnection = yield fetch(toHttpUrl(this.url), {\n        method: 'HEAD'\n      }).then(resp => resp.ok).catch(() => false);\n      if (!hasNetworkConnection) {\n        return;\n      }\n      this.log.info('detected network reconnected');\n      if (\n      // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n      this.client.currentState === SignalConnectionState.RECONNECTING ||\n      // also if the browser went offline before and the engine still thinks it's in a connected state, treat it as a network interruption that we haven't noticed yet\n      this.isWaitingForNetworkReconnect && this.client.currentState === SignalConnectionState.CONNECTED) {\n        this.clearReconnectTimeout();\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        this.isWaitingForNetworkReconnect = false;\n      }\n    });\n    this.handleBrowserOffline = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.url) {\n        return;\n      }\n      try {\n        yield Promise.race([fetch(toHttpUrl(this.url), {\n          method: 'HEAD'\n        }),\n        // if there's no internet connection the fetch rejects immediately, so we only use a short timeout here\n        sleep(4000).then(() => Promise.reject())]);\n      } catch (e) {\n        // only set if the browser still thinks it's offline after the request failed\n        if (window.navigator.onLine === false) {\n          this.log.info('detected network interruption');\n          this.isWaitingForNetworkReconnect = true;\n        }\n      }\n    });\n    this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n    this.loggerOptions = {\n      loggerName: options.loggerName,\n      loggerContextCb: () => this.logContext\n    };\n    this.client = new SignalClient(undefined, this.loggerOptions);\n    this.client.signalLatency = this.options.expSignalLatency;\n    this.reconnectPolicy = this.options.reconnectPolicy;\n    this.closingLock = new _();\n    this.dataProcessLock = new _();\n    this.dcBufferStatus = new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\n    this.client.onParticipantUpdate = updates => this.emit(EngineEvent.ParticipantUpdate, updates);\n    this.client.onConnectionQuality = update => this.emit(EngineEvent.ConnectionQualityUpdate, update);\n    this.client.onRoomUpdate = update => this.emit(EngineEvent.RoomUpdate, update);\n    this.client.onSubscriptionError = resp => this.emit(EngineEvent.SubscriptionError, resp);\n    this.client.onSubscriptionPermissionUpdate = update => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n    this.client.onSpeakersChanged = update => this.emit(EngineEvent.SpeakersChanged, update);\n    this.client.onStreamStateUpdate = update => this.emit(EngineEvent.StreamStateChanged, update);\n    this.client.onRequestResponse = response => this.emit(EngineEvent.SignalRequestResponse, response);\n  }\n  /** @internal */\n  get logContext() {\n    var _a, _b, _c, _d, _e, _f;\n    return {\n      room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n      roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n      participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\n      pID: this.participantSid\n    };\n  }\n  join(url, token, opts, abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.url = url;\n      this.token = token;\n      this.signalOpts = opts;\n      this.maxJoinAttempts = opts.maxRetries;\n      try {\n        this.joinAttempts += 1;\n        this.setupSignalClientCallbacks();\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n        this._isClosed = false;\n        this.latestJoinResponse = joinResponse;\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\n        if (!this.pcManager) {\n          yield this.configure(joinResponse);\n        }\n        // create offer\n        if (!this.subscriberPrimary || joinResponse.fastPublish) {\n          this.negotiate().catch(err => {\n            livekitLogger.error(err, this.logContext);\n          });\n        }\n        this.registerOnLineListener();\n        this.clientConfiguration = joinResponse.clientConfiguration;\n        this.emit(EngineEvent.SignalConnected, joinResponse);\n        return joinResponse;\n      } catch (e) {\n        if (e instanceof ConnectionError) {\n          if (e.reason === ConnectionErrorReason.ServerUnreachable) {\n            this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n            if (this.joinAttempts < this.maxJoinAttempts) {\n              return this.join(url, token, opts, abortSignal);\n            }\n          }\n        }\n        throw e;\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.closingLock.lock();\n      if (this.isClosed) {\n        unlock();\n        return;\n      }\n      try {\n        this._isClosed = true;\n        this.joinAttempts = 0;\n        this.emit(EngineEvent.Closing);\n        this.removeAllListeners();\n        this.deregisterOnLineListener();\n        this.clearPendingReconnect();\n        this.cleanupLossyDataStats();\n        yield this.cleanupPeerConnections();\n        yield this.cleanupClient();\n      } finally {\n        unlock();\n      }\n    });\n  }\n  cleanupPeerConnections() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n      this.pcManager = undefined;\n      const dcCleanup = dc => {\n        if (!dc) return;\n        dc.close();\n        dc.onbufferedamountlow = null;\n        dc.onclose = null;\n        dc.onclosing = null;\n        dc.onerror = null;\n        dc.onmessage = null;\n        dc.onopen = null;\n      };\n      dcCleanup(this.lossyDC);\n      dcCleanup(this.lossyDCSub);\n      dcCleanup(this.reliableDC);\n      dcCleanup(this.reliableDCSub);\n      this.lossyDC = undefined;\n      this.lossyDCSub = undefined;\n      this.reliableDC = undefined;\n      this.reliableDCSub = undefined;\n      this.reliableMessageBuffer = new DataPacketBuffer();\n      this.reliableDataSequence = 1;\n      this.reliableReceivedState.clear();\n    });\n  }\n  cleanupLossyDataStats() {\n    this.lossyDataStatByterate = 0;\n    this.lossyDataStatCurrentBytes = 0;\n    if (this.lossyDataStatInterval) {\n      clearInterval(this.lossyDataStatInterval);\n      this.lossyDataStatInterval = undefined;\n    }\n    this.lossyDataDropCount = 0;\n  }\n  cleanupClient() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.close();\n      this.client.resetCallbacks();\n    });\n  }\n  addTrack(req) {\n    if (this.pendingTrackResolvers[req.cid]) {\n      throw new TrackInvalidError('a track with the same ID has already been published');\n    }\n    return new Promise((resolve, reject) => {\n      const publicationTimeout = setTimeout(() => {\n        delete this.pendingTrackResolvers[req.cid];\n        reject(ConnectionError.timeout('publication of local track timed out, no response from server'));\n      }, 10000);\n      this.pendingTrackResolvers[req.cid] = {\n        resolve: info => {\n          clearTimeout(publicationTimeout);\n          resolve(info);\n        },\n        reject: () => {\n          clearTimeout(publicationTimeout);\n          reject(new Error('Cancelled publication by calling unpublish'));\n        }\n      };\n      this.client.sendAddTrack(req);\n    });\n  }\n  /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */\n  removeTrack(sender) {\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n      const {\n        reject\n      } = this.pendingTrackResolvers[sender.track.id];\n      if (reject) {\n        reject();\n      }\n      delete this.pendingTrackResolvers[sender.track.id];\n    }\n    try {\n      this.pcManager.removeTrack(sender);\n      return true;\n    } catch (e) {\n      this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n    }\n    return false;\n  }\n  updateMuteStatus(trackSid, muted) {\n    this.client.sendMuteTrack(trackSid, muted);\n  }\n  get dataSubscriberReadyState() {\n    var _a;\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n  }\n  getConnectedServerAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n    });\n  }\n  /* @internal */\n  setRegionUrlProvider(provider) {\n    this.regionUrlProvider = provider;\n  }\n  configure(joinResponse) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      // already configured\n      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n        return;\n      }\n      this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n      const rtcConfig = this.makeRTCConfiguration(joinResponse);\n      this.pcManager = new PCTransportManager(rtcConfig, this.options.singlePeerConnection ? 'publisher-only' : joinResponse.subscriberPrimary ? 'subscriber-primary' : 'publisher-primary', this.loggerOptions);\n      this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n      this.pcManager.onIceCandidate = (candidate, target) => {\n        this.client.sendIceCandidate(candidate, target);\n      };\n      this.pcManager.onPublisherOffer = (offer, offerId) => {\n        this.client.sendOffer(offer, offerId);\n      };\n      this.pcManager.onDataChannel = this.handleDataChannel;\n      this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {\n        this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n        if (['closed', 'disconnected', 'failed'].includes(publisherState)) {\n          // reset publisher connection promise\n          this.publisherConnectionPromise = undefined;\n        }\n        if (connectionState === PCTransportState.CONNECTED) {\n          const shouldEmit = this.pcState === PCState.New;\n          this.pcState = PCState.Connected;\n          if (shouldEmit) {\n            this.emit(EngineEvent.Connected, joinResponse);\n          }\n        } else if (connectionState === PCTransportState.FAILED) {\n          // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n          if (this.pcState === PCState.Connected || this.pcState === PCState.Reconnecting) {\n            this.pcState = PCState.Disconnected;\n            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n          }\n        }\n        // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\n        const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\n        const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);\n        if (isSignalSevered && isPCSevered && !this._isClosed) {\n          this.emit(EngineEvent.Offline);\n        }\n      });\n      this.pcManager.onTrack = ev => {\n        // this fires after the underlying transceiver is stopped and potentially\n        // peer connection closed, so do not bubble up if there are no streams\n        if (ev.streams.length === 0) return;\n        this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n      };\n      if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\n        this.createDataChannels();\n      }\n    });\n  }\n  setupSignalClientCallbacks() {\n    // configure signaling client\n    this.client.onAnswer = (sd, offerId, midToTrackId) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        return;\n      }\n      this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: sd.type,\n        sdp: sd.sdp,\n        midToTrackId\n      }));\n      this.midToTrackId = midToTrackId;\n      yield this.pcManager.setPublisherAnswer(sd, offerId);\n    });\n    // add candidate on trickle\n    this.client.onTrickle = (candidate, target) => {\n      if (!this.pcManager) {\n        return;\n      }\n      this.log.debug('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\n        candidate,\n        target\n      }));\n      this.pcManager.addIceCandidate(candidate, target);\n    };\n    // when server creates an offer for the client\n    this.client.onOffer = (sd, offerId, midToTrackId) => __awaiter(this, void 0, void 0, function* () {\n      this.latestRemoteOfferId = offerId;\n      if (!this.pcManager) {\n        return;\n      }\n      this.midToTrackId = midToTrackId;\n      const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd, offerId);\n      if (answer) {\n        this.client.sendAnswer(answer, offerId);\n      }\n    });\n    this.client.onLocalTrackPublished = res => {\n      var _a;\n      this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\n        cid: res.cid,\n        track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n      }));\n      if (!this.pendingTrackResolvers[res.cid]) {\n        this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n          cid: res.cid\n        }));\n        return;\n      }\n      const {\n        resolve\n      } = this.pendingTrackResolvers[res.cid];\n      delete this.pendingTrackResolvers[res.cid];\n      resolve(res.track);\n    };\n    this.client.onLocalTrackUnpublished = response => {\n      this.emit(EngineEvent.LocalTrackUnpublished, response);\n    };\n    this.client.onLocalTrackSubscribed = trackSid => {\n      this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\n    };\n    this.client.onTokenRefresh = token => {\n      var _a;\n      this.token = token;\n      (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.updateToken(token);\n    };\n    this.client.onRemoteMuteChanged = (trackSid, muted) => {\n      this.emit(EngineEvent.RemoteMute, trackSid, muted);\n    };\n    this.client.onSubscribedQualityUpdate = update => {\n      this.emit(EngineEvent.SubscribedQualityUpdate, update);\n    };\n    this.client.onRoomMoved = res => {\n      var _a;\n      this.participantSid = (_a = res.participant) === null || _a === void 0 ? void 0 : _a.sid;\n      if (this.latestJoinResponse) {\n        this.latestJoinResponse.room = res.room;\n      }\n      this.emit(EngineEvent.RoomMoved, res);\n    };\n    this.client.onMediaSectionsRequirement = requirement => {\n      var _a, _b;\n      const transceiverInit = {\n        direction: 'recvonly'\n      };\n      for (let i = 0; i < requirement.numAudios; i++) {\n        (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.addPublisherTransceiverOfKind('audio', transceiverInit);\n      }\n      for (let i = 0; i < requirement.numVideos; i++) {\n        (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.addPublisherTransceiverOfKind('video', transceiverInit);\n      }\n      this.negotiate();\n    };\n    this.client.onClose = () => {\n      this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\n    };\n    this.client.onLeave = leave => {\n      this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\n        reason: leave === null || leave === void 0 ? void 0 : leave.reason\n      }));\n      if (leave.regions && this.regionUrlProvider) {\n        this.log.debug('updating regions', this.logContext);\n        this.regionUrlProvider.setServerReportedRegions({\n          updatedAtInMs: Date.now(),\n          maxAgeInMs: DEFAULT_MAX_AGE_MS,\n          regionSettings: leave.regions\n        });\n      }\n      switch (leave.action) {\n        case LeaveRequest_Action.DISCONNECT:\n          this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n          this.close();\n          break;\n        case LeaveRequest_Action.RECONNECT:\n          this.fullReconnectOnNext = true;\n          // reconnect immediately instead of waiting for next attempt\n          this.handleDisconnect(leaveReconnect);\n          break;\n        case LeaveRequest_Action.RESUME:\n          // reconnect immediately instead of waiting for next attempt\n          this.handleDisconnect(leaveReconnect);\n      }\n    };\n  }\n  makeRTCConfiguration(serverResponse) {\n    var _a;\n    const rtcConfig = Object.assign({}, this.rtcConfig);\n    if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n      this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\n      //  this makes sure that no data is sent before the transforms are ready\n      // @ts-ignore\n      rtcConfig.encodedInsertableStreams = true;\n    }\n    // update ICE servers before creating PeerConnection\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\n      const rtcIceServers = [];\n      serverResponse.iceServers.forEach(iceServer => {\n        const rtcIceServer = {\n          urls: iceServer.urls\n        };\n        if (iceServer.username) rtcIceServer.username = iceServer.username;\n        if (iceServer.credential) {\n          rtcIceServer.credential = iceServer.credential;\n        }\n        rtcIceServers.push(rtcIceServer);\n      });\n      rtcConfig.iceServers = rtcIceServers;\n    }\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n      rtcConfig.iceTransportPolicy = 'relay';\n    }\n    // @ts-ignore\n    rtcConfig.sdpSemantics = 'unified-plan';\n    // @ts-ignore\n    rtcConfig.continualGatheringPolicy = 'gather_continually';\n    return rtcConfig;\n  }\n  createDataChannels() {\n    if (!this.pcManager) {\n      return;\n    }\n    // clear old data channel callbacks if recreate\n    if (this.lossyDC) {\n      this.lossyDC.onmessage = null;\n      this.lossyDC.onerror = null;\n    }\n    if (this.reliableDC) {\n      this.reliableDC.onmessage = null;\n      this.reliableDC.onerror = null;\n    }\n    // create data channels\n    this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n      ordered: false,\n      maxRetransmits: 0\n    });\n    this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n      ordered: true\n    });\n    // also handle messages over the pub channel, for backwards compatibility\n    this.lossyDC.onmessage = this.handleDataMessage;\n    this.reliableDC.onmessage = this.handleDataMessage;\n    // handle datachannel errors\n    this.lossyDC.onerror = this.handleDataError;\n    this.reliableDC.onerror = this.handleDataError;\n    // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\n    // handle buffer amount low events\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    this.cleanupLossyDataStats();\n    this.lossyDataStatInterval = setInterval(() => {\n      this.lossyDataStatByterate = this.lossyDataStatCurrentBytes;\n      this.lossyDataStatCurrentBytes = 0;\n      const dc = this.dataChannelForKind(DataPacket_Kind.LOSSY);\n      if (dc) {\n        // control buffered latency to ~100ms\n        const threshold = this.lossyDataStatByterate / 10;\n        dc.bufferedAmountLowThreshold = Math.min(Math.max(threshold, lossyDataChannelBufferThresholdMin), lossyDataChannelBufferThresholdMax);\n      }\n    }, 1000);\n  }\n  createSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver()) {\n        const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n        return sender;\n      }\n      if (supportsAddTrack()) {\n        this.log.warn('using add-track fallback', this.logContext);\n        const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n        return sender;\n      }\n      throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\n    });\n  }\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // store RTCRtpSender\n      if (supportsTransceiver()) {\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n      }\n      if (supportsAddTrack()) {\n        this.log.debug('using add-track fallback', this.logContext);\n        return this.createRTCRtpSender(track.mediaStreamTrack);\n      }\n      throw new UnexpectedConnectionState('Cannot stream on this device');\n    });\n  }\n  createTransceiverRTCRtpSender(track, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      const streams = [];\n      if (track.mediaStream) {\n        streams.push(track.mediaStream);\n      }\n      if (isVideoTrack(track)) {\n        track.codec = opts.videoCodec;\n      }\n      const transceiverInit = {\n        direction: 'sendonly',\n        streams\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n      const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n      return transceiver.sender;\n    });\n  }\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      const transceiverInit = {\n        direction: 'sendonly'\n      };\n      if (encodings) {\n        transceiverInit.sendEncodings = encodings;\n      }\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n      const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n      if (!opts.videoCodec) {\n        return;\n      }\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n      return transceiver.sender;\n    });\n  }\n  createRTCRtpSender(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher is closed');\n      }\n      return this.pcManager.addPublisherTrack(track);\n    });\n  }\n  attemptReconnect(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (this._isClosed) {\n        return;\n      }\n      // guard for attempting reconnection multiple times while one attempt is still not finished\n      if (this.attemptingReconnect) {\n        livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\n        return;\n      }\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED ||\n      // signaling state could change to closed due to hardware sleep\n      // those connections cannot be resumed\n      ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n        this.fullReconnectOnNext = true;\n      }\n      try {\n        this.attemptingReconnect = true;\n        if (this.fullReconnectOnNext) {\n          yield this.restartConnection();\n        } else {\n          yield this.resumeConnection(reason);\n        }\n        this.clearPendingReconnect();\n        this.fullReconnectOnNext = false;\n      } catch (e) {\n        this.reconnectAttempts += 1;\n        let recoverable = true;\n        if (e instanceof UnexpectedConnectionState) {\n          this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n          // unrecoverable\n          recoverable = false;\n        } else if (!(e instanceof SignalReconnectError)) {\n          // cannot resume\n          this.fullReconnectOnNext = true;\n        }\n        if (recoverable) {\n          this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\n        } else {\n          this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n          this.emit(EngineEvent.Disconnected);\n          yield this.close();\n        }\n      } finally {\n        this.attemptingReconnect = false;\n      }\n    });\n  }\n  getNextRetryDelay(context) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\n    } catch (e) {\n      this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n    }\n    // error in user code with provided reconnect policy, stop reconnecting\n    return null;\n  }\n  restartConnection(regionUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      try {\n        if (!this.url || !this.token) {\n          // permanent failure, don't attempt reconnection\n          throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n        }\n        this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n        this.emit(EngineEvent.Restarting);\n        if (!this.client.isDisconnected) {\n          yield this.client.sendLeave();\n        }\n        yield this.cleanupPeerConnections();\n        yield this.cleanupClient();\n        let joinResponse;\n        try {\n          if (!this.signalOpts) {\n            this.log.warn('attempted connection restart, without signal options present', this.logContext);\n            throw new SignalReconnectError();\n          }\n          // in case a regionUrl is passed, the region URL takes precedence\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n        } catch (e) {\n          if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\n            throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n          }\n          throw new SignalReconnectError();\n        }\n        if (this.shouldFailNext) {\n          this.shouldFailNext = false;\n          throw new Error('simulated failure');\n        }\n        this.client.setReconnected();\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\n        yield this.waitForPCReconnected();\n        // re-check signal connection state before setting engine as resumed\n        if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n          throw new SignalReconnectError('Signal connection got severed during reconnect');\n        }\n        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n        // reconnect success\n        this.emit(EngineEvent.Restarted);\n      } catch (error) {\n        const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n        if (nextRegionUrl) {\n          yield this.restartConnection(nextRegionUrl);\n          return;\n        } else {\n          // no more regions to try (or we're not on cloud)\n          (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n          throw error;\n        }\n      }\n    });\n  }\n  resumeConnection(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this.url || !this.token) {\n        // permanent failure, don't attempt reconnection\n        throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n      }\n      // trigger publisher reconnect\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('publisher and subscriber connections unset');\n      }\n      this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n      this.emit(EngineEvent.Resuming);\n      let res;\n      try {\n        this.setupSignalClientCallbacks();\n        res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n      } catch (error) {\n        let message = '';\n        if (error instanceof Error) {\n          message = error.message;\n          this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n            error\n          }));\n        }\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n          throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n        }\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\n          throw error;\n        }\n        throw new SignalReconnectError(message);\n      }\n      this.emit(EngineEvent.SignalResumed);\n      if (res) {\n        const rtcConfig = this.makeRTCConfiguration(res);\n        this.pcManager.updateConfiguration(rtcConfig);\n        if (this.latestJoinResponse) {\n          this.latestJoinResponse.serverInfo = res.serverInfo;\n        }\n      } else {\n        this.log.warn('Did not receive reconnect response', this.logContext);\n      }\n      if (this.shouldFailNext) {\n        this.shouldFailNext = false;\n        throw new Error('simulated failure');\n      }\n      yield this.pcManager.triggerIceRestart();\n      yield this.waitForPCReconnected();\n      // re-check signal connection state before setting engine as resumed\n      if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n        throw new SignalReconnectError('Signal connection got severed during reconnect');\n      }\n      this.client.setReconnected();\n      // recreate publish datachannel if it's id is null\n      // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\n        this.createDataChannels();\n      }\n      if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {\n        this.resendReliableMessagesForResume(res.lastMessageSeq);\n      }\n      // resume success\n      this.emit(EngineEvent.Resumed);\n    });\n  }\n  waitForPCInitialConnection(timeout, abortController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager) {\n        throw new UnexpectedConnectionState('PC manager is closed');\n      }\n      yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n    });\n  }\n  waitForPCReconnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.pcState = PCState.Reconnecting;\n      this.log.debug('waiting for peer connection to reconnect', this.logContext);\n      try {\n        yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n        if (!this.pcManager) {\n          throw new UnexpectedConnectionState('PC manager is closed');\n        }\n        yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n        this.pcState = PCState.Connected;\n      } catch (e) {\n        // TODO do we need a `failed` state here for the PC?\n        this.pcState = PCState.Disconnected;\n        throw ConnectionError.internal(\"could not establish PC connection, \".concat(e.message));\n      }\n    });\n  }\n  /** @internal */\n  publishRpcResponse(destinationIdentity, requestId, payload, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcResponse',\n          value: new RpcResponse({\n            requestId,\n            value: error ? {\n              case: 'error',\n              value: error.toProto()\n            } : {\n              case: 'payload',\n              value: payload !== null && payload !== void 0 ? payload : ''\n            }\n          })\n        }\n      });\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /** @internal */\n  publishRpcAck(destinationIdentity, requestId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcAck',\n          value: new RpcAck({\n            requestId\n          })\n        }\n      });\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /* @internal */\n  sendDataPacket(packet, kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we do have a data connection\n      yield this.ensurePublisherConnected(kind);\n      if (this.e2eeManager && this.e2eeManager.isDataChannelEncryptionEnabled) {\n        const encryptablePacket = asEncryptablePacket(packet);\n        if (encryptablePacket) {\n          const encryptedData = yield this.e2eeManager.encryptData(encryptablePacket.toBinary());\n          packet.value = {\n            case: 'encryptedPacket',\n            value: new EncryptedPacket({\n              encryptedValue: encryptedData.payload,\n              iv: encryptedData.iv,\n              keyIndex: encryptedData.keyIndex\n            })\n          };\n        }\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        packet.sequence = this.reliableDataSequence;\n        this.reliableDataSequence += 1;\n      }\n      const msg = packet.toBinary();\n      const dc = this.dataChannelForKind(kind);\n      if (dc) {\n        if (kind === DataPacket_Kind.RELIABLE) {\n          yield this.waitForBufferStatusLow(kind);\n          this.reliableMessageBuffer.push({\n            data: msg,\n            sequence: packet.sequence\n          });\n        } else {\n          // lossy channel, drop messages to reduce latency\n          if (!this.isBufferStatusLow(kind)) {\n            this.lossyDataDropCount += 1;\n            if (this.lossyDataDropCount % 100 === 0) {\n              this.log.warn(\"dropping lossy data channel messages, total dropped: \".concat(this.lossyDataDropCount), this.logContext);\n            }\n            return;\n          }\n          this.lossyDataStatCurrentBytes += msg.byteLength;\n        }\n        if (this.attemptingReconnect) {\n          return;\n        }\n        dc.send(msg);\n      }\n      this.updateAndEmitDCBufferStatus(kind);\n    });\n  }\n  resendReliableMessagesForResume(lastMessageSeq) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);\n      const dc = this.dataChannelForKind(DataPacket_Kind.RELIABLE);\n      if (dc) {\n        this.reliableMessageBuffer.popToSequence(lastMessageSeq);\n        this.reliableMessageBuffer.getAll().forEach(msg => {\n          dc.send(msg.data);\n        });\n      }\n      this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);\n    });\n  }\n  waitForBufferStatusLow(kind) {\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      if (this.isBufferStatusLow(kind)) {\n        resolve();\n      } else {\n        const onClosing = () => reject('Engine closed');\n        this.once(EngineEvent.Closing, onClosing);\n        while (!this.dcBufferStatus.get(kind)) {\n          yield sleep(10);\n        }\n        this.off(EngineEvent.Closing, onClosing);\n        resolve();\n      }\n    }));\n  }\n  /**\n   * @internal\n   */\n  ensureDataTransportConnected(kind_1) {\n    return __awaiter(this, arguments, void 0, function (kind) {\n      var _this2 = this;\n      let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n      return function* () {\n        var _a;\n        if (!_this2.pcManager) {\n          throw new UnexpectedConnectionState('PC manager is closed');\n        }\n        const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\n        const transportName = subscriber ? 'Subscriber' : 'Publisher';\n        if (!transport) {\n          throw ConnectionError.internal(\"\".concat(transportName, \" connection not set\"));\n        }\n        let needNegotiation = false;\n        if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\n          _this2.createDataChannels();\n          needNegotiation = true;\n        }\n        if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== 'checking') {\n          needNegotiation = true;\n        }\n        if (needNegotiation) {\n          // start negotiation\n          _this2.negotiate().catch(err => {\n            livekitLogger.error(err, _this2.logContext);\n          });\n        }\n        const targetChannel = _this2.dataChannelForKind(kind, subscriber);\n        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\n          return;\n        }\n        // wait until ICE connected\n        const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\n        while (new Date().getTime() < endTime) {\n          if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\n            return;\n          }\n          yield sleep(50);\n        }\n        throw ConnectionError.internal(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()));\n      }();\n    });\n  }\n  ensurePublisherConnected(kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.publisherConnectionPromise) {\n        this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\n      }\n      yield this.publisherConnectionPromise;\n    });\n  }\n  /* @internal */\n  verifyTransport() {\n    if (!this.pcManager) {\n      return false;\n    }\n    // primary connection\n    if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n      return false;\n    }\n    // ensure signal is connected\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n      return false;\n    }\n    return true;\n  }\n  /** @internal */\n  negotiate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // observe signal state\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        if (!this.pcManager) {\n          reject(new NegotiationError('PC manager is closed'));\n          return;\n        }\n        this.pcManager.requirePublisher();\n        // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\n        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\n          this.createDataChannels();\n        }\n        const abortController = new AbortController();\n        const handleClosed = () => {\n          abortController.abort();\n          this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\n          resolve();\n          return;\n        };\n        if (this.isClosed) {\n          reject('cannot negotiate on closed engine');\n        }\n        this.on(EngineEvent.Closing, handleClosed);\n        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, rtpTypes => {\n          const rtpMap = new Map();\n          rtpTypes.forEach(rtp => {\n            const codec = rtp.codec.toLowerCase();\n            if (isVideoCodec(codec)) {\n              rtpMap.set(rtp.payload, codec);\n            }\n          });\n          this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n        });\n        try {\n          yield this.pcManager.negotiate(abortController);\n          resolve();\n        } catch (e) {\n          if (e instanceof NegotiationError) {\n            this.fullReconnectOnNext = true;\n          }\n          this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\n          reject(e);\n        } finally {\n          this.off(EngineEvent.Closing, handleClosed);\n        }\n      }));\n    });\n  }\n  dataChannelForKind(kind, sub) {\n    if (!sub) {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDC;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDC;\n      }\n    } else {\n      if (kind === DataPacket_Kind.LOSSY) {\n        return this.lossyDCSub;\n      }\n      if (kind === DataPacket_Kind.RELIABLE) {\n        return this.reliableDCSub;\n      }\n    }\n  }\n  /** @internal */\n  sendSyncState(remoteTracks, localTracks) {\n    var _a, _b, _c, _d;\n    if (!this.pcManager) {\n      this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\n      return;\n    }\n    const previousPublisherOffer = this.pcManager.publisher.getLocalDescription();\n    const previousPublisherAnswer = this.pcManager.publisher.getRemoteDescription();\n    const previousSubscriberOffer = (_a = this.pcManager.subscriber) === null || _a === void 0 ? void 0 : _a.getRemoteDescription();\n    const previousSubscriberAnswer = (_b = this.pcManager.subscriber) === null || _b === void 0 ? void 0 : _b.getLocalDescription();\n    /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */\n    const autoSubscribe = (_d = (_c = this.signalOpts) === null || _c === void 0 ? void 0 : _c.autoSubscribe) !== null && _d !== void 0 ? _d : true;\n    const trackSids = new Array();\n    const trackSidsDisabled = new Array();\n    remoteTracks.forEach(track => {\n      if (track.isDesired !== autoSubscribe) {\n        trackSids.push(track.trackSid);\n      }\n      if (!track.isEnabled) {\n        trackSidsDisabled.push(track.trackSid);\n      }\n    });\n    this.client.sendSyncState(new SyncState({\n      answer: this.options.singlePeerConnection ? previousPublisherAnswer ? toProtoSessionDescription({\n        sdp: previousPublisherAnswer.sdp,\n        type: previousPublisherAnswer.type\n      }) : undefined : previousSubscriberAnswer ? toProtoSessionDescription({\n        sdp: previousSubscriberAnswer.sdp,\n        type: previousSubscriberAnswer.type\n      }) : undefined,\n      offer: this.options.singlePeerConnection ? previousPublisherOffer ? toProtoSessionDescription({\n        sdp: previousPublisherOffer.sdp,\n        type: previousPublisherOffer.type\n      }) : undefined : previousSubscriberOffer ? toProtoSessionDescription({\n        sdp: previousSubscriberOffer.sdp,\n        type: previousSubscriberOffer.type\n      }) : undefined,\n      subscription: new UpdateSubscription({\n        trackSids,\n        subscribe: !autoSubscribe,\n        participantTracks: []\n      }),\n      publishTracks: getTrackPublicationInfo(localTracks),\n      dataChannels: this.dataChannelsInfo(),\n      trackSidsDisabled,\n      datachannelReceiveStates: this.reliableReceivedState.map((seq, sid) => {\n        return new DataChannelReceiveState({\n          publisherSid: sid,\n          lastSeq: seq\n        });\n      })\n    }));\n  }\n  /* @internal */\n  failNext() {\n    // debugging method to fail the next reconnect/resume attempt\n    this.shouldFailNext = true;\n  }\n  dataChannelsInfo() {\n    const infos = [];\n    const getInfo = (dc, target) => {\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n        infos.push(new DataChannelInfo({\n          label: dc.label,\n          id: dc.id,\n          target\n        }));\n      }\n    };\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n    return infos;\n  }\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\n    }\n  }\n  clearPendingReconnect() {\n    this.clearReconnectTimeout();\n    this.reconnectAttempts = 0;\n  }\n  registerOnLineListener() {\n    if (isWeb()) {\n      window.addEventListener('online', this.handleBrowserOnLine);\n      window.addEventListener('offline', this.handleBrowserOffline);\n    }\n  }\n  deregisterOnLineListener() {\n    if (isWeb()) {\n      window.removeEventListener('online', this.handleBrowserOnLine);\n      window.removeEventListener('offline', this.handleBrowserOffline);\n    }\n  }\n  getTrackIdForReceiver(receiver) {\n    var _a;\n    const mid = (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getMidForReceiver(receiver);\n    if (mid) {\n      const match = Object.entries(this.midToTrackId).find(_ref2 => {\n        let [key] = _ref2;\n        return key === mid;\n      });\n      if (match) {\n        return match[1];\n      }\n    }\n  }\n}\nfunction supportOptionalDatachannel(protocol) {\n  return protocol !== undefined && protocol > 13;\n}\nfunction applyUserDataCompat(newObj, oldObj) {\n  const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\n  newObj.participantIdentity = participantIdentity;\n  oldObj.participantIdentity = participantIdentity;\n  const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\n  newObj.destinationIdentities = destinationIdentities;\n  oldObj.destinationIdentities = destinationIdentities;\n}class BaseStreamReader {\n  get info() {\n    return this._info;\n  }\n  /** @internal */\n  validateBytesReceived() {\n    let doneReceiving = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (typeof this.totalByteSize !== 'number' || this.totalByteSize === 0) {\n      return;\n    }\n    if (doneReceiving && this.bytesReceived < this.totalByteSize) {\n      throw new DataStreamError(\"Not enough chunk(s) received - expected \".concat(this.totalByteSize, \" bytes of data total, only received \").concat(this.bytesReceived, \" bytes\"), DataStreamErrorReason.Incomplete);\n    } else if (this.bytesReceived > this.totalByteSize) {\n      throw new DataStreamError(\"Extra chunk(s) received - expected \".concat(this.totalByteSize, \" bytes of data total, received \").concat(this.bytesReceived, \" bytes\"), DataStreamErrorReason.LengthExceeded);\n    }\n  }\n  constructor(info, stream, totalByteSize, outOfBandFailureRejectingFuture) {\n    this.reader = stream;\n    this.totalByteSize = totalByteSize;\n    this._info = info;\n    this.bytesReceived = 0;\n    this.outOfBandFailureRejectingFuture = outOfBandFailureRejectingFuture;\n  }\n}\nclass ByteStreamReader extends BaseStreamReader {\n  handleChunkReceived(chunk) {\n    var _a;\n    this.bytesReceived += chunk.content.byteLength;\n    this.validateBytesReceived();\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n  }\n  [Symbol.asyncIterator]() {\n    const reader = this.reader.getReader();\n    let rejectingSignalFuture = new Future();\n    let activeSignal = null;\n    let onAbort = null;\n    if (this.signal) {\n      const signal = this.signal;\n      onAbort = () => {\n        var _a;\n        (_a = rejectingSignalFuture.reject) === null || _a === void 0 ? void 0 : _a.call(rejectingSignalFuture, signal.reason);\n      };\n      signal.addEventListener('abort', onAbort);\n      activeSignal = signal;\n    }\n    const cleanup = () => {\n      reader.releaseLock();\n      if (activeSignal && onAbort) {\n        activeSignal.removeEventListener('abort', onAbort);\n      }\n      this.signal = undefined;\n    };\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n          const {\n            done,\n            value\n          } = yield Promise.race([reader.read(),\n          // Rejects if this.signal is aborted\n          rejectingSignalFuture.promise,\n          // Rejects if something external says it should, like a participant disconnecting, etc\n          (_b = (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0 ? void 0 : _a.promise) !== null && _b !== void 0 ? _b : new Promise(() => {\n            /* never resolves */\n          })]);\n          if (done) {\n            this.validateBytesReceived(true);\n            return {\n              done: true,\n              value: undefined\n            };\n          } else {\n            this.handleChunkReceived(value);\n            return {\n              done: false,\n              value: value.content\n            };\n          }\n        } catch (err) {\n          cleanup();\n          throw err;\n        }\n      }),\n      // note: `return` runs only for premature exits, see:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration\n      return() {\n        return __awaiter(this, void 0, void 0, function* () {\n          cleanup();\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n      }\n    };\n  }\n  /**\n   * Injects an AbortSignal, which if aborted, will terminate the currently active\n   * stream iteration operation.\n   *\n   * Note that when using AbortSignal.timeout(...), the timeout applies across\n   * the whole iteration operation, not just one individual chunk read.\n   */\n  withAbortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  readAll() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this = this;\n      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function* () {\n        var _a, e_1, _b, _c;\n        let chunks = new Set();\n        const iterator = opts.signal ? _this.withAbortSignal(opts.signal) : _this;\n        try {\n          for (var _d = true, iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = yield iterator_1.next(), _a = iterator_1_1.done, !_a; _d = true) {\n            _c = iterator_1_1.value;\n            _d = false;\n            const chunk = _c;\n            chunks.add(chunk);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = iterator_1.return)) yield _b.call(iterator_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n        return Array.from(chunks);\n      }();\n    });\n  }\n}\n/**\n * A class to read chunks from a ReadableStream and provide them in a structured format.\n */\nclass TextStreamReader extends BaseStreamReader {\n  /**\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\n   * that has been received up to the current point in time.\n   */\n  constructor(info, stream, totalChunkCount, outOfBandFailureRejectingFuture) {\n    super(info, stream, totalChunkCount, outOfBandFailureRejectingFuture);\n    this.receivedChunks = new Map();\n  }\n  handleChunkReceived(chunk) {\n    var _a;\n    const index = bigIntToNumber(chunk.chunkIndex);\n    const previousChunkAtIndex = this.receivedChunks.get(index);\n    if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\n      // we have a newer version already, dropping the old one\n      return;\n    }\n    this.receivedChunks.set(index, chunk);\n    this.bytesReceived += chunk.content.byteLength;\n    this.validateBytesReceived();\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n  }\n  /**\n   * Async iterator implementation to allow usage of `for await...of` syntax.\n   * Yields structured chunks from the stream.\n   *\n   */\n  [Symbol.asyncIterator]() {\n    const reader = this.reader.getReader();\n    const decoder = new TextDecoder('utf-8', {\n      fatal: true\n    });\n    let rejectingSignalFuture = new Future();\n    let activeSignal = null;\n    let onAbort = null;\n    if (this.signal) {\n      const signal = this.signal;\n      onAbort = () => {\n        var _a;\n        (_a = rejectingSignalFuture.reject) === null || _a === void 0 ? void 0 : _a.call(rejectingSignalFuture, signal.reason);\n      };\n      signal.addEventListener('abort', onAbort);\n      activeSignal = signal;\n    }\n    const cleanup = () => {\n      reader.releaseLock();\n      if (activeSignal && onAbort) {\n        activeSignal.removeEventListener('abort', onAbort);\n      }\n      this.signal = undefined;\n    };\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n          const {\n            done,\n            value\n          } = yield Promise.race([reader.read(),\n          // Rejects if this.signal is aborted\n          rejectingSignalFuture.promise,\n          // Rejects if something external says it should, like a participant disconnecting, etc\n          (_b = (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0 ? void 0 : _a.promise) !== null && _b !== void 0 ? _b : new Promise(() => {\n            /* never resolves */\n          })]);\n          if (done) {\n            this.validateBytesReceived(true);\n            return {\n              done: true,\n              value: undefined\n            };\n          } else {\n            this.handleChunkReceived(value);\n            let decodedResult;\n            try {\n              decodedResult = decoder.decode(value.content);\n            } catch (err) {\n              throw new DataStreamError(\"Cannot decode datastream chunk \".concat(value.chunkIndex, \" as text: \").concat(err), DataStreamErrorReason.DecodeFailed);\n            }\n            return {\n              done: false,\n              value: decodedResult\n            };\n          }\n        } catch (err) {\n          cleanup();\n          throw err;\n        }\n      }),\n      // note: `return` runs only for premature exits, see:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration\n      return() {\n        return __awaiter(this, void 0, void 0, function* () {\n          cleanup();\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n      }\n    };\n  }\n  /**\n   * Injects an AbortSignal, which if aborted, will terminate the currently active\n   * stream iteration operation.\n   *\n   * Note that when using AbortSignal.timeout(...), the timeout applies across\n   * the whole iteration operation, not just one individual chunk read.\n   */\n  withAbortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  readAll() {\n    return __awaiter(this, arguments, void 0, function () {\n      var _this2 = this;\n      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function* () {\n        var _a, e_2, _b, _c;\n        let finalString = '';\n        const iterator = opts.signal ? _this2.withAbortSignal(opts.signal) : _this2;\n        try {\n          for (var _d = true, iterator_2 = __asyncValues(iterator), iterator_2_1; iterator_2_1 = yield iterator_2.next(), _a = iterator_2_1.done, !_a; _d = true) {\n            _c = iterator_2_1.value;\n            _d = false;\n            const chunk = _c;\n            finalString += chunk;\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (!_d && !_a && (_b = iterator_2.return)) yield _b.call(iterator_2);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n        return finalString;\n      }();\n    });\n  }\n}class IncomingDataStreamManager {\n  constructor() {\n    this.log = livekitLogger;\n    this.byteStreamControllers = new Map();\n    this.textStreamControllers = new Map();\n    this.byteStreamHandlers = new Map();\n    this.textStreamHandlers = new Map();\n  }\n  registerTextStreamHandler(topic, callback) {\n    if (this.textStreamHandlers.has(topic)) {\n      throw new DataStreamError(\"A text stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"), DataStreamErrorReason.HandlerAlreadyRegistered);\n    }\n    this.textStreamHandlers.set(topic, callback);\n  }\n  unregisterTextStreamHandler(topic) {\n    this.textStreamHandlers.delete(topic);\n  }\n  registerByteStreamHandler(topic, callback) {\n    if (this.byteStreamHandlers.has(topic)) {\n      throw new DataStreamError(\"A byte stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"), DataStreamErrorReason.HandlerAlreadyRegistered);\n    }\n    this.byteStreamHandlers.set(topic, callback);\n  }\n  unregisterByteStreamHandler(topic) {\n    this.byteStreamHandlers.delete(topic);\n  }\n  clearControllers() {\n    this.byteStreamControllers.clear();\n    this.textStreamControllers.clear();\n  }\n  validateParticipantHasNoActiveDataStreams(participantIdentity) {\n    var _a, _b, _c, _d;\n    // Terminate any in flight data stream receives from the given participant\n    const textStreamsBeingSentByDisconnectingParticipant = Array.from(this.textStreamControllers.entries()).filter(entry => entry[1].sendingParticipantIdentity === participantIdentity);\n    const byteStreamsBeingSentByDisconnectingParticipant = Array.from(this.byteStreamControllers.entries()).filter(entry => entry[1].sendingParticipantIdentity === participantIdentity);\n    if (textStreamsBeingSentByDisconnectingParticipant.length > 0 || byteStreamsBeingSentByDisconnectingParticipant.length > 0) {\n      const abnormalEndError = new DataStreamError(\"Participant \".concat(participantIdentity, \" unexpectedly disconnected in the middle of sending data\"), DataStreamErrorReason.AbnormalEnd);\n      for (const [id, controller] of byteStreamsBeingSentByDisconnectingParticipant) {\n        (_b = (_a = controller.outOfBandFailureRejectingFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, abnormalEndError);\n        this.byteStreamControllers.delete(id);\n      }\n      for (const [id, controller] of textStreamsBeingSentByDisconnectingParticipant) {\n        (_d = (_c = controller.outOfBandFailureRejectingFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, abnormalEndError);\n        this.textStreamControllers.delete(id);\n      }\n    }\n  }\n  handleDataStreamPacket(packet, encryptionType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      switch (packet.value.case) {\n        case 'streamHeader':\n          return this.handleStreamHeader(packet.value.value, packet.participantIdentity, encryptionType);\n        case 'streamChunk':\n          return this.handleStreamChunk(packet.value.value, encryptionType);\n        case 'streamTrailer':\n          return this.handleStreamTrailer(packet.value.value, encryptionType);\n        default:\n          throw new Error(\"DataPacket of value \\\"\".concat(packet.value.case, \"\\\" is not data stream related!\"));\n      }\n    });\n  }\n  handleStreamHeader(streamHeader, participantIdentity, encryptionType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (streamHeader.contentHeader.case === 'byteHeader') {\n        const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\n        if (!streamHandlerCallback) {\n          this.log.debug('ignoring incoming byte stream due to no handler for topic', streamHeader.topic);\n          return;\n        }\n        let streamController;\n        const outOfBandFailureRejectingFuture = new Future();\n        outOfBandFailureRejectingFuture.promise.catch(err => {\n          this.log.error(err);\n        });\n        const info = {\n          id: streamHeader.streamId,\n          name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : 'unknown',\n          mimeType: streamHeader.mimeType,\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n          topic: streamHeader.topic,\n          timestamp: bigIntToNumber(streamHeader.timestamp),\n          attributes: streamHeader.attributes,\n          encryptionType\n        };\n        const stream = new ReadableStream({\n          start: controller => {\n            streamController = controller;\n            if (this.textStreamControllers.has(streamHeader.streamId)) {\n              throw new DataStreamError(\"A data stream read is already in progress for a stream with id \".concat(streamHeader.streamId, \".\"), DataStreamErrorReason.AlreadyOpened);\n            }\n            this.byteStreamControllers.set(streamHeader.streamId, {\n              info,\n              controller: streamController,\n              startTime: Date.now(),\n              sendingParticipantIdentity: participantIdentity,\n              outOfBandFailureRejectingFuture\n            });\n          }\n        });\n        streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength), outOfBandFailureRejectingFuture), {\n          identity: participantIdentity\n        });\n      } else if (streamHeader.contentHeader.case === 'textHeader') {\n        const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\n        if (!streamHandlerCallback) {\n          this.log.debug('ignoring incoming text stream due to no handler for topic', streamHeader.topic);\n          return;\n        }\n        let streamController;\n        const outOfBandFailureRejectingFuture = new Future();\n        outOfBandFailureRejectingFuture.promise.catch(err => {\n          this.log.error(err);\n        });\n        const info = {\n          id: streamHeader.streamId,\n          mimeType: streamHeader.mimeType,\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n          topic: streamHeader.topic,\n          timestamp: Number(streamHeader.timestamp),\n          attributes: streamHeader.attributes,\n          encryptionType\n        };\n        const stream = new ReadableStream({\n          start: controller => {\n            streamController = controller;\n            if (this.textStreamControllers.has(streamHeader.streamId)) {\n              throw new DataStreamError(\"A data stream read is already in progress for a stream with id \".concat(streamHeader.streamId, \".\"), DataStreamErrorReason.AlreadyOpened);\n            }\n            this.textStreamControllers.set(streamHeader.streamId, {\n              info,\n              controller: streamController,\n              startTime: Date.now(),\n              sendingParticipantIdentity: participantIdentity,\n              outOfBandFailureRejectingFuture\n            });\n          }\n        });\n        streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength), outOfBandFailureRejectingFuture), {\n          identity: participantIdentity\n        });\n      }\n    });\n  }\n  handleStreamChunk(chunk, encryptionType) {\n    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\n    if (fileBuffer) {\n      if (fileBuffer.info.encryptionType !== encryptionType) {\n        fileBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(chunk.streamId, \". Expected \").concat(encryptionType, \", got \").concat(fileBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n        this.byteStreamControllers.delete(chunk.streamId);\n      } else if (chunk.content.length > 0) {\n        fileBuffer.controller.enqueue(chunk);\n      }\n    }\n    const textBuffer = this.textStreamControllers.get(chunk.streamId);\n    if (textBuffer) {\n      if (textBuffer.info.encryptionType !== encryptionType) {\n        textBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(chunk.streamId, \". Expected \").concat(encryptionType, \", got \").concat(textBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n        this.textStreamControllers.delete(chunk.streamId);\n      } else if (chunk.content.length > 0) {\n        textBuffer.controller.enqueue(chunk);\n      }\n    }\n  }\n  handleStreamTrailer(trailer, encryptionType) {\n    const textBuffer = this.textStreamControllers.get(trailer.streamId);\n    if (textBuffer) {\n      if (textBuffer.info.encryptionType !== encryptionType) {\n        textBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(trailer.streamId, \". Expected \").concat(encryptionType, \", got \").concat(textBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n      } else {\n        textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\n        textBuffer.controller.close();\n        this.textStreamControllers.delete(trailer.streamId);\n      }\n    }\n    const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\n    if (fileBuffer) {\n      if (fileBuffer.info.encryptionType !== encryptionType) {\n        fileBuffer.controller.error(new DataStreamError(\"Encryption type mismatch for stream \".concat(trailer.streamId, \". Expected \").concat(encryptionType, \", got \").concat(fileBuffer.info.encryptionType), DataStreamErrorReason.EncryptionTypeMismatch));\n      } else {\n        fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\n        fileBuffer.controller.close();\n      }\n      this.byteStreamControllers.delete(trailer.streamId);\n    }\n  }\n}class BaseStreamWriter {\n  constructor(writableStream, info, onClose) {\n    this.writableStream = writableStream;\n    this.defaultWriter = writableStream.getWriter();\n    this.onClose = onClose;\n    this.info = info;\n  }\n  write(chunk) {\n    return this.defaultWriter.write(chunk);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield this.defaultWriter.close();\n      this.defaultWriter.releaseLock();\n      (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\n    });\n  }\n}\nclass TextStreamWriter extends BaseStreamWriter {}\nclass ByteStreamWriter extends BaseStreamWriter {}const STREAM_CHUNK_SIZE = 15000;\n/**\n * Manages sending custom user data via data channels.\n * @internal\n */\nclass OutgoingDataStreamManager {\n  constructor(engine, log) {\n    this.engine = engine;\n    this.log = log;\n  }\n  setupEngine(engine) {\n    this.engine = engine;\n  }\n  /** {@inheritDoc LocalParticipant.sendText} */\n  sendText(text, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const streamId = crypto.randomUUID();\n      const textInBytes = new TextEncoder().encode(text);\n      const totalTextLength = textInBytes.byteLength;\n      const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => crypto.randomUUID());\n      const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\n      const handleProgress = (progress, idx) => {\n        var _a;\n        progresses[idx] = progress;\n        const totalProgress = progresses.reduce((acc, val) => acc + val, 0);\n        (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\n      };\n      const writer = yield this.streamText({\n        streamId,\n        totalSize: totalTextLength,\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\n        topic: options === null || options === void 0 ? void 0 : options.topic,\n        attachedStreamIds: fileIds,\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\n      });\n      yield writer.write(text);\n      // set text part of progress to 1\n      handleProgress(1, 0);\n      yield writer.close();\n      if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\n        yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {\n          return this._sendFile(fileIds[idx], file, {\n            topic: options.topic,\n            mimeType: file.type,\n            onProgress: progress => {\n              handleProgress(progress, idx + 1);\n            }\n          });\n        })));\n      }\n      return writer.info;\n    });\n  }\n  /**\n   * @internal\n   */\n  streamText(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n      const info = {\n        id: streamId,\n        mimeType: 'text/plain',\n        timestamp: Date.now(),\n        topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : '',\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\n        attributes: options === null || options === void 0 ? void 0 : options.attributes,\n        encryptionType: ((_c = this.engine.e2eeManager) === null || _c === void 0 ? void 0 : _c.isDataChannelEncryptionEnabled) ? Encryption_Type.GCM : Encryption_Type.NONE\n      };\n      const header = new DataStream_Header({\n        streamId,\n        mimeType: info.mimeType,\n        topic: info.topic,\n        timestamp: numberToBigInt(info.timestamp),\n        totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\n        attributes: info.attributes,\n        contentHeader: {\n          case: 'textHeader',\n          value: new DataStream_TextHeader({\n            version: options === null || options === void 0 ? void 0 : options.version,\n            attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\n            replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\n            operationType: (options === null || options === void 0 ? void 0 : options.type) === 'update' ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\n          })\n        }\n      });\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n      const packet = new DataPacket({\n        destinationIdentities,\n        value: {\n          case: 'streamHeader',\n          value: header\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      let chunkId = 0;\n      const engine = this.engine;\n      const writableStream = new WritableStream({\n        // Implement the sink\n        write(text) {\n          return __awaiter(this, void 0, void 0, function* () {\n            for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {\n              const chunk = new DataStream_Chunk({\n                content: textByteChunk,\n                streamId,\n                chunkIndex: numberToBigInt(chunkId)\n              });\n              const chunkPacket = new DataPacket({\n                destinationIdentities,\n                value: {\n                  case: 'streamChunk',\n                  value: chunk\n                }\n              });\n              yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n              chunkId += 1;\n            }\n          });\n        },\n        close() {\n          return __awaiter(this, void 0, void 0, function* () {\n            const trailer = new DataStream_Trailer({\n              streamId\n            });\n            const trailerPacket = new DataPacket({\n              destinationIdentities,\n              value: {\n                case: 'streamTrailer',\n                value: trailer\n              }\n            });\n            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n          });\n        },\n        abort(err) {\n          console.log('Sink error:', err);\n          // TODO handle aborts to signal something to receiver side\n        }\n      });\n      let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {\n        yield writer.close();\n      });\n      engine.once(EngineEvent.Closing, onEngineClose);\n      const writer = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));\n      return writer;\n    });\n  }\n  sendFile(file, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const streamId = crypto.randomUUID();\n      yield this._sendFile(streamId, file, options);\n      return {\n        id: streamId\n      };\n    });\n  }\n  _sendFile(streamId, file, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const writer = yield this.streamBytes({\n        streamId,\n        totalSize: file.size,\n        name: file.name,\n        mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\n        topic: options === null || options === void 0 ? void 0 : options.topic,\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\n      });\n      const reader = file.stream().getReader();\n      while (true) {\n        const {\n          done,\n          value\n        } = yield reader.read();\n        if (done) {\n          break;\n        }\n        yield writer.write(value);\n      }\n      yield writer.close();\n      return writer.info;\n    });\n  }\n  streamBytes(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e, _f;\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n      const info = {\n        id: streamId,\n        mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : 'application/octet-stream',\n        topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : '',\n        timestamp: Date.now(),\n        attributes: options === null || options === void 0 ? void 0 : options.attributes,\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\n        name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : 'unknown',\n        encryptionType: ((_e = this.engine.e2eeManager) === null || _e === void 0 ? void 0 : _e.isDataChannelEncryptionEnabled) ? Encryption_Type.GCM : Encryption_Type.NONE\n      };\n      const header = new DataStream_Header({\n        totalLength: numberToBigInt((_f = info.size) !== null && _f !== void 0 ? _f : 0),\n        mimeType: info.mimeType,\n        streamId,\n        topic: info.topic,\n        timestamp: numberToBigInt(Date.now()),\n        attributes: info.attributes,\n        contentHeader: {\n          case: 'byteHeader',\n          value: new DataStream_ByteHeader({\n            name: info.name\n          })\n        }\n      });\n      const packet = new DataPacket({\n        destinationIdentities,\n        value: {\n          case: 'streamHeader',\n          value: header\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      let chunkId = 0;\n      const writeMutex = new _();\n      const engine = this.engine;\n      const logLocal = this.log;\n      const writableStream = new WritableStream({\n        write(chunk) {\n          return __awaiter(this, void 0, void 0, function* () {\n            const unlock = yield writeMutex.lock();\n            let byteOffset = 0;\n            try {\n              while (byteOffset < chunk.byteLength) {\n                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\n                const chunkPacket = new DataPacket({\n                  destinationIdentities,\n                  value: {\n                    case: 'streamChunk',\n                    value: new DataStream_Chunk({\n                      content: subChunk,\n                      streamId,\n                      chunkIndex: numberToBigInt(chunkId)\n                    })\n                  }\n                });\n                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                chunkId += 1;\n                byteOffset += subChunk.byteLength;\n              }\n            } finally {\n              unlock();\n            }\n          });\n        },\n        close() {\n          return __awaiter(this, void 0, void 0, function* () {\n            const trailer = new DataStream_Trailer({\n              streamId\n            });\n            const trailerPacket = new DataPacket({\n              destinationIdentities,\n              value: {\n                case: 'streamTrailer',\n                value: trailer\n              }\n            });\n            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n          });\n        },\n        abort(err) {\n          logLocal.error('Sink error:', err);\n        }\n      });\n      const byteWriter = new ByteStreamWriter(writableStream, info);\n      return byteWriter;\n    });\n  }\n}class RemoteTrack extends Track {\n  constructor(mediaTrack, sid, kind, receiver, loggerOptions) {\n    super(mediaTrack, kind, loggerOptions);\n    this.sid = sid;\n    this.receiver = receiver;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** @internal */\n  setMuted(muted) {\n    if (this.isMuted !== muted) {\n      this.isMuted = muted;\n      this._mediaStreamTrack.enabled = !muted;\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n  }\n  /** @internal */\n  setMediaStream(stream) {\n    // this is needed to determine when the track is finished\n    this.mediaStream = stream;\n    const onRemoveTrack = event => {\n      if (event.track === this._mediaStreamTrack) {\n        stream.removeEventListener('removetrack', onRemoveTrack);\n        if (this.receiver && 'playoutDelayHint' in this.receiver) {\n          this.receiver.playoutDelayHint = undefined;\n        }\n        this.receiver = undefined;\n        this._currentBitrate = 0;\n        this.emit(TrackEvent.Ended, this);\n      }\n    };\n    stream.addEventListener('removetrack', onRemoveTrack);\n  }\n  start() {\n    this.startMonitor();\n    // use `enabled` of track to enable re-use of transceiver\n    super.enable();\n  }\n  stop() {\n    this.stopMonitor();\n    // use `enabled` of track to enable re-use of transceiver\n    super.disable();\n  }\n  /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n        return;\n      }\n      const statsReport = yield this.receiver.getStats();\n      return statsReport;\n    });\n  }\n  /**\n   * Allows to set a playout delay (in seconds) for this track.\n   * A higher value allows for more buffering of the track in the browser\n   * and will result in a delay of media being played back of `delayInSeconds`\n   */\n  setPlayoutDelay(delayInSeconds) {\n    if (this.receiver) {\n      if ('playoutDelayHint' in this.receiver) {\n        this.receiver.playoutDelayHint = delayInSeconds;\n      } else {\n        this.log.warn('Playout delay not supported in this browser');\n      }\n    } else {\n      this.log.warn('Cannot set playout delay, track already ended');\n    }\n  }\n  /**\n   * Returns the current playout delay (in seconds) of this track.\n   */\n  getPlayoutDelay() {\n    if (this.receiver) {\n      if ('playoutDelayHint' in this.receiver) {\n        return this.receiver.playoutDelayHint;\n      } else {\n        this.log.warn('Playout delay not supported in this browser');\n      }\n    } else {\n      this.log.warn('Cannot get playout delay, track already ended');\n    }\n    return 0;\n  }\n  /* @internal */\n  startMonitor() {\n    if (!this.monitorInterval) {\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\n    }\n    if (supportsSynchronizationSources()) {\n      this.registerTimeSyncUpdate();\n    }\n  }\n  registerTimeSyncUpdate() {\n    const loop = () => {\n      var _a;\n      this.timeSyncHandle = requestAnimationFrame(() => loop());\n      const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\n      if (sources) {\n        const {\n          timestamp,\n          rtpTimestamp\n        } = sources;\n        if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\n          this.emit(TrackEvent.TimeSyncUpdate, {\n            timestamp,\n            rtpTimestamp\n          });\n          this.rtpTimestamp = rtpTimestamp;\n        }\n      }\n    };\n    loop();\n  }\n}class RemoteAudioTrack extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {\n    super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.audioContext = audioContext;\n    this.webAudioPluginNodes = [];\n    if (audioOutput) {\n      this.sinkId = audioOutput.deviceId;\n    }\n  }\n  /**\n   * sets the volume for all attached audio elements\n   */\n  setVolume(volume) {\n    var _a;\n    for (const el of this.attachedElements) {\n      if (this.audioContext) {\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n      } else {\n        el.volume = volume;\n      }\n    }\n    if (isReactNative()) {\n      // @ts-ignore\n      this._mediaStreamTrack._setVolume(volume);\n    }\n    this.elementVolume = volume;\n  }\n  /**\n   * gets the volume of attached audio elements (loudest)\n   */\n  getVolume() {\n    if (this.elementVolume) {\n      return this.elementVolume;\n    }\n    if (isReactNative()) {\n      // RN volume value defaults to 1.0 if hasn't been changed.\n      return 1.0;\n    }\n    let highestVolume = 0;\n    this.attachedElements.forEach(element => {\n      if (element.volume > highestVolume) {\n        highestVolume = element.volume;\n      }\n    });\n    return highestVolume;\n  }\n  /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */\n  setSinkId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.sinkId = deviceId;\n      yield Promise.all(this.attachedElements.map(elm => {\n        if (!supportsSetSinkId(elm)) {\n          return;\n        }\n        /* @ts-ignore */\n        return elm.setSinkId(deviceId);\n      }));\n    });\n  }\n  attach(element) {\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    if (this.sinkId && supportsSetSinkId(element)) {\n      element.setSinkId(this.sinkId).catch(e => {\n        this.log.error('Failed to set sink id on remote audio track', e, this.logContext);\n      });\n    }\n    if (this.audioContext && needsNewWebAudioConnection) {\n      this.log.debug('using audio context mapping', this.logContext);\n      this.connectWebAudio(this.audioContext, element);\n      element.volume = 0;\n      element.muted = true;\n    }\n    if (this.elementVolume) {\n      // make sure volume setting is being applied to the newly attached element\n      this.setVolume(this.elementVolume);\n    }\n    return element;\n  }\n  detach(element) {\n    let detached;\n    if (!element) {\n      detached = super.detach();\n      this.disconnectWebAudio();\n    } else {\n      detached = super.detach(element);\n      // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n      // disconnect webaudio otherwise\n      if (this.audioContext) {\n        if (this.attachedElements.length > 0) {\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        } else {\n          this.disconnectWebAudio();\n        }\n      }\n    }\n    return detached;\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(audioContext) {\n    this.audioContext = audioContext;\n    if (audioContext && this.attachedElements.length > 0) {\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\n    } else if (!audioContext) {\n      this.disconnectWebAudio();\n    }\n  }\n  /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */\n  setWebAudioPlugins(nodes) {\n    this.webAudioPluginNodes = nodes;\n    if (this.attachedElements.length > 0 && this.audioContext) {\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n    }\n  }\n  connectWebAudio(context, element) {\n    this.disconnectWebAudio();\n    // @ts-ignore attached elements always have a srcObject set\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\n    let lastNode = this.sourceNode;\n    this.webAudioPluginNodes.forEach(node => {\n      lastNode.connect(node);\n      lastNode = node;\n    });\n    this.gainNode = context.createGain();\n    lastNode.connect(this.gainNode);\n    this.gainNode.connect(context.destination);\n    if (this.elementVolume) {\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n    }\n    // try to resume the context if it isn't running already\n    if (context.state !== 'running') {\n      context.resume().then(() => {\n        if (context.state !== 'running') {\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n        }\n      }).catch(e => {\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\n      });\n    }\n  }\n  disconnectWebAudio() {\n    var _a, _b;\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n    this.gainNode = undefined;\n    this.sourceNode = undefined;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      stats.forEach(v => {\n        if (v.type === 'inbound-rtp') {\n          receiverStats = {\n            type: 'audio',\n            streamId: v.id,\n            timestamp: v.timestamp,\n            jitter: v.jitter,\n            bytesReceived: v.bytesReceived,\n            concealedSamples: v.concealedSamples,\n            concealmentEvents: v.concealmentEvents,\n            silentConcealedSamples: v.silentConcealedSamples,\n            silentConcealmentEvents: v.silentConcealmentEvents,\n            totalAudioEnergy: v.totalAudioEnergy,\n            totalSamplesDuration: v.totalSamplesDuration\n          };\n        }\n      });\n      return receiverStats;\n    });\n  }\n}const REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {\n    super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n    this.elementInfos = [];\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const stats = yield this.getReceiverStats();\n      if (stats && this.prevStats && this.receiver) {\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\n      }\n      this.prevStats = stats;\n    });\n    this.debouncedHandleResize = r(() => {\n      this.updateDimensions();\n    }, REACTION_DELAY);\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\n  }\n  get isAdaptiveStream() {\n    return this.adaptiveStreamSettings !== undefined;\n  }\n  setStreamState(value) {\n    super.setStreamState(value);\n    this.log.debug('setStreamState', value);\n    if (this.isAdaptiveStream && value === Track.StreamState.Active) {\n      // update visibility for adaptive stream tracks when stream state received from server is active\n      // this is needed to ensure the track is stopped when there's no element attached to it at all\n      this.updateVisibility();\n    }\n  }\n  /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /** @internal */\n  setMuted(muted) {\n    super.setMuted(muted);\n    this.attachedElements.forEach(element => {\n      // detach or attach\n      if (muted) {\n        detachTrack(this._mediaStreamTrack, element);\n      } else {\n        attachToElement(this._mediaStreamTrack, element);\n      }\n    });\n  }\n  attach(element) {\n    if (!element) {\n      element = super.attach();\n    } else {\n      super.attach(element);\n    }\n    // It's possible attach is called multiple times on an element. When that's\n    // the case, we'd want to avoid adding duplicate elementInfos\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info.element === element) === undefined) {\n      const elementInfo = new HTMLElementInfo(element);\n      this.observeElementInfo(elementInfo);\n    }\n    return element;\n  }\n  /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */\n  observeElementInfo(elementInfo) {\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info === elementInfo) === undefined) {\n      elementInfo.handleResize = () => {\n        this.debouncedHandleResize();\n      };\n      elementInfo.handleVisibilityChanged = () => {\n        this.updateVisibility();\n      };\n      this.elementInfos.push(elementInfo);\n      elementInfo.observe();\n      // trigger the first resize update cycle\n      // if the tab is backgrounded, the initial resize event does not fire until\n      // the tab comes into focus for the first time.\n      this.debouncedHandleResize();\n      this.updateVisibility();\n    } else {\n      this.log.warn('visibility resize observer not triggered', this.logContext);\n    }\n  }\n  /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */\n  stopObservingElementInfo(elementInfo) {\n    if (!this.isAdaptiveStream) {\n      this.log.warn('stopObservingElementInfo ignored', this.logContext);\n      return;\n    }\n    const stopElementInfos = this.elementInfos.filter(info => info === elementInfo);\n    for (const info of stopElementInfos) {\n      info.stopObserving();\n    }\n    this.elementInfos = this.elementInfos.filter(info => info !== elementInfo);\n    this.updateVisibility();\n    this.debouncedHandleResize();\n  }\n  detach(element) {\n    let detachedElements = [];\n    if (element) {\n      this.stopObservingElement(element);\n      return super.detach(element);\n    }\n    detachedElements = super.detach();\n    for (const e of detachedElements) {\n      this.stopObservingElement(e);\n    }\n    return detachedElements;\n  }\n  /** @internal */\n  getDecoderImplementation() {\n    var _a;\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats) {\n        return;\n      }\n      const stats = yield this.receiver.getStats();\n      let receiverStats;\n      let codecID = '';\n      let codecs = new Map();\n      stats.forEach(v => {\n        if (v.type === 'inbound-rtp') {\n          codecID = v.codecId;\n          receiverStats = {\n            type: 'video',\n            streamId: v.id,\n            framesDecoded: v.framesDecoded,\n            framesDropped: v.framesDropped,\n            framesReceived: v.framesReceived,\n            packetsReceived: v.packetsReceived,\n            packetsLost: v.packetsLost,\n            frameWidth: v.frameWidth,\n            frameHeight: v.frameHeight,\n            pliCount: v.pliCount,\n            firCount: v.firCount,\n            nackCount: v.nackCount,\n            jitter: v.jitter,\n            timestamp: v.timestamp,\n            bytesReceived: v.bytesReceived,\n            decoderImplementation: v.decoderImplementation\n          };\n        } else if (v.type === 'codec') {\n          codecs.set(v.id, v);\n        }\n      });\n      if (receiverStats && codecID !== '' && codecs.get(codecID)) {\n        receiverStats.mimeType = codecs.get(codecID).mimeType;\n      }\n      return receiverStats;\n    });\n  }\n  stopObservingElement(element) {\n    const stopElementInfos = this.elementInfos.filter(info => info.element === element);\n    for (const info of stopElementInfos) {\n      this.stopObservingElementInfo(info);\n    }\n  }\n  handleAppVisibilityChanged() {\n    const _super = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.handleAppVisibilityChanged.call(this);\n      if (!this.isAdaptiveStream) return;\n      this.updateVisibility();\n    });\n  }\n  updateVisibility(forceEmit) {\n    var _a, _b;\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n    ) ? this.isInBackground : false;\n    const isPiPMode = this.elementInfos.some(info => info.pictureInPicture);\n    const isVisible = this.elementInfos.some(info => info.visible) && !backgroundPause || isPiPMode;\n    if (this.lastVisible === isVisible && !forceEmit) {\n      return;\n    }\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n      // delay hidden events\n      CriticalTimers.setTimeout(() => {\n        this.updateVisibility();\n      }, REACTION_DELAY);\n      return;\n    }\n    this.lastVisible = isVisible;\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n  }\n  updateDimensions() {\n    var _a, _b;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    const pixelDensity = this.getPixelDensity();\n    for (const info of this.elementInfos) {\n      const currentElementWidth = info.width() * pixelDensity;\n      const currentElementHeight = info.height() * pixelDensity;\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n        maxWidth = currentElementWidth;\n        maxHeight = currentElementHeight;\n      }\n    }\n    if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n      return;\n    }\n    this.lastDimensions = {\n      width: maxWidth,\n      height: maxHeight\n    };\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n  }\n  getPixelDensity() {\n    var _a;\n    const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n    if (pixelDensity === 'screen') {\n      return getDevicePixelRatio();\n    } else if (!pixelDensity) {\n      // when unset, we'll pick a sane default here.\n      // for higher pixel density devices (mobile phones, etc), we'll use 2\n      // otherwise it defaults to 1\n      const devicePixelRatio = getDevicePixelRatio();\n      if (devicePixelRatio > 2) {\n        return 2;\n      } else {\n        return 1;\n      }\n    }\n    return pixelDensity;\n  }\n}\nclass HTMLElementInfo {\n  get visible() {\n    return this.isPiP || this.isIntersecting;\n  }\n  get pictureInPicture() {\n    return this.isPiP;\n  }\n  constructor(element, visible) {\n    this.onVisibilityChanged = entry => {\n      var _a;\n      const {\n        target,\n        isIntersecting\n      } = entry;\n      if (target === this.element) {\n        this.isIntersecting = isIntersecting;\n        this.isPiP = isElementInPiP(this.element);\n        this.visibilityChangedAt = Date.now();\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n    };\n    this.onEnterPiP = () => {\n      var _a, _b, _c;\n      (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener('pagehide', this.onLeavePiP);\n      this.isPiP = isElementInPiP(this.element);\n      (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\n    };\n    this.onLeavePiP = () => {\n      var _a;\n      this.isPiP = isElementInPiP(this.element);\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element = element;\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n    this.isPiP = isWeb() && isElementInPiP(element);\n    this.visibilityChangedAt = 0;\n  }\n  width() {\n    return this.element.clientWidth;\n  }\n  height() {\n    return this.element.clientHeight;\n  }\n  observe() {\n    var _a, _b, _c;\n    // make sure we update the current visible state once we start to observe\n    this.isIntersecting = isElementInViewport(this.element);\n    this.isPiP = isElementInPiP(this.element);\n    this.element.handleResize = () => {\n      var _a;\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\n    getIntersectionObserver().observe(this.element);\n    getResizeObserver().observe(this.element);\n    this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\n    this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\n    (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener('enter', this.onEnterPiP);\n    (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener('pagehide', this.onLeavePiP);\n  }\n  stopObserving() {\n    var _a, _b, _c, _d, _e;\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n    this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\n    this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\n    (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener('enter', this.onEnterPiP);\n    (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener('pagehide', this.onLeavePiP);\n  }\n}\nfunction isElementInPiP(el) {\n  var _a, _b;\n  // Simple video PiP\n  if (document.pictureInPictureElement === el) return true;\n  // Document PiP\n  if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\n  return false;\n}\n// does not account for occlusion by other elements or opacity property\nfunction isElementInViewport(el, win) {\n  const viewportWindow = win || window;\n  let top = el.offsetTop;\n  let left = el.offsetLeft;\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n  const {\n    hidden\n  } = el;\n  const {\n    display\n  } = getComputedStyle(el);\n  while (el.offsetParent) {\n    el = el.offsetParent;\n    top += el.offsetTop;\n    left += el.offsetLeft;\n  }\n  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== 'none';\n}class TrackPublication extends eventsExports.EventEmitter {\n  constructor(kind, id, name, loggerOptions) {\n    var _a;\n    super();\n    this.metadataMuted = false;\n    this.encryption = Encryption_Type.NONE;\n    this.log = livekitLogger;\n    this.handleMuted = () => {\n      this.emit(TrackEvent.Muted);\n    };\n    this.handleUnmuted = () => {\n      this.emit(TrackEvent.Unmuted);\n    };\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n    this.loggerContextCb = this.loggerContextCb;\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this.trackSid = id;\n    this.trackName = name;\n    this.source = Track.Source.Unknown;\n  }\n  /** @internal */\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Muted, this.handleMuted);\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n    this.track = track;\n    if (track) {\n      // forward events\n      track.on(TrackEvent.Muted, this.handleMuted);\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\n    }\n  }\n  get logContext() {\n    var _a;\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n  }\n  get isMuted() {\n    return this.metadataMuted;\n  }\n  get isEnabled() {\n    return true;\n  }\n  get isSubscribed() {\n    return this.track !== undefined;\n  }\n  get isEncrypted() {\n    return this.encryption !== Encryption_Type.NONE;\n  }\n  /**\n   * an [AudioTrack] if this publication holds an audio track\n   */\n  get audioTrack() {\n    if (isAudioTrack(this.track)) {\n      return this.track;\n    }\n  }\n  /**\n   * an [VideoTrack] if this publication holds a video track\n   */\n  get videoTrack() {\n    if (isVideoTrack(this.track)) {\n      return this.track;\n    }\n  }\n  /** @internal */\n  updateInfo(info) {\n    this.trackSid = info.sid;\n    this.trackName = info.name;\n    this.source = Track.sourceFromProto(info.source);\n    this.mimeType = info.mimeType;\n    if (this.kind === Track.Kind.Video && info.width > 0) {\n      this.dimensions = {\n        width: info.width,\n        height: info.height\n      };\n      this.simulcasted = info.simulcast;\n    }\n    this.encryption = info.encryption;\n    this.trackInfo = info;\n    this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\n      info\n    }));\n  }\n}\n(function (TrackPublication) {\n  (function (SubscriptionStatus) {\n    SubscriptionStatus[\"Desired\"] = \"desired\";\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n  })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n  (function (PermissionStatus) {\n    PermissionStatus[\"Allowed\"] = \"allowed\";\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n  })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));class LocalTrackPublication extends TrackPublication {\n  get isUpstreamPaused() {\n    var _a;\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n  }\n  constructor(kind, ti, track, loggerOptions) {\n    super(kind, ti.sid, ti.name, loggerOptions);\n    this.track = undefined;\n    this.handleTrackEnded = () => {\n      this.emit(TrackEvent.Ended);\n    };\n    this.handleCpuConstrained = () => {\n      if (this.track && isVideoTrack(this.track)) {\n        this.emit(TrackEvent.CpuConstrained, this.track);\n      }\n    };\n    this.updateInfo(ti);\n    this.setTrack(track);\n  }\n  setTrack(track) {\n    if (this.track) {\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n      this.track.off(TrackEvent.CpuConstrained, this.handleCpuConstrained);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n      track.on(TrackEvent.CpuConstrained, this.handleCpuConstrained);\n    }\n  }\n  get isMuted() {\n    if (this.track) {\n      return this.track.isMuted;\n    }\n    return super.isMuted;\n  }\n  get audioTrack() {\n    return super.audioTrack;\n  }\n  get videoTrack() {\n    return super.videoTrack;\n  }\n  get isLocal() {\n    return true;\n  }\n  /**\n   * Mute the track associated with this publication\n   */\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n    });\n  }\n  /**\n   * Unmute track associated with this publication\n   */\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n    });\n  }\n  /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n    });\n  }\n  /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n    });\n  }\n  getTrackFeatures() {\n    var _a;\n    if (isAudioTrack(this.track)) {\n      const settings = this.track.getSourceTrackSettings();\n      const features = new Set();\n      if (settings.autoGainControl) {\n        features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n      }\n      if (settings.echoCancellation) {\n        features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\n      }\n      if (settings.noiseSuppression) {\n        features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n      }\n      if (settings.channelCount && settings.channelCount > 1) {\n        features.add(AudioTrackFeature.TF_STEREO);\n      }\n      if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\n        features.add(AudioTrackFeature.TF_NO_DTX);\n      }\n      if (this.track.enhancedNoiseCancellation) {\n        features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\n      }\n      return Array.from(features.values());\n    } else return [];\n  }\n}/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */\nfunction createLocalTracks(options, loggerOptions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    options !== null && options !== void 0 ? options : options = {};\n    let attemptExactMatch = false;\n    const {\n      audioProcessor,\n      videoProcessor,\n      optionsWithoutProcessor: internalOptions\n    } = extractProcessorsFromOptions(options);\n    let retryAudioOptions = internalOptions.audio;\n    let retryVideoOptions = internalOptions.video;\n    if (audioProcessor && typeof internalOptions.audio === 'object') {\n      internalOptions.audio.processor = audioProcessor;\n    }\n    if (videoProcessor && typeof internalOptions.video === 'object') {\n      internalOptions.video.processor = videoProcessor;\n    }\n    // if the user passes a device id as a string, we default to exact match\n    if (options.audio && typeof internalOptions.audio === 'object' && typeof internalOptions.audio.deviceId === 'string') {\n      const deviceId = internalOptions.audio.deviceId;\n      internalOptions.audio.deviceId = {\n        exact: deviceId\n      };\n      attemptExactMatch = true;\n      retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\n        deviceId: {\n          ideal: deviceId\n        }\n      });\n    }\n    if (internalOptions.video && typeof internalOptions.video === 'object' && typeof internalOptions.video.deviceId === 'string') {\n      const deviceId = internalOptions.video.deviceId;\n      internalOptions.video.deviceId = {\n        exact: deviceId\n      };\n      attemptExactMatch = true;\n      retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\n        deviceId: {\n          ideal: deviceId\n        }\n      });\n    }\n    if (internalOptions.audio === true) {\n      internalOptions.audio = {\n        deviceId: 'default'\n      };\n    } else if (typeof internalOptions.audio === 'object' && internalOptions.audio !== null) {\n      internalOptions.audio = Object.assign(Object.assign({}, internalOptions.audio), {\n        deviceId: internalOptions.audio.deviceId || 'default'\n      });\n    }\n    if (internalOptions.video === true) {\n      internalOptions.video = {\n        deviceId: 'default'\n      };\n    } else if (typeof internalOptions.video === 'object' && !internalOptions.video.deviceId) {\n      internalOptions.video.deviceId = 'default';\n    }\n    const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\n    const constraints = constraintsForOptions(opts);\n    // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n    // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n    if (internalOptions.audio) {\n      DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('audioinput'));\n    }\n    if (internalOptions.video) {\n      DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('videoinput'));\n    }\n    try {\n      const stream = yield mediaPromise;\n      return yield Promise.all(stream.getTracks().map(mediaStreamTrack => __awaiter(this, void 0, void 0, function* () {\n        const isAudio = mediaStreamTrack.kind === 'audio';\n        let trackOptions = isAudio ? opts.audio : opts.video;\n        if (typeof trackOptions === 'boolean' || !trackOptions) {\n          trackOptions = {};\n        }\n        let trackConstraints;\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\n        if (typeof conOrBool !== 'boolean') {\n          trackConstraints = conOrBool;\n        }\n        // update the constraints with the device id the user gave permissions to in the permission prompt\n        // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n        const newDeviceId = mediaStreamTrack.getSettings().deviceId;\n        if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\n          trackConstraints.deviceId = newDeviceId;\n        } else if (!trackConstraints) {\n          trackConstraints = {\n            deviceId: newDeviceId\n          };\n        }\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\n        if (track.kind === Track.Kind.Video) {\n          track.source = Track.Source.Camera;\n        } else if (track.kind === Track.Kind.Audio) {\n          track.source = Track.Source.Microphone;\n        }\n        track.mediaStream = stream;\n        if (isAudioTrack(track) && audioProcessor) {\n          yield track.setProcessor(audioProcessor);\n        } else if (isVideoTrack(track) && videoProcessor) {\n          yield track.setProcessor(videoProcessor);\n        }\n        return track;\n      })));\n    } catch (e) {\n      if (!attemptExactMatch) {\n        throw e;\n      }\n      return createLocalTracks(Object.assign(Object.assign({}, options), {\n        audio: retryAudioOptions,\n        video: retryVideoOptions\n      }), loggerOptions);\n    }\n  });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */\nfunction createLocalVideoTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: false,\n      video: options !== null && options !== void 0 ? options : true\n    });\n    return tracks[0];\n  });\n}\nfunction createLocalAudioTrack(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tracks = yield createLocalTracks({\n      audio: options !== null && options !== void 0 ? options : true,\n      video: false\n    });\n    return tracks[0];\n  });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */\nfunction createLocalScreenTracks(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.resolution === undefined && !isSafari17Based()) {\n      options.resolution = ScreenSharePresets.h1080fps30.resolution;\n    }\n    if (navigator.mediaDevices.getDisplayMedia === undefined) {\n      throw new DeviceUnsupportedError('getDisplayMedia not supported');\n    }\n    const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n    const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n    const tracks = stream.getVideoTracks();\n    if (tracks.length === 0) {\n      throw new TrackInvalidError('no video track found');\n    }\n    const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n    screenVideo.source = Track.Source.ScreenShare;\n    const localTracks = [screenVideo];\n    if (stream.getAudioTracks().length > 0) {\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n      screenAudio.source = Track.Source.ScreenShareAudio;\n      localTracks.push(screenAudio);\n    }\n    return localTracks;\n  });\n}var ConnectionQuality;\n(function (ConnectionQuality) {\n  ConnectionQuality[\"Excellent\"] = \"excellent\";\n  ConnectionQuality[\"Good\"] = \"good\";\n  ConnectionQuality[\"Poor\"] = \"poor\";\n  /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */\n  ConnectionQuality[\"Lost\"] = \"lost\";\n  ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n  switch (q) {\n    case ConnectionQuality$1.EXCELLENT:\n      return ConnectionQuality.Excellent;\n    case ConnectionQuality$1.GOOD:\n      return ConnectionQuality.Good;\n    case ConnectionQuality$1.POOR:\n      return ConnectionQuality.Poor;\n    case ConnectionQuality$1.LOST:\n      return ConnectionQuality.Lost;\n    default:\n      return ConnectionQuality.Unknown;\n  }\n}\nclass Participant extends eventsExports.EventEmitter {\n  get logContext() {\n    var _a, _b;\n    return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n  get isEncrypted() {\n    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every(tr => tr.isEncrypted);\n  }\n  get isAgent() {\n    var _a;\n    return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\n  }\n  get isActive() {\n    var _a;\n    return ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) === ParticipantInfo_State.ACTIVE;\n  }\n  get kind() {\n    return this._kind;\n  }\n  /** participant attributes, similar to metadata, but as a key/value map */\n  get attributes() {\n    return Object.freeze(Object.assign({}, this._attributes));\n  }\n  /** @internal */\n  constructor(sid, identity, name, metadata, attributes, loggerOptions) {\n    let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\n    var _a;\n    super();\n    /** audio level between 0-1.0, 1 being loudest, 0 being softest */\n    this.audioLevel = 0;\n    /** if participant is currently speaking */\n    this.isSpeaking = false;\n    this._connectionQuality = ConnectionQuality.Unknown;\n    this.log = livekitLogger;\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n    this.loggerOptions = loggerOptions;\n    this.setMaxListeners(100);\n    this.sid = sid;\n    this.identity = identity;\n    this.name = name;\n    this.metadata = metadata;\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.trackPublications = new Map();\n    this._kind = kind;\n    this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\n  }\n  getTrackPublications() {\n    return Array.from(this.trackPublications.values());\n  }\n  /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */\n  getTrackPublication(source) {\n    for (const [, pub] of this.trackPublications) {\n      if (pub.source === source) {\n        return pub;\n      }\n    }\n  }\n  /**\n   * Finds the first track that matches the track's name.\n   */\n  getTrackPublicationByName(name) {\n    for (const [, pub] of this.trackPublications) {\n      if (pub.trackName === name) {\n        return pub;\n      }\n    }\n  }\n  /**\n   * Waits until the participant is active and ready to receive data messages\n   * @returns a promise that resolves when the participant is active\n   */\n  waitUntilActive() {\n    if (this.isActive) {\n      return Promise.resolve();\n    }\n    if (this.activeFuture) {\n      return this.activeFuture.promise;\n    }\n    this.activeFuture = new Future();\n    this.once(ParticipantEvent.Active, () => {\n      var _a, _b;\n      (_b = (_a = this.activeFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n      this.activeFuture = undefined;\n    });\n    return this.activeFuture.promise;\n  }\n  get connectionQuality() {\n    return this._connectionQuality;\n  }\n  get isCameraEnabled() {\n    var _a;\n    const track = this.getTrackPublication(Track.Source.Camera);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isMicrophoneEnabled() {\n    var _a;\n    const track = this.getTrackPublication(Track.Source.Microphone);\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n  }\n  get isScreenShareEnabled() {\n    const track = this.getTrackPublication(Track.Source.ScreenShare);\n    return !!track;\n  }\n  get isLocal() {\n    return false;\n  }\n  /** when participant joined the room */\n  get joinedAt() {\n    if (this.participantInfo) {\n      return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n    }\n    return new Date();\n  }\n  /** @internal */\n  updateInfo(info) {\n    var _a;\n    // it's possible the update could be applied out of order due to await\n    // during reconnect sequences. when that happens, it's possible for server\n    // to have sent more recent version of participant info while JS is waiting\n    // to process the existing payload.\n    // when the participant sid remains the same, and we already have a later version\n    // of the payload, they can be safely skipped\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n      return false;\n    }\n    this.identity = info.identity;\n    this.sid = info.sid;\n    this._setName(info.name);\n    this._setMetadata(info.metadata);\n    this._setAttributes(info.attributes);\n    if (info.state === ParticipantInfo_State.ACTIVE && ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) !== ParticipantInfo_State.ACTIVE) {\n      this.emit(ParticipantEvent.Active);\n    }\n    if (info.permission) {\n      this.setPermissions(info.permission);\n    }\n    // set this last so setMetadata can detect changes\n    this.participantInfo = info;\n    return true;\n  }\n  /**\n   * Updates metadata from server\n   **/\n  _setMetadata(md) {\n    const changed = this.metadata !== md;\n    const prevMetadata = this.metadata;\n    this.metadata = md;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n    }\n  }\n  _setName(name) {\n    const changed = this.name !== name;\n    this.name = name;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\n    }\n  }\n  /**\n   * Updates metadata from server\n   **/\n  _setAttributes(attributes) {\n    const diff = diffAttributes(this.attributes, attributes);\n    this._attributes = attributes;\n    if (Object.keys(diff).length > 0) {\n      this.emit(ParticipantEvent.AttributesChanged, diff);\n    }\n  }\n  /** @internal */\n  setPermissions(permissions) {\n    var _a, _b, _c, _d, _e, _f;\n    const prevPermissions = this.permissions;\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\n      var _a;\n      return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n    }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\n    this.permissions = permissions;\n    if (changed) {\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n    }\n    return changed;\n  }\n  /** @internal */\n  setIsSpeaking(speaking) {\n    if (speaking === this.isSpeaking) {\n      return;\n    }\n    this.isSpeaking = speaking;\n    if (speaking) {\n      this.lastSpokeAt = new Date();\n    }\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n  }\n  /** @internal */\n  setConnectionQuality(q) {\n    const prevQuality = this._connectionQuality;\n    this._connectionQuality = qualityFromProto(q);\n    if (prevQuality !== this._connectionQuality) {\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n    }\n  }\n  /**\n   * @internal\n   */\n  setDisconnected() {\n    var _a, _b;\n    if (this.activeFuture) {\n      (_b = (_a = this.activeFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error('Participant disconnected'));\n      this.activeFuture = undefined;\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioContext(ctx) {\n    this.audioContext = ctx;\n    this.audioTrackPublications.forEach(track => isAudioTrack(track.track) && track.track.setAudioContext(ctx));\n  }\n  addTrackPublication(publication) {\n    // forward publication driven events\n    publication.on(TrackEvent.Muted, () => {\n      this.emit(ParticipantEvent.TrackMuted, publication);\n    });\n    publication.on(TrackEvent.Unmuted, () => {\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\n    });\n    const pub = publication;\n    if (pub.track) {\n      pub.track.sid = publication.trackSid;\n    }\n    this.trackPublications.set(publication.trackSid, publication);\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.set(publication.trackSid, publication);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.set(publication.trackSid, publication);\n        break;\n    }\n  }\n}function trackPermissionToProto(perms) {\n  var _a, _b, _c;\n  if (!perms.participantSid && !perms.participantIdentity) {\n    throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\n  }\n  return new TrackPermission({\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n    trackSids: perms.allowedTrackSids || []\n  });\n}class LocalParticipant extends Participant {\n  /** @internal */\n  constructor(sid, identity, engine, options, roomRpcHandlers, roomOutgoingDataStreamManager) {\n    super(sid, identity, undefined, undefined, undefined, {\n      loggerName: options.loggerName,\n      loggerContextCb: () => this.engine.logContext\n    });\n    this.pendingPublishing = new Set();\n    this.pendingPublishPromises = new Map();\n    this.participantTrackPermissions = [];\n    this.allParticipantsAllowedToSubscribe = true;\n    this.encryptionType = Encryption_Type.NONE;\n    this.enabledPublishVideoCodecs = [];\n    this.pendingAcks = new Map();\n    this.pendingResponses = new Map();\n    this.handleReconnecting = () => {\n      if (!this.reconnectFuture) {\n        this.reconnectFuture = new Future();\n      }\n    };\n    this.handleReconnected = () => {\n      var _a, _b;\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n      this.reconnectFuture = undefined;\n      this.updateTrackSubscriptionPermissions();\n    };\n    this.handleClosing = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (this.reconnectFuture) {\n        this.reconnectFuture.promise.catch(e => this.log.warn(e.message, this.logContext));\n        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error('Got disconnected during reconnection attempt'));\n        this.reconnectFuture = undefined;\n      }\n      if (this.signalConnectedFuture) {\n        (_d = (_c = this.signalConnectedFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, new Error('Got disconnected without signal connected'));\n        this.signalConnectedFuture = undefined;\n      }\n      (_f = (_e = this.activeAgentFuture) === null || _e === void 0 ? void 0 : _e.reject) === null || _f === void 0 ? void 0 : _f.call(_e, new Error('Got disconnected without active agent present'));\n      this.activeAgentFuture = undefined;\n      this.firstActiveAgent = undefined;\n    };\n    this.handleSignalConnected = joinResponse => {\n      var _a, _b;\n      if (joinResponse.participant) {\n        this.updateInfo(joinResponse.participant);\n      }\n      if (!this.signalConnectedFuture) {\n        this.signalConnectedFuture = new Future();\n      }\n      (_b = (_a = this.signalConnectedFuture).resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    this.handleSignalRequestResponse = response => {\n      const {\n        requestId,\n        reason,\n        message\n      } = response;\n      const targetRequest = this.pendingSignalRequests.get(requestId);\n      if (targetRequest) {\n        if (reason !== RequestResponse_Reason.OK) {\n          targetRequest.reject(new SignalRequestError(message, reason));\n        }\n        this.pendingSignalRequests.delete(requestId);\n      }\n    };\n    this.handleDataPacket = packet => {\n      switch (packet.value.case) {\n        case 'rpcResponse':\n          let rpcResponse = packet.value.value;\n          let payload = null;\n          let error = null;\n          if (rpcResponse.value.case === 'payload') {\n            payload = rpcResponse.value.value;\n          } else if (rpcResponse.value.case === 'error') {\n            error = RpcError.fromProto(rpcResponse.value.value);\n          }\n          this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\n          break;\n        case 'rpcAck':\n          let rpcAck = packet.value.value;\n          this.handleIncomingRpcAck(rpcAck.requestId);\n          break;\n      }\n    };\n    this.updateTrackSubscriptionPermissions = () => {\n      this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n        participantTrackPermissions: this.participantTrackPermissions\n      }));\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map(p => trackPermissionToProto(p)));\n    };\n    /** @internal */\n    this.onTrackUnmuted = track => {\n      this.onTrackMuted(track, track.isUpstreamPaused);\n    };\n    // when the local track changes in mute status, we'll notify server as such\n    /** @internal */\n    this.onTrackMuted = (track, muted) => {\n      if (muted === undefined) {\n        muted = true;\n      }\n      if (!track.sid) {\n        this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return;\n      }\n      this.engine.updateMuteStatus(track.sid, muted);\n    };\n    this.onTrackUpstreamPaused = track => {\n      this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      this.onTrackMuted(track, true);\n    };\n    this.onTrackUpstreamResumed = track => {\n      this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      this.onTrackMuted(track, track.isMuted);\n    };\n    this.onTrackFeatureUpdate = track => {\n      const pub = this.audioTrackPublications.get(track.sid);\n      if (!pub) {\n        this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\n        return;\n      }\n      this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\n    };\n    this.onTrackCpuConstrained = (track, publication) => {\n      this.log.debug('track cpu constrained', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n      this.emit(ParticipantEvent.LocalTrackCpuConstrained, track, publication);\n    };\n    this.handleSubscribedQualityUpdate = update => __awaiter(this, void 0, void 0, function* () {\n      var _a, e_1, _b, _c;\n      var _d;\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n        return;\n      }\n      const pub = this.videoTrackPublications.get(update.trackSid);\n      if (!pub) {\n        this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: update.trackSid\n        }));\n        return;\n      }\n      if (!pub.videoTrack) {\n        return;\n      }\n      const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n      try {\n        for (var _e = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _e = true) {\n          _c = newCodecs_1_1.value;\n          _e = false;\n          const codec = _c;\n          if (isBackupCodec(codec)) {\n            this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n            yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_e && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n    this.handleLocalTrackUnpublished = unpublished => {\n      const track = this.trackPublications.get(unpublished.trackSid);\n      if (!track) {\n        this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: unpublished.trackSid\n        }));\n        return;\n      }\n      this.unpublishTrack(track.track);\n    };\n    this.handleTrackEnded = track => __awaiter(this, void 0, void 0, function* () {\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n        this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        this.unpublishTrack(track);\n      } else if (track.isUserProvided) {\n        yield track.mute();\n      } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\n        try {\n          if (isWeb()) {\n            try {\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\n                // @ts-ignore\n                name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\n              });\n              if (currentPermissions && currentPermissions.state === 'denied') {\n                this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                // detect granted change after permissions were denied to try and resume then\n                currentPermissions.onchange = () => {\n                  if (currentPermissions.state !== 'denied') {\n                    if (!track.isMuted) {\n                      track.restartTrack();\n                    }\n                    currentPermissions.onchange = null;\n                  }\n                };\n                throw new Error('GetUserMedia Permission denied');\n              }\n            } catch (e) {\n              // permissions query fails for firefox, we continue and try to restart the track\n            }\n          }\n          if (!track.isMuted) {\n            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            if (isLocalAudioTrack(track)) {\n              // fall back to default device if available\n              yield track.restartTrack({\n                deviceId: 'default'\n              });\n            } else {\n              yield track.restartTrack();\n            }\n          }\n        } catch (e) {\n          this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n          yield track.mute();\n        }\n      }\n    });\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.trackPublications = new Map();\n    this.engine = engine;\n    this.roomOptions = options;\n    this.setupEngine(engine);\n    this.activeDeviceMap = new Map([['audioinput', 'default'], ['videoinput', 'default'], ['audiooutput', 'default']]);\n    this.pendingSignalRequests = new Map();\n    this.rpcHandlers = roomRpcHandlers;\n    this.roomOutgoingDataStreamManager = roomOutgoingDataStreamManager;\n  }\n  get lastCameraError() {\n    return this.cameraError;\n  }\n  get lastMicrophoneError() {\n    return this.microphoneError;\n  }\n  get isE2EEEnabled() {\n    return this.encryptionType !== Encryption_Type.NONE;\n  }\n  getTrackPublication(source) {\n    const track = super.getTrackPublication(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackPublicationByName(name) {\n    const track = super.getTrackPublicationByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * @internal\n   */\n  setupEngine(engine) {\n    var _a;\n    this.engine = engine;\n    this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {\n      const pub = this.trackPublications.get(trackSid);\n      if (!pub || !pub.track) {\n        return;\n      }\n      if (muted) {\n        pub.mute();\n      } else {\n        pub.unmute();\n      }\n    });\n    if ((_a = this.signalConnectedFuture) === null || _a === void 0 ? void 0 : _a.isResolved) {\n      this.signalConnectedFuture = undefined;\n    }\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalConnected, this.handleSignalConnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Closing, this.handleClosing).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\n  }\n  /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */\n  setMetadata(metadata) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        metadata\n      });\n    });\n  }\n  /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */\n  setName(name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        name\n      });\n    });\n  }\n  /**\n   * Set or update participant attributes. It will make updates only to keys that\n   * are present in `attributes`, and will not override others.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param attributes attributes to update\n   */\n  setAttributes(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requestMetadataUpdate({\n        attributes\n      });\n    });\n  }\n  requestMetadataUpdate(_a) {\n    return __awaiter(this, arguments, void 0, function (_ref) {\n      var _this = this;\n      let {\n        metadata,\n        name,\n        attributes\n      } = _ref;\n      return function* () {\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\n          var _a, _b;\n          try {\n            let isRejected = false;\n            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : '', (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : '', attributes);\n            const startTime = performance.now();\n            this.pendingSignalRequests.set(requestId, {\n              resolve,\n              reject: error => {\n                reject(error);\n                isRejected = true;\n              },\n              values: {\n                name,\n                metadata,\n                attributes\n              }\n            });\n            while (performance.now() - startTime < 5000 && !isRejected) {\n              if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every(_ref2 => {\n                let [key, value] = _ref2;\n                return this.attributes[key] === value || value === '' && !this.attributes[key];\n              }))) {\n                this.pendingSignalRequests.delete(requestId);\n                resolve();\n                return;\n              }\n              yield sleep(50);\n            }\n            reject(new SignalRequestError('Request to update local metadata timed out', 'TimeoutError'));\n          } catch (e) {\n            if (e instanceof Error) reject(e);\n          }\n        }));\n      }();\n    });\n  }\n  /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setCameraEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n  }\n  /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setMicrophoneEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n  }\n  /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setScreenShareEnabled(enabled, options, publishOptions) {\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n  }\n  /** @internal */\n  setE2EEEnabled(enabled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n      yield this.republishAllTracks(undefined, false);\n    });\n  }\n  setTrackEnabled(source, enabled, options, publishOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\n        source,\n        enabled\n      }));\n      if (this.republishPromise) {\n        yield this.republishPromise;\n      }\n      let track = this.getTrackPublication(source);\n      if (enabled) {\n        if (track) {\n          yield track.unmute();\n        } else {\n          let localTracks;\n          if (this.pendingPublishing.has(source)) {\n            const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\n            if (!pendingTrack) {\n              this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\n                source\n              }));\n            }\n            yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\n            return pendingTrack;\n          }\n          this.pendingPublishing.add(source);\n          try {\n            switch (source) {\n              case Track.Source.Camera:\n                localTracks = yield this.createTracks({\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\n                });\n                break;\n              case Track.Source.Microphone:\n                localTracks = yield this.createTracks({\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                });\n                break;\n              case Track.Source.ScreenShare:\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                break;\n              default:\n                throw new TrackInvalidError(source);\n            }\n          } catch (e) {\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\n              tr.stop();\n            });\n            if (e instanceof Error) {\n              this.emit(ParticipantEvent.MediaDevicesError, e, sourceToKind(source));\n            }\n            this.pendingPublishing.delete(source);\n            throw e;\n          }\n          for (const localTrack of localTracks) {\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            if (source === Track.Source.Microphone && isAudioTrack(localTrack) && opts.preConnectBuffer) {\n              this.log.info('starting preconnect buffer for microphone', Object.assign({}, this.logContext));\n              localTrack.startPreConnectBuffer();\n            }\n          }\n          try {\n            const publishPromises = [];\n            for (const localTrack of localTracks) {\n              this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\n            }\n            const publishedTracks = yield Promise.all(publishPromises);\n            // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n            // revisit if we want to return an array of tracks instead for v2\n            [track] = publishedTracks;\n          } catch (e) {\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\n              tr.stop();\n            });\n            throw e;\n          } finally {\n            this.pendingPublishing.delete(source);\n          }\n        }\n      } else {\n        if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\n          // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\n          track = yield this.waitForPendingPublicationOfSource(source);\n          if (!track) {\n            this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\n              source\n            }));\n          }\n        }\n        if (track && track.track) {\n          // screenshare cannot be muted, unpublish instead\n          if (source === Track.Source.ScreenShare) {\n            track = yield this.unpublishTrack(track.track);\n            const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\n            if (screenAudioTrack && screenAudioTrack.track) {\n              this.unpublishTrack(screenAudioTrack.track);\n            }\n          } else {\n            yield track.mute();\n          }\n        }\n      }\n      return track;\n    });\n  }\n  /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */\n  enableCameraAndMicrophone() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n        // no-op it's already been requested\n        return;\n      }\n      this.pendingPublishing.add(Track.Source.Camera);\n      this.pendingPublishing.add(Track.Source.Microphone);\n      try {\n        const tracks = yield this.createTracks({\n          audio: true,\n          video: true\n        });\n        yield Promise.all(tracks.map(track => this.publishTrack(track)));\n      } finally {\n        this.pendingPublishing.delete(Track.Source.Camera);\n        this.pendingPublishing.delete(Track.Source.Microphone);\n      }\n    });\n  }\n  /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */\n  createTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      options !== null && options !== void 0 ? options : options = {};\n      const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n      try {\n        const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        const localTracks = tracks.map(track => {\n          if (isAudioTrack(track)) {\n            this.microphoneError = undefined;\n            track.setAudioContext(this.audioContext);\n            track.source = Track.Source.Microphone;\n            this.emit(ParticipantEvent.AudioStreamAcquired);\n          }\n          if (isVideoTrack(track)) {\n            this.cameraError = undefined;\n            track.source = Track.Source.Camera;\n          }\n          return track;\n        });\n        return localTracks;\n      } catch (err) {\n        if (err instanceof Error) {\n          if (options.audio) {\n            this.microphoneError = err;\n          }\n          if (options.video) {\n            this.cameraError = err;\n          }\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */\n  createScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options === undefined) {\n        options = {};\n      }\n      if (navigator.mediaDevices.getDisplayMedia === undefined) {\n        throw new DeviceUnsupportedError('getDisplayMedia not supported');\n      }\n      if (options.resolution === undefined && !isSafari17Based()) {\n        // we need to constrain the dimensions, otherwise it could lead to low bitrate\n        // due to encoding a huge video. Encoding such large surfaces is really expensive\n        // unfortunately Safari 17 has a but and cannot be constrained by default\n        options.resolution = ScreenSharePresets.h1080fps30.resolution;\n      }\n      const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n      const tracks = stream.getVideoTracks();\n      if (tracks.length === 0) {\n        throw new TrackInvalidError('no video track found');\n      }\n      const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      screenVideo.source = Track.Source.ScreenShare;\n      if (options.contentHint) {\n        screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n      }\n      const localTracks = [screenVideo];\n      if (stream.getAudioTracks().length > 0) {\n        this.emit(ParticipantEvent.AudioStreamAcquired);\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        screenAudio.source = Track.Source.ScreenShareAudio;\n        localTracks.push(screenAudio);\n      }\n      return localTracks;\n    });\n  }\n  /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */\n  publishTrack(track, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.publishOrRepublishTrack(track, options);\n    });\n  }\n  publishOrRepublishTrack(track_1, options_1) {\n    return __awaiter(this, arguments, void 0, function (track, options) {\n      var _this2 = this;\n      let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return function* () {\n        var _a, _b, _c, _d;\n        if (isLocalAudioTrack(track)) {\n          track.setAudioContext(_this2.audioContext);\n        }\n        yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n        if (_this2.republishPromise && !isRepublish) {\n          yield _this2.republishPromise;\n        }\n        if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\n          yield _this2.pendingPublishPromises.get(track);\n        }\n        let defaultConstraints;\n        if (track instanceof MediaStreamTrack) {\n          defaultConstraints = track.getConstraints();\n        } else {\n          // we want to access constraints directly as `track.mediaStreamTrack`\n          // might be pointing to a non-device track (e.g. processed track) already\n          defaultConstraints = track.constraints;\n          let deviceKind = undefined;\n          switch (track.source) {\n            case Track.Source.Microphone:\n              deviceKind = 'audioinput';\n              break;\n            case Track.Source.Camera:\n              deviceKind = 'videoinput';\n          }\n          if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\n            defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n              deviceId: _this2.activeDeviceMap.get(deviceKind)\n            });\n          }\n        }\n        // convert raw media track into audio or video track\n        if (track instanceof MediaStreamTrack) {\n          switch (track.kind) {\n            case 'audio':\n              track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\n                loggerName: _this2.roomOptions.loggerName,\n                loggerContextCb: () => _this2.logContext\n              });\n              break;\n            case 'video':\n              track = new LocalVideoTrack(track, defaultConstraints, true, {\n                loggerName: _this2.roomOptions.loggerName,\n                loggerContextCb: () => _this2.logContext\n              });\n              break;\n            default:\n              throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n          }\n        } else {\n          track.updateLoggerOptions({\n            loggerName: _this2.roomOptions.loggerName,\n            loggerContextCb: () => _this2.logContext\n          });\n        }\n        // is it already published? if so skip\n        let existingPublication;\n        _this2.trackPublications.forEach(publication => {\n          if (!publication.track) {\n            return;\n          }\n          if (publication.track === track) {\n            existingPublication = publication;\n          }\n        });\n        if (existingPublication) {\n          _this2.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\n          return existingPublication;\n        }\n        const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\n        const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() &&\n        // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n        track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n        const isStereo = (_b = opts.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n        // disable dtx for stereo track if not enabled explicitly\n        if (isStereo) {\n          if (opts.dtx === undefined) {\n            _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\n          }\n          if (opts.red === undefined) {\n            _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n          }\n          (_c = opts.dtx) !== null && _c !== void 0 ? _c : opts.dtx = false;\n          (_d = opts.red) !== null && _d !== void 0 ? _d : opts.red = false;\n        }\n        if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\n          _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\n          opts.simulcast = false;\n        }\n        if (opts.source) {\n          track.source = opts.source;\n        }\n        const publishPromise = new Promise((resolve, reject) => __awaiter(_this2, void 0, void 0, function* () {\n          try {\n            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\n              this.log.debug('deferring track publication until signal is connected', Object.assign(Object.assign({}, this.logContext), {\n                track: getLogContextFromTrack(track)\n              }));\n              let publicationTimedOut = false;\n              const timeout = setTimeout(() => {\n                publicationTimedOut = true;\n                track.stop();\n                reject(new PublishTrackError('publishing rejected as engine not connected within timeout', 408));\n              }, 15000);\n              yield this.waitUntilEngineConnected();\n              clearTimeout(timeout);\n              if (publicationTimedOut) {\n                return;\n              }\n              const publication = yield this.publish(track, opts, isStereo);\n              resolve(publication);\n            } else {\n              try {\n                const publication = yield this.publish(track, opts, isStereo);\n                resolve(publication);\n              } catch (e) {\n                reject(e);\n              }\n            }\n          } catch (e) {\n            reject(e);\n          }\n        }));\n        _this2.pendingPublishPromises.set(track, publishPromise);\n        try {\n          const publication = yield publishPromise;\n          return publication;\n        } catch (e) {\n          throw e;\n        } finally {\n          _this2.pendingPublishPromises.delete(track);\n        }\n      }();\n    });\n  }\n  waitUntilEngineConnected() {\n    if (!this.signalConnectedFuture) {\n      this.signalConnectedFuture = new Future();\n    }\n    return this.signalConnectedFuture.promise;\n  }\n  hasPermissionsToPublish(track) {\n    if (!this.permissions) {\n      this.log.warn('no permissions present for publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      return false;\n    }\n    const {\n      canPublish,\n      canPublishSources\n    } = this.permissions;\n    if (canPublish && (canPublishSources.length === 0 || canPublishSources.map(source => getTrackSourceFromProto(source)).includes(track.source))) {\n      return true;\n    }\n    this.log.warn('insufficient permissions to publish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n    return false;\n  }\n  publish(track, opts, isStereo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n      if (!this.hasPermissionsToPublish(track)) {\n        throw new PublishTrackError('failed to publish track, insufficient permissions', 403);\n      }\n      const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => isLocalTrack(track) && publishedTrack.source === track.source);\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n        this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n      }\n      if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\n        track.stopOnMute = true;\n      }\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\n        // Firefox does not work well with simulcasted screen share\n        // we frequently get no data on layer 0 when enabled\n        opts.simulcast = false;\n      }\n      // require full AV1/VP9 SVC support prior to using it\n      if (opts.videoCodec === 'av1' && !supportsAV1()) {\n        opts.videoCodec = undefined;\n      }\n      if (opts.videoCodec === 'vp9' && !supportsVP9()) {\n        opts.videoCodec = undefined;\n      }\n      if (opts.videoCodec === undefined) {\n        opts.videoCodec = defaultVideoCodec;\n      }\n      if (this.enabledPublishVideoCodecs.length > 0) {\n        // fallback to a supported codec if it is not supported\n        if (!this.enabledPublishVideoCodecs.some(c => opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\n          opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\n        }\n      }\n      const videoCodec = opts.videoCodec;\n      // handle track actions\n      track.on(TrackEvent.Muted, this.onTrackMuted);\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n      const audioFeatures = [];\n      const disableDtx = !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true);\n      const settings = track.getSourceTrackSettings();\n      if (settings.autoGainControl) {\n        audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n      }\n      if (settings.echoCancellation) {\n        audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);\n      }\n      if (settings.noiseSuppression) {\n        audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n      }\n      if (settings.channelCount && settings.channelCount > 1) {\n        audioFeatures.push(AudioTrackFeature.TF_STEREO);\n      }\n      if (disableDtx) {\n        audioFeatures.push(AudioTrackFeature.TF_NO_DTX);\n      }\n      if (isLocalAudioTrack(track) && track.hasPreConnectBuffer) {\n        audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);\n      }\n      // create track publication from track\n      const req = new AddTrackRequest({\n        // get local track id for use during publishing\n        cid: track.mediaStreamTrack.id,\n        name: opts.name,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        disableDtx,\n        encryption: this.encryptionType,\n        stereo: isStereo,\n        disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n        stream: opts === null || opts === void 0 ? void 0 : opts.stream,\n        backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,\n        audioFeatures\n      });\n      // compute encodings and layers for video\n      let encodings;\n      if (track.kind === Track.Kind.Video) {\n        let dims = {\n          width: 0,\n          height: 0\n        };\n        try {\n          dims = yield track.waitForDimensions();\n        } catch (e) {\n          // use defaults, it's quite painful for congestion control without simulcast\n          // so using default dims according to publish settings\n          const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n          dims = {\n            width: defaultRes.width,\n            height: defaultRes.height\n          };\n          // log failure\n          this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n            dims\n          }));\n        }\n        // width and height should be defined for video\n        req.width = dims.width;\n        req.height = dims.height;\n        // for svc codecs, disable simulcast and use vp8 for backup codec\n        if (isLocalVideoTrack(track)) {\n          if (isSVCCodec(videoCodec)) {\n            if (track.source === Track.Source.ScreenShare) {\n              // vp9 svc with screenshare cannot encode multiple spatial layers\n              // doing so reduces publish resolution to minimal resolution\n              opts.scalabilityMode = 'L1T3';\n              // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\n              // It has a different path for screenshare handling and it seems to be untested/buggy\n              // As a workaround, we are setting contentHint to force it to go through the same\n              // path as regular camera video. While this is not optimal, it delivers the performance\n              // that we need\n              if ('contentHint' in track.mediaStreamTrack) {\n                track.mediaStreamTrack.contentHint = 'motion';\n                this.log.info('forcing contentHint to motion for screenshare with SVC codecs', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n              }\n            }\n            // set scalabilityMode to 'L3T3_KEY' by default\n            opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\n          }\n          req.simulcastCodecs = [new SimulcastCodec({\n            codec: videoCodec,\n            cid: track.mediaStreamTrack.id\n          })];\n          // set up backup\n          if (opts.backupCodec === true) {\n            opts.backupCodec = {\n              codec: defaultVideoCodec\n            };\n          }\n          if (opts.backupCodec && videoCodec !== opts.backupCodec.codec &&\n          // TODO remove this once e2ee is supported for backup codecs\n          req.encryption === Encryption_Type.NONE) {\n            // multi-codec simulcast requires dynacast\n            if (!this.roomOptions.dynacast) {\n              this.roomOptions.dynacast = true;\n            }\n            req.simulcastCodecs.push(new SimulcastCodec({\n              codec: opts.backupCodec.codec,\n              cid: ''\n            }));\n          }\n        }\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n        req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n      } else if (track.kind === Track.Kind.Audio) {\n        encodings = [{\n          maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\n          priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : 'high',\n          networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : 'high'\n        }];\n      }\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\n      }\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        if (!this.engine.pcManager) {\n          throw new UnexpectedConnectionState('pcManager is not ready');\n        }\n        track.sender = yield this.engine.createSender(track, opts, encodings);\n        this.emit(ParticipantEvent.LocalSenderCreated, track.sender, track);\n        if (isLocalVideoTrack(track)) {\n          (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\n          track.setDegradationPreference(opts.degradationPreference);\n        }\n        if (encodings) {\n          if (isFireFox() && track.kind === Track.Kind.Audio) {\n            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n               publish high quality audio track. But firefox always uses this value as the actual\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n               fix the issue.\n             */\n            let trackTransceiver = undefined;\n            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\n              if (transceiver.sender === track.sender) {\n                trackTransceiver = transceiver;\n                break;\n              }\n            }\n            if (trackTransceiver) {\n              this.engine.pcManager.publisher.setTrackCodecBitrate({\n                transceiver: trackTransceiver,\n                codec: 'opus',\n                maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n              });\n            }\n          } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\n            this.engine.pcManager.publisher.setTrackCodecBitrate({\n              cid: req.cid,\n              codec: track.codec,\n              maxbr: encodings[0].maxBitrate / 1000\n            });\n          }\n        }\n        yield this.engine.negotiate();\n      });\n      let ti;\n      const addTrackPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n          ti = yield this.engine.addTrack(req);\n          resolve(ti);\n        } catch (err) {\n          if (track.sender && ((_a = this.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher)) {\n            this.engine.pcManager.publisher.removeTrack(track.sender);\n            yield this.engine.negotiate().catch(negotiateErr => {\n              this.log.error('failed to negotiate after removing track due to failed add track request', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                error: negotiateErr\n              }));\n            });\n          }\n          reject(err);\n        }\n      }));\n      if (this.enabledPublishVideoCodecs.length > 0) {\n        const rets = yield Promise.all([addTrackPromise, negotiate()]);\n        ti = rets[0];\n      } else {\n        ti = yield addTrackPromise;\n        // server might not support the codec the client has requested, in that case, fallback\n        // to a supported codec\n        let primaryCodecMime;\n        ti.codecs.forEach(codec => {\n          if (primaryCodecMime === undefined) {\n            primaryCodecMime = codec.mimeType;\n          }\n        });\n        if (primaryCodecMime && track.kind === Track.Kind.Video) {\n          const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n          if (updatedCodec !== videoCodec) {\n            this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n              codec: updatedCodec\n            }));\n            opts.videoCodec = updatedCodec;\n            // recompute encodings since bitrates/etc could have changed\n            encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n          }\n        }\n        yield negotiate();\n      }\n      const publication = new LocalTrackPublication(track.kind, ti, track, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      publication.on(TrackEvent.CpuConstrained, constrainedTrack => this.onTrackCpuConstrained(constrainedTrack, publication));\n      // save options for when it needs to be republished again\n      publication.options = opts;\n      track.sid = ti.sid;\n      this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n        encodings,\n        trackInfo: ti\n      }));\n      if (isLocalVideoTrack(track)) {\n        track.startMonitor(this.engine.client);\n      } else if (isLocalAudioTrack(track)) {\n        track.startMonitor();\n      }\n      this.addTrackPublication(publication);\n      // send event for publication\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\n      if (isLocalAudioTrack(track) && ti.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)) {\n        const stream = track.getPreConnectBuffer();\n        const mimeType = track.getPreConnectBufferMimeType();\n        // TODO: we're registering the listener after negotiation, so there might be a race\n        this.on(ParticipantEvent.LocalTrackSubscribed, pub => {\n          if (pub.trackSid === ti.sid) {\n            if (!track.hasPreConnectBuffer) {\n              this.log.warn('subscribe event came to late, buffer already closed', this.logContext);\n              return;\n            }\n            this.log.debug('finished recording preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            track.stopPreConnectBuffer();\n          }\n        });\n        if (stream) {\n          const bufferStreamPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            var _a, e_2, _b, _c;\n            var _d, _e;\n            try {\n              this.log.debug('waiting for agent', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n              const agentActiveTimeout = setTimeout(() => {\n                reject(new Error('agent not active within 10 seconds'));\n              }, 10000);\n              const agent = yield this.waitUntilActiveAgentPresent();\n              clearTimeout(agentActiveTimeout);\n              this.log.debug('sending preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n              const writer = yield this.streamBytes({\n                name: 'preconnect-buffer',\n                mimeType,\n                topic: 'lk.agent.pre-connect-audio-buffer',\n                destinationIdentities: [agent.identity],\n                attributes: {\n                  trackId: publication.trackSid,\n                  sampleRate: String((_d = settings.sampleRate) !== null && _d !== void 0 ? _d : '48000'),\n                  channels: String((_e = settings.channelCount) !== null && _e !== void 0 ? _e : '1')\n                }\n              });\n              try {\n                for (var _f = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a = stream_1_1.done, !_a; _f = true) {\n                  _c = stream_1_1.value;\n                  _f = false;\n                  const chunk = _c;\n                  yield writer.write(chunk);\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n              yield writer.close();\n              resolve();\n            } catch (e) {\n              reject(e);\n            }\n          }));\n          bufferStreamPromise.then(() => {\n            this.log.debug('preconnect buffer sent successfully', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n          }).catch(e => {\n            this.log.error('error sending preconnect buffer', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n              error: e\n            }));\n          });\n        }\n      }\n      return publication;\n    });\n  }\n  get isLocal() {\n    return true;\n  }\n  /** @internal\n   * publish additional codec to existing track\n   */\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      // TODO remove once e2ee is supported for backup tracks\n      if (this.encryptionType !== Encryption_Type.NONE) {\n        return;\n      }\n      // is it not published? if so skip\n      let existingPublication;\n      this.trackPublications.forEach(publication => {\n        if (!publication.track) {\n          return;\n        }\n        if (publication.track === track) {\n          existingPublication = publication;\n        }\n      });\n      if (!existingPublication) {\n        throw new TrackInvalidError('track is not published');\n      }\n      if (!isLocalVideoTrack(track)) {\n        throw new TrackInvalidError('track is not a video track');\n      }\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n      if (!encodings) {\n        this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return;\n      }\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n      if (!simulcastTrack) {\n        return;\n      }\n      const req = new AddTrackRequest({\n        cid: simulcastTrack.mediaStreamTrack.id,\n        type: Track.kindToProto(track.kind),\n        muted: track.isMuted,\n        source: Track.sourceToProto(track.source),\n        sid: track.sid,\n        simulcastCodecs: [{\n          codec: opts.videoCodec,\n          cid: simulcastTrack.mediaStreamTrack.id\n        }]\n      });\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n      if (!this.engine || this.engine.isClosed) {\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\n      }\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\n        yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n        yield this.engine.negotiate();\n      });\n      const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);\n      const ti = rets[0];\n      this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n        encodings,\n        trackInfo: ti\n      }));\n    });\n  }\n  unpublishTrack(track, stopOnUnpublish) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (isLocalTrack(track)) {\n        const publishPromise = this.pendingPublishPromises.get(track);\n        if (publishPromise) {\n          this.log.info('awaiting publish promise before attempting to unpublish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n          yield publishPromise;\n        }\n      }\n      // look through all published tracks to find the right ones\n      const publication = this.getPublicationForTrack(track);\n      const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n      this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n      if (!publication || !publication.track) {\n        this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n        return undefined;\n      }\n      track = publication.track;\n      track.off(TrackEvent.Muted, this.onTrackMuted);\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n      if (stopOnUnpublish === undefined) {\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n      }\n      if (stopOnUnpublish) {\n        track.stop();\n      } else {\n        track.stopMonitor();\n      }\n      let negotiationNeeded = false;\n      const trackSender = track.sender;\n      track.sender = undefined;\n      if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n        try {\n          for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\n            // if sender is not currently sending (after replaceTrack(null))\n            // removeTrack would have no effect.\n            // to ensure we end up successfully removing the track, manually set\n            // the transceiver to inactive\n            if (transceiver.sender === trackSender) {\n              transceiver.direction = 'inactive';\n              negotiationNeeded = true;\n            }\n          }\n          if (this.engine.removeTrack(trackSender)) {\n            negotiationNeeded = true;\n          }\n          if (isLocalVideoTrack(track)) {\n            for (const [, trackInfo] of track.simulcastCodecs) {\n              if (trackInfo.sender) {\n                if (this.engine.removeTrack(trackInfo.sender)) {\n                  negotiationNeeded = true;\n                }\n                trackInfo.sender = undefined;\n              }\n            }\n            track.simulcastCodecs.clear();\n          }\n        } catch (e) {\n          this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n            error: e\n          }));\n        }\n      }\n      // remove from our maps\n      this.trackPublications.delete(publication.trackSid);\n      switch (publication.kind) {\n        case Track.Kind.Audio:\n          this.audioTrackPublications.delete(publication.trackSid);\n          break;\n        case Track.Kind.Video:\n          this.videoTrackPublications.delete(publication.trackSid);\n          break;\n      }\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n      publication.setTrack(undefined);\n      if (negotiationNeeded) {\n        yield this.engine.negotiate();\n      }\n      return publication;\n    });\n  }\n  unpublishTracks(tracks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const results = yield Promise.all(tracks.map(track => this.unpublishTrack(track)));\n      return results.filter(track => !!track);\n    });\n  }\n  republishAllTracks(options_1) {\n    return __awaiter(this, arguments, void 0, function (options) {\n      var _this3 = this;\n      let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return function* () {\n        if (_this3.republishPromise) {\n          yield _this3.republishPromise;\n        }\n        _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {\n          try {\n            const localPubs = [];\n            this.trackPublications.forEach(pub => {\n              if (pub.track) {\n                if (options) {\n                  pub.options = Object.assign(Object.assign({}, pub.options), options);\n                }\n                localPubs.push(pub);\n              }\n            });\n            yield Promise.all(localPubs.map(pub => __awaiter(this, void 0, void 0, function* () {\n              const track = pub.track;\n              yield this.unpublishTrack(track, false);\n              if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\n                // generally we need to restart the track before publishing, often a full reconnect\n                // is necessary because computer had gone to sleep.\n                this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\n                  track: pub.trackSid\n                }));\n                yield track.restartTrack();\n              }\n              yield this.publishOrRepublishTrack(track, pub.options, true);\n            })));\n            resolve();\n          } catch (error) {\n            reject(error);\n          } finally {\n            this.republishPromise = undefined;\n          }\n        }));\n        yield _this3.republishPromise;\n      }();\n    });\n  }\n  /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */\n  publishData(data_1) {\n    return __awaiter(this, arguments, void 0, function (data) {\n      var _this4 = this;\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return function* () {\n        const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\n        const destinationIdentities = options.destinationIdentities;\n        const topic = options.topic;\n        let userPacket = new UserPacket({\n          participantIdentity: _this4.identity,\n          payload: data,\n          destinationIdentities,\n          topic\n        });\n        const packet = new DataPacket({\n          kind: kind,\n          value: {\n            case: 'user',\n            value: userPacket\n          }\n        });\n        yield _this4.engine.sendDataPacket(packet, kind);\n      }();\n    });\n  }\n  /**\n   * Publish SIP DTMF message to the room.\n   *\n   * @param code DTMF code\n   * @param digit DTMF digit\n   */\n  publishDtmf(code, digit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'sipDtmf',\n          value: new SipDTMF({\n            code: code,\n            digit: digit\n          })\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /** @deprecated Consider migrating to {@link sendText} */\n  sendChatMessage(text, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = {\n        id: crypto.randomUUID(),\n        message: text,\n        timestamp: Date.now(),\n        attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\n      };\n      const packet = new DataPacket({\n        value: {\n          case: 'chatMessage',\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n            timestamp: protoInt64.parse(msg.timestamp)\n          }))\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      this.emit(ParticipantEvent.ChatMessage, msg);\n      return msg;\n    });\n  }\n  /** @deprecated Consider migrating to {@link sendText} */\n  editChatMessage(editText, originalMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const msg = Object.assign(Object.assign({}, originalMessage), {\n        message: editText,\n        editTimestamp: Date.now()\n      });\n      const packet = new DataPacket({\n        value: {\n          case: 'chatMessage',\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n            timestamp: protoInt64.parse(msg.timestamp),\n            editTimestamp: protoInt64.parse(msg.editTimestamp)\n          }))\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n      this.emit(ParticipantEvent.ChatMessage, msg);\n      return msg;\n    });\n  }\n  /**\n   * Sends the given string to participants in the room via the data channel.\n   * For longer messages, consider using {@link streamText} instead.\n   *\n   * @param text The text payload\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   */\n  sendText(text, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.roomOutgoingDataStreamManager.sendText(text, options);\n    });\n  }\n  /**\n   * Creates a new TextStreamWriter which can be used to stream text incrementally\n   * to participants in the room via the data channel.\n   *\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   *\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */\n  streamText(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.roomOutgoingDataStreamManager.streamText(options);\n    });\n  }\n  /** Send a File to all participants in the room via the data channel.\n   * @param file The File object payload\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   * @param options.onProgress A callback function used to monitor the upload progress percentage.\n   */\n  sendFile(file, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.roomOutgoingDataStreamManager.sendFile(file, options);\n    });\n  }\n  /**\n   * Stream bytes incrementally to participants in the room via the data channel.\n   * For sending files, consider using {@link sendFile} instead.\n   *\n   * @param options.topic Topic identifier used to route the stream to appropriate handlers.\n   */\n  streamBytes(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.roomOutgoingDataStreamManager.streamBytes(options);\n    });\n  }\n  /**\n   * Initiate an RPC call to a remote participant\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\n   * @returns A promise that resolves with the response payload or rejects with an error.\n   * @throws Error on failure. Details in `message`.\n   */\n  performRpc(_a) {\n    return __awaiter(this, arguments, void 0, function (_ref3) {\n      var _this5 = this;\n      let {\n        destinationIdentity,\n        method,\n        payload,\n        responseTimeout = 15000\n      } = _ref3;\n      return function* () {\n        const maxRoundTripLatency = 7000;\n        const minEffectiveTimeout = maxRoundTripLatency + 1000;\n        return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {\n          var _a, _b, _c, _d;\n          if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\n            reject(RpcError.builtIn('REQUEST_PAYLOAD_TOO_LARGE'));\n            return;\n          }\n          if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, '1.8.0') < 0) {\n            reject(RpcError.builtIn('UNSUPPORTED_SERVER'));\n            return;\n          }\n          const effectiveTimeout = Math.max(responseTimeout, minEffectiveTimeout);\n          const id = crypto.randomUUID();\n          yield this.publishRpcRequest(destinationIdentity, id, method, payload, effectiveTimeout);\n          const ackTimeoutId = setTimeout(() => {\n            this.pendingAcks.delete(id);\n            reject(RpcError.builtIn('CONNECTION_TIMEOUT'));\n            this.pendingResponses.delete(id);\n            clearTimeout(responseTimeoutId);\n          }, maxRoundTripLatency);\n          this.pendingAcks.set(id, {\n            resolve: () => {\n              clearTimeout(ackTimeoutId);\n            },\n            participantIdentity: destinationIdentity\n          });\n          const responseTimeoutId = setTimeout(() => {\n            this.pendingResponses.delete(id);\n            reject(RpcError.builtIn('RESPONSE_TIMEOUT'));\n          }, responseTimeout);\n          this.pendingResponses.set(id, {\n            resolve: (responsePayload, responseError) => {\n              clearTimeout(responseTimeoutId);\n              if (this.pendingAcks.has(id)) {\n                this.log.warn('RPC response received before ack', id);\n                this.pendingAcks.delete(id);\n                clearTimeout(ackTimeoutId);\n              }\n              if (responseError) {\n                reject(responseError);\n              } else {\n                resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : '');\n              }\n            },\n            participantIdentity: destinationIdentity\n          });\n        }));\n      }();\n    });\n  }\n  /**\n   * @deprecated use `room.registerRpcMethod` instead\n   */\n  registerRpcMethod(method, handler) {\n    if (this.rpcHandlers.has(method)) {\n      this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\n    }\n    this.rpcHandlers.set(method, handler);\n  }\n  /**\n   * @deprecated use `room.unregisterRpcMethod` instead\n   */\n  unregisterRpcMethod(method) {\n    this.rpcHandlers.delete(method);\n  }\n  /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.participantTrackPermissions = participantTrackPermissions;\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n    if (!this.engine.client.isDisconnected) {\n      this.updateTrackSubscriptionPermissions();\n    }\n  }\n  handleIncomingRpcAck(requestId) {\n    const handler = this.pendingAcks.get(requestId);\n    if (handler) {\n      handler.resolve();\n      this.pendingAcks.delete(requestId);\n    } else {\n      console.error('Ack received for unexpected RPC request', requestId);\n    }\n  }\n  handleIncomingRpcResponse(requestId, payload, error) {\n    const handler = this.pendingResponses.get(requestId);\n    if (handler) {\n      handler.resolve(payload, error);\n      this.pendingResponses.delete(requestId);\n    } else {\n      console.error('Response received for unexpected RPC request', requestId);\n    }\n  }\n  /** @internal */\n  publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const packet = new DataPacket({\n        destinationIdentities: [destinationIdentity],\n        kind: DataPacket_Kind.RELIABLE,\n        value: {\n          case: 'rpcRequest',\n          value: new RpcRequest({\n            id: requestId,\n            method,\n            payload,\n            responseTimeoutMs: responseTimeout,\n            version: 1\n          })\n        }\n      });\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n    });\n  }\n  /** @internal */\n  handleParticipantDisconnected(participantIdentity) {\n    for (const [id, {\n      participantIdentity: pendingIdentity\n    }] of this.pendingAcks) {\n      if (pendingIdentity === participantIdentity) {\n        this.pendingAcks.delete(id);\n      }\n    }\n    for (const [id, {\n      participantIdentity: pendingIdentity,\n      resolve\n    }] of this.pendingResponses) {\n      if (pendingIdentity === participantIdentity) {\n        resolve(null, RpcError.builtIn('RECIPIENT_DISCONNECTED'));\n        this.pendingResponses.delete(id);\n      }\n    }\n  }\n  /** @internal */\n  setEnabledPublishCodecs(codecs) {\n    this.enabledPublishVideoCodecs = codecs.filter(c => c.mime.split('/')[0].toLowerCase() === 'video');\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    // reconcile track mute status.\n    // if server's track mute status doesn't match actual, we'll have to update\n    // the server's copy\n    info.tracks.forEach(ti => {\n      var _a, _b;\n      const pub = this.trackPublications.get(ti.sid);\n      if (pub) {\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n        if (mutedOnServer !== ti.muted) {\n          this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n            mutedOnServer\n          }));\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n        }\n      }\n    });\n    return true;\n  }\n  /** @internal */\n  setActiveAgent(agent) {\n    var _a, _b, _c, _d;\n    this.firstActiveAgent = agent;\n    if (agent && !this.firstActiveAgent) {\n      this.firstActiveAgent = agent;\n    }\n    if (agent) {\n      (_b = (_a = this.activeAgentFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a, agent);\n    } else {\n      (_d = (_c = this.activeAgentFuture) === null || _c === void 0 ? void 0 : _c.reject) === null || _d === void 0 ? void 0 : _d.call(_c, new Error('Agent disconnected'));\n    }\n    this.activeAgentFuture = undefined;\n  }\n  waitUntilActiveAgentPresent() {\n    if (this.firstActiveAgent) {\n      return Promise.resolve(this.firstActiveAgent);\n    }\n    if (!this.activeAgentFuture) {\n      this.activeAgentFuture = new Future();\n    }\n    return this.activeAgentFuture.promise;\n  }\n  getPublicationForTrack(track) {\n    let publication;\n    this.trackPublications.forEach(pub => {\n      const localTrack = pub.track;\n      if (!localTrack) {\n        return;\n      }\n      // this looks overly complicated due to this object tree\n      if (track instanceof MediaStreamTrack) {\n        if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\n          if (localTrack.mediaStreamTrack === track) {\n            publication = pub;\n          }\n        }\n      } else if (track === localTrack) {\n        publication = pub;\n      }\n    });\n    return publication;\n  }\n  waitForPendingPublicationOfSource(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const waitForPendingTimeout = 10000;\n      const startTime = Date.now();\n      while (Date.now() < startTime + waitForPendingTimeout) {\n        const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(_ref4 => {\n          let [pendingTrack] = _ref4;\n          return pendingTrack.source === source;\n        });\n        if (publishPromiseEntry) {\n          return publishPromiseEntry[1];\n        }\n        yield sleep(20);\n      }\n    });\n  }\n}class RemoteTrackPublication extends TrackPublication {\n  constructor(kind, ti, autoSubscribe, loggerOptions) {\n    super(kind, ti.sid, ti.name, loggerOptions);\n    this.track = undefined;\n    /** @internal */\n    this.allowed = true;\n    this.requestedDisabled = undefined;\n    this.visible = true;\n    this.handleEnded = track => {\n      this.setTrack(undefined);\n      this.emit(TrackEvent.Ended, track);\n    };\n    this.handleVisibilityChange = visible => {\n      this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n      this.visible = visible;\n      this.emitTrackUpdate();\n    };\n    this.handleVideoDimensionsChange = dimensions => {\n      this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n      this.videoDimensionsAdaptiveStream = dimensions;\n      this.emitTrackUpdate();\n    };\n    this.subscribed = autoSubscribe;\n    this.updateInfo(ti);\n  }\n  /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */\n  setSubscribed(subscribed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.subscribed = subscribed;\n    // reset allowed status when desired subscription state changes\n    // server will notify client via signal message if it's not allowed\n    if (subscribed) {\n      this.allowed = true;\n    }\n    const sub = new UpdateSubscription({\n      trackSids: [this.trackSid],\n      subscribe: this.subscribed,\n      participantTracks: [new ParticipantTracks({\n        // sending an empty participant id since TrackPublication doesn't keep it\n        // this is filled in by the participant that receives this message\n        participantSid: '',\n        trackSids: [this.trackSid]\n      })]\n    });\n    this.emit(TrackEvent.UpdateSubscription, sub);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n    this.emitPermissionUpdateIfChanged(prevPermission);\n  }\n  get subscriptionStatus() {\n    if (this.subscribed === false) {\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\n    }\n    if (!super.isSubscribed) {\n      return TrackPublication.SubscriptionStatus.Desired;\n    }\n    return TrackPublication.SubscriptionStatus.Subscribed;\n  }\n  get permissionStatus() {\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n  }\n  /**\n   * Returns true if track is subscribed, and ready for playback\n   */\n  get isSubscribed() {\n    if (this.subscribed === false) {\n      return false;\n    }\n    return super.isSubscribed;\n  }\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n  get isDesired() {\n    return this.subscribed !== false;\n  }\n  get isEnabled() {\n    return this.requestedDisabled !== undefined ? !this.requestedDisabled : this.isAdaptiveStream ? this.visible : true;\n  }\n  get isLocal() {\n    return false;\n  }\n  /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */\n  setEnabled(enabled) {\n    if (!this.isManualOperationAllowed() || this.requestedDisabled === !enabled) {\n      return;\n    }\n    this.requestedDisabled = !enabled;\n    this.emitTrackUpdate();\n  }\n  /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */\n  setVideoQuality(quality) {\n    if (!this.isManualOperationAllowed() || this.requestedMaxQuality === quality) {\n      return;\n    }\n    this.requestedMaxQuality = quality;\n    this.requestedVideoDimensions = undefined;\n    this.emitTrackUpdate();\n  }\n  /**\n   * Explicitly set the video dimensions for this track.\n   *\n   * This will take precedence over adaptive stream dimensions.\n   *\n   * @param dimensions The video dimensions to set.\n   */\n  setVideoDimensions(dimensions) {\n    var _a, _b;\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (((_a = this.requestedVideoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.requestedVideoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n      return;\n    }\n    if (isRemoteVideoTrack(this.track)) {\n      this.requestedVideoDimensions = dimensions;\n    }\n    this.requestedMaxQuality = undefined;\n    this.emitTrackUpdate();\n  }\n  setVideoFPS(fps) {\n    if (!this.isManualOperationAllowed()) {\n      return;\n    }\n    if (!isRemoteVideoTrack(this.track)) {\n      return;\n    }\n    if (this.fps === fps) {\n      return;\n    }\n    this.fps = fps;\n    this.emitTrackUpdate();\n  }\n  get videoQuality() {\n    var _a;\n    return (_a = this.requestedMaxQuality) !== null && _a !== void 0 ? _a : VideoQuality.HIGH;\n  }\n  /** @internal */\n  setTrack(track) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    const prevTrack = this.track;\n    if (prevTrack === track) {\n      return;\n    }\n    if (prevTrack) {\n      // unregister listener\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\n      prevTrack.detach();\n      prevTrack.stopMonitor();\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\n    }\n    super.setTrack(track);\n    if (track) {\n      track.sid = this.trackSid;\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n      track.on(TrackEvent.Ended, this.handleEnded);\n      this.emit(TrackEvent.Subscribed, track);\n    }\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setAllowed(allowed) {\n    const prevStatus = this.subscriptionStatus;\n    const prevPermission = this.permissionStatus;\n    this.allowed = allowed;\n    this.emitPermissionUpdateIfChanged(prevPermission);\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\n  }\n  /** @internal */\n  setSubscriptionError(error) {\n    this.emit(TrackEvent.SubscriptionFailed, error);\n  }\n  /** @internal */\n  updateInfo(info) {\n    super.updateInfo(info);\n    const prevMetadataMuted = this.metadataMuted;\n    this.metadataMuted = info.muted;\n    if (this.track) {\n      this.track.setMuted(info.muted);\n    } else if (prevMetadataMuted !== info.muted) {\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n    }\n  }\n  emitSubscriptionUpdateIfChanged(previousStatus) {\n    const currentStatus = this.subscriptionStatus;\n    if (previousStatus === currentStatus) {\n      return;\n    }\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n  }\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\n    const currentPermissionStatus = this.permissionStatus;\n    if (currentPermissionStatus !== previousPermissionStatus) {\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n    }\n  }\n  isManualOperationAllowed() {\n    if (!this.isDesired) {\n      this.log.warn('cannot update track settings when not subscribed', this.logContext);\n      return false;\n    }\n    return true;\n  }\n  get isAdaptiveStream() {\n    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\n  }\n  /* @internal */\n  emitTrackUpdate() {\n    const settings = new UpdateTrackSettings({\n      trackSids: [this.trackSid],\n      disabled: !this.isEnabled,\n      fps: this.fps\n    });\n    if (this.kind === Track.Kind.Video) {\n      let minDimensions = this.requestedVideoDimensions;\n      if (this.videoDimensionsAdaptiveStream !== undefined) {\n        if (minDimensions) {\n          // check whether the adaptive stream dimensions are smaller than the requested dimensions and use smaller one\n          const smallerAdaptive = areDimensionsSmaller(this.videoDimensionsAdaptiveStream, minDimensions);\n          if (smallerAdaptive) {\n            this.log.debug('using adaptive stream dimensions instead of requested', Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n            minDimensions = this.videoDimensionsAdaptiveStream;\n          }\n        } else if (this.requestedMaxQuality !== undefined && this.trackInfo) {\n          // check whether adaptive stream dimensions are smaller than the max quality layer and use smaller one\n          const maxQualityLayer = layerDimensionsFor(this.trackInfo, this.requestedMaxQuality);\n          if (maxQualityLayer && areDimensionsSmaller(this.videoDimensionsAdaptiveStream, maxQualityLayer)) {\n            this.log.debug('using adaptive stream dimensions instead of max quality layer', Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n            minDimensions = this.videoDimensionsAdaptiveStream;\n          }\n        } else {\n          this.log.debug('using adaptive stream dimensions', Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));\n          minDimensions = this.videoDimensionsAdaptiveStream;\n        }\n      }\n      if (minDimensions) {\n        settings.width = Math.ceil(minDimensions.width);\n        settings.height = Math.ceil(minDimensions.height);\n      } else if (this.requestedMaxQuality !== undefined) {\n        this.log.debug('using requested max quality', Object.assign(Object.assign({}, this.logContext), {\n          quality: this.requestedMaxQuality\n        }));\n        settings.quality = this.requestedMaxQuality;\n      } else {\n        this.log.debug('using default quality', Object.assign(Object.assign({}, this.logContext), {\n          quality: VideoQuality.HIGH\n        }));\n        // defaults to high quality\n        settings.quality = VideoQuality.HIGH;\n      }\n    }\n    this.emit(TrackEvent.UpdateSettings, settings);\n  }\n}class RemoteParticipant extends Participant {\n  /** @internal */\n  static fromParticipantInfo(signalClient, pi, loggerOptions) {\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\n  }\n  get logContext() {\n    return Object.assign(Object.assign({}, super.logContext), {\n      rpID: this.sid,\n      remoteParticipant: this.identity\n    });\n  }\n  /** @internal */\n  constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {\n    let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\n    super(sid, identity || '', name, metadata, attributes, loggerOptions, kind);\n    this.signalClient = signalClient;\n    this.trackPublications = new Map();\n    this.audioTrackPublications = new Map();\n    this.videoTrackPublications = new Map();\n    this.volumeMap = new Map();\n  }\n  addTrackPublication(publication) {\n    super.addTrackPublication(publication);\n    // register action events\n    publication.on(TrackEvent.UpdateSettings, settings => {\n      this.log.debug('send update settings', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)), {\n        settings\n      }));\n      this.signalClient.sendUpdateTrackSettings(settings);\n    });\n    publication.on(TrackEvent.UpdateSubscription, sub => {\n      sub.participantTracks.forEach(pt => {\n        pt.participantSid = this.sid;\n      });\n      this.signalClient.sendUpdateSubscription(sub);\n    });\n    publication.on(TrackEvent.SubscriptionPermissionChanged, status => {\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n    });\n    publication.on(TrackEvent.SubscriptionStatusChanged, status => {\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n    });\n    publication.on(TrackEvent.Subscribed, track => {\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n    });\n    publication.on(TrackEvent.Unsubscribed, previousTrack => {\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n    });\n    publication.on(TrackEvent.SubscriptionFailed, error => {\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n    });\n  }\n  getTrackPublication(source) {\n    const track = super.getTrackPublication(source);\n    if (track) {\n      return track;\n    }\n  }\n  getTrackPublicationByName(name) {\n    const track = super.getTrackPublicationByName(name);\n    if (track) {\n      return track;\n    }\n  }\n  /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */\n  setVolume(volume) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n    this.volumeMap.set(source, volume);\n    const audioPublication = this.getTrackPublication(source);\n    if (audioPublication && audioPublication.track) {\n      audioPublication.track.setVolume(volume);\n    }\n  }\n  /**\n   * gets the volume on the participant's microphone track\n   */\n  getVolume() {\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n    const audioPublication = this.getTrackPublication(source);\n    if (audioPublication && audioPublication.track) {\n      return audioPublication.track.getVolume();\n    }\n    return this.volumeMap.get(source);\n  }\n  /** @internal */\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n    // find the track publication\n    // it's possible for the media track to arrive before participant info\n    let publication = this.getTrackPublicationBySid(sid);\n    // it's also possible that the browser didn't honor our original track id\n    // FireFox would use its own local uuid instead of server track id\n    if (!publication) {\n      if (!sid.startsWith('TR')) {\n        // find the first track that matches type\n        this.trackPublications.forEach(p => {\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\n            publication = p;\n          }\n        });\n      }\n    }\n    // when we couldn't locate the track, it's possible that the metadata hasn't\n    // yet arrived. Wait a bit longer for it to arrive, or fire an error\n    if (!publication) {\n      if (triesLeft === 0) {\n        this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\n          trackSid: sid\n        }));\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n        return;\n      }\n      if (triesLeft === undefined) triesLeft = 20;\n      setTimeout(() => {\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n      }, 150);\n      return;\n    }\n    if (mediaTrack.readyState === 'ended') {\n      this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n      return;\n    }\n    const isVideo = mediaTrack.kind === 'video';\n    let track;\n    if (isVideo) {\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n    } else {\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n    }\n    // set track info\n    track.source = publication.source;\n    // keep publication's muted status\n    track.isMuted = publication.isMuted;\n    track.setMediaStream(mediaStream);\n    track.start();\n    publication.setTrack(track);\n    // set participant volumes on new audio tracks\n    if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\n      track.setVolume(this.volumeMap.get(publication.source));\n    }\n    return publication;\n  }\n  /** @internal */\n  get hasMetadata() {\n    return !!this.participantInfo;\n  }\n  /**\n   * @internal\n   */\n  getTrackPublicationBySid(sid) {\n    return this.trackPublications.get(sid);\n  }\n  /** @internal */\n  updateInfo(info) {\n    if (!super.updateInfo(info)) {\n      return false;\n    }\n    // we are getting a list of all available tracks, reconcile in here\n    // and send out events for changes\n    // reconcile track publications, publish events only if metadata is already there\n    // i.e. changes since the local participant has joined\n    const validTracks = new Map();\n    const newTracks = new Map();\n    info.tracks.forEach(ti => {\n      var _a, _b;\n      let publication = this.getTrackPublicationBySid(ti.sid);\n      if (!publication) {\n        // new publication\n        const kind = Track.kindFromProto(ti.type);\n        if (!kind) {\n          return;\n        }\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n          loggerContextCb: () => this.logContext,\n          loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n        });\n        publication.updateInfo(ti);\n        newTracks.set(ti.sid, publication);\n        const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n          this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n            oldTrack: getLogContextFromTrack(existingTrackOfSource),\n            newTrack: getLogContextFromTrack(publication)\n          }));\n        }\n        this.addTrackPublication(publication);\n      } else {\n        publication.updateInfo(ti);\n      }\n      validTracks.set(ti.sid, publication);\n    });\n    // detect removed tracks\n    this.trackPublications.forEach(publication => {\n      if (!validTracks.has(publication.trackSid)) {\n        this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n        this.unpublishTrack(publication.trackSid, true);\n      }\n    });\n    // always emit events for new publications, Room will not forward them unless it's ready\n    newTracks.forEach(publication => {\n      this.emit(ParticipantEvent.TrackPublished, publication);\n    });\n    return true;\n  }\n  /** @internal */\n  unpublishTrack(sid, sendUnpublish) {\n    const publication = this.trackPublications.get(sid);\n    if (!publication) {\n      return;\n    }\n    // also send unsubscribe, if track is actively subscribed\n    const {\n      track\n    } = publication;\n    if (track) {\n      track.stop();\n      publication.setTrack(undefined);\n    }\n    // remove track from maps only after unsubscribed has been fired\n    this.trackPublications.delete(sid);\n    // remove from the right type map\n    switch (publication.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.delete(sid);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.delete(sid);\n        break;\n    }\n    if (sendUnpublish) {\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\n    }\n  }\n  /**\n   * @internal\n   */\n  setAudioOutput(output) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutput = output;\n      const promises = [];\n      this.audioTrackPublications.forEach(pub => {\n        var _a;\n        if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\n        }\n      });\n      yield Promise.all(promises);\n    });\n  }\n  /** @internal */\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\n      event,\n      args\n    }));\n    return super.emit(event, ...args);\n  }\n}var ConnectionState;\n(function (ConnectionState) {\n  ConnectionState[\"Disconnected\"] = \"disconnected\";\n  ConnectionState[\"Connecting\"] = \"connecting\";\n  ConnectionState[\"Connected\"] = \"connected\";\n  ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n  ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst CONNECTION_RECONCILE_FREQUENCY_MS = 4 * 1000;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */\nclass Room extends eventsExports.EventEmitter {\n  get hasE2EESetup() {\n    return this.e2eeManager !== undefined;\n  }\n  /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */\n  constructor(options) {\n    var _this;\n    var _a, _b, _c;\n    super();\n    _this = this;\n    this.state = ConnectionState.Disconnected;\n    /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */\n    this.activeSpeakers = [];\n    /** reflects the sender encryption status of the local participant */\n    this.isE2EEEnabled = false;\n    this.audioEnabled = true;\n    this.isVideoPlaybackBlocked = false;\n    this.log = livekitLogger;\n    this.bufferedEvents = [];\n    this.isResuming = false;\n    this.rpcHandlers = new Map();\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!isBrowserSupported()) {\n        if (isReactNative()) {\n          throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\n        } else {\n          throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\n        }\n      }\n      // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n      const unlockDisconnect = yield this.disconnectLock.lock();\n      if (this.state === ConnectionState.Connected) {\n        // when the state is reconnecting or connected, this function returns immediately\n        this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n        unlockDisconnect();\n        return Promise.resolve();\n      }\n      if (this.connectFuture) {\n        unlockDisconnect();\n        return this.connectFuture.promise;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\n      if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== ensureTrailingSlash(url)) {\n        this.regionUrl = undefined;\n        this.regionUrlProvider = undefined;\n      }\n      if (isCloud(new URL(url))) {\n        if (this.regionUrlProvider === undefined) {\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\n        } else {\n          this.regionUrlProvider.updateToken(token);\n        }\n        // trigger the first fetch without waiting for a response\n        // if initial connection fails, this will speed up picking regional url\n        // on subsequent runs\n        this.regionUrlProvider.fetchRegionSettings().then(settings => {\n          var _a;\n          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\n        }).catch(e => {\n          this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        });\n      }\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (this.abortController) {\n          this.abortController.abort();\n        }\n        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n        const abortController = new AbortController();\n        this.abortController = abortController;\n        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n        try {\n          yield BackOffStrategy.getInstance().getBackOffPromise(url);\n          if (abortController.signal.aborted) {\n            throw ConnectionError.cancelled('Connection attempt aborted');\n          }\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n          this.abortController = undefined;\n          resolve();\n        } catch (error) {\n          if (this.regionUrlProvider && error instanceof ConnectionError && error.reason !== ConnectionErrorReason.Cancelled && error.reason !== ConnectionErrorReason.NotAllowed) {\n            let nextUrl = null;\n            try {\n              this.log.debug('Fetching next region');\n              nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n            } catch (regionFetchError) {\n              if (regionFetchError instanceof ConnectionError && (regionFetchError.status === 401 || regionFetchError.reason === ConnectionErrorReason.Cancelled)) {\n                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                reject(regionFetchError);\n                return;\n              }\n            }\n            if (\n            // making sure we only register failed attempts on things we actually care about\n            [ConnectionErrorReason.InternalError, ConnectionErrorReason.ServerUnreachable, ConnectionErrorReason.Timeout].includes(error.reason)) {\n              this.log.debug('Adding failed connection attempt to back off');\n              BackOffStrategy.getInstance().addFailedConnectionAttempt(url);\n            }\n            if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\n              this.log.info(\"Initial connection failed with ConnectionError: \".concat(error.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n              this.recreateEngine();\n              yield connectFn(resolve, reject, nextUrl);\n            } else {\n              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(error));\n              reject(error);\n            }\n          } else {\n            let disconnectReason = DisconnectReason.UNKNOWN_REASON;\n            if (error instanceof ConnectionError) {\n              disconnectReason = getDisconnectReasonFromConnectionError(error);\n            }\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\n            reject(error);\n          }\n        }\n      });\n      const regionUrl = this.regionUrl;\n      this.regionUrl = undefined;\n      this.connectFuture = new Future((resolve, reject) => {\n        connectFn(resolve, reject, regionUrl);\n      }, () => {\n        this.clearConnectionFutures();\n      });\n      return this.connectFuture.promise;\n    });\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      const joinResponse = yield engine.join(url, token, {\n        autoSubscribe: connectOptions.autoSubscribe,\n        adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\n        maxRetries: connectOptions.maxRetries,\n        e2eeEnabled: !!this.e2eeManager,\n        websocketTimeout: connectOptions.websocketTimeout,\n        singlePeerConnection: roomOptions.singlePeerConnection\n      }, abortController.signal);\n      let serverInfo = joinResponse.serverInfo;\n      if (!serverInfo) {\n        serverInfo = {\n          version: joinResponse.serverVersion,\n          region: joinResponse.serverRegion\n        };\n      }\n      this.serverInfo = serverInfo;\n      this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map(_ref => {\n        let [key, value] = _ref;\n        return \"\".concat(key, \": \").concat(value);\n      }).join(', ')), {\n        room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\n        roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\n        identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\n      });\n      if (!serverInfo.version) {\n        throw new UnsupportedServer('unknown server version');\n      }\n      if (serverInfo.version === '0.15.1' && this.options.dynacast) {\n        this.log.debug('disabling dynacast due to server version', this.logContext);\n        // dynacast has a bug in 0.15.1, so we cannot use it then\n        roomOptions.dynacast = false;\n      }\n      return joinResponse;\n    });\n    this.applyJoinResponse = joinResponse => {\n      const pi = joinResponse.participant;\n      this.localParticipant.sid = pi.sid;\n      this.localParticipant.identity = pi.identity;\n      this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\n      if (this.e2eeManager) {\n        try {\n          this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n        } catch (e) {\n          this.log.error(e instanceof Error ? e.message : 'Could not set SifTrailer', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        }\n      }\n      // populate remote participants, these should not trigger new events\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\n      if (joinResponse.room) {\n        this.handleRoomUpdate(joinResponse.room);\n      }\n    };\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\n        this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\n        // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n        this.recreateEngine();\n      } else {\n        // create engine if previously disconnected\n        this.maybeCreateEngine();\n      }\n      if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\n        this.engine.setRegionUrlProvider(this.regionUrlProvider);\n      }\n      this.acquireAudioContext();\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n      if (this.connOptions.rtcConfig) {\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\n      }\n      if (this.connOptions.peerConnectionTimeout) {\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n      }\n      try {\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n        this.applyJoinResponse(joinResponse);\n        // forward metadata changed for the local participant\n        this.setupLocalParticipantEvents();\n        this.emit(RoomEvent.SignalConnected);\n      } catch (err) {\n        yield this.engine.close();\n        this.recreateEngine();\n        const resultingError = abortController.signal.aborted ? ConnectionError.cancelled('Signal connection aborted') : ConnectionError.serverUnreachable('could not establish signal connection');\n        if (err instanceof Error) {\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n        }\n        if (err instanceof ConnectionError) {\n          resultingError.reason = err.reason;\n          resultingError.status = err.status;\n        }\n        this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n          error: err\n        }));\n        throw resultingError;\n      }\n      if (abortController.signal.aborted) {\n        yield this.engine.close();\n        this.recreateEngine();\n        throw ConnectionError.cancelled(\"Connection attempt aborted\");\n      }\n      try {\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n      } catch (e) {\n        yield this.engine.close();\n        this.recreateEngine();\n        throw e;\n      }\n      // also hook unload event\n      if (isWeb() && this.options.disconnectOnPageLeave) {\n        // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n        window.addEventListener('pagehide', this.onPageLeave);\n        window.addEventListener('beforeunload', this.onPageLeave);\n      }\n      if (isWeb()) {\n        window.addEventListener('freeze', this.onPageLeave);\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Connected);\n      BackOffStrategy.getInstance().resetFailedConnectionAttempts(url);\n      this.registerConnectionReconcile();\n      // Notify region provider about successful connection\n      if (this.regionUrlProvider) {\n        this.regionUrlProvider.notifyConnected();\n      }\n    });\n    /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */\n    this.disconnect = function () {\n      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {\n        args_1[_key] = arguments[_key];\n      }\n      return __awaiter(_this, [...args_1], void 0, function () {\n        var _this2 = this;\n        let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return function* () {\n          var _a, _b, _c;\n          const unlock = yield _this2.disconnectLock.lock();\n          try {\n            if (_this2.state === ConnectionState.Disconnected) {\n              _this2.log.debug('already disconnected', _this2.logContext);\n              return;\n            }\n            _this2.log.info('disconnect from room', Object.assign({}, _this2.logContext));\n            if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\n              // try aborting pending connection attempt\n              const msg = 'Abort connection attempt due to user initiated disconnect';\n              _this2.log.warn(msg, _this2.logContext);\n              (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort(msg);\n              // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n              (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, ConnectionError.cancelled('Client initiated disconnect'));\n              _this2.connectFuture = undefined;\n            }\n            // close engine (also closes client)\n            if (_this2.engine) {\n              // send leave\n              if (!_this2.engine.client.isDisconnected) {\n                yield _this2.engine.client.sendLeave();\n              }\n              yield _this2.engine.close();\n            }\n            _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n            /* @ts-ignore */\n            _this2.engine = undefined;\n          } finally {\n            unlock();\n          }\n        }();\n      });\n    };\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\n      this.log.info('Page leave detected, disconnecting', this.logContext);\n      yield this.disconnect();\n    });\n    /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */\n    this.startAudio = () => __awaiter(this, void 0, void 0, function* () {\n      const elements = [];\n      const browser = getBrowser();\n      if (browser && browser.os === 'iOS') {\n        /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */\n        const audioId = 'livekit-dummy-audio-el';\n        let dummyAudioEl = document.getElementById(audioId);\n        if (!dummyAudioEl) {\n          dummyAudioEl = document.createElement('audio');\n          dummyAudioEl.id = audioId;\n          dummyAudioEl.autoplay = true;\n          dummyAudioEl.hidden = true;\n          const track = getEmptyAudioStreamTrack();\n          track.enabled = true;\n          const stream = new MediaStream([track]);\n          dummyAudioEl.srcObject = stream;\n          document.addEventListener('visibilitychange', () => {\n            if (!dummyAudioEl) {\n              return;\n            }\n            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n            dummyAudioEl.srcObject = document.hidden ? null : stream;\n            if (!document.hidden) {\n              this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\n              this.startAudio();\n            }\n          });\n          document.body.append(dummyAudioEl);\n          this.once(RoomEvent.Disconnected, () => {\n            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n            dummyAudioEl = null;\n          });\n        }\n        elements.push(dummyAudioEl);\n      }\n      this.remoteParticipants.forEach(p => {\n        p.audioTrackPublications.forEach(t => {\n          if (t.track) {\n            t.track.attachedElements.forEach(e => {\n              elements.push(e);\n            });\n          }\n        });\n      });\n      try {\n        yield Promise.all([this.acquireAudioContext(), ...elements.map(e => {\n          e.muted = false;\n          return e.play();\n        })]);\n        this.handleAudioPlaybackStarted();\n      } catch (err) {\n        this.handleAudioPlaybackFailed(err);\n        throw err;\n      }\n    });\n    this.startVideo = () => __awaiter(this, void 0, void 0, function* () {\n      const elements = [];\n      for (const p of this.remoteParticipants.values()) {\n        p.videoTrackPublications.forEach(tr => {\n          var _a;\n          (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach(el => {\n            if (!elements.includes(el)) {\n              elements.push(el);\n            }\n          });\n        });\n      }\n      yield Promise.all(elements.map(el => el.play())).then(() => {\n        this.handleVideoPlaybackStarted();\n      }).catch(e => {\n        if (e.name === 'NotAllowedError') {\n          this.handleVideoPlaybackFailed();\n        } else {\n          this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\n        }\n      });\n    });\n    this.handleRestarting = () => {\n      this.clearConnectionReconcile();\n      // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\n      this.isResuming = false;\n      // also unwind existing participants & existing subscriptions\n      for (const p of this.remoteParticipants.values()) {\n        this.handleParticipantDisconnected(p.identity, p);\n      }\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    };\n    this.handleSignalRestarted = joinResponse => __awaiter(this, void 0, void 0, function* () {\n      this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n        region: joinResponse.serverRegion\n      }));\n      this.bufferedEvents = [];\n      this.applyJoinResponse(joinResponse);\n      try {\n        // unpublish & republish tracks\n        yield this.localParticipant.republishAllTracks(undefined, true);\n      } catch (error) {\n        this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\n          error\n        }));\n      }\n      try {\n        yield this.engine.waitForRestarted();\n        this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n          region: joinResponse.serverRegion\n        }));\n      } catch (_a) {\n        // reconnection failed, handleDisconnect is being invoked already, just return here\n        return;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      this.emit(RoomEvent.Reconnected);\n      this.registerConnectionReconcile();\n      this.emitBufferedEvents();\n    });\n    this.handleParticipantUpdates = participantInfos => {\n      // handle changes to participant state, and send events\n      participantInfos.forEach(info => {\n        var _a;\n        if (info.identity === this.localParticipant.identity) {\n          this.localParticipant.updateInfo(info);\n          return;\n        }\n        // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\n        // so we try to map an empty identity to an already known sID manually\n        if (info.identity === '') {\n          info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : '';\n        }\n        let remoteParticipant = this.remoteParticipants.get(info.identity);\n        // when it's disconnected, send updates\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\n          this.handleParticipantDisconnected(info.identity, remoteParticipant);\n        } else {\n          // create participant if doesn't exist\n          remoteParticipant = this.getOrCreateParticipant(info.identity, info);\n        }\n      });\n    };\n    // updates are sent only when there's a change to speaker ordering\n    this.handleActiveSpeakersUpdate = speakers => {\n      const activeSpeakers = [];\n      const seenSids = {};\n      speakers.forEach(speaker => {\n        seenSids[speaker.sid] = true;\n        if (speaker.sid === this.localParticipant.sid) {\n          this.localParticipant.audioLevel = speaker.level;\n          this.localParticipant.setIsSpeaking(true);\n          activeSpeakers.push(this.localParticipant);\n        } else {\n          const p = this.getRemoteParticipantBySid(speaker.sid);\n          if (p) {\n            p.audioLevel = speaker.level;\n            p.setIsSpeaking(true);\n            activeSpeakers.push(p);\n          }\n        }\n      });\n      if (!seenSids[this.localParticipant.sid]) {\n        this.localParticipant.audioLevel = 0;\n        this.localParticipant.setIsSpeaking(false);\n      }\n      this.remoteParticipants.forEach(p => {\n        if (!seenSids[p.sid]) {\n          p.audioLevel = 0;\n          p.setIsSpeaking(false);\n        }\n      });\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    // process list of changed speakers\n    this.handleSpeakersChanged = speakerUpdates => {\n      const lastSpeakers = new Map();\n      this.activeSpeakers.forEach(p => {\n        const remoteParticipant = this.remoteParticipants.get(p.identity);\n        if (remoteParticipant && remoteParticipant.sid !== p.sid) {\n          return;\n        }\n        lastSpeakers.set(p.sid, p);\n      });\n      speakerUpdates.forEach(speaker => {\n        let p = this.getRemoteParticipantBySid(speaker.sid);\n        if (speaker.sid === this.localParticipant.sid) {\n          p = this.localParticipant;\n        }\n        if (!p) {\n          return;\n        }\n        p.audioLevel = speaker.level;\n        p.setIsSpeaking(speaker.active);\n        if (speaker.active) {\n          lastSpeakers.set(speaker.sid, p);\n        } else {\n          lastSpeakers.delete(speaker.sid);\n        }\n      });\n      const activeSpeakers = Array.from(lastSpeakers.values());\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\n      this.activeSpeakers = activeSpeakers;\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n    };\n    this.handleStreamStateUpdate = streamStateUpdate => {\n      streamStateUpdate.streamStates.forEach(streamState => {\n        const participant = this.getRemoteParticipantBySid(streamState.participantSid);\n        if (!participant) {\n          return;\n        }\n        const pub = participant.getTrackPublicationBySid(streamState.trackSid);\n        if (!pub || !pub.track) {\n          return;\n        }\n        const newStreamState = Track.streamStateFromProto(streamState.state);\n        pub.track.setStreamState(newStreamState);\n        if (newStreamState !== pub.track.streamState) {\n          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n          this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n        }\n      });\n    };\n    this.handleSubscriptionPermissionUpdate = update => {\n      const participant = this.getRemoteParticipantBySid(update.participantSid);\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setAllowed(update.allowed);\n    };\n    this.handleSubscriptionError = update => {\n      const participant = Array.from(this.remoteParticipants.values()).find(p => p.trackPublications.has(update.trackSid));\n      if (!participant) {\n        return;\n      }\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\n      if (!pub) {\n        return;\n      }\n      pub.setSubscriptionError(update.err);\n    };\n    this.handleDataPacket = (packet, encryptionType) => {\n      // find the participant\n      const participant = this.remoteParticipants.get(packet.participantIdentity);\n      if (packet.value.case === 'user') {\n        this.handleUserPacket(participant, packet.value.value, packet.kind, encryptionType);\n      } else if (packet.value.case === 'transcription') {\n        this.handleTranscription(participant, packet.value.value);\n      } else if (packet.value.case === 'sipDtmf') {\n        this.handleSipDtmf(participant, packet.value.value);\n      } else if (packet.value.case === 'chatMessage') {\n        this.handleChatMessage(participant, packet.value.value);\n      } else if (packet.value.case === 'metrics') {\n        this.handleMetrics(packet.value.value, participant);\n      } else if (packet.value.case === 'streamHeader' || packet.value.case === 'streamChunk' || packet.value.case === 'streamTrailer') {\n        this.handleDataStream(packet, encryptionType);\n      } else if (packet.value.case === 'rpcRequest') {\n        const rpc = packet.value.value;\n        this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\n      }\n    };\n    this.handleUserPacket = (participant, userPacket, kind, encryptionType) => {\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic, encryptionType);\n      // also emit on the participant\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind, encryptionType);\n    };\n    this.handleSipDtmf = (participant, dtmf) => {\n      this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\n      // also emit on the participant\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\n    };\n    this.handleTranscription = (_remoteParticipant, transcription) => {\n      // find the participant\n      const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\n      const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\n      const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\n      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\n      this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\n    };\n    this.handleChatMessage = (participant, chatMessage) => {\n      const msg = extractChatMessage(chatMessage);\n      this.emit(RoomEvent.ChatMessage, msg, participant);\n    };\n    this.handleMetrics = (metrics, participant) => {\n      this.emit(RoomEvent.MetricsReceived, metrics, participant);\n    };\n    this.handleDataStream = (packet, encryptionType) => {\n      this.incomingDataStreamManager.handleDataStreamPacket(packet, encryptionType);\n    };\n    this.bufferedSegments = new Map();\n    this.handleAudioPlaybackStarted = () => {\n      if (this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = true;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n    };\n    this.handleAudioPlaybackFailed = e => {\n      this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\n        error: e\n      }));\n      if (!this.canPlaybackAudio) {\n        return;\n      }\n      this.audioEnabled = false;\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n    };\n    this.handleVideoPlaybackStarted = () => {\n      if (this.isVideoPlaybackBlocked) {\n        this.isVideoPlaybackBlocked = false;\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n      }\n    };\n    this.handleVideoPlaybackFailed = () => {\n      if (!this.isVideoPlaybackBlocked) {\n        this.isVideoPlaybackBlocked = true;\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n      }\n    };\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) !== 'iOS') {\n        // default devices are non deterministic on iOS, so we don't attempt to select them here\n        yield this.selectDefaultDevices();\n      }\n      this.emit(RoomEvent.MediaDevicesChanged);\n    });\n    this.handleRoomUpdate = room => {\n      const oldRoom = this.roomInfo;\n      this.roomInfo = room;\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n      }\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n      }\n    };\n    this.handleConnectionQualityUpdate = update => {\n      update.updates.forEach(info => {\n        if (info.participantSid === this.localParticipant.sid) {\n          this.localParticipant.setConnectionQuality(info.quality);\n          return;\n        }\n        const participant = this.getRemoteParticipantBySid(info.participantSid);\n        if (participant) {\n          participant.setConnectionQuality(info.quality);\n        }\n      });\n    };\n    this.onLocalParticipantMetadataChanged = metadata => {\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n    };\n    this.onLocalParticipantNameChanged = name => {\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n    };\n    this.onLocalAttributesChanged = changedAttributes => {\n      this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\n    };\n    this.onLocalTrackMuted = pub => {\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n    };\n    this.onLocalTrackUnmuted = pub => {\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n    };\n    this.onTrackProcessorUpdate = processor => {\n      var _a;\n      (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\n    };\n    this.onLocalTrackPublished = pub => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d, _e, _f;\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\n      (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n      if (isLocalAudioTrack(pub.track)) {\n        const trackIsSilent = yield pub.track.checkForSilence();\n        if (trackIsSilent) {\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n        }\n      }\n      const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\n      const deviceKind = sourceToKind(pub.source);\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n      }\n    });\n    this.onLocalTrackUnpublished = pub => {\n      var _a, _b;\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n    };\n    this.onLocalTrackRestarted = track => __awaiter(this, void 0, void 0, function* () {\n      const deviceId = yield track.getDeviceId(false);\n      const deviceKind = sourceToKind(track.source);\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n        this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n      }\n    });\n    this.onLocalConnectionQualityChanged = quality => {\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n    };\n    this.onMediaDevicesError = (e, kind) => {\n      this.emit(RoomEvent.MediaDevicesError, e, kind);\n    };\n    this.onLocalParticipantPermissionsChanged = prevPermissions => {\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n    };\n    this.onLocalChatMessageSent = msg => {\n      this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\n    };\n    this.setMaxListeners(100);\n    this.remoteParticipants = new Map();\n    this.sidToIdentity = new Map();\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n    this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n    this.transcriptionReceivedTimes = new Map();\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n    this.maybeCreateEngine();\n    this.incomingDataStreamManager = new IncomingDataStreamManager();\n    this.outgoingDataStreamManager = new OutgoingDataStreamManager(this.engine, this.log);\n    this.disconnectLock = new _();\n    this.localParticipant = new LocalParticipant('', '', this.engine, this.options, this.rpcHandlers, this.outgoingDataStreamManager);\n    if (this.options.e2ee || this.options.encryption) {\n      this.setupE2EE();\n    }\n    this.engine.e2eeManager = this.e2eeManager;\n    if (this.options.videoCaptureDefaults.deviceId) {\n      this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n    }\n    if (this.options.audioCaptureDefaults.deviceId) {\n      this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n    }\n    if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n      this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n    }\n    if (isWeb()) {\n      const abortController = new AbortController();\n      // in order to catch device changes prior to room connection we need to register the event in the constructor\n      (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener('devicechange', this.handleDeviceChange, {\n        signal: abortController.signal\n      });\n      if (Room.cleanupRegistry) {\n        Room.cleanupRegistry.register(this, () => {\n          abortController.abort();\n        });\n      }\n    }\n  }\n  registerTextStreamHandler(topic, callback) {\n    return this.incomingDataStreamManager.registerTextStreamHandler(topic, callback);\n  }\n  unregisterTextStreamHandler(topic) {\n    return this.incomingDataStreamManager.unregisterTextStreamHandler(topic);\n  }\n  registerByteStreamHandler(topic, callback) {\n    return this.incomingDataStreamManager.registerByteStreamHandler(topic, callback);\n  }\n  unregisterByteStreamHandler(topic) {\n    return this.incomingDataStreamManager.unregisterByteStreamHandler(topic);\n  }\n  /**\n   * Establishes the participant as a receiver for calls of the specified RPC method.\n   *\n   * @param method - The name of the indicated RPC method\n   * @param handler - Will be invoked when an RPC request for this method is received\n   * @returns A promise that resolves when the method is successfully registered\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\n   *\n   * @example\n   * ```typescript\n   * room.localParticipant?.registerRpcMethod(\n   *   'greet',\n   *   async (data: RpcInvocationData) => {\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\n   *     return `Hello, ${data.callerIdentity}!`;\n   *   }\n   * );\n   * ```\n   *\n   * The handler should return a Promise that resolves to a string.\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\n   *\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\n   * and they will be received on the caller's side with the message intact.\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\n   */\n  registerRpcMethod(method, handler) {\n    if (this.rpcHandlers.has(method)) {\n      throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\n    }\n    this.rpcHandlers.set(method, handler);\n  }\n  /**\n   * Unregisters a previously registered RPC method.\n   *\n   * @param method - The name of the RPC method to unregister\n   */\n  unregisterRpcMethod(method) {\n    this.rpcHandlers.delete(method);\n  }\n  /**\n   * @experimental\n   */\n  setE2EEEnabled(enabled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.e2eeManager) {\n        yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);\n        if (this.localParticipant.identity !== '') {\n          this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n        }\n      } else {\n        throw Error('e2ee not configured, please set e2ee settings within the room options');\n      }\n    });\n  }\n  setupE2EE() {\n    // when encryption is enabled via `options.encryption`, we enable data channel encryption\n    var _a;\n    const dcEncryptionEnabled = !!this.options.encryption;\n    const e2eeOptions = this.options.encryption || this.options.e2ee;\n    if (e2eeOptions) {\n      if ('e2eeManager' in e2eeOptions) {\n        this.e2eeManager = e2eeOptions.e2eeManager;\n        this.e2eeManager.isDataChannelEncryptionEnabled = dcEncryptionEnabled;\n      } else {\n        this.e2eeManager = new E2EEManager(e2eeOptions, dcEncryptionEnabled);\n      }\n      this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {\n        if (isLocalParticipant(participant)) {\n          this.isE2EEEnabled = enabled;\n        }\n        this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n      });\n      this.e2eeManager.on(EncryptionEvent.EncryptionError, (error, participantIdentity) => {\n        const participant = participantIdentity ? this.getParticipantByIdentity(participantIdentity) : undefined;\n        this.emit(RoomEvent.EncryptionError, error, participant);\n      });\n      (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n    }\n  }\n  get logContext() {\n    var _a;\n    return {\n      room: this.name,\n      roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\n      participant: this.localParticipant.identity,\n      pID: this.localParticipant.sid\n    };\n  }\n  /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/\n  get isRecording() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */\n  getSid() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === ConnectionState.Disconnected) {\n        return '';\n      }\n      if (this.roomInfo && this.roomInfo.sid !== '') {\n        return this.roomInfo.sid;\n      }\n      return new Promise((resolve, reject) => {\n        const handleRoomUpdate = roomInfo => {\n          if (roomInfo.sid !== '') {\n            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n            resolve(roomInfo.sid);\n          }\n        };\n        this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\n        this.once(RoomEvent.Disconnected, () => {\n          this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n          reject('Room disconnected before room server id was available');\n        });\n      });\n    });\n  }\n  /** user assigned name, derived from JWT token */\n  get name() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n  }\n  /** room metadata */\n  get metadata() {\n    var _a;\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n  }\n  get numParticipants() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n  }\n  get numPublishers() {\n    var _a, _b;\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n  }\n  maybeCreateEngine() {\n    if (this.engine && !this.engine.isClosed) {\n      return;\n    }\n    this.engine = new RTCEngine(this.options);\n    this.engine.e2eeManager = this.e2eeManager;\n    this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\n      this.onTrackAdded(mediaTrack, stream, receiver);\n    }).on(EngineEvent.Disconnected, reason => {\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\n      this.clearConnectionReconcile();\n      this.isResuming = true;\n      this.log.info('Resuming signal connection', this.logContext);\n      if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\n        this.emit(RoomEvent.SignalReconnecting);\n      }\n    }).on(EngineEvent.Resumed, () => {\n      this.registerConnectionReconcile();\n      this.isResuming = false;\n      this.log.info('Resumed signal connection', this.logContext);\n      this.updateSubscriptions();\n      this.emitBufferedEvents();\n      if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\n        this.emit(RoomEvent.Reconnected);\n      }\n    }).on(EngineEvent.SignalResumed, () => {\n      this.bufferedEvents = [];\n      if (this.state === ConnectionState.Reconnecting || this.isResuming) {\n        this.sendSyncState();\n      }\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n        this.emit(RoomEvent.Reconnecting);\n      }\n    }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n    }).on(EngineEvent.LocalTrackSubscribed, subscribedSid => {\n      const trackPublication = this.localParticipant.getTrackPublications().find(_ref2 => {\n        let {\n          trackSid\n        } = _ref2;\n        return trackSid === subscribedSid;\n      });\n      if (!trackPublication) {\n        this.log.warn('could not find local track subscription for subscribed event', this.logContext);\n        return;\n      }\n      this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\n      this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\n    }).on(EngineEvent.RoomMoved, roomMoved => {\n      this.log.debug('room moved', roomMoved);\n      if (roomMoved.room) {\n        this.handleRoomUpdate(roomMoved.room);\n      }\n      this.remoteParticipants.forEach((participant, identity) => {\n        this.handleParticipantDisconnected(identity, participant);\n      });\n      this.emit(RoomEvent.Moved, roomMoved.room.name);\n      if (roomMoved.participant) {\n        this.handleParticipantUpdates([roomMoved.participant, ...roomMoved.otherParticipants]);\n      } else {\n        this.handleParticipantUpdates(roomMoved.otherParticipants);\n      }\n    });\n    if (this.localParticipant) {\n      this.localParticipant.setupEngine(this.engine);\n    }\n    if (this.e2eeManager) {\n      this.e2eeManager.setupEngine(this.engine);\n    }\n    if (this.outgoingDataStreamManager) {\n      this.outgoingDataStreamManager.setupEngine(this.engine);\n    }\n  }\n  /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it requests device permissions by default if needed\n   * and makes sure the returned device does not consist of dummy devices\n   * @param kind\n   * @returns a list of available local devices\n   */\n  static getLocalDevices(kind) {\n    let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n  }\n  /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */\n  prepareConnection(url, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state !== ConnectionState.Disconnected) {\n        return;\n      }\n      this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n      try {\n        if (isCloud(new URL(url)) && token) {\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\n          const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n          // we will not replace the regionUrl if an attempt had already started\n          // to avoid overriding regionUrl after a new connection attempt had started\n          if (regionUrl && this.state === ConnectionState.Disconnected) {\n            this.regionUrl = regionUrl;\n            yield fetch(toHttpUrl(regionUrl), {\n              method: 'HEAD'\n            });\n            this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n          }\n        } else {\n          yield fetch(toHttpUrl(url), {\n            method: 'HEAD'\n          });\n        }\n      } catch (e) {\n        this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\n          error: e\n        }));\n      }\n    });\n  }\n  /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */\n  getParticipantByIdentity(identity) {\n    if (this.localParticipant.identity === identity) {\n      return this.localParticipant;\n    }\n    return this.remoteParticipants.get(identity);\n  }\n  clearConnectionFutures() {\n    this.connectFuture = undefined;\n  }\n  /**\n   * @internal for testing\n   */\n  simulateScenario(scenario, arg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let postAction = () => __awaiter(this, void 0, void 0, function* () {});\n      let req;\n      switch (scenario) {\n        case 'signal-reconnect':\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate disconnect');\n          break;\n        case 'speaker':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'speakerUpdate',\n              value: 3\n            }\n          });\n          break;\n        case 'node-failure':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'nodeFailure',\n              value: true\n            }\n          });\n          break;\n        case 'server-leave':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'serverLeave',\n              value: true\n            }\n          });\n          break;\n        case 'migration':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'migration',\n              value: true\n            }\n          });\n          break;\n        case 'resume-reconnect':\n          this.engine.failNext();\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          break;\n        case 'disconnect-signal-on-resume':\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            // @ts-expect-error function is private\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          });\n          req = new SimulateScenario({\n            scenario: {\n              case: 'disconnectSignalOnResume',\n              value: true\n            }\n          });\n          break;\n        case 'disconnect-signal-on-resume-no-messages':\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            // @ts-expect-error function is private\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n          });\n          req = new SimulateScenario({\n            scenario: {\n              case: 'disconnectSignalOnResumeNoMessages',\n              value: true\n            }\n          });\n          break;\n        case 'full-reconnect':\n          this.engine.fullReconnectOnNext = true;\n          // @ts-expect-error function is private\n          yield this.engine.client.handleOnClose('simulate full-reconnect');\n          break;\n        case 'force-tcp':\n        case 'force-tls':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'switchCandidateProtocol',\n              value: scenario === 'force-tls' ? 2 : 1\n            }\n          });\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\n            const onLeave = this.engine.client.onLeave;\n            if (onLeave) {\n              onLeave(new LeaveRequest({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                action: LeaveRequest_Action.RECONNECT\n              }));\n            }\n          });\n          break;\n        case 'subscriber-bandwidth':\n          if (arg === undefined || typeof arg !== 'number') {\n            throw new Error('subscriber-bandwidth requires a number as argument');\n          }\n          req = new SimulateScenario({\n            scenario: {\n              case: 'subscriberBandwidth',\n              value: numberToBigInt(arg)\n            }\n          });\n          break;\n        case 'leave-full-reconnect':\n          req = new SimulateScenario({\n            scenario: {\n              case: 'leaveRequestFullReconnect',\n              value: true\n            }\n          });\n      }\n      if (req) {\n        yield this.engine.client.sendSimulateScenario(req);\n        yield postAction();\n      }\n    });\n  }\n  /**\n   * Returns true if audio playback is enabled\n   */\n  get canPlaybackAudio() {\n    return this.audioEnabled;\n  }\n  /**\n   * Returns true if video playback is enabled\n   */\n  get canPlaybackVideo() {\n    return !this.isVideoPlaybackBlocked;\n  }\n  getActiveDevice(kind) {\n    return this.localParticipant.activeDeviceMap.get(kind);\n  }\n  /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */\n  switchActiveDevice(kind_1, deviceId_1) {\n    return __awaiter(this, arguments, void 0, function (kind, deviceId) {\n      var _this3 = this;\n      let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return function* () {\n        var _a, _b, _c, _d, _e, _f;\n        var _g;\n        let success = true;\n        let shouldTriggerImmediateDeviceChange = false;\n        const deviceConstraint = exact ? {\n          exact: deviceId\n        } : deviceId;\n        if (kind === 'audioinput') {\n          shouldTriggerImmediateDeviceChange = _this3.localParticipant.audioTrackPublications.size === 0;\n          const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\n          _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\n          const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter(track => track.source === Track.Source.Microphone);\n          try {\n            success = (yield Promise.all(tracks.map(t => {\n              var _a;\n              return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n            }))).every(val => val === true);\n          } catch (e) {\n            _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\n            throw e;\n          }\n          const isMuted = tracks.some(t => {\n            var _a, _b;\n            return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !== null && _b !== void 0 ? _b : false;\n          });\n          if (success && isMuted) shouldTriggerImmediateDeviceChange = true;\n        } else if (kind === 'videoinput') {\n          shouldTriggerImmediateDeviceChange = _this3.localParticipant.videoTrackPublications.size === 0;\n          const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\n          _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\n          const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter(track => track.source === Track.Source.Camera);\n          try {\n            success = (yield Promise.all(tracks.map(t => {\n              var _a;\n              return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n            }))).every(val => val === true);\n          } catch (e) {\n            _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\n            throw e;\n          }\n          const isMuted = tracks.some(t => {\n            var _a, _b;\n            return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !== null && _b !== void 0 ? _b : false;\n          });\n          if (success && isMuted) shouldTriggerImmediateDeviceChange = true;\n        } else if (kind === 'audiooutput') {\n          shouldTriggerImmediateDeviceChange = true;\n          if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !('setSinkId' in _this3.audioContext)) {\n            throw new Error('cannot switch audio output, the current browser does not support it');\n          }\n          if (_this3.options.webAudioMix) {\n            // setting `default` for web audio output doesn't work, so we need to normalize the id before\n            deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId('audiooutput', deviceId)) !== null && _c !== void 0 ? _c : '';\n          }\n          (_d = (_g = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _g.audioOutput = {};\n          const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\n          _this3.options.audioOutput.deviceId = deviceId;\n          try {\n            if (_this3.options.webAudioMix) {\n              // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n              (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\n            }\n            // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\n            // see https://issues.chromium.org/issues/40252911#comment7\n            yield Promise.all(Array.from(_this3.remoteParticipants.values()).map(p => p.setAudioOutput({\n              deviceId\n            })));\n          } catch (e) {\n            _this3.options.audioOutput.deviceId = prevDeviceId;\n            throw e;\n          }\n        }\n        if (shouldTriggerImmediateDeviceChange) {\n          _this3.localParticipant.activeDeviceMap.set(kind, deviceId);\n          _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n        }\n        return success;\n      }();\n    });\n  }\n  setupLocalParticipantEvents() {\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n  }\n  recreateEngine() {\n    var _a;\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n    /* @ts-ignore */\n    this.engine = undefined;\n    this.isResuming = false;\n    // clear out existing remote participants, since they may have attached\n    // the old engine\n    this.remoteParticipants.clear();\n    this.sidToIdentity.clear();\n    this.bufferedEvents = [];\n    this.maybeCreateEngine();\n  }\n  onTrackAdded(mediaTrack, stream, receiver) {\n    // don't fire onSubscribed when connecting\n    // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n    // at that time, ICE connectivity has not been established so the track is not\n    // technically subscribed.\n    // We'll defer these events until when the room is connected or eventually disconnected.\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n      const reconnectedHandler = () => {\n        this.log.debug('deferring on track for later', {\n          mediaTrackId: mediaTrack.id,\n          mediaStreamId: stream.id,\n          tracksInStream: stream.getTracks().map(track => track.id)\n        });\n        this.onTrackAdded(mediaTrack, stream, receiver);\n        cleanup();\n      };\n      const cleanup = () => {\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\n        this.off(RoomEvent.Connected, reconnectedHandler);\n        this.off(RoomEvent.Disconnected, cleanup);\n      };\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\n      this.once(RoomEvent.Connected, reconnectedHandler);\n      this.once(RoomEvent.Disconnected, cleanup);\n      return;\n    }\n    if (this.state === ConnectionState.Disconnected) {\n      this.log.warn('skipping incoming track after Room disconnected', this.logContext);\n      return;\n    }\n    if (mediaTrack.readyState === 'ended') {\n      this.log.info('skipping incoming track as it already ended', this.logContext);\n      return;\n    }\n    const parts = unpackStreamId(stream.id);\n    const participantSid = parts[0];\n    let streamId = parts[1];\n    let trackId = mediaTrack.id;\n    // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n    // and generates its own track id instead of infer from sdp track id.\n    if (streamId && streamId.startsWith('TR')) trackId = streamId;\n    if (participantSid === this.localParticipant.sid) {\n      this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\n      return;\n    }\n    const participant = Array.from(this.remoteParticipants.values()).find(p => p.sid === participantSid);\n    if (!participant) {\n      this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n      return;\n    }\n    // in single peer connection case, the trackID is locally generated,\n    // not the TR_ prefixed one generated by the server,\n    // use `mid` to find the appropriate track.\n    if (!trackId.startsWith('TR')) {\n      const id = this.engine.getTrackIdForReceiver(receiver);\n      if (!id) {\n        this.log.error(\"Tried to add a track whose 'sid' could not be found for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n        return;\n      }\n      trackId = id;\n    }\n    if (!trackId.startsWith('TR')) {\n      this.log.warn(\"Tried to add a track whose 'sid' could not be determined for a participant, that's not present. Sid: \".concat(participantSid, \", streamId: \").concat(streamId, \", trackId: \").concat(trackId), Object.assign(Object.assign({}, this.logContext), {\n        rpID: participantSid,\n        streamId,\n        trackId\n      }));\n    }\n    let adaptiveStreamSettings;\n    if (this.options.adaptiveStream) {\n      if (typeof this.options.adaptiveStream === 'object') {\n        adaptiveStreamSettings = this.options.adaptiveStream;\n      } else {\n        adaptiveStreamSettings = {};\n      }\n    }\n    const publication = participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    if ((publication === null || publication === void 0 ? void 0 : publication.isEncrypted) && !this.e2eeManager) {\n      this.emit(RoomEvent.EncryptionError, new Error(\"Encrypted \".concat(publication.source, \" track received from participant \").concat(participant.sid, \", but room does not have encryption enabled!\")));\n    }\n  }\n  handleDisconnect() {\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    var _a;\n    this.clearConnectionReconcile();\n    this.isResuming = false;\n    this.bufferedEvents = [];\n    this.transcriptionReceivedTimes.clear();\n    this.incomingDataStreamManager.clearControllers();\n    if (this.state === ConnectionState.Disconnected) {\n      return;\n    }\n    this.regionUrl = undefined;\n    // Notify region provider about disconnect to potentially stop auto-refetch\n    if (this.regionUrlProvider) {\n      this.regionUrlProvider.notifyDisconnected();\n    }\n    try {\n      this.remoteParticipants.forEach(p => {\n        p.trackPublications.forEach(pub => {\n          p.unpublishTrack(pub.trackSid);\n        });\n      });\n      this.localParticipant.trackPublications.forEach(pub => {\n        var _a, _b, _c;\n        if (pub.track) {\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n        }\n        if (shouldStopTracks) {\n          (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n        } else {\n          (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\n        }\n      });\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n      this.localParticipant.trackPublications.clear();\n      this.localParticipant.videoTrackPublications.clear();\n      this.localParticipant.audioTrackPublications.clear();\n      this.remoteParticipants.clear();\n      this.sidToIdentity.clear();\n      this.activeSpeakers = [];\n      if (this.audioContext && typeof this.options.webAudioMix === 'boolean') {\n        this.audioContext.close();\n        this.audioContext = undefined;\n      }\n      if (isWeb()) {\n        window.removeEventListener('beforeunload', this.onPageLeave);\n        window.removeEventListener('pagehide', this.onPageLeave);\n        window.removeEventListener('freeze', this.onPageLeave);\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\n      }\n    } finally {\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\n      this.emit(RoomEvent.Disconnected, reason);\n    }\n  }\n  handleParticipantDisconnected(identity, participant) {\n    var _a;\n    // remove and send event\n    this.remoteParticipants.delete(identity);\n    if (!participant) {\n      return;\n    }\n    this.incomingDataStreamManager.validateParticipantHasNoActiveDataStreams(identity);\n    participant.trackPublications.forEach(publication => {\n      participant.unpublishTrack(publication.trackSid, true);\n    });\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\n    participant.setDisconnected();\n    (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\n  }\n  handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.engine.publishRpcAck(callerIdentity, requestId);\n      if (version !== 1) {\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_VERSION'));\n        return;\n      }\n      const handler = this.rpcHandlers.get(method);\n      if (!handler) {\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_METHOD'));\n        return;\n      }\n      let responseError = null;\n      let responsePayload = null;\n      try {\n        const response = yield handler({\n          requestId,\n          callerIdentity,\n          payload,\n          responseTimeout\n        });\n        if (byteLength(response) > MAX_PAYLOAD_BYTES) {\n          responseError = RpcError.builtIn('RESPONSE_PAYLOAD_TOO_LARGE');\n          this.log.warn(\"RPC Response payload too large for \".concat(method));\n        } else {\n          responsePayload = response;\n        }\n      } catch (error) {\n        if (error instanceof RpcError) {\n          responseError = error;\n        } else {\n          this.log.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\n          responseError = RpcError.builtIn('APPLICATION_ERROR');\n        }\n      }\n      yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\n    });\n  }\n  /**\n   * attempt to select the default devices if the previously selected devices are no longer available after a device change event\n   */\n  selectDefaultDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      const previousDevices = DeviceManager.getInstance().previousDevices;\n      // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\n      const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\n      const browser = getBrowser();\n      if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && browser.os !== 'iOS') {\n        for (let availableDevice of availableDevices) {\n          const previousDevice = previousDevices.find(info => info.deviceId === availableDevice.deviceId);\n          if (previousDevice && previousDevice.label !== '' && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\n            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\n            if (this.getActiveDevice(availableDevice.kind) === 'default') {\n              // emit an active device change event only if the selected output device is actually on `default`\n              this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\n            }\n          }\n        }\n      }\n      const kinds = ['audiooutput', 'audioinput', 'videoinput'];\n      for (let kind of kinds) {\n        const targetSource = kindToSource(kind);\n        const targetPublication = this.localParticipant.getTrackPublication(targetSource);\n        if (targetPublication && ((_a = targetPublication.track) === null || _a === void 0 ? void 0 : _a.isUserProvided)) {\n          // if the track is user provided, we don't want to switch devices on behalf of the user\n          continue;\n        }\n        const devicesOfKind = availableDevices.filter(d => d.kind === kind);\n        const activeDevice = this.getActiveDevice(kind);\n        if (activeDevice === ((_b = previousDevices.filter(info => info.kind === kind)[0]) === null || _b === void 0 ? void 0 : _b.deviceId)) {\n          // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\n          // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\n          if (devicesOfKind.length > 0 && ((_c = devicesOfKind[0]) === null || _c === void 0 ? void 0 : _c.deviceId) !== activeDevice) {\n            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n            continue;\n          }\n        }\n        if (kind === 'audioinput' && !isSafariBased() || kind === 'videoinput') {\n          // airpods on Safari need special handling for audioinput as the track doesn't end as soon as you take them out\n          continue;\n        }\n        // switch to first available device if previously active device is not available any more\n        if (devicesOfKind.length > 0 && !devicesOfKind.find(deviceInfo => deviceInfo.deviceId === this.getActiveDevice(kind)) && (\n        // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback\n        kind !== 'audiooutput' || !isSafariBased())) {\n          yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n        }\n      }\n    });\n  }\n  acquireAudioContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (typeof this.options.webAudioMix !== 'boolean' && this.options.webAudioMix.audioContext) {\n        // override audio context with custom audio context if supplied by user\n        this.audioContext = this.options.webAudioMix.audioContext;\n      } else if (!this.audioContext || this.audioContext.state === 'closed') {\n        // by using an AudioContext, it reduces lag on audio elements\n        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n      }\n      if (this.options.webAudioMix) {\n        this.remoteParticipants.forEach(participant => participant.setAudioContext(this.audioContext));\n      }\n      this.localParticipant.setAudioContext(this.audioContext);\n      if (this.audioContext && this.audioContext.state === 'suspended') {\n        // for iOS a newly created AudioContext is always in `suspended` state.\n        // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n        try {\n          yield Promise.race([this.audioContext.resume(), sleep(200)]);\n        } catch (e) {\n          this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\n            error: e\n          }));\n        }\n      }\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\n      if (newContextIsRunning !== this.canPlaybackAudio) {\n        this.audioEnabled = newContextIsRunning;\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n      }\n    });\n  }\n  createParticipant(identity, info) {\n    var _a;\n    let participant;\n    if (info) {\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\n        loggerContextCb: () => this.logContext,\n        loggerName: this.options.loggerName\n      });\n    } else {\n      participant = new RemoteParticipant(this.engine.client, '', identity, undefined, undefined, undefined, {\n        loggerContextCb: () => this.logContext,\n        loggerName: this.options.loggerName\n      });\n    }\n    if (this.options.webAudioMix) {\n      participant.setAudioContext(this.audioContext);\n    }\n    if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n      participant.setAudioOutput(this.options.audioOutput).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n    }\n    return participant;\n  }\n  getOrCreateParticipant(identity, info) {\n    if (this.remoteParticipants.has(identity)) {\n      const existingParticipant = this.remoteParticipants.get(identity);\n      if (info) {\n        const wasUpdated = existingParticipant.updateInfo(info);\n        if (wasUpdated) {\n          this.sidToIdentity.set(info.sid, info.identity);\n        }\n      }\n      return existingParticipant;\n    }\n    const participant = this.createParticipant(identity, info);\n    this.remoteParticipants.set(identity, participant);\n    this.sidToIdentity.set(info.sid, info.identity);\n    // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n    // firing here to make sure that `ParticipantConnected` fires before the initial track events\n    this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n    // also forward events\n    // trackPublished is only fired for tracks added after both local participant\n    // and remote participant joined the room\n    participant.on(ParticipantEvent.TrackPublished, trackPublication => {\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\n      // monitor playback status\n      if (track.kind === Track.Kind.Audio) {\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n      } else if (track.kind === Track.Kind.Video) {\n        track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n        track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n      }\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackUnpublished, publication => {\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n    }).on(ParticipantEvent.TrackMuted, pub => {\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n    }).on(ParticipantEvent.TrackUnmuted, pub => {\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n    }).on(ParticipantEvent.ParticipantMetadataChanged, metadata => {\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n    }).on(ParticipantEvent.ParticipantNameChanged, name => {\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n    }).on(ParticipantEvent.AttributesChanged, changedAttributes => {\n      this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\n    }).on(ParticipantEvent.ConnectionQualityChanged, quality => {\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions => {\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n    }).on(ParticipantEvent.Active, () => {\n      this.emitWhenConnected(RoomEvent.ParticipantActive, participant);\n      if (participant.kind === ParticipantInfo_Kind.AGENT) {\n        this.localParticipant.setActiveAgent(participant);\n      }\n    });\n    // update info at the end after callbacks have been set up\n    if (info) {\n      participant.updateInfo(info);\n    }\n    return participant;\n  }\n  sendSyncState() {\n    const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {\n      acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n      return acc;\n    }, []);\n    const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n    this.engine.sendSyncState(remoteTracks, localTracks);\n  }\n  /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */\n  updateSubscriptions() {\n    for (const p of this.remoteParticipants.values()) {\n      for (const pub of p.videoTrackPublications.values()) {\n        if (pub.isSubscribed && isRemotePub(pub)) {\n          pub.emitTrackUpdate();\n        }\n      }\n    }\n  }\n  getRemoteParticipantBySid(sid) {\n    const identity = this.sidToIdentity.get(sid);\n    if (identity) {\n      return this.remoteParticipants.get(identity);\n    }\n  }\n  registerConnectionReconcile() {\n    this.clearConnectionReconcile();\n    let consecutiveFailures = 0;\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\n      if (\n      // ensure we didn't tear it down\n      !this.engine ||\n      // engine detected close, but Room missed it\n      this.engine.isClosed ||\n      // transports failed without notifying engine\n      !this.engine.verifyTransport()) {\n        consecutiveFailures++;\n        this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\n          numFailures: consecutiveFailures,\n          engine: this.engine ? {\n            closed: this.engine.isClosed,\n            transportsConnected: this.engine.verifyTransport()\n          } : undefined\n        }));\n        if (consecutiveFailures >= 3) {\n          this.recreateEngine();\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n        }\n      } else {\n        consecutiveFailures = 0;\n      }\n    }, CONNECTION_RECONCILE_FREQUENCY_MS);\n  }\n  clearConnectionReconcile() {\n    if (this.connectionReconcileInterval) {\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\n    }\n  }\n  setAndEmitConnectionState(state) {\n    if (state === this.state) {\n      // unchanged\n      return false;\n    }\n    this.state = state;\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\n    return true;\n  }\n  emitBufferedEvents() {\n    this.bufferedEvents.forEach(_ref3 => {\n      let [ev, args] = _ref3;\n      this.emit(ev, ...args);\n    });\n    this.bufferedEvents = [];\n  }\n  emitWhenConnected(event) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\n      // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n      this.bufferedEvents.push([event, args]);\n    } else if (this.state === ConnectionState.Connected) {\n      return this.emit(event, ...args);\n    }\n    return false;\n  }\n  /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */\n  simulateParticipants(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const publishOptions = Object.assign({\n        audio: true,\n        video: true,\n        useRealTracks: false\n      }, options.publish);\n      const participantOptions = Object.assign({\n        count: 9,\n        audio: false,\n        video: true,\n        aspectRatios: [1.66, 1.7, 1.3]\n      }, options.participants);\n      this.handleDisconnect();\n      this.roomInfo = new Room$1({\n        sid: 'RM_SIMULATED',\n        name: 'simulated-room',\n        emptyTimeout: 0,\n        maxParticipants: 0,\n        creationTime: protoInt64.parse(new Date().getTime()),\n        metadata: '',\n        numParticipants: 1,\n        numPublishers: 1,\n        turnPassword: '',\n        enabledCodecs: [],\n        activeRecording: false\n      });\n      this.localParticipant.updateInfo(new ParticipantInfo({\n        identity: 'simulated-local',\n        name: 'local-name'\n      }));\n      this.setupLocalParticipantEvents();\n      this.emit(RoomEvent.SignalConnected);\n      this.emit(RoomEvent.Connected);\n      this.setAndEmitConnectionState(ConnectionState.Connected);\n      if (publishOptions.video) {\n        const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n          source: TrackSource.CAMERA,\n          sid: Math.floor(Math.random() * 10000).toString(),\n          type: TrackType.AUDIO,\n          name: 'video-dummy'\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n          video: true\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        // @ts-ignore\n        this.localParticipant.addTrackPublication(camPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n      }\n      if (publishOptions.audio) {\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n          source: TrackSource.MICROPHONE,\n          sid: Math.floor(Math.random() * 10000).toString(),\n          type: TrackType.AUDIO\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          audio: true\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        // @ts-ignore\n        this.localParticipant.addTrackPublication(audioPub);\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n      }\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\n        let info = new ParticipantInfo({\n          sid: Math.floor(Math.random() * 10000).toString(),\n          identity: \"simulated-\".concat(i),\n          state: ParticipantInfo_State.ACTIVE,\n          tracks: [],\n          joinedAt: protoInt64.parse(Date.now())\n        });\n        const p = this.getOrCreateParticipant(info.identity, info);\n        if (participantOptions.video) {\n          const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n          const videoTrack = new TrackInfo({\n            source: TrackSource.CAMERA,\n            sid: Math.floor(Math.random() * 10000).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());\n          info.tracks = [...info.tracks, videoTrack];\n        }\n        if (participantOptions.audio) {\n          const dummyTrack = getEmptyAudioStreamTrack();\n          const audioTrack = new TrackInfo({\n            source: TrackSource.MICROPHONE,\n            sid: Math.floor(Math.random() * 10000).toString(),\n            type: TrackType.AUDIO\n          });\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());\n          info.tracks = [...info.tracks, audioTrack];\n        }\n        p.updateInfo(info);\n      }\n    });\n  }\n  // /** @internal */\n  emit(event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    // active speaker updates are too spammy\n    if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\n      // only extract logContext from arguments in order to avoid logging the whole object tree\n      const minimizedArgs = mapArgs(args).filter(arg => arg !== undefined);\n      if (event === RoomEvent.TrackSubscribed || event === RoomEvent.TrackUnsubscribed) {\n        this.log.trace(\"subscribe trace: \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n          event,\n          args: minimizedArgs\n        }));\n      }\n      this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n        event,\n        args: minimizedArgs\n      }));\n    }\n    return super.emit(event, ...args);\n  }\n}\nRoom.cleanupRegistry = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(cleanup => {\n  cleanup();\n});\nfunction mapArgs(args) {\n  return args.map(arg => {\n    if (!arg) {\n      return;\n    }\n    if (Array.isArray(arg)) {\n      return mapArgs(arg);\n    }\n    if (typeof arg === 'object') {\n      return 'logContext' in arg ? arg.logContext : undefined;\n    }\n    return arg;\n  });\n}// This file was generated from JSON Schema using quicktype, do not modify it directly.\n// The code generation lives at https://github.com/livekit/attribute-definitions\n//\n// To parse this data:\n//\n//   import { Convert, AgentAttributes, TranscriptionAttributes } from \"./file\";\n//\n//   const agentAttributes = Convert.toAgentAttributes(json);\n//   const transcriptionAttributes = Convert.toTranscriptionAttributes(json);\n// Converts JSON strings to/from your types\nclass Convert {\n  static toAgentAttributes(json) {\n    return JSON.parse(json);\n  }\n  static agentAttributesToJson(value) {\n    return JSON.stringify(value);\n  }\n  static toTranscriptionAttributes(json) {\n    return JSON.parse(json);\n  }\n  static transcriptionAttributesToJson(value) {\n    return JSON.stringify(value);\n  }\n}var attributeTypings=/*#__PURE__*/Object.freeze({__proto__:null,Convert:Convert});var CheckStatus;\n(function (CheckStatus) {\n  CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n  CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n  CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n  CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n  CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.status = CheckStatus.IDLE;\n    this.logs = [];\n    this.options = {};\n    this.url = url;\n    this.token = token;\n    this.name = this.constructor.name;\n    this.room = new Room(options.roomOptions);\n    this.connectOptions = options.connectOptions;\n    this.options = options;\n  }\n  run(onComplete) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== CheckStatus.IDLE) {\n        throw Error('check is running already');\n      }\n      this.setStatus(CheckStatus.RUNNING);\n      try {\n        yield this.perform();\n      } catch (err) {\n        if (err instanceof Error) {\n          if (this.options.errorsAsWarnings) {\n            this.appendWarning(err.message);\n          } else {\n            this.appendError(err.message);\n          }\n        }\n      }\n      yield this.disconnect();\n      // sleep for a bit to ensure disconnect\n      yield new Promise(resolve => setTimeout(resolve, 500));\n      // @ts-ignore\n      if (this.status !== CheckStatus.SKIPPED) {\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n      }\n      if (onComplete) {\n        onComplete();\n      }\n      return this.getInfo();\n    });\n  }\n  isSuccess() {\n    return !this.logs.some(l => l.level === 'error');\n  }\n  connect(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room.state === ConnectionState.Connected) {\n        return this.room;\n      }\n      if (!url) {\n        url = this.url;\n      }\n      yield this.room.connect(url, this.token, this.connectOptions);\n      return this.room;\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\n        yield this.room.disconnect();\n        // wait for it to go through\n        yield new Promise(resolve => setTimeout(resolve, 500));\n      }\n    });\n  }\n  skip() {\n    this.setStatus(CheckStatus.SKIPPED);\n  }\n  switchProtocol(protocol) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hasReconnecting = false;\n      let hasReconnected = false;\n      this.room.on(RoomEvent.Reconnecting, () => {\n        hasReconnecting = true;\n      });\n      this.room.once(RoomEvent.Reconnected, () => {\n        hasReconnected = true;\n      });\n      this.room.simulateScenario(\"force-\".concat(protocol));\n      yield new Promise(resolve => setTimeout(resolve, 1000));\n      if (!hasReconnecting) {\n        // no need to wait for reconnection\n        return;\n      }\n      // wait for 10 seconds for reconnection\n      const timeout = Date.now() + 10000;\n      while (Date.now() < timeout) {\n        if (hasReconnected) {\n          return;\n        }\n        yield sleep(100);\n      }\n      throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\n    });\n  }\n  appendMessage(message) {\n    this.logs.push({\n      level: 'info',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  appendWarning(message) {\n    this.logs.push({\n      level: 'warning',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  appendError(message) {\n    this.logs.push({\n      level: 'error',\n      message\n    });\n    this.emit('update', this.getInfo());\n  }\n  setStatus(status) {\n    this.status = status;\n    this.emit('update', this.getInfo());\n  }\n  get engine() {\n    var _a;\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n  }\n  getInfo() {\n    return {\n      logs: this.logs,\n      name: this.name,\n      status: this.status,\n      description: this.description\n    };\n  }\n}/**\n * Checks for connections quality to closests Cloud regions and determining the best quality\n */\nclass CloudRegionCheck extends Checker {\n  get description() {\n    return 'Cloud regions';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const regionProvider = new RegionUrlProvider(this.url, this.token);\n      if (!regionProvider.isCloud()) {\n        this.skip();\n        return;\n      }\n      const regionStats = [];\n      const seenUrls = new Set();\n      for (let i = 0; i < 3; i++) {\n        const regionUrl = yield regionProvider.getNextBestRegionUrl();\n        if (!regionUrl) {\n          break;\n        }\n        if (seenUrls.has(regionUrl)) {\n          continue;\n        }\n        seenUrls.add(regionUrl);\n        const stats = yield this.checkCloudRegion(regionUrl);\n        this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\n        regionStats.push(stats);\n      }\n      regionStats.sort((a, b) => {\n        return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\n      });\n      const bestRegion = regionStats[0];\n      this.bestStats = bestRegion;\n      this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\n    });\n  }\n  getInfo() {\n    const info = super.getInfo();\n    info.data = this.bestStats;\n    return info;\n  }\n  checkCloudRegion(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      yield this.connect(url);\n      if (this.options.protocol === 'tcp') {\n        yield this.switchProtocol('tcp');\n      }\n      const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\n      if (!region) {\n        throw new Error('Region not found');\n      }\n      const writer = yield this.room.localParticipant.streamText({\n        topic: 'test'\n      });\n      const chunkSize = 1000; // each chunk is about 1000 bytes\n      const totalSize = 1000000; // approximately 1MB of data\n      const numChunks = totalSize / chunkSize; // will yield 1000 chunks\n      const chunkData = 'A'.repeat(chunkSize); // create a string of 1000 'A' characters\n      const startTime = Date.now();\n      for (let i = 0; i < numChunks; i++) {\n        yield writer.write(chunkData);\n      }\n      yield writer.close();\n      const endTime = Date.now();\n      const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\n      const regionStats = {\n        region: region,\n        rtt: 10000,\n        duration: endTime - startTime\n      };\n      stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\n        if (stat.type === 'candidate-pair' && stat.nominated) {\n          regionStats.rtt = stat.currentRoundTripTime * 1000;\n        }\n      });\n      yield this.disconnect();\n      return regionStats;\n    });\n  }\n}const TEST_DURATION = 10000;\nclass ConnectionProtocolCheck extends Checker {\n  get description() {\n    return 'Connection via UDP vs TCP';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const udpStats = yield this.checkConnectionProtocol('udp');\n      const tcpStats = yield this.checkConnectionProtocol('tcp');\n      this.bestStats = udpStats;\n      // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\n      // 1. the bandwidth limitation is worse on UDP by 500ms\n      // 2. the packet loss is higher on UDP by 1%\n      if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\n        this.appendMessage('best connection quality via tcp');\n        this.bestStats = tcpStats;\n      } else {\n        this.appendMessage('best connection quality via udp');\n      }\n      const stats = this.bestStats;\n      this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\n      this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\n      this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\n      if (stats.packetsLost > 0) {\n        this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\n      }\n      if (stats.qualityLimitationDurations.bandwidth > 1) {\n        this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n      }\n      if (stats.qualityLimitationDurations.cpu > 0) {\n        this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n      }\n    });\n  }\n  getInfo() {\n    const info = super.getInfo();\n    info.data = this.bestStats;\n    return info;\n  }\n  checkConnectionProtocol(protocol) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connect();\n      if (protocol === 'tcp') {\n        yield this.switchProtocol('tcp');\n      } else {\n        yield this.switchProtocol('udp');\n      }\n      // create a canvas with animated content\n      const canvas = document.createElement('canvas');\n      canvas.width = 1280;\n      canvas.height = 720;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Could not get canvas context');\n      }\n      let hue = 0;\n      const animate = () => {\n        hue = (hue + 1) % 360;\n        ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        requestAnimationFrame(animate);\n      };\n      animate();\n      // create video track from canvas\n      const stream = canvas.captureStream(30); // 30fps\n      const videoTrack = stream.getVideoTracks()[0];\n      // publish to room\n      const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\n        simulcast: false,\n        degradationPreference: 'maintain-resolution',\n        videoEncoding: {\n          maxBitrate: 2000000\n        }\n      });\n      const track = pub.track;\n      const protocolStats = {\n        protocol,\n        packetsLost: 0,\n        packetsSent: 0,\n        qualityLimitationDurations: {},\n        rttTotal: 0,\n        jitterTotal: 0,\n        bitrateTotal: 0,\n        count: 0\n      };\n      // gather stats once a second\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        const stats = yield track.getRTCStatsReport();\n        stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\n          if (stat.type === 'outbound-rtp') {\n            protocolStats.packetsSent = stat.packetsSent;\n            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\n            protocolStats.bitrateTotal += stat.targetBitrate;\n            protocolStats.count++;\n          } else if (stat.type === 'remote-inbound-rtp') {\n            protocolStats.packetsLost = stat.packetsLost;\n            protocolStats.rttTotal += stat.roundTripTime;\n            protocolStats.jitterTotal += stat.jitter;\n          }\n        });\n      }), 1000);\n      // wait a bit to gather stats\n      yield new Promise(resolve => setTimeout(resolve, TEST_DURATION));\n      clearInterval(interval);\n      videoTrack.stop();\n      canvas.remove();\n      yield this.disconnect();\n      return protocolStats;\n    });\n  }\n}class PublishAudioCheck extends Checker {\n  get description() {\n    return 'Can publish audio';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      const track = yield createLocalAudioTrack();\n      const trackIsSilent = yield detectSilence(track, 1000);\n      if (trackIsSilent) {\n        throw new Error('unable to detect audio from microphone');\n      }\n      this.appendMessage('detected audio from microphone');\n      room.localParticipant.publishTrack(track);\n      // wait for a few seconds to publish\n      yield new Promise(resolve => setTimeout(resolve, 3000));\n      // verify RTC stats that it's publishing\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error('Could not get RTCStats');\n      }\n      let numPackets = 0;\n      stats.forEach(stat => {\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'audio' || !stat.kind && stat.mediaType === 'audio')) {\n          numPackets = stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error('Could not determine packets are sent');\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n    });\n  }\n}class PublishVideoCheck extends Checker {\n  get description() {\n    return 'Can publish video';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      const track = yield createLocalVideoTrack();\n      // check if we have video from camera\n      yield this.checkForVideo(track.mediaStreamTrack);\n      room.localParticipant.publishTrack(track);\n      // wait for a few seconds to publish\n      yield new Promise(resolve => setTimeout(resolve, 5000));\n      // verify RTC stats that it's publishing\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n      if (!stats) {\n        throw new Error('Could not get RTCStats');\n      }\n      let numPackets = 0;\n      stats.forEach(stat => {\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'video' || !stat.kind && stat.mediaType === 'video')) {\n          numPackets += stat.packetsSent;\n        }\n      });\n      if (numPackets === 0) {\n        throw new Error('Could not determine packets are sent');\n      }\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n    });\n  }\n  checkForVideo(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stream = new MediaStream();\n      stream.addTrack(track.clone());\n      // Create video element to check frames\n      const video = document.createElement('video');\n      video.srcObject = stream;\n      video.muted = true;\n      video.autoplay = true;\n      video.playsInline = true;\n      // For iOS Safari\n      video.setAttribute('playsinline', 'true');\n      document.body.appendChild(video);\n      yield new Promise(resolve => {\n        video.onplay = () => {\n          setTimeout(() => {\n            var _a, _b, _c, _d;\n            const canvas = document.createElement('canvas');\n            const settings = track.getSettings();\n            const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\n            const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            // Draw video frame to canvas\n            ctx.drawImage(video, 0, 0);\n            // Get image data and check if all pixels are black\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n            let isAllBlack = true;\n            for (let i = 0; i < data.length; i += 4) {\n              if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\n                isAllBlack = false;\n                break;\n              }\n            }\n            if (isAllBlack) {\n              this.appendError('camera appears to be producing only black frames');\n            } else {\n              this.appendMessage('received video frames');\n            }\n            resolve();\n          }, 1000);\n        };\n        video.play();\n      });\n      stream.getTracks().forEach(t => t.stop());\n      video.remove();\n    });\n  }\n}class ReconnectCheck extends Checker {\n  get description() {\n    return 'Resuming connection after interruption';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const room = yield this.connect();\n      let reconnectingTriggered = false;\n      let reconnected = false;\n      let reconnectResolver;\n      const reconnectTimeout = new Promise(resolve => {\n        setTimeout(resolve, 5000);\n        reconnectResolver = resolve;\n      });\n      const handleReconnecting = () => {\n        reconnectingTriggered = true;\n      };\n      room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {\n        reconnected = true;\n        reconnectResolver(true);\n      });\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n      const onClose = room.engine.client.onClose;\n      if (onClose) {\n        onClose('');\n      }\n      yield reconnectTimeout;\n      if (!reconnectingTriggered) {\n        throw new Error('Did not attempt to reconnect');\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\n        this.appendWarning('reconnection is only possible in Redis-based configurations');\n        throw new Error('Not able to reconnect');\n      }\n    });\n  }\n}class TURNCheck extends Checker {\n  get description() {\n    return 'Can connect via TURN';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (isCloud(new URL(this.url))) {\n        this.appendMessage('Using region specific url');\n        this.url = (_a = yield new RegionUrlProvider(this.url, this.token).getNextBestRegionUrl()) !== null && _a !== void 0 ? _a : this.url;\n      }\n      const signalClient = new SignalClient();\n      const joinRes = yield signalClient.join(this.url, this.token, {\n        autoSubscribe: true,\n        maxRetries: 0,\n        e2eeEnabled: false,\n        websocketTimeout: 15000,\n        singlePeerConnection: false\n      });\n      let hasTLS = false;\n      let hasTURN = false;\n      let hasSTUN = false;\n      for (let iceServer of joinRes.iceServers) {\n        for (let url of iceServer.urls) {\n          if (url.startsWith('turn:')) {\n            hasTURN = true;\n            hasSTUN = true;\n          } else if (url.startsWith('turns:')) {\n            hasTURN = true;\n            hasSTUN = true;\n            hasTLS = true;\n          }\n          if (url.startsWith('stun:')) {\n            hasSTUN = true;\n          }\n        }\n      }\n      if (!hasSTUN) {\n        this.appendWarning('No STUN servers configured on server side.');\n      } else if (hasTURN && !hasTLS) {\n        this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\n      }\n      yield signalClient.close();\n      if (((_c = (_b = this.connectOptions) === null || _b === void 0 ? void 0 : _b.rtcConfig) === null || _c === void 0 ? void 0 : _c.iceServers) || hasTURN) {\n        yield this.room.connect(this.url, this.token, {\n          rtcConfig: {\n            iceTransportPolicy: 'relay'\n          }\n        });\n      } else {\n        this.appendWarning('No TURN servers configured.');\n        this.skip();\n        yield new Promise(resolve => setTimeout(resolve, 0));\n      }\n    });\n  }\n}class WebRTCCheck extends Checker {\n  get description() {\n    return 'Establishing WebRTC connection';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hasTcp = false;\n      let hasIpv4Udp = false;\n      this.room.on(RoomEvent.SignalConnected, () => {\n        var _a;\n        const prevTrickle = this.room.engine.client.onTrickle;\n        this.room.engine.client.onTrickle = (sd, target) => {\n          if (sd.candidate) {\n            const candidate = new RTCIceCandidate(sd);\n            let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n            if (candidate.address) {\n              if (isIPPrivate(candidate.address)) {\n                str += ' (private)';\n              } else {\n                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\n                  hasTcp = true;\n                  str += ' (passive)';\n                } else if (candidate.protocol === 'udp') {\n                  hasIpv4Udp = true;\n                }\n              }\n            }\n            this.appendMessage(str);\n          }\n          if (prevTrickle) {\n            prevTrickle(sd, target);\n          }\n        };\n        if ((_a = this.room.engine.pcManager) === null || _a === void 0 ? void 0 : _a.subscriber) {\n          this.room.engine.pcManager.subscriber.onIceCandidateError = ev => {\n            if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n              this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n            }\n          };\n        }\n      });\n      try {\n        yield this.connect();\n        livekitLogger.info('now the room is connected');\n      } catch (err) {\n        this.appendWarning('ports need to be open on firewall in order to connect.');\n        throw err;\n      }\n      if (!hasTcp) {\n        this.appendWarning('Server is not configured for ICE/TCP');\n      }\n      if (!hasIpv4Udp) {\n        this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\n      }\n    });\n  }\n}\nfunction isIPPrivate(address) {\n  const parts = address.split('.');\n  if (parts.length === 4) {\n    if (parts[0] === '10') {\n      return true;\n    } else if (parts[0] === '192' && parts[1] === '168') {\n      return true;\n    } else if (parts[0] === '172') {\n      const second = parseInt(parts[1], 10);\n      if (second >= 16 && second <= 31) {\n        return true;\n      }\n    }\n  }\n  return false;\n}class WebSocketCheck extends Checker {\n  get description() {\n    return 'Connecting to signal connection via WebSocket';\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\n        this.appendWarning('Server is insecure, clients may block connections to it');\n      }\n      let signalClient = new SignalClient();\n      let joinRes;\n      try {\n        joinRes = yield signalClient.join(this.url, this.token, {\n          autoSubscribe: true,\n          maxRetries: 0,\n          e2eeEnabled: false,\n          websocketTimeout: 15000,\n          singlePeerConnection: false\n        });\n      } catch (e) {\n        if (isCloud(new URL(this.url))) {\n          this.appendMessage(\"Initial connection failed with error \".concat(e.message, \". Retrying with region fallback\"));\n          const regionProvider = new RegionUrlProvider(this.url, this.token);\n          const regionUrl = yield regionProvider.getNextBestRegionUrl();\n          if (regionUrl) {\n            joinRes = yield signalClient.join(regionUrl, this.token, {\n              autoSubscribe: true,\n              maxRetries: 0,\n              e2eeEnabled: false,\n              websocketTimeout: 15000,\n              singlePeerConnection: false\n            });\n            this.appendMessage(\"Fallback to region worked. To avoid initial connections failing, ensure you're calling room.prepareConnection() ahead of time\");\n          }\n        }\n      }\n      if (joinRes) {\n        this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n        if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n          this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n        }\n      } else {\n        this.appendError(\"Websocket connection could not be established\");\n      }\n      yield signalClient.close();\n    });\n  }\n}class ConnectionCheck extends eventsExports.EventEmitter {\n  constructor(url, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.options = {};\n    this.checkResults = new Map();\n    this.url = url;\n    this.token = token;\n    this.options = options;\n  }\n  getNextCheckId() {\n    const nextId = this.checkResults.size;\n    this.checkResults.set(nextId, {\n      logs: [],\n      status: CheckStatus.IDLE,\n      name: '',\n      description: ''\n    });\n    return nextId;\n  }\n  updateCheck(checkId, info) {\n    this.checkResults.set(checkId, info);\n    this.emit('checkUpdate', checkId, info);\n  }\n  isSuccess() {\n    return Array.from(this.checkResults.values()).every(r => r.status !== CheckStatus.FAILED);\n  }\n  getResults() {\n    return Array.from(this.checkResults.values());\n  }\n  createAndRunCheck(check) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const checkId = this.getNextCheckId();\n      const test = new check(this.url, this.token, this.options);\n      const handleUpdate = info => {\n        this.updateCheck(checkId, info);\n      };\n      test.on('update', handleUpdate);\n      const result = yield test.run();\n      test.off('update', handleUpdate);\n      return result;\n    });\n  }\n  checkWebsocket() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebSocketCheck);\n    });\n  }\n  checkWebRTC() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebRTCCheck);\n    });\n  }\n  checkTURN() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(TURNCheck);\n    });\n  }\n  checkReconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(ReconnectCheck);\n    });\n  }\n  checkPublishAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishAudioCheck);\n    });\n  }\n  checkPublishVideo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishVideoCheck);\n    });\n  }\n  checkConnectionProtocol() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\n      if (info.data && 'protocol' in info.data) {\n        const stats = info.data;\n        this.options.protocol = stats.protocol;\n      }\n      return info;\n    });\n  }\n  checkCloudRegion() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(CloudRegionCheck);\n    });\n  }\n}/** A Fixed TokenSource is a token source that takes no parameters and returns a completely\n * independently derived value on each fetch() call.\n *\n * The most common downstream implementer is {@link TokenSourceLiteral}.\n */\nclass TokenSourceFixed {}\n/** A Configurable TokenSource is a token source that takes a\n * {@link TokenSourceFetchOptions} object as input and returns a deterministic\n * {@link TokenSourceResponseObject} output based on the options specified.\n *\n * For example, if options.participantName is set, it should be expected that\n * all tokens that are generated will have participant name field set to the\n * provided value.\n *\n * A few common downstream implementers are {@link TokenSourceEndpoint}\n * and {@link TokenSourceCustom}.\n */\nclass TokenSourceConfigurable {}function _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}new TextEncoder();\nconst decoder = new TextDecoder();function decodeBase64(encoded) {\n  if (Uint8Array.fromBase64) {\n    return Uint8Array.fromBase64(encoded);\n  }\n  const binary = atob(encoded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}function decode(input) {\n  if (Uint8Array.fromBase64) {\n    return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n      alphabet: 'base64url'\n    });\n  }\n  let encoded = input;\n  if (encoded instanceof Uint8Array) {\n    encoded = decoder.decode(encoded);\n  }\n  encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');\n  try {\n    return decodeBase64(encoded);\n  } catch (_unused) {\n    throw new TypeError('The input to be decoded is not correctly encoded.');\n  }\n}class JOSEError extends Error {\n  constructor(message, options) {\n    var _Error$captureStackTr;\n    super(message, options);\n    _defineProperty(this, \"code\", 'ERR_JOSE_GENERIC');\n    this.name = this.constructor.name;\n    (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, this, this.constructor);\n  }\n}\n_defineProperty(JOSEError, \"code\", 'ERR_JOSE_GENERIC');\nclass JWTClaimValidationFailed extends JOSEError {\n  constructor(message, payload) {\n    let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unspecified';\n    let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unspecified';\n    super(message, {\n      cause: {\n        claim,\n        reason,\n        payload\n      }\n    });\n    _defineProperty(this, \"code\", 'ERR_JWT_CLAIM_VALIDATION_FAILED');\n    _defineProperty(this, \"claim\", void 0);\n    _defineProperty(this, \"reason\", void 0);\n    _defineProperty(this, \"payload\", void 0);\n    this.claim = claim;\n    this.reason = reason;\n    this.payload = payload;\n  }\n}\n_defineProperty(JWTClaimValidationFailed, \"code\", 'ERR_JWT_CLAIM_VALIDATION_FAILED');\nclass JWTExpired extends JOSEError {\n  constructor(message, payload) {\n    let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unspecified';\n    let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unspecified';\n    super(message, {\n      cause: {\n        claim,\n        reason,\n        payload\n      }\n    });\n    _defineProperty(this, \"code\", 'ERR_JWT_EXPIRED');\n    _defineProperty(this, \"claim\", void 0);\n    _defineProperty(this, \"reason\", void 0);\n    _defineProperty(this, \"payload\", void 0);\n    this.claim = claim;\n    this.reason = reason;\n    this.payload = payload;\n  }\n}\n_defineProperty(JWTExpired, \"code\", 'ERR_JWT_EXPIRED');\nclass JOSEAlgNotAllowed extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JOSE_ALG_NOT_ALLOWED');\n  }\n}\n_defineProperty(JOSEAlgNotAllowed, \"code\", 'ERR_JOSE_ALG_NOT_ALLOWED');\nclass JOSENotSupported extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JOSE_NOT_SUPPORTED');\n  }\n}\n_defineProperty(JOSENotSupported, \"code\", 'ERR_JOSE_NOT_SUPPORTED');\nclass JWEDecryptionFailed extends JOSEError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'decryption operation failed';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, options);\n    _defineProperty(this, \"code\", 'ERR_JWE_DECRYPTION_FAILED');\n  }\n}\n_defineProperty(JWEDecryptionFailed, \"code\", 'ERR_JWE_DECRYPTION_FAILED');\nclass JWEInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JWE_INVALID');\n  }\n}\n_defineProperty(JWEInvalid, \"code\", 'ERR_JWE_INVALID');\nclass JWSInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JWS_INVALID');\n  }\n}\n_defineProperty(JWSInvalid, \"code\", 'ERR_JWS_INVALID');\nclass JWTInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JWT_INVALID');\n  }\n}\n_defineProperty(JWTInvalid, \"code\", 'ERR_JWT_INVALID');\nclass JWKInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JWK_INVALID');\n  }\n}\n_defineProperty(JWKInvalid, \"code\", 'ERR_JWK_INVALID');\nclass JWKSInvalid extends JOSEError {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"code\", 'ERR_JWKS_INVALID');\n  }\n}\n_defineProperty(JWKSInvalid, \"code\", 'ERR_JWKS_INVALID');\nclass JWKSNoMatchingKey extends JOSEError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'no applicable key found in the JSON Web Key Set';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, options);\n    _defineProperty(this, \"code\", 'ERR_JWKS_NO_MATCHING_KEY');\n  }\n}\n_defineProperty(JWKSNoMatchingKey, \"code\", 'ERR_JWKS_NO_MATCHING_KEY');\nclass JWKSMultipleMatchingKeys extends JOSEError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'multiple matching keys found in the JSON Web Key Set';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, options);\n    _defineProperty(this, Symbol.asyncIterator, void 0);\n    _defineProperty(this, \"code\", 'ERR_JWKS_MULTIPLE_MATCHING_KEYS');\n  }\n}\n_defineProperty(JWKSMultipleMatchingKeys, \"code\", 'ERR_JWKS_MULTIPLE_MATCHING_KEYS');\nclass JWKSTimeout extends JOSEError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'request timed out';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, options);\n    _defineProperty(this, \"code\", 'ERR_JWKS_TIMEOUT');\n  }\n}\n_defineProperty(JWKSTimeout, \"code\", 'ERR_JWKS_TIMEOUT');\nclass JWSSignatureVerificationFailed extends JOSEError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature verification failed';\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, options);\n    _defineProperty(this, \"code\", 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED');\n  }\n}\n_defineProperty(JWSSignatureVerificationFailed, \"code\", 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED');const isObjectLike = value => typeof value === 'object' && value !== null;\nfunction isObject(input) {\n  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n    return false;\n  }\n  if (Object.getPrototypeOf(input) === null) {\n    return true;\n  }\n  let proto = input;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(input) === proto;\n}function decodeJwt(jwt) {\n  if (typeof jwt !== 'string') throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n  const {\n    1: payload,\n    length\n  } = jwt.split('.');\n  if (length === 5) throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n  if (length !== 3) throw new JWTInvalid('Invalid JWT');\n  if (!payload) throw new JWTInvalid('JWTs must contain a payload');\n  let decoded;\n  try {\n    decoded = decode(payload);\n  } catch (_unused) {\n    throw new JWTInvalid('Failed to base64url decode the payload');\n  }\n  let result;\n  try {\n    result = JSON.parse(decoder.decode(decoded));\n  } catch (_unused2) {\n    throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n  }\n  if (!isObject(result)) throw new JWTInvalid('Invalid JWT Claims Set');\n  return result;\n}const ONE_SECOND_IN_MILLISECONDS = 1000;\nconst ONE_MINUTE_IN_MILLISECONDS = 60 * ONE_SECOND_IN_MILLISECONDS;\nfunction isResponseTokenValid(response) {\n  const jwtPayload = decodeTokenPayload(response.participantToken);\n  if (!(jwtPayload === null || jwtPayload === void 0 ? void 0 : jwtPayload.nbf) || !(jwtPayload === null || jwtPayload === void 0 ? void 0 : jwtPayload.exp)) {\n    return true;\n  }\n  const now = new Date();\n  const nbfInMilliseconds = jwtPayload.nbf * ONE_SECOND_IN_MILLISECONDS;\n  const nbfDate = new Date(nbfInMilliseconds);\n  const expInMilliseconds = jwtPayload.exp * ONE_SECOND_IN_MILLISECONDS;\n  const expDate = new Date(expInMilliseconds - ONE_MINUTE_IN_MILLISECONDS);\n  return nbfDate <= now && expDate > now;\n}\n/** Given a LiveKit generated participant token, decodes and returns the associated {@link TokenPayload} data. */\nfunction decodeTokenPayload(token) {\n  const payload = decodeJwt(token);\n  const {\n      roomConfig\n    } = payload,\n    rest = __rest(payload, [\"roomConfig\"]);\n  const mappedPayload = Object.assign(Object.assign({}, rest), {\n    roomConfig: payload.roomConfig ? RoomConfiguration.fromJson(payload.roomConfig) : undefined\n  });\n  return mappedPayload;\n}\n/** Given two TokenSourceFetchOptions values, check to see if they are deep equal. */\nfunction areTokenSourceFetchOptionsEqual(a, b) {\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]);\n  for (const key of allKeysSet) {\n    switch (key) {\n      case 'roomName':\n      case 'participantName':\n      case 'participantIdentity':\n      case 'participantMetadata':\n      case 'participantAttributes':\n      case 'agentName':\n      case 'agentMetadata':\n        if (a[key] !== b[key]) {\n          return false;\n        }\n        break;\n      default:\n        // ref: https://stackoverflow.com/a/58009992\n        const exhaustiveCheckedKey = key;\n        throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being checked for equality!\"));\n    }\n  }\n  return true;\n}/** A TokenSourceCached is a TokenSource which caches the last {@link TokenSourceResponseObject} value and returns it\n * until a) it expires or b) the {@link TokenSourceFetchOptions} provided to .fetch(...) change. */\nclass TokenSourceCached extends TokenSourceConfigurable {\n  constructor() {\n    super(...arguments);\n    this.cachedFetchOptions = null;\n    this.cachedResponse = null;\n    this.fetchMutex = new _();\n  }\n  isSameAsCachedFetchOptions(options) {\n    if (!this.cachedFetchOptions) {\n      return false;\n    }\n    for (const key of Object.keys(this.cachedFetchOptions)) {\n      switch (key) {\n        case 'roomName':\n        case 'participantName':\n        case 'participantIdentity':\n        case 'participantMetadata':\n        case 'participantAttributes':\n        case 'agentName':\n        case 'agentMetadata':\n          if (this.cachedFetchOptions[key] !== options[key]) {\n            return false;\n          }\n          break;\n        default:\n          // ref: https://stackoverflow.com/a/58009992\n          const exhaustiveCheckedKey = key;\n          throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being checked for equality!\"));\n      }\n    }\n    return true;\n  }\n  shouldReturnCachedValueFromFetch(fetchOptions) {\n    if (!this.cachedResponse) {\n      return false;\n    }\n    if (!isResponseTokenValid(this.cachedResponse)) {\n      return false;\n    }\n    if (this.isSameAsCachedFetchOptions(fetchOptions)) {\n      return false;\n    }\n    return true;\n  }\n  getCachedResponseJwtPayload() {\n    if (!this.cachedResponse) {\n      return null;\n    }\n    return decodeTokenPayload(this.cachedResponse.participantToken);\n  }\n  fetch(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const unlock = yield this.fetchMutex.lock();\n      try {\n        if (this.shouldReturnCachedValueFromFetch(options)) {\n          return this.cachedResponse.toJson();\n        }\n        this.cachedFetchOptions = options;\n        const tokenResponse = yield this.update(options);\n        this.cachedResponse = tokenResponse;\n        return tokenResponse.toJson();\n      } finally {\n        unlock();\n      }\n    });\n  }\n}\nclass TokenSourceLiteral extends TokenSourceFixed {\n  constructor(literalOrFn) {\n    super();\n    this.literalOrFn = literalOrFn;\n  }\n  fetch() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.literalOrFn === 'function') {\n        return this.literalOrFn();\n      } else {\n        return this.literalOrFn;\n      }\n    });\n  }\n}\nclass TokenSourceCustom extends TokenSourceCached {\n  constructor(customFn) {\n    super();\n    this.customFn = customFn;\n  }\n  update(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const resultMaybePromise = this.customFn(options);\n      let result;\n      if (resultMaybePromise instanceof Promise) {\n        result = yield resultMaybePromise;\n      } else {\n        result = resultMaybePromise;\n      }\n      return TokenSourceResponse.fromJson(result, {\n        // NOTE: it could be possible that the response body could contain more fields than just\n        // what's in TokenSourceResponse depending on the implementation\n        ignoreUnknownFields: true\n      });\n    });\n  }\n}\nclass TokenSourceEndpoint extends TokenSourceCached {\n  constructor(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.url = url;\n    this.endpointOptions = options;\n  }\n  createRequestFromOptions(options) {\n    var _a, _b, _c;\n    const request = new TokenSourceRequest();\n    for (const key of Object.keys(options)) {\n      switch (key) {\n        case 'roomName':\n        case 'participantName':\n        case 'participantIdentity':\n        case 'participantMetadata':\n          request[key] = options[key];\n          break;\n        case 'participantAttributes':\n          request.participantAttributes = (_a = options.participantAttributes) !== null && _a !== void 0 ? _a : {};\n          break;\n        case 'agentName':\n          request.roomConfig = (_b = request.roomConfig) !== null && _b !== void 0 ? _b : new RoomConfiguration();\n          if (request.roomConfig.agents.length === 0) {\n            request.roomConfig.agents.push(new RoomAgentDispatch());\n          }\n          request.roomConfig.agents[0].agentName = options.agentName;\n          break;\n        case 'agentMetadata':\n          request.roomConfig = (_c = request.roomConfig) !== null && _c !== void 0 ? _c : new RoomConfiguration();\n          if (request.roomConfig.agents.length === 0) {\n            request.roomConfig.agents.push(new RoomAgentDispatch());\n          }\n          request.roomConfig.agents[0].metadata = options.agentMetadata;\n          break;\n        default:\n          // ref: https://stackoverflow.com/a/58009992\n          const exhaustiveCheckedKey = key;\n          throw new Error(\"Options key \".concat(exhaustiveCheckedKey, \" not being included in forming request!\"));\n      }\n    }\n    return request;\n  }\n  update(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const request = this.createRequestFromOptions(options);\n      const response = yield fetch(this.url, Object.assign(Object.assign({}, this.endpointOptions), {\n        method: (_a = this.endpointOptions.method) !== null && _a !== void 0 ? _a : 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/json'\n        }, this.endpointOptions.headers),\n        body: request.toJsonString({\n          useProtoFieldName: true\n        })\n      }));\n      if (!response.ok) {\n        throw new Error(\"Error generating token from endpoint \".concat(this.url, \": received \").concat(response.status, \" / \").concat(yield response.text()));\n      }\n      const body = yield response.json();\n      return TokenSourceResponse.fromJson(body, {\n        // NOTE: it could be possible that the response body could contain more fields than just\n        // what's in TokenSourceResponse depending on the implementation (ie, SandboxTokenServer)\n        ignoreUnknownFields: true\n      });\n    });\n  }\n}\nclass TokenSourceSandboxTokenServer extends TokenSourceEndpoint {\n  constructor(sandboxId, options) {\n    const {\n        baseUrl = 'https://cloud-api.livekit.io'\n      } = options,\n      rest = __rest(options, [\"baseUrl\"]);\n    super(\"\".concat(baseUrl, \"/api/v2/sandbox/connection-details\"), Object.assign(Object.assign({}, rest), {\n      headers: {\n        'X-Sandbox-ID': sandboxId\n      }\n    }));\n  }\n}\nconst TokenSource = {\n  /** TokenSource.literal contains a single, literal set of {@link TokenSourceResponseObject}\n   * credentials, either provided directly or returned from a provided function. */\n  literal(literalOrFn) {\n    return new TokenSourceLiteral(literalOrFn);\n  },\n  /**\n   * TokenSource.custom allows a user to define a manual function which generates new\n   * {@link TokenSourceResponseObject} values on demand.\n   *\n   * Use this to get credentials from custom backends / etc.\n   */\n  custom(customFn) {\n    return new TokenSourceCustom(customFn);\n  },\n  /**\n   * TokenSource.endpoint creates a token source that fetches credentials from a given URL using\n   * the standard endpoint format:\n   * @see https://cloud.livekit.io/projects/p_/sandbox/templates/token-server\n   */\n  endpoint(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new TokenSourceEndpoint(url, options);\n  },\n  /**\n   * TokenSource.sandboxTokenServer queries a sandbox token server for credentials,\n   * which supports quick prototyping / getting started types of use cases.\n   *\n   * This token provider is INSECURE and should NOT be used in production.\n   *\n   * For more info:\n   * @see https://cloud.livekit.io/projects/p_/sandbox/templates/token-server\n   */\n  sandboxTokenServer(sandboxId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new TokenSourceSandboxTokenServer(sandboxId, options);\n  }\n};/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */\nfunction facingModeFromLocalTrack(localTrack) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\n  const trackSettings = track.getSettings();\n  let result = {\n    facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\n    confidence: 'low'\n  };\n  // 1. Try to get facingMode from track settings.\n  if ('facingMode' in trackSettings) {\n    const rawFacingMode = trackSettings.facingMode;\n    livekitLogger.trace('rawFacingMode', {\n      rawFacingMode\n    });\n    if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\n      result = {\n        facingMode: rawFacingMode,\n        confidence: 'high'\n      };\n    }\n  }\n  // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n  if (['low', 'medium'].includes(result.confidence)) {\n    livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n    const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n    if (labelAnalysisResult !== undefined) {\n      result = labelAnalysisResult;\n    }\n  }\n  return result;\n}\nconst knownDeviceLabels = new Map([['obs virtual camera', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}]]);\nconst knownDeviceLabelSections = new Map([['iphone', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}], ['ipad', {\n  facingMode: 'environment',\n  confidence: 'medium'\n}]]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */\nfunction facingModeFromDeviceLabel(deviceLabel) {\n  var _a;\n  const label = deviceLabel.trim().toLowerCase();\n  // Empty string is a valid device label but we can't infer anything from it.\n  if (label === '') {\n    return undefined;\n  }\n  // Can we match against widely known device labels.\n  if (knownDeviceLabels.has(label)) {\n    return knownDeviceLabels.get(label);\n  }\n  // Can we match against sections of the device label.\n  return (_a = Array.from(knownDeviceLabelSections.entries()).find(_ref => {\n    let [section] = _ref;\n    return label.includes(section);\n  })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n  const allowedValues = ['user', 'environment', 'left', 'right'];\n  return item === undefined || allowedValues.includes(item);\n}//# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdDQUFnQyxzQkFBc0IsOEVBQThFLDZCQUE2QiwyQ0FBMkMsbUNBQW1DLCtCQUErQixhQUFhLElBQUksRUFBRSxFQUFFLHlCQUF5QjtBQUM1VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU5BQXVOLE9BQU8sdUJBQXVCLE9BQU8sb0JBQW9CLE9BQU87QUFDdlI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxTQUFTO0FBQ2pFLFVBQVUsTUFBTSw2Q0FBNkMsTUFBTSxHQUFHLElBQUk7QUFDMUUsSUFBSSxLQUFLLEdBQUcsSUFBSSxPQUFPLEtBQUs7QUFDNUI7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsZUFBZSxJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0EsQ0FBQyxrQkFBa0IsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGNBQWMsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw4RUFBOEU7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLDJDQUEyQyx1WkFBdVosRUFBRTtBQUNyYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDLDZiQUE2YixFQUFFO0FBQzVlO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJDQUEyQyxpWEFBaVgsRUFBRSxhQUFhLGFBQWE7QUFDemI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELGdFQUFnRSx1Q0FBdUMsZ0NBQWdDLGVBQWU7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQ0FBMkMsMmFBQTJhLEVBQUU7QUFDemQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QjtBQUMxQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRkFBb0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3REFBd0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUNBQXVDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBNkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOERBQThEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0IsZUFBZSx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0IsZUFBZSx1QkFBdUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRTtBQUMxRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWEsZ0JBQWdCLGVBQWUsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxVQUFVO0FBQ2xELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxlQUFlLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsYUFBYTtBQUM3Qyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQ0FBb0M7QUFDcEMsd0JBQXdCO0FBQ3hCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsOENBQThDO0FBQzlDO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhEQUE4RDtBQUNsSDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixpRkFBaUY7QUFDakY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsY0FBYztBQUNkLGlHQUFpRztBQUNqRztBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUZBQXlGO0FBQ3pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlGQUF5RjtBQUN6RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YseUNBQXlDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtEQUErRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULGdHQUFnRztBQUNoRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNHQUFzRztBQUN0RztBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixnRkFBZ0Y7QUFDaEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4SEFBOEg7QUFDOUg7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLDBHQUEwRztBQUMxRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0RUFBNEU7QUFDNUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9HQUFvRztBQUNwRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyRkFBMkY7QUFDM0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHFFQUFxRTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixxRUFBcUU7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtGQUFrRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhFQUE4RTtBQUNqRixDQUFDLDRDQUE0QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdFQUF3RTtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkpBQTZKO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0S0FBNEs7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxrRkFBa0YsK0RBQStEO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0dBQWdHO0FBQ2hHLFdBQVc7QUFDWCwwR0FBMEc7QUFDMUc7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFIQUFxSDtBQUNySDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpR0FBaUc7QUFDakc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0ZBQW9GO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSLDhFQUE4RTtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtLQUErSztBQUMvSztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0hBQW9IO0FBQ3BIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkdBQTZHO0FBQzdHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQixJQUFJLGFBQWE7QUFDcEYsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLG9GQUFvRjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa1BBQWtQO0FBQ2xQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3RkFBd0Y7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaURBQWlELCtCQUErQixFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSxpQ0FBaUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxRQUFRLHdCQUF3QjtBQUNoQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsb0JBQW9CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0UsaUNBQWlDO0FBQ2xHLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLGlDQUFpQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBK2hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanM/M2E0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pe20uZm9yRWFjaChmdW5jdGlvbihlKXtlJiZ0eXBlb2YgZSE9PSdzdHJpbmcnJiYhQXJyYXkuaXNBcnJheShlKSYmT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihrKXtpZihrIT09J2RlZmF1bHQnJiYhKGsgaW4gbikpe3ZhciBkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxrKTtPYmplY3QuZGVmaW5lUHJvcGVydHkobixrLGQuZ2V0P2Q6e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtrXX19KTt9fSl9KTtyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTt9dmFyIGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgaCA9IChpLCBzLCB0KSA9PiBzIGluIGkgPyBlKGksIHMsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHRcbn0pIDogaVtzXSA9IHQ7XG52YXIgbyA9IChpLCBzLCB0KSA9PiBoKGksIHR5cGVvZiBzICE9IFwic3ltYm9sXCIgPyBzICsgXCJcIiA6IHMsIHQpO1xuY2xhc3MgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIG8odGhpcywgXCJfbG9ja2luZ1wiKTtcbiAgICBvKHRoaXMsIFwiX2xvY2tzXCIpO1xuICAgIHRoaXMuX2xvY2tpbmcgPSBQcm9taXNlLnJlc29sdmUoKSwgdGhpcy5fbG9ja3MgPSAwO1xuICB9XG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrcyArPSAxO1xuICAgIGxldCBzO1xuICAgIGNvbnN0IHQgPSBuZXcgUHJvbWlzZShsID0+IHMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvY2tzIC09IDEsIGwoKTtcbiAgICAgIH0pLFxuICAgICAgYyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiBzKTtcbiAgICByZXR1cm4gdGhpcy5fbG9ja2luZyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiB0KSwgYztcbiAgfVxufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LFxuICBGTE9BVDMyX01JTiA9IC0zNDAyODIzNDY2Mzg1Mjg4NmUyMixcbiAgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsXG4gIElOVDMyX01BWCA9IDB4N2ZmZmZmZmYsXG4gIElOVDMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBzaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFyZykpIHJldHVybjtcbiAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn0vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgZW51bVR5cGVTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvZW51bS10eXBlXCIpO1xuLyoqXG4gKiBHZXQgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGEgZ2VuZXJhdGVkIGVudW0uXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGdlbmVyYXRlZFxuICogZW51bSwgaXQgcmFpc2VzIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBnZXRFbnVtVHlwZShlbnVtT2JqZWN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICBhc3NlcnQodCwgXCJtaXNzaW5nIGVudW0gdHlwZSBvbiBlbnVtIG9iamVjdFwiKTtcbiAgcmV0dXJuIHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbn1cbi8qKlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uIG9uIGEgZ2VuZXJhdGVkIGVudW0uXG4gKi9cbmZ1bmN0aW9uIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdID0gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMubWFwKHYgPT4gKHtcbiAgICBubzogdi5ubyxcbiAgICBuYW1lOiB2Lm5hbWUsXG4gICAgbG9jYWxOYW1lOiBlbnVtT2JqZWN0W3Yubm9dXG4gIH0pKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBFbnVtVHlwZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuX29wdCkge1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IG51bWJlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgIC8vIGNvbnN0IHZhbHVlOiBFbnVtVmFsdWVJbmZvID0gey4uLnYsIG9wdGlvbnM6IHYub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0fTtcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcbiAgICBuYW1lc1t2YWx1ZS5uYW1lXSA9IG47XG4gICAgbnVtYmVyc1t2YWx1ZS5ub10gPSBuO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZU5hbWUsXG4gICAgdmFsdWVzOiBub3JtYWxWYWx1ZXMsXG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBvcHRpb25zOiBvcHQ/Lm9wdGlvbnMgPz8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBmaW5kTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZXNbbmFtZV07XG4gICAgfSxcbiAgICBmaW5kTnVtYmVyKG5vKSB7XG4gICAgICByZXR1cm4gbnVtYmVyc1tub107XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW51bSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgY29uc3QgZW51bU9iamVjdCA9IHt9O1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICBlbnVtT2JqZWN0W24ubm9dID0gbi5sb2NhbE5hbWU7XG4gIH1cbiAgc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcyk7XG4gIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gIGlmIChcImxvY2FsTmFtZVwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSwge1xuICAgIGxvY2FsTmFtZTogdmFsdWUubmFtZVxuICB9KTtcbn0vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBNZXNzYWdlIGlzIHRoZSBiYXNlIGNsYXNzIG9mIGV2ZXJ5IG1lc3NhZ2UsIGdlbmVyYXRlZCwgb3IgY3JlYXRlZCBhdFxuICogcnVudGltZS5cbiAqXG4gKiBJdCBpcyBfbm90XyBzYWZlIHRvIGV4dGVuZCB0aGlzIGNsYXNzLiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBtZXNzYWdlIGF0XG4gKiBydW4gdGltZSwgdXNlIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoKS5cbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRpc3JlZ2FyZHMgZXh0ZW5zaW9ucyBhbmQgdW5rbm93biBmaWVsZHMuXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmVxdWFscyh0aGlzLmdldFR5cGUoKSwgdGhpcywgb3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICpcbiAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgKiBleGlzdGluZyBrZXlzLlxuICAgKlxuICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgKiBuZXcgZGF0YS5cbiAgICovXG4gIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodGhpcywgb3B0LnJlYWRlckZhY3RvcnkoYnl0ZXMpLCBieXRlcy5ieXRlTGVuZ3RoLCBvcHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAqL1xuICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbixcbiAgICAgIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBcIi5jb25jYXQodGhpcy5nZXRUeXBlKCkudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cbiAgICovXG4gIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICB3cml0ZXIgPSBvcHQud3JpdGVyRmFjdG9yeSgpO1xuICAgIGJpbi53cml0ZU1lc3NhZ2UodGhpcywgd3JpdGVyLCBvcHQpO1xuICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cbiAgICovXG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAganNvbiA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIHRvSnNvblN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldHR5U3BhY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZm9yIHNlcmlhbGl6YXRpb24gYmVoYXZpb3IuIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW4gY2FsbGluZ1xuICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHNlcmlhbGl6ZSBnb29nbGUucHJvdG9idWYuQW55IHdpdGggYSBwYWNrZWRcbiAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgKiB1bnBhY2tlZCwgYW5kIHRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgdHlwZSByZWdpc3RyeSB0byBsb29rIHVwIHRoZVxuICAgKiBtZXNzYWdlIHR5cGUuICBBcyBhIHJlc3VsdCwgYXR0ZW1wdGluZyB0byBzZXJpYWxpemUgYSBtZXNzYWdlIHdpdGggdGhpc1xuICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHByb3RlY3RlZCBiZWNhdXNlIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gaW52b2tlIGl0XG4gICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICogc3RyaW5naWZpZWQgSlNPTi4gIEFsdGVybmF0aXZlbHksIGlmIGFjdHVhbCBKU09OIGlzIGRlc2lyZWQsIHlvdSBzaG91bGRcbiAgICogdXNlIHRvSnNvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIE1lc3NhZ2VUeXBlIG9mIHRoaXMgbWVzc2FnZSAtIGEgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50c1xuICAgKiB0aGUgcHJvdG9idWYgbWVzc2FnZSBkZWNsYXJhdGlvbiBhbmQgcHJvdmlkZXMgbWV0YWRhdGEgZm9yIHJlZmxlY3Rpb24tXG4gICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICB9XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgY29uc3QgdHlwZSA9IHtcbiAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xuICAgICAgcnVudGltZS51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgfVtsb2NhbE5hbWVdO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUsIG5ldyBNZXNzYWdlKCkpO1xuICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICBydW50aW1lLFxuICAgIHR5cGVOYW1lLFxuICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUudXRpbC5lcXVhbHModHlwZSwgYSwgYik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59Ly8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gIH1cbiAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xuICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gIH1cbiAgZm9yIChsZXQgc2hpZnQgPSAzOyBzaGlmdCA8PSAzMTsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3BsaXRCaXRzID0gbG8gPj4+IDI4ICYgMHgwZiB8IChoaSAmIDB4MDcpIDw8IDQ7XG4gIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XG4gIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGJ5dGVzLnB1c2goaGkgPj4+IDMxICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xuICBpZiAobWludXMpIHtcbiAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gIH1cbiAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAvLyBkaWdpdHMgdG8gYmluYXJ5LiBUaGlzIGlzIHNhZmUgdG8gZG8gd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoIGJlY2F1c2VcbiAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gIGNvbnN0IGJhc2UgPSAxZTY7XG4gIGxldCBsb3dCaXRzID0gMDtcbiAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xuICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cbiAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArIChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbiAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XG4gICAgfVxuICB9XG4gIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICBhZGQxZTZkaWdpdCgtMTIsIC02KTtcbiAgYWRkMWU2ZGlnaXQoLTYpO1xuICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgLy8gYSBtYW51YWwgdHdvJ3MgY29tcGxlbWVudCBjb252ZXJzaW9uIGJlZm9yZSB0aGUgZGVjaW1hbCBjb252ZXJzaW9uLlxuICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAoe1xuICAgIGxvLFxuICAgIGhpXG4gIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xuICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXG4gIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cbiAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xuICB9XG4gIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgY29uc3QgbG93ID0gbG8gJiAweEZGRkZGRjtcbiAgY29uc3QgbWlkID0gKGxvID4+PiAyNCB8IGhpIDw8IDgpICYgMHhGRkZGRkY7XG4gIGNvbnN0IGhpZ2ggPSBoaSA+PiAxNiAmIDB4RkZGRjtcbiAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgbGV0IGRpZ2l0QSA9IGxvdyArIG1pZCAqIDY3NzcyMTYgKyBoaWdoICogNjcxMDY1NjtcbiAgbGV0IGRpZ2l0QiA9IG1pZCArIGhpZ2ggKiA4MTQ3NDk3O1xuICBsZXQgZGlnaXRDID0gaGlnaCAqIDI7XG4gIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgIGRpZ2l0QSAlPSBiYXNlO1xuICB9XG4gIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgIGRpZ2l0QiAlPSBiYXNlO1xuICB9XG4gIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxuICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcbn1cbmZ1bmN0aW9uIHRvVW5zaWduZWQobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvID4+PiAwLFxuICAgIGhpOiBoaSA+Pj4gMFxuICB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgcmV0dXJuIHtcbiAgICBsbzogbG8gfCAwLFxuICAgIGhpOiBoaSB8IDBcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gIGlmIChsb3dCaXRzKSB7XG4gICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBsb3dCaXRzIGlzIDAsIHRoZW4gYml0d2lzZS1ub3QgaXMgMHhGRkZGRkZGRixcbiAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICBoaWdoQml0cyArPSAxO1xuICB9XG4gIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gZGlnaXQxZTcgPT4ge1xuICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMTI3IHwgMTI4KTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICB9XG4gICAgYnl0ZXMucHVzaCgxKTtcbiAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHgwZikgPDwgMjg7XG4gIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKSBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGlmICgoYiAmIDB4ODApICE9IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5mdW5jdGlvbiBtYWtlSW50NjRTdXBwb3J0KCkge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAvLyBub3RlIHRoYXQgU2FmYXJpIDE0IGltcGxlbWVudHMgQmlnSW50LCBidXQgbm90IHRoZSBEYXRhVmlldyBtZXRob2RzXG4gIGNvbnN0IG9rID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBwcm9jZXNzICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIHByb2Nlc3MuZW52ICE9IFwib2JqZWN0XCIgfHwgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gIGlmIChvaykge1xuICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLFxuICAgICAgTUFYID0gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxcbiAgICAgIFVNSU4gPSBCaWdJbnQoXCIwXCIpLFxuICAgICAgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB6ZXJvOiBCaWdJbnQoMCksXG4gICAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBpZiAoYmkgPiBNQVggfHwgYmkgPCBNSU4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmk7XG4gICAgICB9LFxuICAgICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidWludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaTtcbiAgICAgIH0sXG4gICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy5wYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMudVBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gdmFsdWUgPT4gYXNzZXJ0KC9eLT9bMC05XSskLy50ZXN0KHZhbHVlKSwgXCJpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgY29uc3QgYXNzZXJ0VUludDY0U3RyaW5nID0gdmFsdWUgPT4gYXNzZXJ0KC9eWzAtOV0rJC8udGVzdCh2YWx1ZSksIFwidWludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xuICByZXR1cm4ge1xuICAgIHplcm86IFwiMFwiLFxuICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZW5jKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICB1RW5jKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgZGVjKGxvLCBoaSkge1xuICAgICAgcmV0dXJuIGludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICB9LFxuICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICByZXR1cm4gdUludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpOy8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xudmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAvLyBPcmRlciBpcyB3ZWlyZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQ2NCBpZlxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDY0XCJdID0gNF0gPSBcIlVJTlQ2NFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDMyXCJdID0gNV0gPSBcIklOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQk9PTFwiXSA9IDhdID0gXCJCT09MXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCBhbmQgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuIEhvd2V2ZXIsIFByb3RvM1xuICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gIC8vIFRZUEVfR1JPVVAgPSAxMCxcbiAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiQllURVNcIl0gPSAxMl0gPSBcIkJZVEVTXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gIC8vIFRZUEVfRU5VTSA9IDE0LFxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQzMlwiXSA9IDE1XSA9IFwiU0ZJWEVEMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQ2NFwiXSA9IDE4XSA9IFwiU0lOVDY0XCI7XG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcbi8qKlxuICogSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBmaWVsZHMgd2l0aCA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMuSlNUeXBlLCB3aGljaCBkZWZpbmVzIEpTX05PUk1BTCxcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXG4gKlxuICogYGBgcHJvdG9idWZcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05PUk1BTF07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXG4gKiBgYGBcbiAqL1xudmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XG4gIC8qKlxuICAgKiBVc2UgSmF2YVNjcmlwdCBTdHJpbmcuXG4gICAqXG4gICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgKi9cbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpOy8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgIHJldHVybiBhID09IGI7XG4gIH1cbiAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6ZXJvIHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHNjYWxhclplcm9WYWx1ZSh0eXBlLCBsb25nVHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgcmV0dXJuIGxvbmdUeXBlID09IDAgPyBwcm90b0ludDY0Lnplcm8gOiBcIjBcIjtcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiAwLjA7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gSGFuZGxlcyBJTlQzMiwgVUlOVDMyLCBTSU5UMzIsIEZJWEVEMzIsIFNGSVhFRDMyLlxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBpbmRpdmlkdWFsIGNhc2VzIHRvIHNhdmUgYSBmZXcgYnl0ZXMgY29kZSBzaXplLlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGZvciBhIHplcm8tdmFsdWUuIEZvciBleGFtcGxlLCBhbiBpbnRlZ2VyIGhhcyB0aGUgemVyby12YWx1ZSBgMGAsXG4gKiBhIGJvb2xlYW4gaXMgYGZhbHNlYCwgYSBzdHJpbmcgaXMgYFwiXCJgLCBhbmQgYnl0ZXMgaXMgYW4gZW1wdHkgVWludDhBcnJheS5cbiAqXG4gKiBJbiBwcm90bzMsIHplcm8tdmFsdWVzIGFyZSBub3Qgd3JpdHRlbiB0byB0aGUgd2lyZSwgdW5sZXNzIHRoZSBmaWVsZCBpc1xuICogb3B0aW9uYWwgb3IgcmVwZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSBcIlwiO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgIXZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZSA9PSAwO1xuICAgIC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgfVxufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3Qsbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cbi8qKlxuICogUHJvdG9idWYgYmluYXJ5IGZvcm1hdCB3aXJlIHR5cGVzLlxuICpcbiAqIEEgd2lyZSB0eXBlIHByb3ZpZGVzIGp1c3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGZvbGxvd2luZyB2YWx1ZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nI3N0cnVjdHVyZVxuICovXG52YXIgV2lyZVR5cGU7XG4oZnVuY3Rpb24gKFdpcmVUeXBlKSB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJWYXJpbnRcIl0gPSAwXSA9IFwiVmFyaW50XCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBmaXhlZDY0LCBzZml4ZWQ2NCwgZG91YmxlLlxuICAgKiBBbHdheXMgOCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0NjRcIl0gPSAxXSA9IFwiQml0NjRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG4gICAqXG4gICAqIE9ubHkgcmVwZWF0ZWQgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCxcbiAgICogb3IgNjQtYml0IHdpcmUgdHlwZXMpIGNhbiBiZSBwYWNrZWQuIEluIHByb3RvMywgc3VjaCBmaWVsZHMgYXJlXG4gICAqIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJMZW5ndGhEZWxpbWl0ZWRcIl0gPSAyXSA9IFwiTGVuZ3RoRGVsaW1pdGVkXCI7XG4gIC8qKlxuICAgKiBTdGFydCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLCBzdWNoIGFzIGEgcHJvdG8yIGdyb3VwLCBvciBhIG1lc3NhZ2VcbiAgICogaW4gZWRpdGlvbnMgd2l0aCBtZXNzYWdlX2VuY29kaW5nID0gREVMSU1JVEVELlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcbiAgLyoqXG4gICAqIEVuZCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xuICAgIC8qKlxuICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAqL1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmJ1ZiA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTsgLy8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlcy5zZXQodGhpcy5jaHVua3NbaV0sIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHJldHVybiBieXRlcztcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXG4gICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgKlxuICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxuICAgKi9cbiAgZm9yaygpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgY2h1bmtzOiB0aGlzLmNodW5rcyxcbiAgICAgIGJ1ZjogdGhpcy5idWZcbiAgICB9KTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICovXG4gIGpvaW4oKSB7XG4gICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLmZpbmlzaCgpO1xuICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgaWYgKCFwcmV2KSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XG4gICAgdGhpcy5idWYgPSBwcmV2LmJ1ZjtcbiAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGVzIGEgdGFnIChmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZSkuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgKlxuICAgKiBHZW5lcmF0ZWQgY29kZSBzaG91bGQgY29tcHV0ZSB0aGUgdGFnIGFoZWFkIG9mIHRpbWUgYW5kIGNhbGwgYHVpbnQzMigpYC5cbiAgICovXG4gIHRhZyhmaWVsZE5vLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgKi9cbiAgcmF3KGNodW5rKSB7XG4gICAgaWYgKHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpO1xuICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMiwgaW5saW5lZCBmb3Igc3BlZWRcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlICYgMHg3ZiB8IDB4ODApO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICB9XG4gICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGludDMyYCB2YWx1ZSwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIGludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2wodmFsdWUpIHtcbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAqL1xuICBieXRlcyh2YWx1ZSkge1xuICAgIHRoaXMudWludDMyKHZhbHVlLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgKi9cbiAgc3RyaW5nKHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZmxvYXQodmFsdWUpIHtcbiAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldFVpbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLFxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxuICAgICAgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpLFxuICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgc2lnbiA9IHRjLmhpID4+IDMxLFxuICAgICAgbG8gPSB0Yy5sbyA8PCAxIF4gc2lnbixcbiAgICAgIGhpID0gKHRjLmhpIDw8IDEgfCB0Yy5sbyA+Pj4gMzEpIF4gc2lnbjtcbiAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGB1aW50NjRgIHZhbHVlLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgdWludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cbiAgICovXG4gIHRhZygpIHtcbiAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSxcbiAgICAgIGZpZWxkTm8gPSB0YWcgPj4+IDMsXG4gICAgICB3aXJlVHlwZSA9IHRhZyAmIDc7XG4gICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xuICB9XG4gIC8qKlxuICAgKiBTa2lwIG9uZSBlbGVtZW50IGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cbiAgICpcbiAgICogV2hlbiBza2lwcGluZyBTdGFydEdyb3VwLCBwcm92aWRlIHRoZSB0YWdzIGZpZWxkIG51bWJlciB0byBjaGVjayBmb3JcbiAgICogbWF0Y2hpbmcgZmllbGQgbnVtYmVyIGluIHRoZSBFbmRHcm91cCB0YWcuXG4gICAqL1xuICBza2lwKHdpcmVUeXBlLCBmaWVsZE5vKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDB4ODApIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0MzI6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgY29uc3QgW2ZuLCB3dF0gPSB0aGlzLnRhZygpO1xuICAgICAgICAgIGlmICh3dCA9PT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICAgIGlmIChmaWVsZE5vICE9PSB1bmRlZmluZWQgJiYgZm4gIT09IGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2tpcCh3dCwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FudCBza2lwIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICB9XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHRoaXMucG9zKTtcbiAgfVxuICAvKipcbiAgICogVGhyb3dzIGVycm9yIGlmIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXkgaXMgb3V0IG9mIHJhbmdlLlxuICAgKi9cbiAgYXNzZXJ0Qm91bmRzKCkge1xuICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGVuKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInByZW1hdHVyZSBFT0ZcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgaW50MzJgIGZpZWxkLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgKi9cbiAgaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNpbnQzMmAgZmllbGQsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDMyKCkge1xuICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xuICAgIC8vIGRlY29kZSB6aWd6YWdcbiAgICByZXR1cm4genplID4+PiAxIF4gLSh6emUgJiAxKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBpbnQ2NGAgZmllbGQsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgdWludDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LnVEZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzaW50NjRgIGZpZWxkLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50NjQoKSB7XG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgIC8vIGRlY29kZSB6aWcgemFnXG4gICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgbG8gPSAobG8gPj4+IDEgfCAoaGkgJiAxKSA8PCAzMSkgXiBzO1xuICAgIGhpID0gaGkgPj4+IDEgXiBzO1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyhsbywgaGkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAqL1xuICBib29sKCkge1xuICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDMyKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNmaXhlZDMyYCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDMyKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkNjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmbG9hdGAgZmllbGQsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBmbG9hdCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZG91YmxlYCBmaWVsZCwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZG91YmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAqL1xuICBieXRlcygpIHtcbiAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKSxcbiAgICAgIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc3RyaW5nYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgKi9cbiAgc3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xuICB9XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gbWFrZUV4dGVuc2lvbihydW50aW1lLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gIGxldCBmaTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlTmFtZSxcbiAgICBleHRlbmRlZSxcbiAgICBnZXQgZmllbGQoKSB7XG4gICAgICBpZiAoIWZpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0eXBlb2YgZmllbGQgPT0gXCJmdW5jdGlvblwiID8gZmllbGQoKSA6IGZpZWxkO1xuICAgICAgICBpLm5hbWUgPSB0eXBlTmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgICAgIGkuanNvbk5hbWUgPSBcIltcIi5jb25jYXQodHlwZU5hbWUsIFwiXVwiKTtcbiAgICAgICAgZmkgPSBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KFtpXSkubGlzdCgpWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpO1xuICAgIH0sXG4gICAgcnVudGltZVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb250YWluZXIgdGhhdCBhbGxvd3MgdXMgdG8gcmVhZCBleHRlbnNpb24gZmllbGRzIGludG8gaXQgd2l0aCB0aGVcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHRlbnNpb24pIHtcbiAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgY29udGFpbmVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29udGFpbmVyW2xvY2FsTmFtZV0gPSBpbml0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uKTtcbiAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcbn1cbmZ1bmN0aW9uIGluaXRFeHRlbnNpb25GaWVsZChleHQpIHtcbiAgY29uc3QgZmllbGQgPSBleHQuZmllbGQ7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmRlZmF1bHQ7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIGZpZWxkLkwpO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgIGNvbnN0IFQgPSBmaWVsZC5ULFxuICAgICAgICB2YWx1ZSA9IG5ldyBUKCk7XG4gICAgICByZXR1cm4gVC5maWVsZFdyYXBwZXIgPyBULmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjYXNlIFwibWFwXCI6XG4gICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZmlsdGVyIHVua25vd24gZmllbGRzLCBvcHRpbWl6ZWQgYmFzZWQgb24gZmllbGQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xuICBpZiAoIWZpZWxkLnJlcGVhdGVkICYmIChmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcbiAgICAvLyBzaW5ndWxhciBzY2FsYXIgZmllbGRzIGRvIG5vdCBtZXJnZSwgd2UgcGljayB0aGUgbGFzdFxuICAgIGZvciAobGV0IGkgPSB1bmtub3duRmllbGRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodW5rbm93bkZpZWxkc1tpXS5ubyA9PSBmaWVsZC5ubykge1xuICAgICAgICByZXR1cm4gW3Vua25vd25GaWVsZHNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKHVmID0+IHVmLm5vID09PSBmaWVsZC5ubyk7XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgcHJlZmVyLWNvbnN0ICovXG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyIHRvIGJ5dGVcbmxldCBlbmNUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLnNwbGl0KFwiXCIpO1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciAqY29kZSogdG8gYnl0ZSBiZWNhdXNlIGxvb2t1cCBieSBudW1iZXIgaXMgZmFzdFxubGV0IGRlY1RhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IGVuY1RhYmxlLmxlbmd0aDsgaSsrKSBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5jb25zdCBwcm90b0Jhc2U2NCA9IHtcbiAgLyoqXG4gICAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogLSBpZ25vcmVzIHdoaXRlLXNwYWNlLCBpbmNsdWRpbmcgbGluZSBicmVha3MgYW5kIHRhYnNcbiAgICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXG4gICAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXG4gICAqIC0gdW5kZXJzdGFuZHMgYmFzZTY0dXJsIGVuY29kaW5nOlxuICAgKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXG4gICAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcbiAgICogICBubyBwYWRkaW5nXG4gICAqL1xuICBkZWMoYmFzZTY0U3RyKSB7XG4gICAgLy8gZXN0aW1hdGUgYnl0ZSBzaXplLCBub3QgYWNjb3VudGluZyBmb3IgaW5uZXIgcGFkZGluZyBhbmQgd2hpdGVzcGFjZVxuICAgIGxldCBlcyA9IGJhc2U2NFN0ci5sZW5ndGggKiAzIC8gNDtcbiAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIikgZXMgLT0gMjtlbHNlIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDFdID09IFwiPVwiKSBlcyAtPSAxO1xuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGVzKSxcbiAgICAgIGJ5dGVQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxuICAgICAgZ3JvdXBQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICBiLFxuICAgICAgLy8gY3VycmVudCBieXRlXG4gICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IHAgPDwgMiB8IChiICYgNDgpID4+IDQ7XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMTUpIDw8IDQgfCAoYiAmIDYwKSA+PiAyO1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDMpIDw8IDYgfCBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdyb3VwUG9zID09IDEpIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cbiAgICovXG4gIGVuYyhieXRlcykge1xuICAgIGxldCBiYXNlNjQgPSBcIlwiLFxuICAgICAgZ3JvdXBQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICBiLFxuICAgICAgLy8gY3VycmVudCBieXRlXG4gICAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiID0gYnl0ZXNbaV07XG4gICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICBwID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA0XTtcbiAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNl07XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgb3V0cHV0IHBhZGRpbmdcbiAgICBpZiAoZ3JvdXBQb3MpIHtcbiAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwXTtcbiAgICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgICAgIGlmIChncm91cFBvcyA9PSAxKSBiYXNlNjQgKz0gXCI9XCI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH1cbn07Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0cmlldmUgYW4gZXh0ZW5zaW9uIHZhbHVlIGZyb20gYSBtZXNzYWdlLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gVXNlIGhhc0V4dGVuc2lvbigpIHRvIGNoZWNrIHdoZXRoZXIgYW5cbiAqIGV4dGVuc2lvbiBpcyBzZXQuIElmIHRoZSBleHRlbnNpb24gaXMgbm90IHNldCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICogZGVmYXVsdCB2YWx1ZSAoaWYgb25lIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHByb3RvYnVmIHNvdXJjZSksIG9yIHRoZSB6ZXJvIHZhbHVlXG4gKiAoZm9yIGV4YW1wbGUgYDBgIGZvciBudW1lcmljIHR5cGVzLCBgW11gIGZvciByZXBlYXRlZCBleHRlbnNpb24gZmllbGRzLCBhbmRcbiAqIGFuIGVtcHR5IG1lc3NhZ2UgaW5zdGFuY2UgZm9yIG1lc3NhZ2UgZmllbGRzKS5cbiAqXG4gKiBFeHRlbnNpb25zIGFyZSBzdG9yZWQgYXMgdW5rbm93biBmaWVsZHMgb24gYSBtZXNzYWdlLiBUbyBtdXRhdGUgYW4gZXh0ZW5zaW9uXG4gKiB2YWx1ZSwgbWFrZSBzdXJlIHRvIHN0b3JlIHRoZSBuZXcgdmFsdWUgd2l0aCBzZXRFeHRlbnNpb24oKSBhZnRlciBtdXRhdGluZy5cbiAqXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICovXG5mdW5jdGlvbiBnZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uLCBvcHRpb25zKSB7XG4gIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gIGNvbnN0IG9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IHVmcyA9IGZpbHRlclVua25vd25GaWVsZHMobWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSksIGV4dGVuc2lvbi5maWVsZCk7XG4gIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKTtcbiAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcbiAgICBleHRlbnNpb24ucnVudGltZS5iaW4ucmVhZEZpZWxkKGNvbnRhaW5lciwgb3B0LnJlYWRlckZhY3RvcnkodWYuZGF0YSksIGV4dGVuc2lvbi5maWVsZCwgdWYud2lyZVR5cGUsIG9wdCk7XG4gIH1cbiAgcmV0dXJuIGdldCgpO1xufVxuLyoqXG4gKiBTZXQgYW4gZXh0ZW5zaW9uIHZhbHVlIG9uIGEgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgYWxyZWFkeSBoYXMgYSB2YWx1ZSBmb3JcbiAqIHRoaXMgZXh0ZW5zaW9uLCB0aGUgdmFsdWUgaXMgcmVwbGFjZWQuXG4gKlxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqL1xuZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKTtcbiAgY29uc3QgcmVhZE9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IHdyaXRlT3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmIChoYXNFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uKSkge1xuICAgIGNvbnN0IHVmcyA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLmZpbHRlcih1ZiA9PiB1Zi5ubyAhPSBleHRlbnNpb24uZmllbGQubm8pO1xuICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmRpc2NhcmRVbmtub3duRmllbGRzKG1lc3NhZ2UpO1xuICAgIGZvciAoY29uc3QgdWYgb2YgdWZzKSB7XG4gICAgICBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgIH1cbiAgfVxuICBjb25zdCB3cml0ZXIgPSB3cml0ZU9wdC53cml0ZXJGYWN0b3J5KCk7XG4gIGxldCBmID0gZXh0ZW5zaW9uLmZpZWxkO1xuICAvLyBJbXBsaWNpdCBwcmVzZW5jZSBkb2VzIG5vdCBhcHBseSB0byBleHRlbnNpb25zLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9pc3N1ZXMvODIzNFxuICAvLyBXZSBwYXRjaCB0aGUgZmllbGQgaW5mbyB0byB1c2UgZXhwbGljaXQgcHJlc2VuY2U6XG4gIGlmICghZi5vcHQgJiYgIWYucmVwZWF0ZWQgJiYgKGYua2luZCA9PSBcImVudW1cIiB8fCBmLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcbiAgICBmID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRlbnNpb24uZmllbGQpLCB7XG4gICAgICBvcHQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBleHRlbnNpb24ucnVudGltZS5iaW4ud3JpdGVGaWVsZChmLCB2YWx1ZSwgd3JpdGVyLCB3cml0ZU9wdCk7XG4gIGNvbnN0IHJlYWRlciA9IHJlYWRPcHQucmVhZGVyRmFjdG9yeSh3cml0ZXIuZmluaXNoKCkpO1xuICB3aGlsZSAocmVhZGVyLnBvcyA8IHJlYWRlci5sZW4pIHtcbiAgICBjb25zdCBbbm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIG5vKTtcbiAgICBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpO1xuICB9XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gZXh0ZW5zaW9uIGlzIHNldCBvbiBhIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pIHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgcmV0dXJuIGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSA9PT0gbWVzc2FnZVR5cGUudHlwZU5hbWUgJiYgISFtZXNzYWdlVHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKS5maW5kKHVmID0+IHVmLm5vID09IGV4dGVuc2lvbi5maWVsZC5ubyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpIHtcbiAgYXNzZXJ0KGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSA9PSBtZXNzYWdlLmdldFR5cGUoKS50eXBlTmFtZSwgXCJleHRlbnNpb24gXCIuY29uY2F0KGV4dGVuc2lvbi50eXBlTmFtZSwgXCIgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBtZXNzYWdlIFwiKS5jb25jYXQoZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lKSk7XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWVsZCBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xuICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXS5sZW5ndGggPiAwO1xuICB9XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHJldHVybiB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXS5jYXNlID09PSBsb2NhbE5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIC8vIGltcGxpY2l0IHByZXNlbmNlXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcImVudW1cIikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IGZpZWxkLlQudmFsdWVzWzBdLm5vO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpc1NjYWxhclplcm9WYWx1ZShmaWVsZC5ULCB0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXRbbG9jYWxOYW1lXSkubGVuZ3RoID4gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgfVxufVxuLyoqXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgY29uc3QgaW1wbGljaXRQcmVzZW5jZSA9ICFmaWVsZC5vcHQgJiYgIWZpZWxkLnJlcTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBbXTtcbiAgfSBlbHNlIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gaW1wbGljaXRQcmVzZW5jZSA/IHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFueSBzdWJ0eXBlIG9mIE1lc3NhZ2Ugb3IgaXMgYSBzcGVjaWZpY1xuICogTWVzc2FnZSBieSBwYXNzaW5nIHRoZSB0eXBlLlxuICpcbiAqIEp1c3QgbGlrZSBgaW5zdGFuY2VvZmAsIGBpc01lc3NhZ2VgIG5hcnJvd3MgdGhlIHR5cGUuIFRoZSBhZHZhbnRhZ2Ugb2ZcbiAqIGBpc01lc3NhZ2VgIGlzIHRoYXQgaXQgY29tcGFyZXMgaWRlbnRpdHkgYnkgdGhlIG1lc3NhZ2UgdHlwZSBuYW1lLCBub3QgYnlcbiAqIGNsYXNzIGlkZW50aXR5LiBUaGlzIG1ha2VzIGl0IHJvYnVzdCBhZ2FpbnN0IHRoZSBkdWFsIHBhY2thZ2UgaGF6YXJkIGFuZFxuICogc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB0aGUgc2FtZSBtZXNzYWdlIGlzIGR1cGxpY2F0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBfbW9zdGx5XyBlcXVpdmFsZW50IHRvIHRoZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IuIEZvclxuICogZXhhbXBsZSwgYGlzTWVzc2FnZShmb28sIE15TWVzc2FnZSlgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNeU1lc3NhZ2VgLFxuICogYW5kIGBpc01lc3NhZ2UoZm9vKWAgaXMgdGhlIHNhbWUgYXMgYGZvbyBpbnN0YW5jZW9mIE1lc3NhZ2VgLiBJbiBtb3N0IGNhc2VzLFxuICogYGlzTWVzc2FnZWAgc2hvdWxkIGJlIHByZWZlcnJlZCBvdmVyIGBpbnN0YW5jZW9mYC5cbiAqXG4gKiBIb3dldmVyLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBgaXNNZXNzYWdlYCBkb2VzIG5vdCB1c2UgY2xhc3MgaWRlbnRpdHksIHRoZXJlXG4gKiBhcmUgc3VidGxlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBmdW5jdGlvbiBhbmQgYGluc3RhbmNlb2ZgLiBOb3RhYmx5LFxuICogY2FsbGluZyBgaXNNZXNzYWdlYCBvbiBhbiBleHBsaWNpdCB0eXBlIG9mIE1lc3NhZ2Ugd2lsbCByZXR1cm4gZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTWVzc2FnZShhcmcsIHR5cGUpIHtcbiAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnICE9IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNZXNzYWdlLnByb3RvdHlwZSkuZXZlcnkobSA9PiBtIGluIGFyZyAmJiB0eXBlb2YgYXJnW21dID09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsVHlwZSA9IGFyZy5nZXRUeXBlKCk7XG4gIGlmIChhY3R1YWxUeXBlID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWxUeXBlICE9IFwiZnVuY3Rpb25cIiB8fCAhKFwidHlwZU5hbWVcIiBpbiBhY3R1YWxUeXBlKSB8fCB0eXBlb2YgYWN0dWFsVHlwZS50eXBlTmFtZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWN0dWFsVHlwZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lO1xufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFdyYXAgYSBwcmltaXRpdmUgbWVzc2FnZSBmaWVsZCB2YWx1ZSBpbiBpdHMgY29ycmVzcG9uZGluZyB3cmFwcGVyXG4gKiBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIGlkZW1wb3RlbnQuXG4gKi9cbmZ1bmN0aW9uIHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICBpZiAoaXNNZXNzYWdlKHZhbHVlKSB8fCAhdHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHR5cGUuZmllbGRXcmFwcGVyLndyYXBGaWVsZCh2YWx1ZSk7XG59XG4oe1xuICBcImdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVwiOiBTY2FsYXJUeXBlLkRPVUJMRSxcbiAgXCJnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZVwiOiBTY2FsYXJUeXBlLkZMT0FULFxuICBcImdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuSU5UNjQsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDY0LFxuICBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuSU5UMzIsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDMyLFxuICBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjogU2NhbGFyVHlwZS5CT09MLFxuICBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiOiBTY2FsYXJUeXBlLlNUUklORyxcbiAgXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiOiBTY2FsYXJUeXBlLkJZVEVTXG59KTsvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZVxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gIGVudW1Bc0ludGVnZXI6IGZhbHNlLFxuICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gIHByZXR0eVNwYWNlczogMFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyQxKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zJDEob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXQoKSB7XG4gIHJldHVybiB7XG4gICAgbWFrZVJlYWRPcHRpb25zOiBtYWtlUmVhZE9wdGlvbnMkMSxcbiAgICBtYWtlV3JpdGVPcHRpb25zOiBtYWtlV3JpdGVPcHRpb25zJDEsXG4gICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbikpKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgY29uc3Qgb25lb2ZTZWVuID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kSnNvbk5hbWUoanNvbktleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xuICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogbXVsdGlwbGUga2V5cyBmb3Igb25lb2YgXFxcIlwiKS5jb25jYXQoZmllbGQub25lb2YubmFtZSwgXCJcXFwiIHByZXNlbnQ6IFxcXCJcIikuY29uY2F0KHNlZW4sIFwiXFxcIiwgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkRmllbGQkMShtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJiBqc29uS2V5LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGpzb25LZXkuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKGpzb25LZXkuc3Vic3RyaW5nKDEsIGpzb25LZXkubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgaWYgKGV4dCAmJiBleHQuZXh0ZW5kZWUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcbiAgICAgICAgICAgICAgcmVhZEZpZWxkJDEoY29udGFpbmVyLCBqc29uVmFsdWUsIGV4dC5maWVsZCwgb3B0aW9ucywgZXh0KTtcbiAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucy9CaW5hcnlXcml0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93biBiaW5hcnkgcmVhZGVyIGFuZCB3cml0ZXIgZmFjdG9yaWVzXG4gICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgZ2V0KCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgbGV0IGZpZWxkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgICB0aHJvdyBcInJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlKGZpZWxkKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZiA/IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXS52YWx1ZSA6IG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXTtcbiAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XG4gICAgICAgIGlmIChyZWdpc3RyeSA9PT0gbnVsbCB8fCByZWdpc3RyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcikge1xuICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XG4gICAgICAgICAgICBpZiAoZXh0ICYmIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHQpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHBhc3Mgb24gdGhlIG9wdGlvbnMgYXMgQmluYXJ5UmVhZE9wdGlvbnMsIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93blxuICAgICAgICAgICAgICAvLyBiaW5hcnkgcmVhZGVyIGZhY3RvcnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGpzb25bZXh0LmZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBtID0gZmllbGQgPyBcImNhbm5vdCBlbmNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgdG8gSlNPTlwiKSA6IFwiY2Fubm90IGVuY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiB0byBKU09OXCIpO1xuICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBcIjogXCIuY29uY2F0KHIpIDogXCJcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlKSB7XG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZC4gRm9yIGJhY2t3YXJkcy1cbiAgICAgIC8vIGNvbXBhdGliaWxpdHksIHdlIHN1cHBvcnQgdGhlIG9sZCBmb3JtIHRoYXQgaXMgcGFydCBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgLy8gdGhyb3VnaCB0aGUgaW50ZXJmYWNlIEpzb25Gb3JtYXQuXG4gICAgICByZXR1cm4gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgfSxcbiAgICB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZW1pdERlZmF1bHRWYWx1ZXMgfHwgaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGpzb24pID8gXCJhcnJheVwiIDogXCJvYmplY3RcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogXCJcXFwiXCIuY29uY2F0KGpzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyksIFwiXFxcIlwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcbiAgfVxufVxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXG5mdW5jdGlvbiByZWFkRmllbGQkMSh0YXJnZXQsIGpzb25WYWx1ZSwgZmllbGQsIG9wdGlvbnMsIHBhcmVudFR5cGUpIHtcbiAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KGZpZWxkLmtpbmQgIT0gXCJtYXBcIik7XG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICBpZiAoanNvbkl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKHJlYWRTY2FsYXIkMShmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCwgdHJ1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uSXRlbSkpO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbFwiKSk7XG4gICAgICB9XG4gICAgICBsZXQga2V5O1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHRva2VuSWdub3JlZFVua25vd25FbnVtKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwW2tleV0gPSByZWFkU2NhbGFyJDEoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcbiAgICAgICAgY2FzZTogbG9jYWxOYW1lXG4gICAgICB9O1xuICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBtZXNzYWdlVHlwZS50eXBlTmFtZSAhPSBcImdvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFZhbHVlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCBmYWxzZSk7XG4gICAgICAgIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgY2FzZSB0b2tlbk51bGw6XG4gICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0b2tlbklnbm9yZWRVbmtub3duRW51bTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNjYWxhclZhbHVlID0gcmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCwgZmFsc2UpO1xuICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZE1hcEtleSh0eXBlLCBqc29uKSB7XG4gIGlmICh0eXBlID09PSBTY2FsYXJUeXBlLkJPT0wpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAoanNvbikge1xuICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAganNvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgIGpzb24gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuTnVsbDtcbiAgfVxuICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGxldCBpbnQzMjtcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKSBpbnQzMiA9IGpzb247ZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICByZXR1cm4gaW50MzI7XG4gICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpIGJyZWFrO1xuICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpIGJyZWFrO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gc3RyaW5nOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSBicmVhaztcbiAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgICAgcmV0dXJuIDA7IC8vIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUuTlVMTF9WQUxVRSA9IDBcbiAgICB9XG4gICAgcmV0dXJuIG51bGxBc1plcm9WYWx1ZSA/IHR5cGUudmFsdWVzWzBdLm5vIDogdG9rZW5OdWxsO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5ubztcbiAgICAgIH1cbiAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0b2tlbklnbm9yZWRVbmtub3duRW51bTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XG59XG4vLyBEZWNpZGUgd2hldGhlciBhbiB1bnNldCBmaWVsZCBzaG91bGQgYmUgZW1pdHRlZCB3aXRoIEpTT04gd3JpdGUgb3B0aW9uIGBlbWl0RGVmYXVsdFZhbHVlc2BcbmZ1bmN0aW9uIGNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZShmaWVsZCkge1xuICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgLy8gbWFwcyBhcmUge30sIHJlcGVhdGVkIGZpZWxkcyBhcmUgW11cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAvLyBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIGVtaXR0ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAvLyBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGFyZSBhbGxvd2VkIHRvIGVtaXQgSlNPTiBudWxsLCBidXQgd2UgZG8gbm90XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcbiAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gd3JpdGVGaWVsZCQxKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyJDEoZmllbGQuVi5ULCBlbnRyeVZhbHVlKTsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGVudHJpZXMubGVuZ3RoID4gMCA/IGpzb25PYmogOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVTY2FsYXIkMShmaWVsZC5ULCB2YWx1ZVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh2YWx1ZVtpXS50b0pzb24ob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xuICB9XG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKGZpZWxkLlQsIHZhbHVlKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgcmV0dXJuIHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVudW1Bc0ludGVnZXIpIHtcbiAgdmFyIF9hO1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgLy8gYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuIFwiTmFOXCI7XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy8gYm9vbDpcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmVuYyh2YWx1ZSk7XG4gIH1cbn0vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAqL1xuY29uc3QgdW5rbm93bkZpZWxkc1N5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi91bmtub3duLWZpZWxkc1wiKTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHJlYWREZWZhdWx0cyA9IHtcbiAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gIHJlYWRlckZhY3Rvcnk6IGJ5dGVzID0+IG5ldyBCaW5hcnlSZWFkZXIoYnl0ZXMpXG59O1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHdyaXRlRGVmYXVsdHMgPSB7XG4gIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpXG59O1xuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfSxcbiAgICBkaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICB9LFxuICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICBpZiAoYykge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xuICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSkge1xuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcbiAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgfVxuICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHtcbiAgICAgICAgbm8sXG4gICAgICAgIHdpcmVUeXBlLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vLCBvcHRpb25zLCBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIGNvbnN0IGVuZCA9IGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vO1xuICAgICAgbGV0IGZpZWxkTm8sIHdpcmVUeXBlO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA9PT0gdHJ1ZSAmJiB3aXJlVHlwZSA9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZChmaWVsZE5vKTtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSwgZmllbGRObyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZWFkRmllbGQobWVzc2FnZSwgcmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgd2lyZVR5cGUgIT0gV2lyZVR5cGUuRW5kR3JvdXAgfHwgZmllbGRObyAhPT0gbGVuZ3RoT3JFbmRUYWdGaWVsZE5vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWFkRmllbGQsXG4gICAgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgIGlmICghaXNGaWVsZFNldChmaWVsZCwgbWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoZmllbGQucmVxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIHRvIGJpbmFyeTogcmVxdWlyZWQgZmllbGQgbm90IHNldFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQub25lb2YgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWUgOiBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV07XG4gICAgICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHRoaXMud3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZCwgaXQgZG9lcyBubyBsb25nZXJcbiAgICAgIC8vIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMgZm9yIHNpbmd1bGFyIHNjYWxhciBhbmQgbWFwLlxuICAgICAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2ZcbiAgICAgIC8vIHRoZSBwdWJsaWMgQVBJIHRocm91Z2ggdGhlIGludGVyZmFjZSBCaW5hcnlGb3JtYXQuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVhZEZpZWxkKHRhcmdldCxcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBgYW55YCBpcyB0aGUgYmVzdCBjaG9pY2UgZm9yIGR5bmFtaWMgYWNjZXNzXG5yZWFkZXIsIGZpZWxkLCB3aXJlVHlwZSwgb3B0aW9ucykge1xuICBsZXQge1xuICAgIHJlcGVhdGVkLFxuICAgIGxvY2FsTmFtZVxuICB9ID0gZmllbGQ7XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgfVxuICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgfVxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXI7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuTCA+IDApIHtcbiAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgaXNQYWNrZWQgPSB3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLlNUUklORyAmJiBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuQllURVM7XG4gICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGUpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZChyZWFkZXIsIHNjYWxhclR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zLCBmaWVsZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTWVzc2FnZSh0YXJnZXRbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMsIGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mICYmICFmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1hcFwiOlxuICAgICAgbGV0IFttYXBLZXksIG1hcFZhbF0gPSByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICBicmVhaztcbiAgfVxufVxuLy8gUmVhZCBhIG1lc3NhZ2UsIGF2b2lkaW5nIE1lc3NhZ2VUeXBlLmZyb21CaW5hcnkoKSB0byByZS11c2UgdGhlXG4vLyBCaW5hcnlSZWFkT3B0aW9ucyBhbmQgdGhlIElCaW5hcnlSZWFkZXIuXG5mdW5jdGlvbiByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgZmllbGQpIHtcbiAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gIGNvbnN0IGRlbGltaXRlZCA9IGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5kZWxpbWl0ZWQ7XG4gIGZvcm1hdC5yZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGRlbGltaXRlZCA/IGZpZWxkLm5vIDogcmVhZGVyLnVpbnQzMigpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICBvcHRpb25zLCBkZWxpbWl0ZWQpO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSxcbiAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICBsZXQga2V5LCB2YWw7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgY29uc3QgW2ZpZWxkTm9dID0gcmVhZGVyLnRhZygpO1xuICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrZXkgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgZmllbGQuVi5UKCksIG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5ID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9IFwibnVtYmVyXCIpIHtcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB2YWwgPSBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHZhbCA9IGZpZWxkLlYuVC52YWx1ZXNbMF0ubm87XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgdmFsID0gbmV3IGZpZWxkLlYuVCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgY29uc3QgdiA9IHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKTtcbiAgcmV0dXJuIHR5cGVvZiB2ID09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2O1xufVxuLy8gRG9lcyBub3QgdXNlIHNjYWxhclR5cGVJbmZvKCkgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgIHJldHVybiByZWFkZXIuaW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgY29uc3QgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZDtcbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcInNjYWxhclwiOlxuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWFwXCI6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xuICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICB3cml0ZXIuZm9yaygpO1xuICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgbGV0IGtleVZhbHVlID0ga2V5O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSB3ZSBkZWxpYmVyYXRlbHkgaGFuZGxlIGp1c3QgdGhlIHNwZWNpYWwgY2FzZXMgZm9yIG1hcCBrZXlzXG4gIHN3aXRjaCAoZmllbGQuSykge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gd3JpdGUga2V5LCBleHBlY3Rpbmcga2V5IGZpZWxkIG51bWJlciA9IDFcbiAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSk7XG4gIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKHZhbHVlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHdyaXRlci5qb2luKCk7XG59XG4vLyBWYWx1ZSBtdXN0IG5vdCBiZSB1bmRlZmluZWRcbmZ1bmN0aW9uIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIHZhbHVlKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gIGlmIChmaWVsZC5kZWxpbWl0ZWQpIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLlN0YXJ0R3JvdXApLnJhdyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKS50YWcoZmllbGQubm8sIFdpcmVUeXBlLkVuZEdyb3VwKTtlbHNlIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kXSA9IHNjYWxhclR5cGVJbmZvKHR5cGUpO1xuICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlIGZvciBwcm90bzMgc2VtYW50aWNzXG4gKlxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICovXG4vLyBUT0RPIHJlcGxhY2UgY2FsbC1zaXRlcyB3cml0ZVNjYWxhcigpIGFuZCB3cml0ZVBhY2tlZCgpLCB0aGVuIHJlbW92ZVxuZnVuY3Rpb24gc2NhbGFyVHlwZUluZm8odHlwZSkge1xuICBsZXQgd2lyZVR5cGUgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIElOVDMyLCBVSU5UMzIsIFNJTlQzMiBhcmUgY292ZXJlZCBieSB0aGUgZGVmYXVsdHNcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgY29uc3QgbWV0aG9kID0gU2NhbGFyVHlwZVt0eXBlXS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2RdO1xufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XG4gIHJldHVybiB7XG4gICAgc2V0RW51bVR5cGUsXG4gICAgaW5pdFBhcnRpYWwoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmdldFR5cGUoKTtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcbiAgICAgICAgICB0ID0gdGFyZ2V0LFxuICAgICAgICAgIHMgPSBzb3VyY2U7XG4gICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE8gaWYgc291cmNlIGlzIGEgTWVzc2FnZSBpbnN0YW5jZSwgd2Ugc2hvdWxkIHVzZSBpc0ZpZWxkU2V0KCkgaGVyZSB0byBzdXBwb3J0IGZ1dHVyZSBmaWVsZCBwcmVzZW5jZVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgIGNvbnN0IHNrID0gc1tsb2NhbE5hbWVdLmNhc2U7XG4gICAgICAgICAgICBpZiAoc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChzayk7XG4gICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmIHNvdXJjZUZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIgJiYgIWlzTWVzc2FnZSh2YWwsIHNvdXJjZUZpZWxkLlQpKSB7XG4gICAgICAgICAgICAgIHZhbCA9IG5ldyBzb3VyY2VGaWVsZC5UKHZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZUZpZWxkICYmIHNvdXJjZUZpZWxkLmtpbmQgPT09IFwic2NhbGFyXCIgJiYgc291cmNlRmllbGQuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICB2YWwgPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGNhc2U6IHNrLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBsZXQgY29weSA9IHNbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgIGlmIChtZW1iZXIuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICBjb3B5ID0gbWVtYmVyLnJlcGVhdGVkID8gY29weS5tYXAodG9VOEFycikgOiB0b1U4QXJyKGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gY29weTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLlYua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci5WLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdG9VOEFycih2KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0W2xvY2FsTmFtZV0sIHNbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVtYmVyLlYuVDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXVtrXTtcbiAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSBwYXJ0aWFsIGlucHV0IGZvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYSB3cmFwcGVyIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aG9zZSBtZXNzYWdlcywgd2UgcmVjdXJzaXZlbHkgbm9ybWFsaXplIHRoZSBwYXJ0aWFsIGlucHV0LlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXcgbWVzc2FnZVR5cGUodmFsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgY29uc3QgbXQgPSBtZW1iZXIuVDtcbiAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gc1tsb2NhbE5hbWVdLm1hcCh2YWwgPT4gaXNNZXNzYWdlKHZhbCwgbXQpID8gdmFsIDogbmV3IG10KHZhbCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAobXQuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICBtdC50eXBlTmFtZSA9PT0gXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gaXNNZXNzYWdlKHZhbCwgbXQpID8gdmFsIDogbmV3IG10KHZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBUT0RPIHVzZSBpc0ZpZWxkU2V0KCkgaGVyZSB0byBzdXBwb3J0IGZ1dHVyZSBmaWVsZCBwcmVzZW5jZVxuICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeShtID0+IHtcbiAgICAgICAgY29uc3QgdmEgPSBhW20ubG9jYWxOYW1lXTtcbiAgICAgICAgY29uc3QgdmIgPSBiW20ubG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhtLlQsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCBhLCB2YltpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBlYXRlZCBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQobS5raW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgbGV0IGEgPSB2YTtcbiAgICAgICAgICAgIGxldCBiID0gdmI7XG4gICAgICAgICAgICBpZiAobS5ULmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkICYmICFpc01lc3NhZ2UoYSkpIHtcbiAgICAgICAgICAgICAgICBhID0gbS5ULmZpZWxkV3JhcHBlci53cmFwRmllbGQoYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGIgIT09IHVuZGVmaW5lZCAmJiAhaXNNZXNzYWdlKGIpKSB7XG4gICAgICAgICAgICAgICAgYiA9IG0uVC5maWVsZFdyYXBwZXIud3JhcEZpZWxkKGIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbS5ULmVxdWFscyhhLCBiKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMobS5ULCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcyA9IG0uZmluZEZpZWxkKHZhLmNhc2UpO1xuICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgICAgc3dpdGNoIChzLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5ULmVxdWFscyh2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMocy5ULCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25lb2YgY2Fubm90IGNvbnRhaW4gXCIuY29uY2F0KHMua2luZCkpO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgY2xvbmUobWVzc2FnZSkge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpLFxuICAgICAgICB0YXJnZXQgPSBuZXcgdHlwZSgpLFxuICAgICAgICBhbnkgPSB0YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgY29weSA9IHNvdXJjZS5tYXAoY2xvbmVTaW5ndWxhckZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgY29weSA9IGFueVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lU2luZ3VsYXJGaWVsZCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XG4gICAgICAgICAgY29uc3QgZiA9IG1lbWJlci5maW5kRmllbGQoc291cmNlLmNhc2UpO1xuICAgICAgICAgIGNvcHkgPSBmID8ge1xuICAgICAgICAgICAgY2FzZTogc291cmNlLmNhc2UsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZS52YWx1ZSlcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYW55W21lbWJlci5sb2NhbE5hbWVdID0gY29weTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICB0eXBlLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKGFueSwgdWYubm8sIHVmLndpcmVUeXBlLCB1Zi5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9O1xufVxuLy8gY2xvbmUgYSBzaW5nbGUgZmllbGQgdmFsdWUgLSBpLmUuIHRoZSBlbGVtZW50IHR5cGUgb2YgcmVwZWF0ZWQgZmllbGRzLCB0aGUgdmFsdWUgdHlwZSBvZiBtYXBzXG5mdW5jdGlvbiBjbG9uZVNpbmd1bGFyRmllbGQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzTWVzc2FnZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgIGMuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gYztcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vLyBjb252ZXJ0cyBhbnkgQXJyYXlMaWtlPG51bWJlcj4gdG8gVWludDhBcnJheSBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiB0b1U4QXJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dCA6IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbn0vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIG5ld0ZpZWxkTGlzdCwgaW5pdEZpZWxkcykge1xuICByZXR1cm4ge1xuICAgIHN5bnRheCxcbiAgICBqc29uOiBtYWtlSnNvbkZvcm1hdCgpLFxuICAgIGJpbjogbWFrZUJpbmFyeUZvcm1hdCgpLFxuICAgIHV0aWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHtcbiAgICAgIG5ld0ZpZWxkTGlzdCxcbiAgICAgIGluaXRGaWVsZHNcbiAgICB9KSxcbiAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgICByZXR1cm4gbWFrZU1lc3NhZ2VUeXBlKHRoaXMsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCk7XG4gICAgfSxcbiAgICBtYWtlRW51bSxcbiAgICBtYWtlRW51bVR5cGUsXG4gICAgZ2V0RW51bVR5cGUsXG4gICAgbWFrZUV4dGVuc2lvbih0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XG4gICAgICByZXR1cm4gbWFrZUV4dGVuc2lvbih0aGlzLCB0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKTtcbiAgICB9XG4gIH07XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBub3JtYWxpemVyKSB7XG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICB9XG4gIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xuICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgfVxuICBmaW5kKGZpZWxkTm8pIHtcbiAgICBpZiAoIXRoaXMubnVtYmVycykge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIHRbZi5ub10gPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5udW1iZXJzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgfVxuICBsaXN0KCkge1xuICAgIGlmICghdGhpcy5hbGwpIHtcbiAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGw7XG4gIH1cbiAgYnlOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcbiAgfVxuICBieU1lbWJlcigpIHtcbiAgICBpZiAoIXRoaXMubWVtYmVycykge1xuICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICBjb25zdCBhID0gdGhpcy5tZW1iZXJzO1xuICAgICAgbGV0IG87XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xuICAgICAgICAgICAgbyA9IGYub25lb2Y7XG4gICAgICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICB9XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIHByb3RvYnVmIGVsZW1lbnQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXG4gKiBtZXNzYWdlcywgZW51bWVyYXRpb25zIGFuZCBzZXJ2aWNlcywgdGhlIHBhY2thZ2UgbmFtZSBpcyBzdHJpcHBlZCBmcm9tXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxuICovXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmaWVsZCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBpbk9uZW9mKSB7XG4gIGNvbnN0IG5hbWUgPSBwcm90b0NhbWVsQ2FzZShwcm90b05hbWUpO1xuICBpZiAoaW5PbmVvZikge1xuICAgIC8vIG9uZW9mIG1lbWJlciBuYW1lcyBhcmUgbm90IHByb3BlcnRpZXMsIGJ1dCB2YWx1ZXMgb2YgdGhlIGBjYXNlYCBwcm9wZXJ0eS5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsT25lb2ZOYW1lKHByb3RvTmFtZSkge1xuICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5jb25zdCBmaWVsZEpzb25OYW1lID0gcHJvdG9DYW1lbENhc2U7XG4vKipcbiAqIENvbnZlcnRzIHNuYWtlX2Nhc2UgdG8gcHJvdG9DYW1lbENhc2UgYWNjb3JkaW5nIHRvIHRoZSBjb252ZW50aW9uXG4gKiB1c2VkIGJ5IHByb3RvYyB0byBjb252ZXJ0IGEgZmllbGQgbmFtZSB0byBhIEpTT04gbmFtZS5cbiAqL1xuZnVuY3Rpb24gcHJvdG9DYW1lbENhc2Uoc25ha2VDYXNlKSB7XG4gIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gIGNvbnN0IGIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYyA9IHNuYWtlQ2FzZS5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlIFwiX1wiOlxuICAgICAgICBjYXBOZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOlxuICAgICAgY2FzZSBcIjFcIjpcbiAgICAgIGNhc2UgXCIyXCI6XG4gICAgICBjYXNlIFwiM1wiOlxuICAgICAgY2FzZSBcIjRcIjpcbiAgICAgIGNhc2UgXCI1XCI6XG4gICAgICBjYXNlIFwiNlwiOlxuICAgICAgY2FzZSBcIjdcIjpcbiAgICAgIGNhc2UgXCI4XCI6XG4gICAgICBjYXNlIFwiOVwiOlxuICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2FwTmV4dCkge1xuICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgICBjID0gYy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBiLmpvaW4oXCJcIik7XG59XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4vLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XG5cImNvbnN0cnVjdG9yXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0pTT05cIiwgXCJ2YWx1ZU9mXCJdKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgdGhlIHJ1bnRpbWUuXG4gKi9cbmNvbnN0IHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lXG5cImdldFR5cGVcIiwgXCJjbG9uZVwiLCBcImVxdWFsc1wiLCBcImZyb21CaW5hcnlcIiwgXCJmcm9tSnNvblwiLCBcImZyb21Kc29uU3RyaW5nXCIsIFwidG9CaW5hcnlcIiwgXCJ0b0pzb25cIiwgXCJ0b0pzb25TdHJpbmdcIixcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lIGZvciB0aGUgZnV0dXJlXG5cInRvT2JqZWN0XCJdKTtcbmNvbnN0IGZhbGxiYWNrID0gbmFtZSA9PiBcIlwiLmNvbmNhdChuYW1lLCBcIiRcIik7XG4vKipcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcbiAqIGZvciBgTWVzc2FnZWBzLlxuICovXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gbmFtZSA9PiB7XG4gIGlmIChyZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuY29uc3Qgc2FmZU9iamVjdFByb3BlcnR5ID0gbmFtZSA9PiB7XG4gIGlmIChyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTsvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgIHRoaXMucmVwZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgdGhpcy5yZXEgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gIH1cbiAgYWRkRmllbGQoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgfVxufS8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENvbnZlcnQgYSBjb2xsZWN0aW9uIG9mIGZpZWxkIGluZm8gdG8gYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCBGaWVsZEluZm8uXG4gKlxuICogVGhlIGFyZ3VtZW50IGBwYWNrZWRCeURlZmF1bHRgIHNwZWNpZmllcyB3aGV0aGVyIGZpZWxkcyB0aGF0IGRvIG5vdCBzcGVjaWZ5XG4gKiBgcGFja2VkYCBzaG91bGQgYmUgcGFja2VkIChwcm90bzMpIG9yIHVucGFja2VkIChwcm90bzIpLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zKGZpZWxkSW5mb3MsIHBhY2tlZEJ5RGVmYXVsdCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgbztcbiAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZEluZm9zKCkgOiBmaWVsZEluZm9zKSB7XG4gICAgY29uc3QgZiA9IGZpZWxkO1xuICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xuICAgIH1cbiAgICBmLmRlbGltaXRlZCA9IChfZCA9IGZpZWxkLmRlbGltaXRlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgZi5yZXEgPSAoX2UgPSBmaWVsZC5yZXEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgIGYub3B0ID0gKF9mID0gZmllbGQub3B0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcbiAgICBpZiAoZmllbGQucGFja2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgZi5wYWNrZWQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5UICE9IFNjYWxhclR5cGUuQllURVMgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xuICAgICAgfVxuICAgICAgZi5vbmVvZiA9IG87XG4gICAgICBvLmFkZEZpZWxkKGYpO1xuICAgIH1cbiAgICByLnB1c2goZik7XG4gIH1cbiAgcmV0dXJuIHI7XG59Ly8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxuICovXG5jb25zdCBwcm90bzMgPSBtYWtlUHJvdG9SdW50aW1lKFwicHJvdG8zXCIsIGZpZWxkcyA9PiB7XG4gIHJldHVybiBuZXcgSW50ZXJuYWxGaWVsZExpc3QoZmllbGRzLCBzb3VyY2UgPT4gbm9ybWFsaXplRmllbGRJbmZvcyhzb3VyY2UpKTtcbn0sXG4vLyBUT0RPIG1lcmdlIHdpdGggcHJvdG8yIGFuZCBpbml0RXh0ZW5zaW9uRmllbGQsIGFsc28gc2VlIGluaXRQYXJ0aWFsLCBlcXVhbHMsIGNsb25lXG50YXJnZXQgPT4ge1xuICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgaWYgKG1lbWJlci5vcHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcbiAgICAgIHQgPSB0YXJnZXQ7XG4gICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICB0W25hbWVdID0ge1xuICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHRbbmFtZV0gPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgdFtuYW1lXSA9IHt9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgdFtuYW1lXSA9IHNjYWxhclplcm9WYWx1ZShtZW1iZXIuVCwgbWVtYmVyLkwpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn0pOy8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXG4gICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAqIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQucGFyc2UobXMgLyAxMDAwKTtcbiAgICB0aGlzLm5hbm9zID0gMDtcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGxldCB6ID0gXCJaXCI7XG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICB9XG4gIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gIH1cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlY29uZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO2NvbnN0IE1ldHJpY3NCYXRjaCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY3NCYXRjaFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RyX2RhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidGltZV9zZXJpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVTZXJpZXNNZXRyaWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImV2ZW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRXZlbnRNZXRyaWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUaW1lU2VyaWVzTWV0cmljID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVGltZVNlcmllc01ldHJpY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2FtcGxlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTWV0cmljU2FtcGxlLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJyaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IE1ldHJpY1NhbXBsZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY1NhbXBsZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidmFsdWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMlxuICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59XSk7XG5jb25zdCBFdmVudE1ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkV2ZW50TWV0cmljXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhYmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzdGFydF90aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImVuZF90aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfc3RhcnRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwibm9ybWFsaXplZF9lbmRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXAsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuY29uc3QgQXVkaW9Db2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQXVkaW9Db2RlY1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX0FDXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiT1BVU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkFBQ1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkFDX01QM1wiXG59XSk7XG5jb25zdCBWaWRlb0NvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5WaWRlb0NvZGVjXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRFRkFVTFRfVkNcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJIMjY0X0JBU0VMSU5FXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiSDI2NF9NQUlOXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiSDI2NF9ISUdIXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiVlA4XCJcbn1dKTtcbmNvbnN0IEltYWdlQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkltYWdlQ29kZWNcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiSUNfREVGQVVMVFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIklDX0pQRUdcIlxufV0pO1xuY29uc3QgQmFja3VwQ29kZWNQb2xpY3kkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQmFja3VwQ29kZWNQb2xpY3lcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUFJFRkVSX1JFR1JFU1NJT05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTSU1VTENBU1RcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJSRUdSRVNTSU9OXCJcbn1dKTtcbmNvbnN0IFRyYWNrVHlwZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVHJhY2tUeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFVRElPXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVklERU9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEQVRBXCJcbn1dKTtcbmNvbnN0IFRyYWNrU291cmNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5UcmFja1NvdXJjZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ0FNRVJBXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiTUlDUk9QSE9ORVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRV9BVURJT1wiXG59XSk7XG5jb25zdCBWaWRlb1F1YWxpdHkkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVmlkZW9RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkxPV1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk1FRElVTVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkhJR0hcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJPRkZcIlxufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHkkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUE9PUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkdPT0RcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFWENFTExFTlRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJMT1NUXCJcbn1dKTtcbmNvbnN0IENsaWVudENvbmZpZ1NldHRpbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5TRVRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJESVNBQkxFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVOQUJMRURcIlxufV0pO1xuY29uc3QgRGlzY29ubmVjdFJlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJNSUdSQVRJT05cIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJTSUdOQUxfQ0xPU0VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiUk9PTV9DTE9TRURcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiVVNFUl9VTkFWQUlMQUJMRVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJVU0VSX1JFSkVDVEVEXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcIlNJUF9UUlVOS19GQUlMVVJFXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcIkNPTk5FQ1RJT05fVElNRU9VVFwiXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJNRURJQV9GQUlMVVJFXCJcbn1dKTtcbmNvbnN0IFJlY29ubmVjdFJlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUmVjb25uZWN0UmVhc29uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlJSX1VOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlJSX1NVQlNDUklCRVJfRkFJTEVEXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwiXG59XSk7XG5jb25zdCBTdWJzY3JpcHRpb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU0VfVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU0VfVFJBQ0tfTk9URk9VTkRcIlxufV0pO1xuY29uc3QgQXVkaW9UcmFja0ZlYXR1cmUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkF1ZGlvVHJhY2tGZWF0dXJlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlRGX1NURVJFT1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlRGX05PX0RUWFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlRGX0FVVE9fR0FJTl9DT05UUk9MXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiVEZfRUNIT19DQU5DRUxMQVRJT05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJURl9OT0lTRV9TVVBQUkVTU0lPTlwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTlwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlRGX1BSRUNPTk5FQ1RfQlVGRkVSXCJcbn1dKTtcbmNvbnN0IFJvb20kMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImRlcGFydHVyZV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiY3JlYXRpb25fdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInR1cm5fcGFzc3dvcmRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJlbmFibGVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibnVtX3B1Ymxpc2hlcnNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImFjdGl2ZV9yZWNvcmRpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVkVmVyc2lvblxufV0pO1xuY29uc3QgQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db2RlY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZm10cF9saW5lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50UGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5fc3Vic2NyaWJlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNhbl9wdWJsaXNoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNhbl9wdWJsaXNoX2RhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hfc291cmNlc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiaGlkZGVuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInJlY29yZGVyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJjYW5fdXBkYXRlX21ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJhZ2VudFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiY2FuX3N1YnNjcmliZV9tZXRyaWNzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdGF0ZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSlcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja0luZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiam9pbmVkX2F0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwiam9pbmVkX2F0X21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBlcm1pc3Npb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvblxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImlzX3B1Ymxpc2hlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwia2luZFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kKVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9yZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxufSwge1xuICBubzogMTgsXG4gIG5hbWU6IFwia2luZF9kZXRhaWxzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX0tpbmREZXRhaWwpLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX1N0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiSk9JTklOR1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkpPSU5FRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkFDVElWRVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIkRJU0NPTk5FQ1RFRFwiXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudEluZm9fS2luZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmRcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU1RBTkRBUkRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJJTkdSRVNTXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRUdSRVNTXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiU0lQXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiQUdFTlRcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJDT05ORUNUT1JcIlxufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmREZXRhaWwgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kRGV0YWlsXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkNMT1VEX0FHRU5UXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiRk9SV0FSREVEXCJcbn1dKTtcbmNvbnN0IEVuY3J5cHRpb25fVHlwZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRW5jcnlwdGlvbi5UeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIk5PTkVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHQ01cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJDVVNUT01cIlxufV0pO1xuY29uc3QgU2ltdWxjYXN0Q29kZWNJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidmlkZW9fbGF5ZXJfbW9kZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvTGF5ZXJfTW9kZSlcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic2RwX2NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBUcmFja0luZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja0luZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJzaW11bGNhc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwibWlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWNJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lZFZlcnNpb25cbn0sIHtcbiAgbm86IDE5LFxuICBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9UcmFja0ZlYXR1cmUpLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5JDEpXG59XSk7XG5jb25zdCBWaWRlb0xheWVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9MYXllclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJiaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInNzcmNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3BhdGlhbF9sYXllclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwicmlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFZpZGVvTGF5ZXJfTW9kZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVmlkZW9MYXllci5Nb2RlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIk1PREVfVU5VU0VEXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiT05FX1NQQVRJQUxfTEFZRVJfUEVSX1NUUkVBTVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk1VTFRJUExFX1NQQVRJQUxfTEFZRVJTX1BFUl9TVFJFQU1cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJPTkVfU1BBVElBTF9MQVlFUl9QRVJfU1RSRUFNX0lOQ09NUExFVEVfUlRDUF9TUlwiXG59XSk7XG5jb25zdCBEYXRhUGFja2V0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVBhY2tldFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJraW5kXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidXNlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXNlclBhY2tldCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzcGVha2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBY3RpdmVTcGVha2VyVXBkYXRlLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInNpcF9kdG1mXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaXBEVE1GLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInRyYW5zY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYW5zY3JpcHRpb24sXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWV0cmljc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTWV0cmljc0JhdGNoLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNoYXRfbWVzc2FnZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2hhdE1lc3NhZ2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInJwY19yZXF1ZXN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNSZXF1ZXN0LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJycGNfYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNBY2ssXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJwY19yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjUmVzcG9uc2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInN0cmVhbV9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fSGVhZGVyLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJzdHJlYW1fY2h1bmtcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fQ2h1bmssXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN0cmVhbV90cmFpbGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX1RyYWlsZXIsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcImVuY3J5cHRlZF9wYWNrZXRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEVuY3J5cHRlZFBhY2tldCxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwic2VxdWVuY2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBEYXRhUGFja2V0X0tpbmQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRhdGFQYWNrZXQuS2luZFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSRUxJQUJMRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkxPU1NZXCJcbn1dKTtcbmNvbnN0IEVuY3J5cHRlZFBhY2tldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkVuY3J5cHRlZFBhY2tldFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJlbmNyeXB0aW9uX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIml2XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwia2V5X2luZGV4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImVuY3J5cHRlZF92YWx1ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59XSk7XG5jb25zdCBFbmNyeXB0ZWRQYWNrZXRQYXlsb2FkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRW5jcnlwdGVkUGFja2V0UGF5bG9hZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1c2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVc2VyUGFja2V0LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNoYXRfbWVzc2FnZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2hhdE1lc3NhZ2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicnBjX3JlcXVlc3RcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY1JlcXVlc3QsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicnBjX2Fja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjQWNrLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInJwY19yZXNwb25zZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjUmVzcG9uc2UsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwic3RyZWFtX2hlYWRlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9IZWFkZXIsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwic3RyZWFtX2NodW5rXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX0NodW5rLFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInN0cmVhbV90cmFpbGVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhU3RyZWFtX1RyYWlsZXIsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn1dKTtcbmNvbnN0IEFjdGl2ZVNwZWFrZXJVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNwZWFrZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTcGVha2VySW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFNwZWFrZXJJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3BlYWtlckluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGV2ZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMlxuICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFjdGl2ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgVXNlclBhY2tldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVzZXJQYWNrZXRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25fc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRvcGljXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImVuZF90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibm9uY2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufV0pO1xuY29uc3QgU2lwRFRNRiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpcERUTUZcIiwgKCkgPT4gW3tcbiAgbm86IDMsXG4gIG5hbWU6IFwiY29kZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkaWdpdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBUcmFuc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhbnNjcmlwdGlvblwiLCAoKSA9PiBbe1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFuc2NyaWJlZF9wYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VnbWVudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYW5zY3JpcHRpb25TZWdtZW50LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVHJhbnNjcmlwdGlvblNlZ21lbnQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFuc2NyaXB0aW9uU2VnbWVudFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRleHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDRcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNFxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJmaW5hbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJsYW5ndWFnZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBDaGF0TWVzc2FnZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNoYXRNZXNzYWdlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJlZGl0X3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzLFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibWVzc2FnZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImRlbGV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBScGNSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1ldGhvZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBheWxvYWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZXNwb25zZV90aW1lb3V0X21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFJwY0FjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY0Fja1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFJwY1Jlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBheWxvYWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJlcnJvclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUnBjRXJyb3IkMSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufV0pO1xuY29uc3QgUnBjRXJyb3IkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY0Vycm9yXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibWVzc2FnZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUGFydGljaXBhbnRUcmFja3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTZXJ2ZXJJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2VydmVySW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJlZGl0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm5vZGVfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZWJ1Z19pbmZvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYWdlbnRfcHJvdG9jb2xcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5jb25zdCBTZXJ2ZXJJbmZvX0VkaXRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJTdGFuZGFyZFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNsb3VkXCJcbn1dKTtcbmNvbnN0IENsaWVudEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DbGllbnRJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNka1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwib3NfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRldmljZV9tb2RlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImJyb3dzZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJhZGRyZXNzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIm5ldHdvcmtcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwib3RoZXJfc2Rrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBDbGllbnRJbmZvX1NESyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ2xpZW50SW5mby5TREtcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkpTXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU1dJRlRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJBTkRST0lEXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiRkxVVFRFUlwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIkdPXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiVU5JVFlcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJSRUFDVF9OQVRJVkVcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJSVVNUXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiUFlUSE9OXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIkNQUFwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJVTklUWV9XRUJcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwiTk9ERVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJVTlJFQUxcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiRVNQMzJcIlxufV0pO1xuY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidmlkZW9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvQ29uZmlndXJhdGlvblxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzY3JlZW5cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvQ29uZmlndXJhdGlvblxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJyZXN1bWVfY29ubmVjdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGlzYWJsZWRDb2RlY3Ncbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZm9yY2VfcmVsYXlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuY29uc3QgVmlkZW9Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImhhcmR3YXJlX2VuY29kZXJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuY29uc3QgRGlzYWJsZWRDb2RlY3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwdWJsaXNoXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRpbWVkVmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVkVmVyc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1bml4X21pY3JvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn1dKTtcbmNvbnN0IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGF0YVN0cmVhbS5PcGVyYXRpb25UeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkNSRUFURVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlVQREFURVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkRFTEVURVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlJFQUNUSU9OXCJcbn1dKTtcbmNvbnN0IERhdGFTdHJlYW1fVGV4dEhlYWRlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uVGV4dEhlYWRlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJvcGVyYXRpb25fdHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSlcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVwbHlfdG9fc3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYXR0YWNoZWRfc3RyZWFtX2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJnZW5lcmF0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RleHRIZWFkZXJcIlxufSk7XG5jb25zdCBEYXRhU3RyZWFtX0J5dGVIZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkJ5dGVIZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSwge1xuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9CeXRlSGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9IZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkhlYWRlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdHJlYW1faWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRvcGljXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidG90YWxfbGVuZ3RoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJlbmNyeXB0aW9uX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwidGV4dF9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fVGV4dEhlYWRlcixcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiYnl0ZV9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fQnl0ZUhlYWRlcixcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fSGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9DaHVuayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uQ2h1bmtcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2h1bmtfaW5kZXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNFxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjb250ZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaXZcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTIsXG4gIG9wdDogdHJ1ZVxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQ2h1bmtcIlxufSk7XG5jb25zdCBEYXRhU3RyZWFtX1RyYWlsZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLlRyYWlsZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicmVhc29uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fVHJhaWxlclwiXG59KTtcbmNvbnN0IEZpbHRlclBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkZpbHRlclBhcmFtc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpbmNsdWRlX2V2ZW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJleGNsdWRlX2V2ZW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgV2ViaG9va0NvbmZpZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LldlYmhvb2tDb25maWdcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic2lnbmluZ19rZXlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJmaWx0ZXJfcGFyYW1zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBGaWx0ZXJQYXJhbXNcbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRBdWRpb0NvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZEF1ZGlvQ29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbmFibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBSb29tQWdlbnREaXNwYXRjaCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21BZ2VudERpc3BhdGNoXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFnZW50X25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBFbmNvZGVkRmlsZVR5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkVuY29kZWRGaWxlVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX0ZJTEVUWVBFXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiTVA0XCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiT0dHXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTVAzXCJcbn1dKTtcbmNvbnN0IFNlZ21lbnRlZEZpbGVQcm90b2NvbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2VnbWVudGVkRmlsZVByb3RvY29sXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRFRkFVTFRfU0VHTUVOVEVEX0ZJTEVfUFJPVE9DT0xcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJITFNfUFJPVE9DT0xcIlxufV0pO1xuY29uc3QgU2VnbWVudGVkRmlsZVN1ZmZpeCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2VnbWVudGVkRmlsZVN1ZmZpeFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJJTkRFWFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlRJTUVTVEFNUFwiXG59XSk7XG5jb25zdCBJbWFnZUZpbGVTdWZmaXggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkltYWdlRmlsZVN1ZmZpeFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJJTUFHRV9TVUZGSVhfSU5ERVhcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJJTUFHRV9TVUZGSVhfVElNRVNUQU1QXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiSU1BR0VfU1VGRklYX05PTkVfT1ZFUldSSVRFXCJcbn1dKTtcbmNvbnN0IFN0cmVhbVByb3RvY29sID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TdHJlYW1Qcm90b2NvbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJERUZBVUxUX1BST1RPQ09MXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUlRNUFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNSVFwiXG59XSk7XG5jb25zdCBBdWRpb01peGluZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQXVkaW9NaXhpbmdcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9NSVhJTkdcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJEVUFMX0NIQU5ORUxfQUdFTlRcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEVUFMX0NIQU5ORUxfQUxURVJOQVRFXCJcbn1dKTtcbmNvbnN0IEVuY29kaW5nT3B0aW9uc1ByZXNldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRW5jb2RpbmdPcHRpb25zUHJlc2V0XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkgyNjRfNzIwUF8zMFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkgyNjRfNzIwUF82MFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkgyNjRfMTA4MFBfMzBcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJIMjY0XzEwODBQXzYwXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUE9SVFJBSVRfSDI2NF83MjBQXzMwXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiUE9SVFJBSVRfSDI2NF83MjBQXzYwXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiUE9SVFJBSVRfSDI2NF8xMDgwUF8zMFwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcIlBPUlRSQUlUX0gyNjRfMTA4MFBfNjBcIlxufV0pO1xuY29uc3QgUm9vbUNvbXBvc2l0ZUVncmVzc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tQ29tcG9zaXRlRWdyZXNzUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tX25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsYXlvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhdWRpb19vbmx5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJhdWRpb19taXhpbmdcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb01peGluZylcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidmlkZW9fb25seVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJjdXN0b21fYmFzZV91cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJmaWxlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBFbmNvZGVkRmlsZU91dHB1dCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwic3RyZWFtXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdHJlYW1PdXRwdXQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzZWdtZW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2VnbWVudGVkRmlsZU91dHB1dCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicHJlc2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RpbmdPcHRpb25zUHJlc2V0KSxcbiAgb25lb2Y6IFwib3B0aW9uc1wiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImFkdmFuY2VkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBFbmNvZGluZ09wdGlvbnMsXG4gIG9uZW9mOiBcIm9wdGlvbnNcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiZmlsZV9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBFbmNvZGVkRmlsZU91dHB1dCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInN0cmVhbV9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdHJlYW1PdXRwdXQsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzZWdtZW50X291dHB1dHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlZ21lbnRlZEZpbGVPdXRwdXQsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJpbWFnZV9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJbWFnZU91dHB1dCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcIndlYmhvb2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBXZWJob29rQ29uZmlnLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgRW5jb2RlZEZpbGVPdXRwdXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5FbmNvZGVkRmlsZU91dHB1dFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJmaWxlX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNvZGVkRmlsZVR5cGUpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImZpbGVwYXRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGlzYWJsZV9tYW5pZmVzdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJzM1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUzNVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImdjcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogR0NQVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJhenVyZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQXp1cmVCbG9iVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhbGlPU1NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFsaU9TU1VwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn1dKTtcbmNvbnN0IFNlZ21lbnRlZEZpbGVPdXRwdXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TZWdtZW50ZWRGaWxlT3V0cHV0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VnbWVudGVkRmlsZVByb3RvY29sKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmaWxlbmFtZV9wcmVmaXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwbGF5bGlzdF9uYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcImxpdmVfcGxheWxpc3RfbmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlZ21lbnRfZHVyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImZpbGVuYW1lX3N1ZmZpeFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlZ21lbnRlZEZpbGVTdWZmaXgpXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImRpc2FibGVfbWFuaWZlc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiczNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFMzVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJnY3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEdDUFVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYXp1cmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEF6dXJlQmxvYlVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiYWxpT1NTXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBbGlPU1NVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59XSk7XG5jb25zdCBJbWFnZU91dHB1dCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkltYWdlT3V0cHV0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhcHR1cmVfaW50ZXJ2YWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZmlsZW5hbWVfcHJlZml4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZmlsZW5hbWVfc3VmZml4XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoSW1hZ2VGaWxlU3VmZml4KVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJpbWFnZV9jb2RlY1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEltYWdlQ29kZWMpXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRpc2FibGVfbWFuaWZlc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiczNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFMzVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJnY3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEdDUFVwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImF6dXJlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBenVyZUJsb2JVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJhbGlPU1NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFsaU9TU1VwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn1dKTtcbmNvbnN0IFMzVXBsb2FkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUzNVcGxvYWRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYWNjZXNzX2tleVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNlY3JldFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzZXNzaW9uX3Rva2VuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcImFzc3VtZV9yb2xlX2FyblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJhc3N1bWVfcm9sZV9leHRlcm5hbF9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImVuZHBvaW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiYnVja2V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZm9yY2VfcGF0aF9zdHlsZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJ0YWdnaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiY29udGVudF9kaXNwb3NpdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJwcm94eVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUHJveHlDb25maWdcbn1dKTtcbmNvbnN0IEdDUFVwbG9hZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkdDUFVwbG9hZFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjcmVkZW50aWFsc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImJ1Y2tldFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3h5XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQcm94eUNvbmZpZ1xufV0pO1xuY29uc3QgQXp1cmVCbG9iVXBsb2FkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQXp1cmVCbG9iVXBsb2FkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFjY291bnRfbmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFjY291bnRfa2V5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY29udGFpbmVyX25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQWxpT1NTVXBsb2FkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWxpT1NTVXBsb2FkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFjY2Vzc19rZXlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzZWNyZXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJlbmRwb2ludFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImJ1Y2tldFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBQcm94eUNvbmZpZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlByb3h5Q29uZmlnXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicGFzc3dvcmRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU3RyZWFtT3V0cHV0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtT3V0cHV0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtUHJvdG9jb2wpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVybHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IEVuY29kaW5nT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkVuY29kaW5nT3B0aW9uc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkZXB0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZnJhbWVyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJhdWRpb19jb2RlY1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvQ29kZWMpXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImF1ZGlvX2JpdHJhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJhdWRpb19xdWFsaXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhdWRpb19mcmVxdWVuY3lcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInZpZGVvX2NvZGVjXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9Db2RlYylcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwidmlkZW9fYml0cmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInZpZGVvX3F1YWxpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJrZXlfZnJhbWVfaW50ZXJ2YWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMVxuICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufV0pO1xuY29uc3QgQXV0b1BhcnRpY2lwYW50RWdyZXNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQXV0b1BhcnRpY2lwYW50RWdyZXNzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInByZXNldFwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY29kaW5nT3B0aW9uc1ByZXNldCksXG4gIG9uZW9mOiBcIm9wdGlvbnNcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhZHZhbmNlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRW5jb2RpbmdPcHRpb25zLFxuICBvbmVvZjogXCJvcHRpb25zXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZmlsZV9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBFbmNvZGVkRmlsZU91dHB1dCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VnbWVudF9vdXRwdXRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgQXV0b1RyYWNrRWdyZXNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQXV0b1RyYWNrRWdyZXNzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImZpbGVwYXRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZGlzYWJsZV9tYW5pZmVzdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzM1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUzNVcGxvYWQsXG4gIG9uZW9mOiBcIm91dHB1dFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImdjcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogR0NQVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJhenVyZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQXp1cmVCbG9iVXBsb2FkLFxuICBvbmVvZjogXCJvdXRwdXRcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJhbGlPU1NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFsaU9TU1VwbG9hZCxcbiAgb25lb2Y6IFwib3V0cHV0XCJcbn1dKTtcbmNvbnN0IFJvb21FZ3Jlc3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tRWdyZXNzXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21Db21wb3NpdGVFZ3Jlc3NSZXF1ZXN0XG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBdXRvUGFydGljaXBhbnRFZ3Jlc3Ncbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBdXRvVHJhY2tFZ3Jlc3Ncbn1dKTtcbmNvbnN0IFJvb21Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUm9vbUNvbmZpZ3VyYXRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGVwYXJ0dXJlX3RpbWVvdXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibWF4X3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJlZ3Jlc3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21FZ3Jlc3Ncbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwibWluX3BsYXlvdXRfZGVsYXlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibWF4X3BsYXlvdXRfZGVsYXlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic3luY19zdHJlYW1zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJhZ2VudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb21BZ2VudERpc3BhdGNoLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU2lnbmFsVGFyZ2V0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TaWduYWxUYXJnZXRcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUFVCTElTSEVSXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiU1VCU0NSSUJFUlwiXG59XSk7XG5jb25zdCBTdHJlYW1TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3RyZWFtU3RhdGVcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiQUNUSVZFXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUEFVU0VEXCJcbn1dKTtcbmNvbnN0IENhbmRpZGF0ZVByb3RvY29sID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVRFBcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJUQ1BcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJUTFNcIlxufV0pO1xuY29uc3QgU2lnbmFsUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpZ25hbFJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJpY2tsZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJpY2tsZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJhZGRfdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFkZFRyYWNrUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm11dGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcInRyYWNrX3NldHRpbmdcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVRyYWNrU2V0dGluZ3MsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJsZWF2ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTGVhdmVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInVwZGF0ZV9sYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVZpZGVvTGF5ZXJzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInN5bmNfc3RhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN5bmNTdGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzaW11bGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxhdGVTY2VuYXJpbyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJwaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcInBpbmdfcmVxXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQaW5nLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInVwZGF0ZV9hdWRpb190cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlTG9jYWxBdWRpb1RyYWNrLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcInVwZGF0ZV92aWRlb190cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlTG9jYWxWaWRlb1RyYWNrLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn1dKTtcbmNvbnN0IFNpZ25hbFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lnbmFsUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiam9pblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSm9pblJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidHJpY2tsZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJpY2tsZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ1cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHJhY2tfcHVibGlzaGVkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibGVhdmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IExlYXZlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIm11dGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwic3BlYWtlcnNfY2hhbmdlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlcnNDaGFuZ2VkLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInJvb21fdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSb29tVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcImNvbm5lY3Rpb25fcXVhbGl0eVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtU3RhdGVVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9xdWFsaXR5X3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25fdXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcInJlZnJlc2hfdG9rZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJ0cmFja191bnB1Ymxpc2hlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcInBvbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJyZWNvbm5lY3RcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlY29ubmVjdFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIwLFxuICBuYW1lOiBcInBvbmdfcmVzcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUG9uZyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcmVzcG9uc2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIyLFxuICBuYW1lOiBcInJlcXVlc3RfcmVzcG9uc2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlcXVlc3RSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMyxcbiAgbmFtZTogXCJ0cmFja19zdWJzY3JpYmVkXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1N1YnNjcmliZWQsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjQsXG4gIG5hbWU6IFwicm9vbV9tb3ZlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbU1vdmVkUmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjUsXG4gIG5hbWU6IFwibWVkaWFfc2VjdGlvbnNfcmVxdWlyZW1lbnRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IE1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyNixcbiAgbmFtZTogXCJzdWJzY3JpYmVkX2F1ZGlvX2NvZGVjX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZEF1ZGlvQ29kZWNVcGRhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufV0pO1xuY29uc3QgU2ltdWxjYXN0Q29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidmlkZW9fbGF5ZXJfbW9kZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvTGF5ZXJfTW9kZSlcbn1dKTtcbmNvbnN0IEFkZFRyYWNrUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzaW11bGNhc3RfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGNhc3RDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzdGVyZW9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3RyZWFtXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShCYWNrdXBDb2RlY1BvbGljeSQxKVxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwiYXVkaW9fZmVhdHVyZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUcmlja2xlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbmRpZGF0ZUluaXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0YXJnZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImZpbmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBNdXRlVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgSm9pblJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuSm9pblJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfcHJpbWFyeVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhbHRlcm5hdGl2ZV91cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJjbGllbnRfY29uZmlndXJhdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2xpZW50Q29uZmlndXJhdGlvblxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInBpbmdfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBpbmdfaW50ZXJ2YWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2VydmVySW5mb1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2lmX3RyYWlsZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiZW5hYmxlZF9wdWJsaXNoX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJmYXN0X3B1Ymxpc2hcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFJlY29ubmVjdFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVjb25uZWN0UmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IElDRVNlcnZlcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic2VydmVyX2luZm9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlcnZlckluZm9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibGFzdF9tZXNzYWdlX3NlcVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuY29uc3QgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrSW5mb1xufV0pO1xuY29uc3QgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBTZXNzaW9uRGVzY3JpcHRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNkcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1pZF90b190cmFja19pZFwiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufV0pO1xuY29uc3QgUGFydGljaXBhbnRVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZVN1YnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50VHJhY2tzLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVXBkYXRlVHJhY2tTZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkaXNhYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJmcHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicHJpb3JpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsQXVkaW9UcmFja1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmZWF0dXJlc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsVmlkZW9UcmFja1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IExlYXZlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkxlYXZlUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFjdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKExlYXZlUmVxdWVzdF9BY3Rpb24pXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlZ2lvbnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlZ2lvblNldHRpbmdzXG59XSk7XG5jb25zdCBMZWF2ZVJlcXVlc3RfQWN0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRJU0NPTk5FQ1RcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJSRVNVTUVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJSRUNPTk5FQ1RcIlxufV0pO1xuY29uc3QgVXBkYXRlVmlkZW9MYXllcnMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDksXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDlcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICB9XG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IElDRVNlcnZlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LklDRVNlcnZlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cmxzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY3JlZGVudGlhbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBTcGVha2Vyc0NoYW5nZWQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgUm9vbVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21VcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbSQxXG59XSk7XG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInNjb3JlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cGRhdGVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdHJlYW1TdGF0ZUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSlcbn1dKTtcbmNvbnN0IFN0cmVhbVN0YXRlVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtU3RhdGVJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaWJlZFF1YWxpdHkgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVuYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRDb2RlY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0aWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRBdWRpb0NvZGVjVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZEF1ZGlvQ29kZWNVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9hdWRpb19jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRBdWRpb0NvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVHJhY2tQZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFsbF90cmFja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBTdWJzY3JpcHRpb25QZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhbGxfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3Blcm1pc3Npb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1Blcm1pc3Npb24sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhbGxvd2VkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBSb29tTW92ZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21Nb3ZlZFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0b2tlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTeW5jU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TeW5jU3RhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYW5zd2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb25cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHVibGlzaF90cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRhdGFfY2hhbm5lbHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFDaGFubmVsSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvblxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJ0cmFja19zaWRzX2Rpc2FibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRhdGFjaGFubmVsX3JlY2VpdmVfc3RhdGVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhQ2hhbm5lbFJlY2VpdmVTdGF0ZSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IERhdGFDaGFubmVsUmVjZWl2ZVN0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YUNoYW5uZWxSZWNlaXZlU3RhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicHVibGlzaGVyX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxhc3Rfc2VxXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBEYXRhQ2hhbm5lbEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFiZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0YXJnZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG59XSk7XG5jb25zdCBTaW11bGF0ZVNjZW5hcmlvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2VyX3VwZGF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vZGVfZmFpbHVyZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm1pZ3JhdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlcnZlcl9sZWF2ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInN3aXRjaF9jYW5kaWRhdGVfcHJvdG9jb2xcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbCksXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaWJlcl9iYW5kd2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVfbm9fbWVzc2FnZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJsZWF2ZV9yZXF1ZXN0X2Z1bGxfcmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn1dKTtcbmNvbnN0IFBpbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QaW5nXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicnR0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuY29uc3QgUG9uZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBvbmdcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibGFzdF9waW5nX3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuY29uc3QgUmVnaW9uU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWdpb25TZXR0aW5nc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZWdpb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWdpb25JbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgUmVnaW9uSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlZ2lvbkluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidXJsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGlzdGFuY2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG5jb25zdCBTdWJzY3JpcHRpb25SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVyclwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKVxufV0pO1xuY29uc3QgUmVxdWVzdFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicmVhc29uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUmVxdWVzdFJlc3BvbnNlX1JlYXNvbilcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibWVzc2FnZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJyZXF1ZXN0XCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiYWRkX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBZGRUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcInJlcXVlc3RcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJyZXF1ZXN0XCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLFxuICBvbmVvZjogXCJyZXF1ZXN0XCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwidXBkYXRlX2F1ZGlvX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVMb2NhbEF1ZGlvVHJhY2ssXG4gIG9uZW9mOiBcInJlcXVlc3RcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJ1cGRhdGVfdmlkZW9fdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayxcbiAgb25lb2Y6IFwicmVxdWVzdFwiXG59XSk7XG5jb25zdCBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5SZXF1ZXN0UmVzcG9uc2UuUmVhc29uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIk9LXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiTk9UX0ZPVU5EXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiTk9UX0FMTE9XRURcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJMSU1JVF9FWENFRURFRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlFVRVVFRFwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlVOU1VQUE9SVEVEX1RZUEVcIlxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJVTkNMQVNTSUZJRURfRVJST1JcIlxufV0pO1xuY29uc3QgVHJhY2tTdWJzY3JpYmVkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tTdWJzY3JpYmVkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBDb25uZWN0aW9uU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uU2V0dGluZ3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYXV0b19zdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiYWRhcHRpdmVfc3RyZWFtXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN1YnNjcmliZXJfYWxsb3dfcGF1c2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRpc2FibGVfaWNlX2xpdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IEpvaW5SZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuSm9pblJlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2xpZW50X2luZm9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudEluZm9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY29ubmVjdGlvbl9zZXR0aW5nc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29ubmVjdGlvblNldHRpbmdzXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJhZGRfdHJhY2tfcmVxdWVzdHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFkZFRyYWNrUmVxdWVzdCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwicHVibGlzaGVyX29mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwicmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInJlY29ubmVjdF9yZWFzb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShSZWNvbm5lY3RSZWFzb24pXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzeW5jX3N0YXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTeW5jU3RhdGVcbn1dKTtcbmNvbnN0IFdyYXBwZWRKb2luUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LldyYXBwZWRKb2luUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb21wcmVzc2lvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFdyYXBwZWRKb2luUmVxdWVzdF9Db21wcmVzc2lvbilcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiam9pbl9yZXF1ZXN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn1dKTtcbmNvbnN0IFdyYXBwZWRKb2luUmVxdWVzdF9Db21wcmVzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuV3JhcHBlZEpvaW5SZXF1ZXN0LkNvbXByZXNzaW9uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIk5PTkVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHWklQXCJcbn1dKTtcbmNvbnN0IE1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJudW1fYXVkaW9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm51bV92aWRlb3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFRva2VuU291cmNlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRva2VuU291cmNlUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyb29tX25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X25hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9tZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJyb29tX2NvbmZpZ1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbUNvbmZpZ3VyYXRpb24sXG4gIG9wdDogdHJ1ZVxufV0pO1xuY29uc3QgVG9rZW5Tb3VyY2VSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRva2VuU291cmNlUmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2VydmVyX3VybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3Rva2VuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtmdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufXZhciBsb2dsZXZlbCQxID0ge2V4cG9ydHM6IHt9fTsvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG52YXIgbG9nbGV2ZWwgPSBsb2dsZXZlbCQxLmV4cG9ydHM7XG52YXIgaGFzUmVxdWlyZWRMb2dsZXZlbDtcbmZ1bmN0aW9uIHJlcXVpcmVMb2dsZXZlbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTG9nbGV2ZWwpIHJldHVybiBsb2dsZXZlbCQxLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkTG9nbGV2ZWwgPSAxO1xuICAoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIChmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuXG4gICAgICBpZiAobW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICAgIH1cbiAgICB9KShsb2dsZXZlbCwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgICAgdmFyIGlzSUUgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlICYmIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciBsb2dNZXRob2RzID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG4gICAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcblxuICAgICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKCkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmdldExldmVsKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgYWN0dWFsIG1ldGhvZHMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gaSA8IGxldmVsID8gbm9vcCA6IHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuXG4gICAgICAgIC8vIFJldHVybiBhbnkgaW1wb3J0YW50IHdhcm5pbmdzLlxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCB0aGlzLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBmYWN0b3J5KSB7XG4gICAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcbiAgICAgICAgICogY2FjaGUgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGRlbGVnYXRpbmcgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IHN0YXlzXG4gICAgICAgICAqIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxvZ2dpbmcgbWV0aG9kcyB0aGF0IHdlIGhhdmUgaW5zdGFsbGVkICh0aGVcbiAgICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcbiAgICAgICAgICogaW4gdGhpcyBjaGlsZCB5ZXQpLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGluaGVyaXRlZExldmVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAgICogYGluaGVyaXRlZExldmVsYC5cbiAgICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAgICogYGRlZmF1bHRMZXZlbGAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciB1c2VyTGV2ZWw7XG4gICAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihjb29raWVOYW1lICsgXCI9XCIpO1xuICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKSlbMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBpbnB1dDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqXG4gICAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuICAgICAgICBzZWxmLmxldmVscyA9IHtcbiAgICAgICAgICBcIlRSQUNFXCI6IDAsXG4gICAgICAgICAgXCJERUJVR1wiOiAxLFxuICAgICAgICAgIFwiSU5GT1wiOiAyLFxuICAgICAgICAgIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCxcbiAgICAgICAgICBcIlNJTEVOVFwiOiA1XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG4gICAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHVzZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckxldmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0ZWRMZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKHVzZXJMZXZlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTk9URTogaW4gdjIsIHRoaXMgc2hvdWxkIGNhbGwgcmVidWlsZCgpLCB3aGljaCB1cGRhdGVzIGNoaWxkcmVuLlxuICAgICAgICAgIHJldHVybiByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYucmVidWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciAhPT0gc2VsZikge1xuICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciA9PT0gc2VsZikge1xuICAgICAgICAgICAgZm9yICh2YXIgY2hpbGROYW1lIGluIF9sb2dnZXJzQnlOYW1lKSB7XG4gICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGFsbCB0aGUgaW50ZXJuYWwgbGV2ZWxzLlxuICAgICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGRlZmF1bHRMb2dnZXIgPyBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkgOiBcIldBUk5cIik7XG4gICAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgICBpZiAoaW5pdGlhbExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbiAgICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUsIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgIH07XG5cbiAgICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgdmFyIF9sb2cgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgICAgfTtcbiAgICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG4gICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9KTtcbiAgfSkobG9nbGV2ZWwkMSk7XG4gIHJldHVybiBsb2dsZXZlbCQxLmV4cG9ydHM7XG59dmFyIGxvZ2xldmVsRXhwb3J0cyA9IHJlcXVpcmVMb2dsZXZlbCgpO3ZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImRlYnVnXCJdID0gMV0gPSBcImRlYnVnXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiaW5mb1wiXSA9IDJdID0gXCJpbmZvXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJzaWxlbnRcIl0gPSA1XSA9IFwic2lsZW50XCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xudmFyIExvZ2dlck5hbWVzO1xuKGZ1bmN0aW9uIChMb2dnZXJOYW1lcykge1xuICBMb2dnZXJOYW1lc1tcIkRlZmF1bHRcIl0gPSBcImxpdmVraXRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJSb29tXCJdID0gXCJsaXZla2l0LXJvb21cIjtcbiAgTG9nZ2VyTmFtZXNbXCJUb2tlblNvdXJjZVwiXSA9IFwibGl2ZWtpdC10b2tlbi1zb3VyY2VcIjtcbiAgTG9nZ2VyTmFtZXNbXCJQYXJ0aWNpcGFudFwiXSA9IFwibGl2ZWtpdC1wYXJ0aWNpcGFudFwiO1xuICBMb2dnZXJOYW1lc1tcIlRyYWNrXCJdID0gXCJsaXZla2l0LXRyYWNrXCI7XG4gIExvZ2dlck5hbWVzW1wiUHVibGljYXRpb25cIl0gPSBcImxpdmVraXQtdHJhY2stcHVibGljYXRpb25cIjtcbiAgTG9nZ2VyTmFtZXNbXCJFbmdpbmVcIl0gPSBcImxpdmVraXQtZW5naW5lXCI7XG4gIExvZ2dlck5hbWVzW1wiU2lnbmFsXCJdID0gXCJsaXZla2l0LXNpZ25hbFwiO1xuICBMb2dnZXJOYW1lc1tcIlBDTWFuYWdlclwiXSA9IFwibGl2ZWtpdC1wYy1tYW5hZ2VyXCI7XG4gIExvZ2dlck5hbWVzW1wiUENUcmFuc3BvcnRcIl0gPSBcImxpdmVraXQtcGMtdHJhbnNwb3J0XCI7XG4gIExvZ2dlck5hbWVzW1wiRTJFRVwiXSA9IFwibGstZTJlZVwiO1xufSkoTG9nZ2VyTmFtZXMgfHwgKExvZ2dlck5hbWVzID0ge30pKTtcbmxldCBsaXZla2l0TG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcignbGl2ZWtpdCcpO1xuY29uc3QgbGl2ZWtpdExvZ2dlcnMgPSBPYmplY3QudmFsdWVzKExvZ2dlck5hbWVzKS5tYXAobmFtZSA9PiBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKG5hbWUpKTtcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBsaXZla2l0TG9nZ2Vycykge1xuICAgICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogdXNlIHRoaXMgdG8gaG9vayBpbnRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uIHRvIGFsbG93IHNlbmRpbmcgaW50ZXJuYWwgbGl2ZWtpdCBsb2dzIHRvIHRoaXJkIHBhcnR5IHNlcnZpY2VzXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxuICovXG5mdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uLCBsb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VycyA9IGxvZ2dlciA/IFtsb2dnZXJdIDogbGl2ZWtpdExvZ2dlcnM7XG4gIGxvZ2dlcnMuZm9yRWFjaChsb2dSID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEZhY3RvcnkgPSBsb2dSLm1ldGhvZEZhY3Rvcnk7XG4gICAgbG9nUi5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgY29uc3QgbG9nTGV2ZWwgPSBMb2dMZXZlbFttZXRob2ROYW1lXTtcbiAgICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcbiAgICAgIHJldHVybiAobXNnLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtlbHNlIHJhd01ldGhvZChtc2cpO1xuICAgICAgICBpZiAobmVlZExvZykge1xuICAgICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGxvZ1Iuc2V0TGV2ZWwobG9nUi5nZXRMZXZlbCgpKTtcbiAgfSk7XG59XG5jb25zdCB3b3JrZXJMb2dnZXIgPSBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsay1lMmVlJyk7Y29uc3QgbWF4UmV0cnlEZWxheSA9IDcwMDA7XG5jb25zdCBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyA9IFswLCAzMDAsIDIgKiAyICogMzAwLCAzICogMyAqIDMwMCwgNCAqIDQgKiAzMDAsIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXldO1xuY2xhc3MgRGVmYXVsdFJlY29ubmVjdFBvbGljeSB7XG4gIGNvbnN0cnVjdG9yKHJldHJ5RGVsYXlzKSB7XG4gICAgdGhpcy5fcmV0cnlEZWxheXMgPSByZXRyeURlbGF5cyAhPT0gdW5kZWZpbmVkID8gWy4uLnJldHJ5RGVsYXlzXSA6IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TO1xuICB9XG4gIG5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA+PSB0aGlzLl9yZXRyeURlbGF5cy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSB0aGlzLl9yZXRyeURlbGF5c1tjb250ZXh0LnJldHJ5Q291bnRdO1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPD0gMSkgcmV0dXJuIHJldHJ5RGVsYXk7XG4gICAgcmV0dXJuIHJldHJ5RGVsYXkgKyBNYXRoLnJhbmRvbSgpICogMTAwMDtcbiAgfVxufS8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07dmFyIGV2ZW50cyA9IHtleHBvcnRzOiB7fX07dmFyIGhhc1JlcXVpcmVkRXZlbnRzO1xuZnVuY3Rpb24gcmVxdWlyZUV2ZW50cygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRXZlbnRzKSByZXR1cm4gZXZlbnRzLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkRXZlbnRzID0gMTtcbiAgdmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbDtcbiAgdmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbicgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH07XG4gIHZhciBSZWZsZWN0T3duS2V5cztcbiAgaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xuICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICB9XG4gIHZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH07XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xuICB9XG4gIGV2ZW50cy5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuICBldmVudHMuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuICAvLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbiAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbiAgLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbiAgZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbiAgRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gICAgfVxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICAgIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgdmFyIGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgdmFyIG07XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgZXhpc3Rpbmc7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICAgIH1cbiAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgfTtcbiAgZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gICAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgZmlyZWQ6IGZhbHNlLFxuICAgICAgd3JhcEZuOiB1bmRlZmluZWQsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9O1xuICAgIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gICAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwb3NpdGlvbiA9IC0xO1xuICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IDApIHJldHVybiB0aGlzO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KCk7ZWxzZSB7XG4gICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcbiAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICAgIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG4gICAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICAgIH1cbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbiAgZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG4gIH07XG4gIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cbiAgZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gICAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgICBsaXN0LnBvcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzLmV4cG9ydHM7XG59dmFyIGV2ZW50c0V4cG9ydHMgPSByZXF1aXJlRXZlbnRzKCk7LypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxubGV0IGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5sZXQgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIGNvbnN0IG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlRmxvYXQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgIGNiLmhhbmRsZUV2ZW50KG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBicm93c2VyOiBudWxsLFxuICAgIHZlcnNpb246IG51bGxcbiAgfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvclxuICB9ID0gd2luZG93O1xuXG4gIC8vIFByZWZlciBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5cbiAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcykge1xuICAgIGNvbnN0IGNocm9taXVtID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzLmZpbmQoYnJhbmQgPT4ge1xuICAgICAgcmV0dXJuIGJyYW5kLmJyYW5kID09PSAnQ2hyb21pdW0nO1xuICAgIH0pO1xuICAgIGlmIChjaHJvbWl1bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogJ2Nocm9tZScsXG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50KGNocm9taXVtLnZlcnNpb24sIDEwKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBGaXJlZm94LlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gcGFyc2VJbnQoZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMikpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiYgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gICAgLy8gT25seSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgcmVzdWx0Ll9zYWZhcmlWZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL1ZlcnNpb25cXC8oXFxkKyhcXC4/XFxkKykpLywgMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBmYWxsdGhyb3VnaDogbm90IHN1cHBvcnRlZC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QkMSh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QkMShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0JDEoZGF0YVtrZXldKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtdWxhdG9yLCB7XG4gICAgICBba2V5XTogdmFsdWVcbiAgICB9KTtcbiAgfSwge30pO1xufVxuXG4vKiBpdGVyYXRlcyB0aGUgc3RhdHMgZ3JhcGggcmVjdXJzaXZlbHkuICovXG5mdW5jdGlvbiB3YWxrU3RhdHMoc3RhdHMsIGJhc2UsIHJlc3VsdFNldCkge1xuICBpZiAoIWJhc2UgfHwgcmVzdWx0U2V0LmhhcyhiYXNlLmlkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXN1bHRTZXQuc2V0KGJhc2UuaWQsIGJhc2UpO1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKCdJZCcpKSB7XG4gICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChiYXNlW25hbWVdKSwgcmVzdWx0U2V0KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkcycpKSB7XG4gICAgICBiYXNlW25hbWVdLmZvckVhY2goaWQgPT4ge1xuICAgICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChpZCksIHJlc3VsdFNldCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBmaWx0ZXIgZ2V0U3RhdHMgZm9yIGEgc2VuZGVyL3JlY2VpdmVyIHRyYWNrLiAqL1xuZnVuY3Rpb24gZmlsdGVyU3RhdHMocmVzdWx0LCB0cmFjaywgb3V0Ym91bmQpIHtcbiAgY29uc3Qgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XG4gIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xuICBpZiAodHJhY2sgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gIH1cbiAgY29uc3QgdHJhY2tTdGF0cyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiYgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xuICAgICAgdHJhY2tTdGF0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICB0cmFja1N0YXRzLmZvckVhY2godHJhY2tTdGF0ID0+IHtcbiAgICByZXN1bHQuZm9yRWFjaChzdGF0cyA9PiB7XG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xuICAgICAgICB3YWxrU3RhdHMocmVzdWx0LCBzdGF0cywgZmlsdGVyZWRSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xufS8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5jb25zdCBsb2dnaW5nID0gbG9nO1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gdHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7XG4gICAgICAgIGlkZWFsOiBjW2tleV1cbiAgICAgIH07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24gKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lID09PSAnZGV2aWNlSWQnID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbiAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcgPyBmYWNlIDoge1xuICAgICAgICBpZGVhbDogZmFjZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcbiAgICAgIGlmIChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykgJiYgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmICFnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcykpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2Zyb250J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBtYXRjaGVzIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gZm9yIGJhY2sgKHR5cGljYWwpLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgICAgICAgICAgbGV0IGRldiA9IGRldmljZXMuZmluZChkID0+IG1hdGNoZXMuc29tZShtYXRjaCA9PiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcbiAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXYpIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge1xuICAgICAgICAgICAgICAgIGV4YWN0OiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBpZGVhbDogZGV2LmRldmljZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGMgPT4ge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XG5cbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgLy8gY29uc3RyYWludHMuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn0vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuZnVuY3Rpb24gc2hpbU9uVHJhY2skMSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgIHRoaXMuX29udHJhY2twb2x5ID0gZSA9PiB7XG4gICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cbiAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRlID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2s6IHRlLnRyYWNrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcbiAgICAgICAgICAgICAgICB0cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJlY2VpdmVyOiBlLnJlY2VpdmVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdykge1xuICAvLyBPdmVycmlkZXMgYWRkVHJhY2svcmVtb3ZlVHJhY2ssIGRlcGVuZHMgb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2suXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbiAocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgIGxldCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcy5fc2VuZGVycy5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHNlbmRlclxuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUsICdkdG1mJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHRoaXMuX3BjLmNyZWF0ZURUTUZTZW5kZXIodGhpcy50cmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAvKiBOb3RlOiB0aGlzIHdpbGwgaW5jbHVkZSBzdGF0cyBvZiBhbGwgc2VuZGVycyB0aGF0XG4gICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgIH07XG4gICAgfVxuICAgIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+IGZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKSk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQgc2VuZGVyO1xuICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgbGV0IGVycjtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChyID0+IHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCBzZW5kZXIgJiYgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXG4gIC8vIHRoZSBpbnRlcmFjdGlvbnMgd2l0aCBsZWdhY3kgZ2V0TG9jYWxTdHJlYW1zIGJlaGF2ZSBhcyBpbiBvdGhlciBicm93c2Vycy5cbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VuZGVyO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjb25zdCBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGlmIChzZW5kZXIpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goc3RyZWFtSWQgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gbmF0aXZlU3RyZWFtcy5tYXAoc3RyZWFtID0+IHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGlkZW50aXR5IG1hcHBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggYWRkVHJhY2suXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKHN0cmVhbS5nZXRUcmFja3MoKSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW1dKTtcbiAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID8gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8ICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQodCA9PiB0ID09PSB0cmFjaykpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYnV0IGFsbCB3ZSBjYW4gbWFuYWdlIHdpdGhvdXRcbiAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICsgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJywgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgIC8vIHRoaXMgaXMgdXNpbmcgb2RkIENocm9tZSBiZWhhdmlvdXIsIHVzZSB3aXRoIGNhdXRpb246XG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VuZGVyIHdpdGggYSBkdG1mIHNlbmRlci5cbiAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgZXh0ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLCBpbnRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgIFttZXRob2RdKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYXJndW1lbnRzWzJdXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcbiAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSk7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXG4gICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgIGlmICghc2VuZGVyLl9wYykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICsgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcbiAgICB9XG4gICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIGxldCBzdHJlYW07XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XG4gICAgICBjb25zdCBoYXNUcmFjayA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpLmZpbmQodHJhY2sgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoaGFzVHJhY2spIHtcbiAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbSh0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayhzZW5kZXIudHJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xuICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCBwYy5nZXRDb25maWd1cmF0aW9uICYmIHBjLmdldENvbmZpZ3VyYXRpb24oKS5zZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufXZhciBjaHJvbWVTaGltPS8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxmaXhOZWdvdGlhdGlvbk5lZWRlZDpmaXhOZWdvdGlhdGlvbk5lZWRlZCxzaGltQWRkVHJhY2tSZW1vdmVUcmFjazpzaGltQWRkVHJhY2tSZW1vdmVUcmFjayxzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmU6c2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlLHNoaW1HZXRTZW5kZXJzV2l0aER0bWY6c2hpbUdldFNlbmRlcnNXaXRoRHRtZixzaGltR2V0VXNlck1lZGlhOnNoaW1HZXRVc2VyTWVkaWEkMixzaGltTWVkaWFTdHJlYW06c2hpbU1lZGlhU3RyZWFtLHNoaW1PblRyYWNrOnNoaW1PblRyYWNrJDEsc2hpbVBlZXJDb25uZWN0aW9uOnNoaW1QZWVyQ29ubmVjdGlvbiQxLHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzOnNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzfSk7LypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBkZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0vKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IERPTUV4Y2VwdGlvbignZ2V0RGlzcGxheU1lZGlhIHdpdGhvdXQgdmlkZW8gJyArICdjb25zdHJhaW50cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgIGVyci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xuICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXG4gICAgICBlcnIuY29kZSA9IDg7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgfTtcbn0vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjsgLy8gcHJvYmFibHkgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZD1mYWxzZSBpbiBhYm91dDpjb25maWdcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcbiAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxuICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICB9O1xuICBjb25zdCBuYXRpdmVHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBjb25zdCBbc2VsZWN0b3IsIG9uU3VjYywgb25FcnJdID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pLnRoZW4oc3RhdHMgPT4ge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgIC8vIFNoaW0gb25seSBwcm9taXNlIGdldFN0YXRzIHdpdGggc3BlYy1oeXBoZW5zIGluIHR5cGUgbmFtZXNcbiAgICAgICAgLy8gTGVhdmUgY2FsbGJhY2sgdmVyc2lvbiBhbG9uZTsgbWlzYyBvbGQgdXNlcyBvZiBmb3JFYWNoIGJlZm9yZSBNYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICAgICAgc3RhdC50eXBlID0gbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBdm9pZCBUeXBlRXJyb3I6IFwidHlwZVwiIGlzIHJlYWQtb25seSwgaW4gb2xkIHZlcnNpb25zLiAzNC00M2lzaFxuICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcbiAgICAgICAgICAgIHN0YXRzLnNldChpLCBPYmplY3QuYXNzaWduKHt9LCBzdGF0LCB7XG4gICAgICAgICAgICAgIHR5cGU6IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH0pLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOiBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgIH07XG4gIH1cbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG4gIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjayk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIGRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgIGlmIChzZW5kZXIudHJhY2sgJiYgc3RyZWFtLmdldFRyYWNrcygpLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcbiAgaWYgKG9yaWdBZGRUcmFuc2NlaXZlcikge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiBhZGRUcmFuc2NlaXZlcigpIHtcbiAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICAvLyBXZWJJREwgaW5wdXQgY29lcmNpb24gYW5kIHZhbGlkYXRpb25cbiAgICAgIGxldCBzZW5kRW5jb2RpbmdzID0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zZW5kRW5jb2RpbmdzO1xuICAgICAgaWYgKHNlbmRFbmNvZGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZW5kRW5jb2RpbmdzID0gW107XG4gICAgICB9XG4gICAgICBzZW5kRW5jb2RpbmdzID0gWy4uLnNlbmRFbmNvZGluZ3NdO1xuICAgICAgY29uc3Qgc2hvdWxkUGVyZm9ybUNoZWNrID0gc2VuZEVuY29kaW5ncy5sZW5ndGggPiAwO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBJZiBzZW5kRW5jb2RpbmdzIHBhcmFtcyBhcmUgcHJvdmlkZWQsIHZhbGlkYXRlIGdyYW1tYXJcbiAgICAgICAgc2VuZEVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nUGFyYW0gPT4ge1xuICAgICAgICAgIGlmICgncmlkJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBjb25zdCByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XG4gICAgICAgICAgICBpZiAoIXJpZFJlZ2V4LnRlc3QoZW5jb2RpbmdQYXJhbS5yaWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgUklEIHZhbHVlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3NjYWxlUmVzb2x1dGlvbkRvd25CeScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5IG11c3QgYmUgPj0gMS4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnbWF4RnJhbWVyYXRlJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0ubWF4RnJhbWVyYXRlKSA+PSAwKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VuZGVyXG4gICAgICAgIH0gPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSB8fFxuICAgICAgICAvLyBBdm9pZCBiZWluZyBmb29sZWQgYnkgcGF0Y2hlZCBnZXRQYXJhbWV0ZXJzKCkgYmVsb3cuXG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID09PSAxICYmIE9iamVjdC5rZXlzKHBhcmFtcy5lbmNvZGluZ3NbMF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHNlbmRlci5zZW5kRW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5wdXNoKHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1HZXRQYXJhbWV0ZXJzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UGFyYW1ldGVycyA9IHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnM7XG4gIGlmIChvcmlnR2V0UGFyYW1ldGVycykge1xuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gb3JpZ0dldFBhcmFtZXRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdLmNvbmNhdCh0aGlzLnNlbmRFbmNvZGluZ3MgfHwgW3t9XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufXZhciBmaXJlZm94U2hpbT0vKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsc2hpbUFkZFRyYW5zY2VpdmVyOnNoaW1BZGRUcmFuc2NlaXZlcixzaGltQ3JlYXRlQW5zd2VyOnNoaW1DcmVhdGVBbnN3ZXIsc2hpbUNyZWF0ZU9mZmVyOnNoaW1DcmVhdGVPZmZlcixzaGltR2V0RGlzcGxheU1lZGlhOnNoaW1HZXREaXNwbGF5TWVkaWEsc2hpbUdldFBhcmFtZXRlcnM6c2hpbUdldFBhcmFtZXRlcnMsc2hpbUdldFVzZXJNZWRpYTpzaGltR2V0VXNlck1lZGlhJDEsc2hpbU9uVHJhY2s6c2hpbU9uVHJhY2ssc2hpbVBlZXJDb25uZWN0aW9uOnNoaW1QZWVyQ29ubmVjdGlvbixzaGltUlRDRGF0YUNoYW5uZWw6c2hpbVJUQ0RhdGFDaGFubmVsLHNoaW1SZWNlaXZlckdldFN0YXRzOnNoaW1SZWNlaXZlckdldFN0YXRzLHNoaW1SZW1vdmVTdHJlYW06c2hpbVJlbW92ZVN0cmVhbSxzaGltU2VuZGVyR2V0U3RhdHM6c2hpbVNlbmRlckdldFN0YXRzfSk7LypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5mdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gZW11bGF0ZSBDaHJvbWUncyBiZWhhdmlvdXIgb2YgYWRkaW5nIGluIGF1ZGlvLXZpZGVvIG9yZGVyLlxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgc3RyZWFtKSk7XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc3RyZWFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICBzdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW3N0cmVhbV07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBjb25zdCBwYyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIGxldCB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSB3aXRoQ2FsbGJhY2s7XG59XG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcbiAgICBjb25zdCBtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgIGNvbnN0IF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGNvbnN0cmFpbnRzID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cbiAgaWYgKCFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cywge1xuICAgICAgdmlkZW86IGNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG1pZ3JhdGUgZnJvbSBub24tc3BlYyBSVENJY2VTZXJ2ZXIudXJsIHRvIFJUQ0ljZVNlcnZlci51cmxzXG4gIGNvbnN0IE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyLnVybHMgPT09IHVuZGVmaW5lZCAmJiBzZXJ2ZXIudXJsKSB7XG4gICAgICAgICAgZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgIHNlcnZlciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VydmVyKSk7XG4gICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChzZXJ2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICB9XG4gICAgICBjb25zdCBhdWRpb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmICFhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSB0cnVlICYmICF2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8IHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG59dmFyIHNhZmFyaVNoaW09LyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHNoaW1BdWRpb0NvbnRleHQ6c2hpbUF1ZGlvQ29udGV4dCxzaGltQ2FsbGJhY2tzQVBJOnNoaW1DYWxsYmFja3NBUEksc2hpbUNvbnN0cmFpbnRzOnNoaW1Db25zdHJhaW50cyxzaGltQ3JlYXRlT2ZmZXJMZWdhY3k6c2hpbUNyZWF0ZU9mZmVyTGVnYWN5LHNoaW1HZXRVc2VyTWVkaWE6c2hpbUdldFVzZXJNZWRpYSxzaGltTG9jYWxTdHJlYW1zQVBJOnNoaW1Mb2NhbFN0cmVhbXNBUEksc2hpbVJUQ0ljZVNlcnZlclVybHM6c2hpbVJUQ0ljZVNlcnZlclVybHMsc2hpbVJlbW90ZVN0cmVhbXNBUEk6c2hpbVJlbW90ZVN0cmVhbXNBUEksc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcjpzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyfSk7dmFyIHNkcCQxID0ge2V4cG9ydHM6IHt9fTsvKiBlc2xpbnQtZW52IG5vZGUgKi9cbnZhciBoYXNSZXF1aXJlZFNkcDtcbmZ1bmN0aW9uIHJlcXVpcmVTZHAoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFNkcCkgcmV0dXJuIHNkcCQxLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkU2RwID0gMTtcbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIC8vIFNEUCBoZWxwZXJzLlxuICAgIGNvbnN0IFNEUFV0aWxzID0ge307XG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbiAgICAvLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgIFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xuICAgIH07XG5cbiAgICAvLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cbiAgICBTRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbiAgICAvLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuICAgIFNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgfTtcbiAgICAvLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cbiAgICBTRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJyk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG4gICAgU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICAgICAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuICAgIFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICAgICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cbiAgICBTRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChibG9iLCBwcmVmaXgpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuICAgIC8vIHJwb3J0IDU1OTk2XCJcbiAgICAvLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cbiAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBsZXQgcGFydHM7XG4gICAgICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICAgICAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICAgICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSB7XG4gICAgICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgICAgICBjb21wb25lbnQ6IHtcbiAgICAgICAgICAxOiAncnRwJyxcbiAgICAgICAgICAyOiAncnRjcCdcbiAgICAgICAgfVtwYXJ0c1sxXV0gfHwgcGFydHNbMV0sXG4gICAgICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICAgICAgaXA6IHBhcnRzWzRdLFxuICAgICAgICBhZGRyZXNzOiBwYXJ0c1s0XSxcbiAgICAgICAgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICAgICAgdHlwZTogcGFydHNbN11cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnLiBEb24ndCBvdmVyd3JpdGUuXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9O1xuXG4gICAgLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cbiAgICAvLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcbiAgICBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IHNkcCA9IFtdO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgICAgIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XG4gICAgICAgIHNkcC5wdXNoKDEpO1xuICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgICAgICBzZHAucHVzaCgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcbiAgICAgIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgICAgIHNkcC5wdXNoKCd0eXAnKTtcbiAgICAgIHNkcC5wdXNoKHR5cGUpO1xuICAgICAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiYgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICAgICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgICAgICBzZHAucHVzaCgndWZyYWcnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbiAgICAvLyBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG4gICAgU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcbiAgICBTRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgICAgIH07XG4gICAgICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG4gICAgICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICAgICAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gICAgICBwYXJzZWQuY2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcbiAgICAgIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICAgICAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3JcbiAgICAvLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgICAgIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAvLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICBTRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgICAgIHVyaTogcGFydHNbMV0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIGFuIGV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuICAgIC8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cbiAgICBTRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uIChoZWFkZXJFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uIDogJycpICsgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1mbXRwOjk2IHZicj1vbjtjbmc9b25cbiAgICAvLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cbiAgICBTRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFyc2VkID0ge307XG4gICAgICBsZXQga3Y7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICBTRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBsZXQgbGluZXMgPSAnJztcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgICAgIGxpbmVzICs9ICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnICsgZmIudHlwZSArIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArICdcXHJcXG4nO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcbiAgICBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICAgICAgY29uc3QgcGFydHMgPSB7XG4gICAgICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApXG4gICAgICB9O1xuICAgICAgY29uc3QgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gICAgICBpZiAoY29sb24gPiAtMSkge1xuICAgICAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEsIGNvbG9uKTtcbiAgICAgICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgYSBzc3JjLWdyb3VwIGxpbmUgKHNlZSBSRkMgNTU3NikuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG4gICAgU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICAgICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbiAgICAvLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cbiAgICBTRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgICAgIGlmIChtaWQpIHtcbiAgICAgICAgcmV0dXJuIG1pZC5zdWJzdHJpbmcoNik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGZpbmdlcnByaW50IGxpbmUgZm9yIERUTFMtU1JUUC5cbiAgICBTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgICAgICB2YWx1ZTogcGFydHNbMV0udG9VcHBlckNhc2UoKSAvLyB0aGUgZGVmaW5pdGlvbiBpcyB1cHBlci1jYXNlIGluIFJGQyA0NTcyLlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gICAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4gICAgLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gICAgICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnYXV0bycsXG4gICAgICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gICAgU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMsIHNldHVwVHlwZSkge1xuICAgICAgbGV0IHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgICAgIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cbiAgICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuICAgIFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcbiAgICAgICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICAgICAgc2Vzc2lvblBhcmFtczogcGFydHMuc2xpY2UoMylcbiAgICAgIH07XG4gICAgfTtcbiAgICBTRFBVdGlscy53cml0ZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgKyBwYXJhbWV0ZXJzLmNyeXB0b1N1aXRlICsgJyAnICsgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCcgPyBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyhwYXJhbWV0ZXJzLmtleVBhcmFtcykgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgKyAocGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zID8gJyAnICsgcGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zLmpvaW4oJyAnKSA6ICcnKSArICdcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXG4gICAgLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcbiAgICBTRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICAgIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyaW5nKDcpLnNwbGl0KCd8Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgICAgICBrZXlTYWx0OiBwYXJ0c1swXSxcbiAgICAgICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgICAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgICAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xuICAgICAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOicgKyBrZXlQYXJhbXMua2V5U2FsdCArIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgKyAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGggPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoIDogJycpO1xuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLmdldENyeXB0b1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9Y3J5cHRvOicpO1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gICAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4gICAgLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cbiAgICBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAgIGNvbnN0IHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS11ZnJhZzonKVswXTtcbiAgICAgIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtcHdkOicpWzBdO1xuICAgICAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgICAgIHBhc3N3b3JkOiBwd2Quc3Vic3RyaW5nKDEwKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG4gICAgU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xuICAgICAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICAgICAgcnRjcDogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICAgIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgICAgICBjb25zdCBwdCA9IG1saW5lW2ldO1xuICAgICAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICAgICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKS5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICB3aWxkY2FyZFJ0Y3BGYi5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgICBjb25zdCBkdXBsaWNhdGUgPSBjb2RlYy5ydGNwRmVlZGJhY2suZmluZChleGlzdGluZ0ZlZWRiYWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiYgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4gICAgLy8gcGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGtpbmQsIGNhcHMpIHtcbiAgICAgIGxldCBzZHAgPSAnJztcblxuICAgICAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICAgICAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICAgICAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gICAgICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgICAgIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcbiAgICAgIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gICAgICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAgICAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gICAgICB9KTtcbiAgICAgIGxldCBtYXhwdGltZSA9IDA7XG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICAgICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuICAgIC8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICAgICAgY29uc3QgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgICAgIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgICAgIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgICAgIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICAgICAgbGV0IHNlY29uZGFyeVNzcmM7XG4gICAgICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKS5tYXAobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgICAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICAgICAgZW5jUGFyYW0ucnR4ID0ge1xuICAgICAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICAgICAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gICAgICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgICAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NSAtIDUwICogNDAgKiA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgfTtcblxuICAgIC8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuICAgIFNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gICAgICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgICAgIC8vIFNTUkNzLlxuICAgICAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgICAgIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICAgICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgICAgIH1cblxuICAgICAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAgICAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gICAgICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICAgICAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICAgICAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgICAgIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgICAgIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICAgICAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICAgICAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG4gICAgICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG4gICAgfTtcbiAgICBTRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gICAgICBsZXQgc2RwID0gJyc7XG4gICAgICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgICAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4gICAgLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cbiAgICBTRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBsZXQgcGFydHM7XG4gICAgICBjb25zdCBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICAgICAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgICAgIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTQ1RQXG4gICAgLy8gcGFyc2VzIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IGZpcnN0IGFuZCBmYWxscyBiYWNrXG4gICAgLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcbiAgICBTRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1saW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgICBpZiAobWF4U2l6ZUxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihtYXhNZXNzYWdlU2l6ZSkpIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gICAgICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cmluZygxMiksIDEwKSxcbiAgICAgICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gICAgICBpZiAoc2N0cE1hcExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF0uc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNDVFBcbiAgICAvLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4gICAgLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbiAgICAvLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxuICAgIC8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcbiAgICBTRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYSwgc2N0cCkge1xuICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbiddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ107XG4gICAgICB9XG4gICAgICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4gICAgLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4gICAgLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG4gICAgU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG4gICAgfTtcblxuICAgIC8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4gICAgLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbiAgICAvLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbiAgICAvLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuICAgIC8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG4gICAgU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbiAoc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgICAgIGlmIChzZXNzSWQpIHtcbiAgICAgICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAgICAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gICAgICByZXR1cm4gJ3Y9MFxcclxcbicgKyAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gKyAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICsgJ3M9LVxcclxcbicgKyAndD0wIDBcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cbiAgICBTRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXNzaW9ucGFydCkge1xuICAgICAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnc2VuZHJlY3YnO1xuICAgIH07XG4gICAgU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cmluZygyKTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbiAgICB9O1xuICAgIFNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBwYXJ0c1swXSxcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgICAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKVxuICAgICAgfTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICAgICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICAgICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgICAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgICAgIGFkZHJlc3M6IHBhcnRzWzVdXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXG4gICAgU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuICAgIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4gICAgfVxuICB9KShzZHAkMSk7XG4gIHJldHVybiBzZHAkMS5leHBvcnRzO1xufXZhciBzZHBFeHBvcnRzID0gcmVxdWlyZVNkcCgpO1xudmFyIFNEUFV0aWxzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNkcEV4cG9ydHMpO3ZhciBzZHA9LyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6U0RQVXRpbHN9LFtzZHBFeHBvcnRzXSk7LypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2FuZGlkYXRlLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuYXRpdmVDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUuY2FuZGlkYXRlKTtcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHJlbGF5UHJvdG9jb2wuXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XG4gICAgICAgICAgMDogJ3RscycsXG4gICAgICAgICAgMTogJ3RjcCcsXG4gICAgICAgICAgMjogJ3VkcCdcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNkcFNlbWFudGljc1xuICAgICAgfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICBjb25zdCBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgfVxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gIH07XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMuX3NhZmFyaVZlcnNpb24gPj0gMTMuMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgICByZXR1cm4gbGluZS50cmltKCkgIT09ICdhPWV4dG1hcC1hbGxvdy1taXhlZCc7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgIC8vIFNhZmFyaSBlbmZvcmNlcyByZWFkLW9ubHktbmVzcyBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24gZmllbGRzLlxuICAgICAgaWYgKHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gJiYgZGVzYyBpbnN0YW5jZW9mIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgICAgICBzZHBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNjLnNkcCA9IHNkcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVNSRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLy8gU3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAvLyBhcyB3ZWxsIGFzIGFkZEljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOiBcIlwiLCAuLi59KVxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05Nzg1ODJcbiAgLy8gTm90ZTogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIHBvbHlmaWxscyB3aGljaCBjaGFuZ2UgdGhlIHNpZ25hdHVyZS5cbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBpZiAoIW5hdGl2ZUFkZEljZUNhbmRpZGF0ZSB8fCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcbiAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAvLyBOYXRpdmUgc3VwcG9ydCBmb3IgaWdub3JpbmcgZXhpc3RzIGZvciBDaHJvbWUgTTc3Ky5cbiAgICAvLyBTYWZhcmkgaWdub3JlcyBhcyB3ZWxsLCBleGFjdCB2ZXJzaW9uIHVua25vd24gYnV0IHdvcmtzIGluIHRoZSBzYW1lXG4gICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXG4gICAgaWYgKChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OCB8fCBicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJykgJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gTm90ZTogTWFrZSBzdXJlIHRvIGNhbGwgdGhpcyBhaGVhZCBvZiBBUElzIHRoYXQgbW9kaWZ5XG4vLyBzZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aFxuZnVuY3Rpb24gc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGxldCBkZXNjID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgZGVzYy50eXBlICYmIGRlc2Muc2RwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIHN0ZXBzIHNob3VsZCB0ZWNobmljYWxseSBoYXBwZW4gd2hlbiBTTEQgY29tZXMgb2ZmIHRoZVxuICAgIC8vIFJUQ1BlZXJDb25uZWN0aW9uJ3Mgb3BlcmF0aW9ucyBjaGFpbiAobm90IGFoZWFkIG9mIGdvaW5nIG9uIGl0KSwgYnV0XG4gICAgLy8gdGhpcyBpcyB0b28gZGlmZmljdWx0IHRvIHNoaW0uIEluc3RlYWQsIHRoaXMgc2hpbSBvbmx5IGNvdmVycyB0aGVcbiAgICAvLyBjb21tb24gY2FzZSB3aGVyZSB0aGUgb3BlcmF0aW9ucyBjaGFpbiBpcyBlbXB0eS4gVGhpcyBpcyBpbXBlcmZlY3QsIGJ1dFxuICAgIC8vIHNob3VsZCBjb3ZlciBtYW55IGNhc2VzLiBSYXRpb25hbGU6IEV2ZW4gaWYgd2UgY2FuJ3QgcmVkdWNlIHRoZSBnbGFyZVxuICAgIC8vIHdpbmRvdyB0byB6ZXJvIG9uIGltcGVyZmVjdCBpbXBsZW1lbnRhdGlvbnMsIHRoZXJlJ3MgdmFsdWUgaW4gdGFwcGluZ1xuICAgIC8vIGludG8gdGhlIHBlcmZlY3QgbmVnb3RpYXRpb24gcGF0dGVybiB0aGF0IHNldmVyYWwgYnJvd3NlcnMgc3VwcG9ydC5cbiAgICBkZXNjID0ge1xuICAgICAgdHlwZTogZGVzYy50eXBlLFxuICAgICAgc2RwOiBkZXNjLnNkcFxuICAgIH07XG4gICAgaWYgKCFkZXNjLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICBjYXNlICdzdGFibGUnOlxuICAgICAgICBjYXNlICdoYXZlLWxvY2FsLW9mZmVyJzpcbiAgICAgICAgY2FzZSAnaGF2ZS1yZW1vdGUtcHJhbnN3ZXInOlxuICAgICAgICAgIGRlc2MudHlwZSA9ICdvZmZlcic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVzYy50eXBlID0gJ2Fuc3dlcic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZXNjLnNkcCB8fCBkZXNjLnR5cGUgIT09ICdvZmZlcicgJiYgZGVzYy50eXBlICE9PSAnYW5zd2VyJykge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NdKTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IGRlc2MudHlwZSA9PT0gJ29mZmVyJyA/IHRoaXMuY3JlYXRlT2ZmZXIgOiB0aGlzLmNyZWF0ZUFuc3dlcjtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzKS50aGVuKGQgPT4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZF0pKTtcbiAgfTtcbn12YXIgY29tbW9uU2hpbT0vKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwscmVtb3ZlRXh0bWFwQWxsb3dNaXhlZDpyZW1vdmVFeHRtYXBBbGxvd01peGVkLHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eTpzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHksc2hpbUNvbm5lY3Rpb25TdGF0ZTpzaGltQ29ubmVjdGlvblN0YXRlLHNoaW1NYXhNZXNzYWdlU2l6ZTpzaGltTWF4TWVzc2FnZVNpemUsc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uOnNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbixzaGltUlRDSWNlQ2FuZGlkYXRlOnNoaW1SVENJY2VDYW5kaWRhdGUsc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2w6c2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wsc2hpbVNlbmRUaHJvd1R5cGVFcnJvcjpzaGltU2VuZFRocm93VHlwZUVycm9yfSk7LypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5cbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxuZnVuY3Rpb24gYWRhcHRlckZhY3RvcnkoKSB7XG4gIGxldCB7XG4gICAgd2luZG93XG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgIHNoaW1DaHJvbWU6IHRydWUsXG4gICAgc2hpbUZpcmVmb3g6IHRydWUsXG4gICAgc2hpbVNhZmFyaTogdHJ1ZVxuICB9O1xuICAvLyBVdGlscy5cbiAgY29uc3QgbG9nZ2luZyA9IGxvZztcbiAgY29uc3QgYnJvd3NlckRldGFpbHMgPSBkZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIGNvbnN0IGFkYXB0ZXIgPSB7XG4gICAgYnJvd3NlckRldGFpbHMsXG4gICAgY29tbW9uU2hpbSxcbiAgICBleHRyYWN0VmVyc2lvbjogZXh0cmFjdFZlcnNpb24sXG4gICAgZGlzYWJsZUxvZzogZGlzYWJsZUxvZyxcbiAgICBkaXNhYmxlV2FybmluZ3M6IGRpc2FibGVXYXJuaW5ncyxcbiAgICAvLyBFeHBvc2Ugc2RwIGFzIGEgY29udmVuaWVuY2UuIEZvciBwcm9kdWN0aW9uIGFwcHMgaW5jbHVkZSBkaXJlY3RseS5cbiAgICBzZHBcbiAgfTtcblxuICAvLyBTaGltIGJyb3dzZXIgaWYgZm91bmQuXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiQxIHx8ICFvcHRpb25zLnNoaW1DaHJvbWUpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGNhbiBub3QgZGV0ZXJtaW5lIHZlcnNpb24sIG5vdCBzaGltbWluZy4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbU1lZGlhU3RyZWFtKHdpbmRvdyk7XG4gICAgICBzaGltUGVlckNvbm5lY3Rpb24kMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1PblRyYWNrJDEod2luZG93KTtcbiAgICAgIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpO1xuICAgICAgc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1PblRyYWNrKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KTtcbiAgICAgIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFBhcmFtZXRlcnMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpO1xuICAgICAgc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIHNoaW1BdWRpb0NvbnRleHQod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn0vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5hZGFwdGVyRmFjdG9yeSh7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3dcbn0pOy8vIHRpbnksIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbGFuY2VkaWtzb24vYm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9wYXJzZXItYnJvd3NlcnMuanNcbi8vIHJlZHVjZWQgdG8gb25seSBkaWZmZXJlbnRpYXRlIENocm9tZShpdW0pIGJhc2VkIGJyb3dzZXJzIC8gRmlyZWZveCAvIFNhZmFyaVxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcbmxldCBicm93c2VyRGV0YWlscztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50KSB7XG4gIGxldCBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCAhPT0gbnVsbCAmJiB1c2VyQWdlbnQgIT09IHZvaWQgMCA/IHVzZXJBZ2VudCA6IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChicm93c2VyRGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdGVzdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gdGVzdC50ZXN0KHVhKTtcbiAgICB9KTtcbiAgICBicm93c2VyRGV0YWlscyA9IGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5kZXNjcmliZSh1YSk7XG4gIH1cbiAgcmV0dXJuIGJyb3dzZXJEZXRhaWxzO1xufVxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW3tcbiAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSlcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCB7XG4gIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmNocm9tZXxjaHJvbWl1bXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NyaW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZCxcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn0sIC8qIFNhZmFyaSAqL1xue1xuICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnLFxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufV07XG5mdW5jdGlvbiBnZXRNYXRjaChleHAsIHVhKSB7XG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IGlkICYmIG1hdGNoW2lkXSB8fCAnJztcbn1cbmZ1bmN0aW9uIGdldE9TVmVyc2lvbih1YSkge1xuICByZXR1cm4gdWEuaW5jbHVkZXMoJ21hYyBvcycpID8gZ2V0TWF0Y2goL1xcKC4rPyhcXGQrX1xcZCsoOj9fXFxkKyk/KS8sIHVhLCAxKS5yZXBsYWNlKC9fL2csICcuJykgOiB1bmRlZmluZWQ7XG59dmFyIHZlcnNpb24kMSA9IFwiMi4xNi4xXCI7Y29uc3QgdmVyc2lvbiA9IHZlcnNpb24kMTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbiA9IDE2O2NsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgdGhpcy5uYW1lID0gJ0xpdmVLaXRFcnJvcic7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgU2ltdWxhdGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ1NpbXVsYXRlZCBmYWlsdXJlJztcbiAgICBzdXBlcigtMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ3NpbXVsYXRlZCc7XG4gIH1cbn1cbnZhciBDb25uZWN0aW9uRXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25FcnJvclJlYXNvbikge1xuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiTm90QWxsb3dlZFwiXSA9IDBdID0gXCJOb3RBbGxvd2VkXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJTZXJ2ZXJVbnJlYWNoYWJsZVwiXSA9IDFdID0gXCJTZXJ2ZXJVbnJlYWNoYWJsZVwiO1xuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiSW50ZXJuYWxFcnJvclwiXSA9IDJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJDYW5jZWxsZWRcIl0gPSAzXSA9IFwiQ2FuY2VsbGVkXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJMZWF2ZVJlcXVlc3RcIl0gPSA0XSA9IFwiTGVhdmVSZXF1ZXN0XCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJUaW1lb3V0XCJdID0gNV0gPSBcIlRpbWVvdXRcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIldlYlNvY2tldFwiXSA9IDZdID0gXCJXZWJTb2NrZXRcIjtcbn0pKENvbm5lY3Rpb25FcnJvclJlYXNvbiB8fCAoQ29ubmVjdGlvbkVycm9yUmVhc29uID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbiwgc3RhdHVzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0Nvbm5lY3Rpb25FcnJvcic7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSBDb25uZWN0aW9uRXJyb3JSZWFzb25bcmVhc29uXTtcbiAgfVxuICBzdGF0aWMgbm90QWxsb3dlZChtZXNzYWdlLCBzdGF0dXMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25FcnJvcihtZXNzYWdlLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCwgc3RhdHVzLCBjb250ZXh0KTtcbiAgfVxuICBzdGF0aWMgdGltZW91dChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uRXJyb3IobWVzc2FnZSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLlRpbWVvdXQpO1xuICB9XG4gIHN0YXRpYyBsZWF2ZVJlcXVlc3QobWVzc2FnZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbkVycm9yKG1lc3NhZ2UsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QsIHVuZGVmaW5lZCwgY29udGV4dCk7XG4gIH1cbiAgc3RhdGljIGludGVybmFsKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25FcnJvcihtZXNzYWdlLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciwgdW5kZWZpbmVkLCBjb250ZXh0KTtcbiAgfVxuICBzdGF0aWMgY2FuY2VsbGVkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25FcnJvcihtZXNzYWdlLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKTtcbiAgfVxuICBzdGF0aWMgc2VydmVyVW5yZWFjaGFibGUobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uRXJyb3IobWVzc2FnZSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlLCBzdGF0dXMpO1xuICB9XG4gIHN0YXRpYyB3ZWJzb2NrZXQobWVzc2FnZSwgc3RhdHVzLCByZWFzb24pIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25FcnJvcihtZXNzYWdlLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uV2ViU29ja2V0LCBzdGF0dXMsIHJlYXNvbik7XG4gIH1cbn1cbmNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgICB0aGlzLm5hbWUgPSAnRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcic7XG4gIH1cbn1cbmNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDIwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndHJhY2sgaXMgaW52YWxpZCcpO1xuICAgIHRoaXMubmFtZSA9ICdUcmFja0ludmFsaWRFcnJvcic7XG4gIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XG4gICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkU2VydmVyJztcbiAgfVxufVxuY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMiwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xuICAgIHRoaXMubmFtZSA9ICdVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlJztcbiAgfVxufVxuY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgICB0aGlzLm5hbWUgPSAnTmVnb3RpYXRpb25FcnJvcic7XG4gIH1cbn1cbmNsYXNzIFB1Ymxpc2hEYXRhRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTQsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmFibGUgdG8gcHVibGlzaCBkYXRhJyk7XG4gICAgdGhpcy5uYW1lID0gJ1B1Ymxpc2hEYXRhRXJyb3InO1xuICB9XG59XG5jbGFzcyBQdWJsaXNoVHJhY2tFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnUHVibGlzaFRyYWNrRXJyb3InO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB9XG59XG5jbGFzcyBTaWduYWxSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24pIHtcbiAgICBzdXBlcigxNSwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NpZ25hbFJlcXVlc3RFcnJvcic7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5yZWFzb25OYW1lID0gdHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycgPyByZWFzb24gOiBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uW3JlYXNvbl07XG4gIH1cbn1cbi8vIE5PVEU6IG1hdGNoZXMgd2l0aCBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC9jbGllbnQtc2RrLXN3aWZ0L2Jsb2IvZjM3YmJkMjYwZDYxZTE2NTA4NDk2MmRiODIyYzc5Zjk5NWYxYTExMy9Tb3VyY2VzL0xpdmVLaXQvRGF0YVN0cmVhbS9TdHJlYW1FcnJvci5zd2lmdCNMMTdcbnZhciBEYXRhU3RyZWFtRXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKERhdGFTdHJlYW1FcnJvclJlYXNvbikge1xuICAvLyBVbmFibGUgdG8gb3BlbiBhIHN0cmVhbSB3aXRoIHRoZSBzYW1lIElEIG1vcmUgdGhhbiBvbmNlLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiQWxyZWFkeU9wZW5lZFwiXSA9IDBdID0gXCJBbHJlYWR5T3BlbmVkXCI7XG4gIC8vIFN0cmVhbSBjbG9zZWQgYWJub3JtYWxseSBieSByZW1vdGUgcGFydGljaXBhbnQuXG4gIERhdGFTdHJlYW1FcnJvclJlYXNvbltEYXRhU3RyZWFtRXJyb3JSZWFzb25bXCJBYm5vcm1hbEVuZFwiXSA9IDFdID0gXCJBYm5vcm1hbEVuZFwiO1xuICAvLyBJbmNvbWluZyBjaHVuayBkYXRhIGNvdWxkIG5vdCBiZSBkZWNvZGVkLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiRGVjb2RlRmFpbGVkXCJdID0gMl0gPSBcIkRlY29kZUZhaWxlZFwiO1xuICAvLyBSZWFkIGxlbmd0aCBleGNlZWRlZCB0b3RhbCBsZW5ndGggc3BlY2lmaWVkIGluIHN0cmVhbSBoZWFkZXIuXG4gIERhdGFTdHJlYW1FcnJvclJlYXNvbltEYXRhU3RyZWFtRXJyb3JSZWFzb25bXCJMZW5ndGhFeGNlZWRlZFwiXSA9IDNdID0gXCJMZW5ndGhFeGNlZWRlZFwiO1xuICAvLyBSZWFkIGxlbmd0aCBsZXNzIHRoYW4gdG90YWwgbGVuZ3RoIHNwZWNpZmllZCBpbiBzdHJlYW0gaGVhZGVyLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiSW5jb21wbGV0ZVwiXSA9IDRdID0gXCJJbmNvbXBsZXRlXCI7XG4gIC8vIFVuYWJsZSB0byByZWdpc3RlciBhIHN0cmVhbSBoYW5kbGVyIG1vcmUgdGhhbiBvbmNlLlxuICBEYXRhU3RyZWFtRXJyb3JSZWFzb25bRGF0YVN0cmVhbUVycm9yUmVhc29uW1wiSGFuZGxlckFscmVhZHlSZWdpc3RlcmVkXCJdID0gN10gPSBcIkhhbmRsZXJBbHJlYWR5UmVnaXN0ZXJlZFwiO1xuICAvLyBFbmNyeXB0aW9uIHR5cGUgbWlzbWF0Y2guXG4gIERhdGFTdHJlYW1FcnJvclJlYXNvbltEYXRhU3RyZWFtRXJyb3JSZWFzb25bXCJFbmNyeXB0aW9uVHlwZU1pc21hdGNoXCJdID0gOF0gPSBcIkVuY3J5cHRpb25UeXBlTWlzbWF0Y2hcIjtcbn0pKERhdGFTdHJlYW1FcnJvclJlYXNvbiB8fCAoRGF0YVN0cmVhbUVycm9yUmVhc29uID0ge30pKTtcbmNsYXNzIERhdGFTdHJlYW1FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbikge1xuICAgIHN1cGVyKDE2LCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnRGF0YVN0cmVhbUVycm9yJztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSBEYXRhU3RyZWFtRXJyb3JSZWFzb25bcmVhc29uXTtcbiAgfVxufVxuY2xhc3MgU2lnbmFsUmVjb25uZWN0RXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTgsIG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTaWduYWxSZWNvbm5lY3RFcnJvcic7XG4gIH1cbn1cbnZhciBNZWRpYURldmljZUZhaWx1cmU7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIlBlcm1pc3Npb25EZW5pZWRcIl0gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiTm90Rm91bmRcIl0gPSBcIk5vdEZvdW5kXCI7XG4gIC8vIGRldmljZSBpcyBpbiB1c2UuIE9uIFdpbmRvd3MsIG9ubHkgYSBzaW5nbGUgdGFiIG1heSBnZXQgYWNjZXNzIHRvIGEgZGV2aWNlIGF0IGEgdGltZS5cbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiRGV2aWNlSW5Vc2VcIl0gPSBcIkRldmljZUluVXNlXCI7XG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk90aGVyXCJdID0gXCJPdGhlclwiO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcbiAgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG4gIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlID0gZ2V0RmFpbHVyZTtcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSB8fCAoTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTsvKipcbiAqIFRpbWVycyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zXG4gKiB0aGF0IGVuc3VyZSB0aGF0IHRoZXkgYXJlIGZpcmVkLiBUaGVzZSBzaG91bGQgYmUgdXNlZCB3aGVuIGl0IGlzIGNyaXRpY2FsXG4gKiB0aGF0IHRoZSB0aW1lciBmaXJlcyBvbiB0aW1lLlxuICovXG5jbGFzcyBDcml0aWNhbFRpbWVycyB7fVxuQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0SW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoLi4uYXJndW1lbnRzKTtcbn07XG5Dcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2xlYXJJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xufTsvKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogV2hlbiB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZC4gVGhpcyBpc24ndCBub3RpY2VhYmxlIHRvIHVzZXJzIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqIEl0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYFJvb21FdmVudC5SZWNvbm5lY3RlZGAgb25jZSB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWQuXG4gICAqIElmIG1lZGlhIGZhaWxzIGFkZGl0aW9uYWxseSBpdCBhbiBhZGRpdGlvbmFsIGBSb29tRXZlbnQuUmVjb25uZWN0aW5nYCB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWQuXG4gICAqXG4gICAqIERpc2Nvbm5lY3RSZWFzb24gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoeSB0aGUgcGFydGljaXBhbnQgd2FzIGRpc2Nvbm5lY3RlZC4gTm90YWJsZSByZWFzb25zIGFyZVxuICAgKiAtIERVUExJQ0FURV9JREVOVElUWTogYW5vdGhlciBjbGllbnQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eSBoYXMgam9pbmVkIHRoZSByb29tXG4gICAqIC0gUEFSVElDSVBBTlRfUkVNT1ZFRDogcGFydGljaXBhbnQgd2FzIHJlbW92ZWQgYnkgUmVtb3ZlUGFydGljaXBhbnQgQVBJXG4gICAqIC0gUk9PTV9ERUxFVEVEOiB0aGUgcm9vbSBoYXMgZW5kZWQgdmlhIERlbGV0ZVJvb20gQVBJXG4gICAqXG4gICAqIGFyZ3M6IChbW0Rpc2Nvbm5lY3RSZWFzb25dXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiBwYXJ0aWNpcGFudCBoYXMgYmVlbiBtb3ZlZCB0byBhIGRpZmZlcmVudCByb29tIGJ5IHRoZSBzZXJ2aWNlIHJlcXVlc3QuXG4gICAqIFRoZSBiZWhhdmlvciBsb29rcyBsaWtlIHRoZSBwYXJ0aWNpcGFudCBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgYW5kIHJlY29ubmVjdGVkIHRvIGEgZGlmZmVyZW50IHJvb21cbiAgICogc2VhbWxlc3NseSB3aXRob3V0IGNvbm5lY3Rpb24gc3RhdGUgdHJhbnNpdGlvbi5cbiAgICogQSBuZXcgdG9rZW4gd2lsbCBiZSBwcm92aWRlZCBmb3IgcmVjb25uZWN0aW5nIHRvIHRoZSBuZXcgcm9vbSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIGFyZ3M6IChbW3Jvb206IHN0cmluZywgdG9rZW46IHN0cmluZ11dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTW92ZWRcIl0gPSBcIm1vdmVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcm9vbVxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cbiAgICogVGhpcyBhbGxvd3MgZm9yIGFwcGxpY2F0aW9ucyB0byBzaG93IFVJIGluZm9ybWluZyB1c2VycyB0aGF0IHRoZXkgbWlnaHQgaGF2ZSB0b1xuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKlxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cbiAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgKlxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gYSBwYXJ0aWNpcGFudCdzIGF0dHJpYnV0ZXMgY2hhbmdlZCwgdGhpcyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzIGFuZCB0aGUgcGFydGljaXBhbnRcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBwYXJ0aWNpcGFudCdzIHN0YXRlIGNoYW5nZXMgdG8gQUNUSVZFIGFuZCBpcyByZWFkeSB0byBzZW5kL3JlY2VpdmUgZGF0YSBtZXNzYWdlc1xuICAgKlxuICAgKiBhcmdzOiAocGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50QWN0aXZlXCJdID0gXCJwYXJ0aWNpcGFudEFjdGl2ZVwiO1xuICAvKipcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUm9vbU1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicm9vbU1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0sIHRvcGljPzogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIFNJUCBEVE1GIHRvbmVzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIGEgcGFydGljaXBhbnQncyB0cmFjay5cbiAgICogQGJldGFcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgKlxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIChyZW1vdGUpIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgc3RhdHVzIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIGF1ZGlvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhdWRpbyBlbGVtZW50cy4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIGBSb29tLmNhblBsYXliYWNrQXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgdmlkZW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGEgdmlkZW8gZWxlbWVudC4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIENhbGxpbmcgYHJvb20uc3RhcnRWaWRlbygpYCBpbiBhIHVzZXIgZ2VzdHVyZSBldmVudCBoYW5kbGVyIHdpbGwgcmVzdW1lIHRoZSB2aWRlbyBwbGF5YmFjay5cbiAgICovXG4gIFJvb21FdmVudFtcIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJ2aWRlb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiB3ZSBoYXZlIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgdHJhY2suXG4gICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cbiAgICogVXNlIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlKGVycm9yKSB0byBnZXQgdGhlIHJlYXNvbiBvZiBmYWlsdXJlLlxuICAgKiBbW0xvY2FsUGFydGljaXBhbnQubGFzdENhbWVyYUVycm9yXV0gYW5kIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0TWljcm9waG9uZUVycm9yXV1cbiAgICogd2lsbCBpbmRpY2F0ZSBpZiBpdCBoYWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogYXJnczogKGVycm9yOiBFcnJvcilcbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFNpZ25hbCBjb25uZWN0ZWQsIGNhbiBwdWJsaXNoIHRyYWNrcy5cbiAgICovXG4gIFJvb21FdmVudFtcIlNpZ25hbENvbm5lY3RlZFwiXSA9IFwic2lnbmFsQ29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBSZWNvcmRpbmcgb2YgYSByb29tIGhhcyBzdGFydGVkL3N0b3BwZWQuIFJvb20uaXNSZWNvcmRpbmcgd2lsbCBiZSB1cGRhdGVkIHRvby5cbiAgICogYXJnczogKGlzUmVjb3JkaW5nOiBib29sZWFuKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiXSA9IFwicmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiO1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgY3VycmVudCBidWZmZXIgc3RhdHVzIG9mIGEgZGF0YSBjaGFubmVsIGNoYW5nZXNcbiAgICogYXJnczogKGlzTG93OiBib29sZWFuLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBieSBhIGNhbGwgdG8gcm9vbS5zd2l0Y2hBY3RpdmVEZXZpY2VcbiAgICogYXJnczogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZylcbiAgICovXG4gIFJvb21FdmVudFtcIkFjdGl2ZURldmljZUNoYW5nZWRcIl0gPSBcImFjdGl2ZURldmljZUNoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiQ2hhdE1lc3NhZ2VcIl0gPSBcImNoYXRNZXNzYWdlXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIGxvY2FsUGFydGljaXBhbnQncyB0cmFja1xuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZXRyaWNzUmVjZWl2ZWRcIl0gPSBcIm1ldHJpY3NSZWNlaXZlZFwiO1xufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIGhhcyBiZWVuIGNvbnN0cmFpbmVkIGJ5IGNwdS5cbiAgICogVGhpcyBldmVudCBpcyB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIHJlZHVjZSB0aGUgY2FwdHVyZSByZXNvbHV0aW9uIG9mIHRoZSB0cmFjay5cbiAgICpcbiAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxWaWRlb1RyYWNrXV0sIFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja0NwdUNvbnN0cmFpbmVkXCJdID0gXCJsb2NhbFRyYWNrQ3B1Q29uc3RyYWluZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsU2VuZGVyQ3JlYXRlZFwiXSA9IFwibG9jYWxTZW5kZXJDcmVhdGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKlxuICAgKiBhcmdzOiAoZHRtZjogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgZGF0YSBzb3VyY2UuXG4gICAqIEBiZXRhXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIEhhcyBzcGVha2luZyBzdGF0dXMgY2hhbmdlZCBmb3IgdGhlIGN1cnJlbnQgcGFydGljaXBhbnRcbiAgICpcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIGEgbG9jYWwgdHJhY2sgaGFzIGJlZW4gY29uc3RyYWluZWQgYnkgY3B1XG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tDcHVDb25zdHJhaW5lZFwiXSA9IFwidHJhY2tDcHVDb25zdHJhaW5lZFwiO1xuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBdWRpb1N0cmVhbUFjcXVpcmVkXCJdID0gXCJhdWRpb1N0cmVhbUFjcXVpcmVkXCI7XG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUENUcmFja0FkZGVkXCJdID0gXCJwY1RyYWNrQWRkZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgKiBhcmdzOiAoY2hhbmdlZEF0dHJpYnV0ZXM6IFtbUmVjb3JkPHN0cmluZywgc3RyaW5nXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXR0cmlidXRlc0NoYW5nZWRcIl0gPSBcImF0dHJpYnV0ZXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBmaXJlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCBvbmx5LCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIHRyYWNrIHNwZWNpZmllZCBpbiB0aGUgcGF5bG9hZFxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJsb2NhbFRyYWNrU3Vic2NyaWJlZFwiO1xuICAvKiogb25seSBlbWl0dGVkIG9uIGxvY2FsIHBhcnRpY2lwYW50ICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJDaGF0TWVzc2FnZVwiXSA9IFwiY2hhdE1lc3NhZ2VcIjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgcGFydGljaXBhbnQncyBzdGF0ZSBjaGFuZ2VzIHRvIEFDVElWRSBhbmQgaXMgcmVhZHkgdG8gc2VuZC9yZWNlaXZlIGRhdGEgbWVzc2FnZXNcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBY3RpdmVcIl0gPSBcImFjdGl2ZVwiO1xufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG52YXIgRW5naW5lRXZlbnQ7XG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiTWVkaWFUcmFja0FkZGVkXCJdID0gXCJtZWRpYVRyYWNrQWRkZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJUUFZpZGVvTWFwVXBkYXRlXCJdID0gXCJydHBWaWRlb01hcFVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUm9vbVVwZGF0ZVwiXSA9IFwicm9vbVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVtb3RlTXV0ZVwiXSA9IFwicmVtb3RlTXV0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiT2ZmbGluZVwiXSA9IFwib2ZmbGluZVwiO1xuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlcXVlc3RSZXNwb25zZVwiXSA9IFwic2lnbmFsUmVxdWVzdFJlc3BvbnNlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSb29tTW92ZWRcIl0gPSBcInJvb21Nb3ZlZFwiO1xufSkoRW5naW5lRXZlbnQgfHwgKEVuZ2luZUV2ZW50ID0ge30pKTtcbnZhciBUcmFja0V2ZW50O1xuKGZ1bmN0aW9uIChUcmFja0V2ZW50KSB7XG4gIFRyYWNrRXZlbnRbXCJNZXNzYWdlXCJdID0gXCJtZXNzYWdlXCI7XG4gIFRyYWNrRXZlbnRbXCJNdXRlZFwiXSA9IFwibXV0ZWRcIjtcbiAgVHJhY2tFdmVudFtcIlVubXV0ZWRcIl0gPSBcInVubXV0ZWRcIjtcbiAgLyoqXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xuICBUcmFja0V2ZW50W1wiRW5kZWRcIl0gPSBcImVuZGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gIFRyYWNrRXZlbnRbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xuICBUcmFja0V2ZW50W1wiQ3B1Q29uc3RyYWluZWRcIl0gPSBcImNwdUNvbnN0cmFpbmVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVNldHRpbmdzXCJdID0gXCJ1cGRhdGVTZXR0aW5nc1wiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTdWJzY3JpcHRpb25cIl0gPSBcInVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxBdWRpb1RyYWNrIGluc3RhbmNlc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJhdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaXNpYmlsaXR5Q2hhbmdlZFwiXSA9IFwidmlzaWJpbGl0eUNoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiXSA9IFwidmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwidmlkZW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwidmlkZW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50QXR0YWNoZWRcIl0gPSBcImVsZW1lbnRBdHRhY2hlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50RGV0YWNoZWRcIl0gPSBcImVsZW1lbnREZXRhY2hlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVBhdXNlZFwiXSA9IFwidXBzdHJlYW1QYXVzZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1SZXN1bWVkXCJdID0gXCJ1cHN0cmVhbVJlc3VtZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwic3Vic2NyaXB0aW9uRmFpbGVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJUcmFja1Byb2Nlc3NvclVwZGF0ZVwiXSA9IFwidHJhY2tQcm9jZXNzb3JVcGRhdGVcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlXCJdID0gXCJhdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZVwiO1xuICAvKipcbiAgICogQGJldGFcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWRcIl0gPSBcInRyYW5zY3JpcHRpb25SZWNlaXZlZFwiO1xuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlRpbWVTeW5jVXBkYXRlXCJdID0gXCJ0aW1lU3luY1VwZGF0ZVwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja0V2ZW50W1wiUHJlQ29ubmVjdEJ1ZmZlckZsdXNoZWRcIl0gPSBcInByZUNvbm5lY3RCdWZmZXJGbHVzaGVkXCI7XG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG5vdCBhIHByb3h5IGJ5IHNwcmVhZGluZyBpdFxuICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZShPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG59Y2xhc3MgVmlkZW9QcmVzZXQge1xuICBjb25zdHJ1Y3Rvcih3aWR0aE9yT3B0aW9ucywgaGVpZ2h0LCBtYXhCaXRyYXRlLCBtYXhGcmFtZXJhdGUsIHByaW9yaXR5KSB7XG4gICAgaWYgKHR5cGVvZiB3aWR0aE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aE9yT3B0aW9ucy53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gd2lkdGhPck9wdGlvbnMuaGVpZ2h0O1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHdpZHRoT3JPcHRpb25zLmFzcGVjdFJhdGlvO1xuICAgICAgdGhpcy5lbmNvZGluZyA9IHtcbiAgICAgICAgbWF4Qml0cmF0ZTogd2lkdGhPck9wdGlvbnMubWF4Qml0cmF0ZSxcbiAgICAgICAgbWF4RnJhbWVyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhGcmFtZXJhdGUsXG4gICAgICAgIHByaW9yaXR5OiB3aWR0aE9yT3B0aW9ucy5wcmlvcml0eVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1heEJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMgLyBoZWlnaHQ7XG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICBtYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGUsXG4gICAgICAgIHByaW9yaXR5XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBvcHRpb25zOiBwcm92aWRlIGF0IGxlYXN0IHdpZHRoLCBoZWlnaHQgYW5kIG1heEJpdHJhdGUnKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZTogdGhpcy5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy5hc3BlY3RSYXRpb1xuICAgIH07XG4gIH1cbn1cbi8vIGByZWRgIGlzIG5vdCB0ZWNobmljYWxseSBhIGNvZGVjLCBidXQgdHJlYXRlZCBhcyBvbmUgaW4gc2lnbmFsbGluZyBwcm90b2NvbFxuY29uc3QgYXVkaW9Db2RlY3MgPSBbJ29wdXMnLCAncmVkJ107XG5jb25zdCBiYWNrdXBWaWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnXTtcbmNvbnN0IHZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCcsICd2cDknLCAnYXYxJywgJ2gyNjUnXTtcbmZ1bmN0aW9uIGlzQmFja3VwVmlkZW9Db2RlYyhjb2RlYykge1xuICByZXR1cm4gISFiYWNrdXBWaWRlb0NvZGVjcy5maW5kKGJhY2t1cCA9PiBiYWNrdXAgPT09IGNvZGVjKTtcbn1cbi8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGlzQmFja3VwVmlkZW9Db2RlY30gaW5zdGVhZCAqL1xuY29uc3QgaXNCYWNrdXBDb2RlYyA9IGlzQmFja3VwVmlkZW9Db2RlYztcbnZhciBCYWNrdXBDb2RlY1BvbGljeTtcbihmdW5jdGlvbiAoQmFja3VwQ29kZWNQb2xpY3kpIHtcbiAgLy8gY29kZWMgcmVncmVzc2lvbiBpcyBwcmVmZXJyZWQsIHRoZSBzZnUgd2lsbCB0cnkgdG8gcmVncmVzcyBjb2RlYyBpZiBwb3NzaWJsZSBidXQgbm90IGd1YXJhbnRlZWRcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJQUkVGRVJfUkVHUkVTU0lPTlwiXSA9IDBdID0gXCJQUkVGRVJfUkVHUkVTU0lPTlwiO1xuICAvLyBtdWx0aS1jb2RlYyBzaW11bGNhc3QsIHB1Ymxpc2ggYm90aCBwcmltYXJ5IGFuZCBiYWNrdXAgY29kZWMgYXQgdGhlIHNhbWUgdGltZVxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlNJTVVMQ0FTVFwiXSA9IDFdID0gXCJTSU1VTENBU1RcIjtcbiAgLy8gYWx3YXlzIHVzZSBiYWNrdXAgY29kZWMgb25seVxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlJFR1JFU1NJT05cIl0gPSAyXSA9IFwiUkVHUkVTU0lPTlwiO1xufSkoQmFja3VwQ29kZWNQb2xpY3kgfHwgKEJhY2t1cENvZGVjUG9saWN5ID0ge30pKTtcbnZhciBBdWRpb1ByZXNldHM7XG4oZnVuY3Rpb24gKEF1ZGlvUHJlc2V0cykge1xuICBBdWRpb1ByZXNldHMudGVsZXBob25lID0ge1xuICAgIG1heEJpdHJhdGU6IDEyMDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5zcGVlY2ggPSB7XG4gICAgbWF4Qml0cmF0ZTogMjQwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY1N0ZXJlbyA9IHtcbiAgICBtYXhCaXRyYXRlOiA2NDAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNIaWdoUXVhbGl0eSA9IHtcbiAgICBtYXhCaXRyYXRlOiA5NjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyA9IHtcbiAgICBtYXhCaXRyYXRlOiAxMjgwMDBcbiAgfTtcbn0pKEF1ZGlvUHJlc2V0cyB8fCAoQXVkaW9QcmVzZXRzID0ge30pKTtcbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMTgwLCAxNjAwMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNTQwLCA4MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTcwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1MDAwMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgODAwMDAwMCwgMzApXG59O1xuLyoqXG4gKiBGb3VyIGJ5IHRocmVlIHByZXNldHNcbiAqL1xuY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjUwMDAsIDIwKSxcbiAgaDI0MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMjQwLCAxNDAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzAwMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDcyMCwgNTQwLCA2MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxMzAwMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTQ0MCwgMTA4MCwgMjMwMDAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDM4MDAwMDAsIDMwKVxufTtcbmNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwMDAwLCAzLCAnbWVkaXVtJyksXG4gIGgzNjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0MDAwMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDAwMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDIwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNTAwMDAwMCwgMzAsICdtZWRpdW0nKSxcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDcwMDAwMDAsIDMwLCAnbWVkaXVtJylcbn07ZnVuY3Rpb24gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKSB7XG4gIHZhciBfYSwgX2I7XG4gIHZhciBfYywgX2Q7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zV2l0aG91dFByb2Nlc3NvcixcbiAgICBhdWRpb1Byb2Nlc3NvcixcbiAgICB2aWRlb1Byb2Nlc3NvclxuICB9ID0gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gIGNvbnN0IGRlZmF1bHRBdWRpb1Byb2Nlc3NvciA9IGF1ZGlvRGVmYXVsdHMgPT09IG51bGwgfHwgYXVkaW9EZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXVkaW9EZWZhdWx0cy5wcm9jZXNzb3I7XG4gIGNvbnN0IGRlZmF1bHRWaWRlb1Byb2Nlc3NvciA9IHZpZGVvRGVmYXVsdHMgPT09IG51bGwgfHwgdmlkZW9EZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW9EZWZhdWx0cy5wcm9jZXNzb3I7XG4gIGNvbnN0IGNsb25lZE9wdGlvbnMgPSBvcHRpb25zV2l0aG91dFByb2Nlc3NvciAhPT0gbnVsbCAmJiBvcHRpb25zV2l0aG91dFByb2Nlc3NvciAhPT0gdm9pZCAwID8gb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgOiB7fTtcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8gPT09IHRydWUpIGNsb25lZE9wdGlvbnMuYXVkaW8gPSB7fTtcbiAgaWYgKGNsb25lZE9wdGlvbnMudmlkZW8gPT09IHRydWUpIGNsb25lZE9wdGlvbnMudmlkZW8gPSB7fTtcbiAgLy8gdXNlIGRlZmF1bHRzXG4gIGlmIChjbG9uZWRPcHRpb25zLmF1ZGlvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoY2xvbmVkT3B0aW9ucy5hdWRpbywgYXVkaW9EZWZhdWx0cyk7XG4gICAgKF9hID0gKF9jID0gY2xvbmVkT3B0aW9ucy5hdWRpbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9jLmRldmljZUlkID0ge1xuICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgIH07XG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yIHx8IGRlZmF1bHRBdWRpb1Byb2Nlc3Nvcikge1xuICAgICAgY2xvbmVkT3B0aW9ucy5hdWRpby5wcm9jZXNzb3IgPSBhdWRpb1Byb2Nlc3NvciAhPT0gbnVsbCAmJiBhdWRpb1Byb2Nlc3NvciAhPT0gdm9pZCAwID8gYXVkaW9Qcm9jZXNzb3IgOiBkZWZhdWx0QXVkaW9Qcm9jZXNzb3I7XG4gICAgfVxuICB9XG4gIGlmIChjbG9uZWRPcHRpb25zLnZpZGVvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoY2xvbmVkT3B0aW9ucy52aWRlbywgdmlkZW9EZWZhdWx0cyk7XG4gICAgKF9iID0gKF9kID0gY2xvbmVkT3B0aW9ucy52aWRlbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9kLmRldmljZUlkID0ge1xuICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgIH07XG4gICAgaWYgKHZpZGVvUHJvY2Vzc29yIHx8IGRlZmF1bHRWaWRlb1Byb2Nlc3Nvcikge1xuICAgICAgY2xvbmVkT3B0aW9ucy52aWRlby5wcm9jZXNzb3IgPSB2aWRlb1Byb2Nlc3NvciAhPT0gbnVsbCAmJiB2aWRlb1Byb2Nlc3NvciAhPT0gdm9pZCAwID8gdmlkZW9Qcm9jZXNzb3IgOiBkZWZhdWx0VmlkZW9Qcm9jZXNzb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWRPcHRpb25zO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcobWFpbk9iamVjdCwgb2JqZWN0VG9NZXJnZSkge1xuICBPYmplY3Qua2V5cyhvYmplY3RUb01lcmdlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKG1haW5PYmplY3Rba2V5XSA9PT0gdW5kZWZpbmVkKSBtYWluT2JqZWN0W2tleV0gPSBvYmplY3RUb01lcmdlW2tleV07XG4gIH0pO1xuICByZXR1cm4gbWFpbk9iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIHZhciBfYywgX2Q7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0ge307XG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgLy8gZGVmYXVsdCB2aWRlbyBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgdmlkZW9PcHRpb25zID0ge307XG4gICAgICBjb25zdCB0YXJnZXQgPSB2aWRlb09wdGlvbnM7XG4gICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnZpZGVvO1xuICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcbiAgICAgICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKHRhcmdldCwgc291cmNlLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB2aWRlb09wdGlvbnM7XG4gICAgICAoX2EgPSAoX2MgPSBjb25zdHJhaW50cy52aWRlbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9jLmRldmljZUlkID0ge1xuICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IG9wdGlvbnMudmlkZW8gPyB7XG4gICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgICB9XG4gICAgICB9IDogZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XG4gICAgICAoX2IgPSAoX2QgPSBjb25zdHJhaW50cy5hdWRpbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9kLmRldmljZUlkID0ge1xuICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgc2lsZW5jZSBvbiBhIGdpdmVuIFtbVHJhY2tdXSBpbnN0YW5jZS5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhY2sgc2VlbXMgdG8gYmUgZW50aXJlbHkgc2lsZW50LlxuICovXG5mdW5jdGlvbiBkZXRlY3RTaWxlbmNlKHRyYWNrXzEpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgbGV0IHRpbWVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDIwMDtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjb25zdCBhbmFseXNlciA9IGN0eC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICBhbmFseXNlci5mZnRTaXplID0gMjA0ODtcbiAgICAgICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RyYWNrLm1lZGlhU3RyZWFtVHJhY2tdKSk7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgICAgeWllbGQgc2xlZXAodGltZU9mZnNldCk7XG4gICAgICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShkYXRhQXJyYXkpO1xuICAgICAgICBjb25zdCBzb21lTm9pc2UgPSBkYXRhQXJyYXkuc29tZShzYW1wbGUgPT4gc2FtcGxlICE9PSAxMjggJiYgc2FtcGxlICE9PSAwKTtcbiAgICAgICAgY3R4LmNsb3NlKCk7XG4gICAgICAgIHJldHVybiAhc29tZU5vaXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKTtcbiAgfSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROZXdBdWRpb0NvbnRleHQoKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQXVkaW9Db250ZXh0ID1cbiAgLy8gQHRzLWlnbm9yZVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbiAgaWYgKEF1ZGlvQ29udGV4dCkge1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoe1xuICAgICAgbGF0ZW5jeUhpbnQ6ICdpbnRlcmFjdGl2ZSdcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgYXVkaW8gY29udGV4dCBpcyBzdXNwZW5kZWQsIHdlIG5lZWQgdG8gcmVzdW1lIGl0IHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBwYWdlXG4gICAgaWYgKGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHdpbmRvdy5kb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvZHkpKSB7XG4gICAgICBjb25zdCBoYW5kbGVSZXN1bWUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgeWllbGQgYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgdHJ5aW5nIHRvIGF1dG8tcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoX2EgPSB3aW5kb3cuZG9jdW1lbnQuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlUmVzdW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmFzZUF1ZGlvQ29udGV4dC9zdGF0ZWNoYW5nZV9ldmVudFxuICAgICAgYXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChhdWRpb0NvbnRleHQuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgKF9hID0gd2luZG93LmRvY3VtZW50LmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db250ZXh0O1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBraW5kVG9Tb3VyY2Uoa2luZCkge1xuICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkge1xuICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgcmV0dXJuICd2aWRlb2lucHV0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHZpZGVvQ29uc3RyYWludHMgPSAoX2EgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAvLyB0cmVhdCAwIGFzIHVuY2FwcGVkXG4gIGlmIChvcHRpb25zLnJlc29sdXRpb24gJiYgb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoID4gMCAmJiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0ID4gMCkge1xuICAgIHZpZGVvQ29uc3RyYWludHMgPSB0eXBlb2YgdmlkZW9Db25zdHJhaW50cyA9PT0gJ2Jvb2xlYW4nID8ge30gOiB2aWRlb0NvbnN0cmFpbnRzO1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0NvbnN0cmFpbnRzKSwge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0NvbnN0cmFpbnRzKSwge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhdWRpbzogKF9iID0gb3B0aW9ucy5hdWRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgdmlkZW86IHZpZGVvQ29uc3RyYWludHMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IGZvciBleHBlcmltZW50YWwgZGlzcGxheSBtZWRpYSBmZWF0dXJlc1xuICAgIGNvbnRyb2xsZXI6IG9wdGlvbnMuY29udHJvbGxlcixcbiAgICBzZWxmQnJvd3NlclN1cmZhY2U6IG9wdGlvbnMuc2VsZkJyb3dzZXJTdXJmYWNlLFxuICAgIHN1cmZhY2VTd2l0Y2hpbmc6IG9wdGlvbnMuc3VyZmFjZVN3aXRjaGluZyxcbiAgICBzeXN0ZW1BdWRpbzogb3B0aW9ucy5zeXN0ZW1BdWRpbyxcbiAgICBwcmVmZXJDdXJyZW50VGFiOiBvcHRpb25zLnByZWZlckN1cnJlbnRUYWJcbiAgfTtcbn1cbmZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlKSB7XG4gIHJldHVybiBtaW1lVHlwZS5zcGxpdCgnLycpWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyh0cmFja3MpIHtcbiAgY29uc3QgaW5mb3MgPSBbXTtcbiAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgIGlmICh0cmFjay50cmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmZvcy5wdXNoKG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcbiAgICAgICAgY2lkOiB0cmFjay50cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgICB0cmFjazogdHJhY2sudHJhY2tJbmZvXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluZm9zO1xufVxuZnVuY3Rpb24gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykge1xuICBpZiAoJ21lZGlhU3RyZWFtVHJhY2snIGluIHRyYWNrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrSUQ6IHRyYWNrLnNpZCxcbiAgICAgIHNvdXJjZTogdHJhY2suc291cmNlLFxuICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICBlbmFibGVkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQsXG4gICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgc3RyZWFtSUQ6IHRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICBzdHJlYW1UcmFja0lEOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tJRDogdHJhY2sudHJhY2tTaWQsXG4gICAgICBlbmFibGVkOiB0cmFjay5pc0VuYWJsZWQsXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIHRyYWNrSW5mbzogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1pbWVUeXBlOiB0cmFjay5taW1lVHlwZSxcbiAgICAgICAgbmFtZTogdHJhY2sudHJhY2tOYW1lLFxuICAgICAgICBlbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxuICAgICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZVxuICAgICAgfSwgdHJhY2sudHJhY2sgPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrLnRyYWNrKSA6IHt9KVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHN1cHBvcnRzU3luY2hyb25pemF0aW9uU291cmNlcygpIHtcbiAgcmV0dXJuIHR5cGVvZiBSVENSdHBSZWNlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2dldFN5bmNocm9uaXphdGlvblNvdXJjZXMnIGluIFJUQ1J0cFJlY2VpdmVyO1xufVxuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMob2xkVmFsdWVzLCBuZXdWYWx1ZXMpIHtcbiAgdmFyIF9hO1xuICBpZiAob2xkVmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBvbGRWYWx1ZXMgPSB7fTtcbiAgfVxuICBpZiAobmV3VmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuZXdWYWx1ZXMgPSB7fTtcbiAgfVxuICBjb25zdCBhbGxLZXlzID0gWy4uLk9iamVjdC5rZXlzKG5ld1ZhbHVlcyksIC4uLk9iamVjdC5rZXlzKG9sZFZhbHVlcyldO1xuICBjb25zdCBkaWZmID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICBpZiAob2xkVmFsdWVzW2tleV0gIT09IG5ld1ZhbHVlc1trZXldKSB7XG4gICAgICBkaWZmW2tleV0gPSAoX2EgPSBuZXdWYWx1ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgbGV0IGF1ZGlvUHJvY2Vzc29yO1xuICBsZXQgdmlkZW9Qcm9jZXNzb3I7XG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3IpIHtcbiAgICBhdWRpb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yO1xuICAgIG5ld09wdGlvbnMuYXVkaW8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ld09wdGlvbnMuYXVkaW8pLCB7XG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3IpIHtcbiAgICB2aWRlb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMudmlkZW8ucHJvY2Vzc29yO1xuICAgIG5ld09wdGlvbnMudmlkZW8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ld09wdGlvbnMudmlkZW8pLCB7XG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgYXVkaW9Qcm9jZXNzb3IsXG4gICAgdmlkZW9Qcm9jZXNzb3IsXG4gICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGNsb25lRGVlcChuZXdPcHRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8oc291cmNlKSB7XG4gIHN3aXRjaCAoc291cmNlKSB7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbn1cbmZ1bmN0aW9uIGFyZURpbWVuc2lvbnNTbWFsbGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEud2lkdGggKiBhLmhlaWdodCA8IGIud2lkdGggKiBiLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGxheWVyRGltZW5zaW9uc0Zvcih0cmFja0luZm8sIHF1YWxpdHkpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gdHJhY2tJbmZvLmxheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQobCA9PiBsLnF1YWxpdHkgPT09IHF1YWxpdHkpO1xufWNvbnN0IEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkgPSA1MDAwO1xuLy8ga2VlcCBvbGQgYXVkaW8gZWxlbWVudHMgd2hlbiBkZXRhY2hlZCwgd2Ugd291bGQgcmUtdXNlIHRoZW0gc2luY2Ugb24gaU9TXG4vLyBTYWZhcmkgdHJhY2tzIHdoaWNoIGF1ZGlvIGVsZW1lbnRzIGhhdmUgYmVlbiBcImJsZXNzZWRcIiBieSB0aGUgdXNlci5cbmNvbnN0IHJlY3ljbGVkRWxlbWVudHMgPSBbXTtcbnZhciBWaWRlb1F1YWxpdHk7XG4oZnVuY3Rpb24gKFZpZGVvUXVhbGl0eSkge1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XXCJdID0gMF0gPSBcIkxPV1wiO1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTUVESVVNXCJdID0gMV0gPSBcIk1FRElVTVwiO1xuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiSElHSFwiXSA9IDJdID0gXCJISUdIXCI7XG59KShWaWRlb1F1YWxpdHkgfHwgKFZpZGVvUXVhbGl0eSA9IHt9KSk7XG5jbGFzcyBUcmFjayBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAqIGhhcyBiZWVuIHBhdXNlZCBieSBjb25nZXN0aW9uIGNvbnRyb2xsZXJcbiAgICovXG4gIGdldCBzdHJlYW1TdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtU3RhdGU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRTdHJlYW1TdGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0cmVhbVN0YXRlID0gdmFsdWU7XG4gIH1cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywga2luZCkge1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmlzTXV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZTtcbiAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5iYWNrZ3JvdW5kVGltZW91dCk7XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cbiAgICAgIC8vIHVwZGF0ZSBpbW1lZGlhdGVseSBpZiBpdCBjb21lcyBiYWNrIHRvIGZvY3VzXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5UcmFjayk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhVHJhY2s7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1JRCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XG4gIH1cbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHVzZWQgZm9yIGtlZXAgbWVkaWFTdHJlYW0ncyBmaXJzdCBpZCwgc2luY2UgaXQncyBpZCBtaWdodCBjaGFuZ2VcbiAgICogaWYgd2UgZGlzYWJsZS9lbmFibGUgYSB0cmFja1xuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgdGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICB0aGlzLmFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgaWYgKGUucGFyZW50RWxlbWVudCA9PT0gbnVsbCAmJiAhZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBwb29sXG4gICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5zcGxpY2UocmVjeWNsZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBldmVuIGlmIHdlIGJlbGlldmUgaXQncyBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50LCBpdCdzIHBvc3NpYmxlXG4gICAgLy8gdGhlIGVsZW1lbnQncyBzcmNPYmplY3Qgd2FzIHNldCB0byBzb21ldGhpbmcgZWxzZSBvdXQgb2YgYmFuZC5cbiAgICAvLyB3ZSdsbCB3YW50IHRvIHJlLWF0dGFjaCBpdCBpbiB0aGF0IGNhc2VcbiAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAvLyBoYW5kbGUgYXV0byBwbGF5YmFjayBmYWlsdXJlc1xuICAgIGNvbnN0IGFsbE1lZGlhU3RyZWFtVHJhY2tzID0gZWxlbWVudC5zcmNPYmplY3QuZ2V0VHJhY2tzKCk7XG4gICAgY29uc3QgaGFzQXVkaW8gPSBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICdhdWRpbycpO1xuICAgIC8vIG1hbnVhbGx5IHBsYXkgbWVkaWEgdG8gZGV0ZWN0IGF1dG8gcGxheWJhY2sgc3RhdHVzXG4gICAgZWxlbWVudC5wbGF5KCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAvLyBjb21tb25seSB0cmlnZ2VyZWQgYnkgYW5vdGhlciBgcGxheWAgcmVxdWVzdCwgb25seSBsb2cgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwiXCIuY29uY2F0KGhhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbycsIFwiIHBsYXliYWNrIGFib3J0ZWQsIGxpa2VseSBkdWUgdG8gbmV3IHBsYXkgcmVxdWVzdFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJjb3VsZCBub3QgcGxheWJhY2sgXCIuY29uY2F0KGhhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbycpLCBlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGF1ZGlvIHBsYXliYWNrIGlzbid0IGFsbG93ZWQgbWFrZSBzdXJlIHdlIHN0aWxsIHBsYXkgYmFjayB0aGUgdmlkZW9cbiAgICAgIGlmIChoYXNBdWRpbyAmJiBlbGVtZW50ICYmIGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUodHIgPT4gdHIua2luZCA9PT0gJ3ZpZGVvJykgJiYgZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIGNhdGNoIGZvciBTYWZhcmksIGV4Y2VlZGVkIG9wdGlvbnMgYXQgdGhpcyBwb2ludCB0byBhdXRvbWF0aWNhbGx5IHBsYXkgdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudEF0dGFjaGVkLCBlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRldGFjaGVkID0gW107XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbG0gPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsbSk7XG4gICAgICAgIGRldGFjaGVkLnB1c2goZWxtKTtcbiAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbG0pO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsbSk7XG4gICAgICB9KTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdHJhY2tzXG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICAgIHJldHVybiBkZXRhY2hlZDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE1vbml0b3IoKSB7XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvckludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZVN5bmNIYW5kbGUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudGltZVN5bmNIYW5kbGUpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUxvZ2dlck9wdGlvbnMobG9nZ2VyT3B0aW9ucykge1xuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpIHtcbiAgICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYikge1xuICAgICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB9XG4gIH1cbiAgcmVjeWNsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHJlLXVzZSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBsZXQgc2hvdWxkQ2FjaGUgPSB0cnVlO1xuICAgICAgZWxlbWVudC5wYXVzZSgpO1xuICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZENhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGNhdGNoIGNsYXVzZSBuZWNlc3NhcnkgZm9yIFNhZmFyaSAqL1xuICAgICAgICB9KSksIDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrLCBlbGVtZW50KSB7XG4gIGxldCBtZWRpYVN0cmVhbTtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIG1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gIH1cbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xuICBsZXQgZXhpc3RpbmdUcmFja3M7XG4gIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICB9IGVsc2Uge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgfVxuICBpZiAoIWV4aXN0aW5nVHJhY2tzLmluY2x1ZGVzKHRyYWNrKSkge1xuICAgIGV4aXN0aW5nVHJhY2tzLmZvckVhY2goZXQgPT4ge1xuICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2soZXQpO1xuICAgIH0pO1xuICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBpZiAoIWlzU2FmYXJpKCkgfHwgIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXG4gICAgLy8gd2Ugd29yayBhcm91bmQgdGhpcyBieSBfbm90XyBzZXR0aW5nIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgb24gc2FmYXJpIGFuZCBpbnN0ZWFkIGNhbGwgYHNldFRpbWVvdXQoKCkgPT4gZWwucGxheSgpLDApYCBmdXJ0aGVyIGRvd25cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgfVxuICAvLyBJbiBjYXNlIHRoZXJlIGFyZSBubyBhdWRpbyB0cmFja3MgcHJlc2VudCBvbiB0aGUgbWVkaWFzdHJlYW0sIHdlIHNldCB0aGUgZWxlbWVudCBhcyBtdXRlZCB0byBlbnN1cmUgYXV0b3BsYXkgd29ya3NcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgfVxuICAvLyBhdm9pZCBmbGlja2VyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCAhPT0gbWVkaWFTdHJlYW0pIHtcbiAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIGlmICgoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgIC8vIEZpcmVmb3ggYWxzbyBoYXMgYSB0aW1pbmcgaXNzdWUgd2hlcmUgdmlkZW8gZG9lc24ndCBhY3R1YWxseSBnZXQgYXR0YWNoZWQgdW5sZXNzXG4gICAgICAvLyBwZXJmb3JtZWQgb3V0LW9mLWJhbmRcbiAgICAgIC8vIFNhZmFyaSAxNSBoYXMgYSBidWcgd2hlcmUgaW4gY2VydGFpbiBsYXlvdXRzLCB2aWRlbyBlbGVtZW50IHJlbmRlcnNcbiAgICAgIC8vIGJsYWNrIHVudGlsIHRoZSBwYWdlIGlzIHJlc2l6ZWQgb3Igb3RoZXIgY2hhbmdlcyB0YWtlIHBsYWNlLlxuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBzcmMgdHJpZ2dlcnMgaXQgdG8gcmVuZGVyLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjkwNTIzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgLy8gU2FmYXJpIDE1IHNvbWV0aW1lcyBmYWlscyB0byBzdGFydCBhIHZpZGVvXG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvdyBpcyBiYWNrZ3JvdW5kZWQgYmVmb3JlIHRoZSBmaXJzdCBmcmFtZSBpcyBkcmF3blxuICAgICAgICAvLyBtYW51YWxseSBjYWxsaW5nIHBsYXkgaGVyZSBzZWVtcyB0byBmaXggdGhhdFxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGFjaFRyYWNrKHRyYWNrLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgaWYgKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2spIHtcbiAgbGV0IEtpbmQ7XG4gIChmdW5jdGlvbiAoS2luZCkge1xuICAgIEtpbmRbXCJBdWRpb1wiXSA9IFwiYXVkaW9cIjtcbiAgICBLaW5kW1wiVmlkZW9cIl0gPSBcInZpZGVvXCI7XG4gICAgS2luZFtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoS2luZCA9IFRyYWNrLktpbmQgfHwgKFRyYWNrLktpbmQgPSB7fSkpO1xuICBsZXQgU291cmNlO1xuICAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICAgIFNvdXJjZVtcIkNhbWVyYVwiXSA9IFwiY2FtZXJhXCI7XG4gICAgU291cmNlW1wiTWljcm9waG9uZVwiXSA9IFwibWljcm9waG9uZVwiO1xuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlXCJdID0gXCJzY3JlZW5fc2hhcmVcIjtcbiAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZUF1ZGlvXCJdID0gXCJzY3JlZW5fc2hhcmVfYXVkaW9cIjtcbiAgICBTb3VyY2VbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKFNvdXJjZSA9IFRyYWNrLlNvdXJjZSB8fCAoVHJhY2suU291cmNlID0ge30pKTtcbiAgbGV0IFN0cmVhbVN0YXRlJDE7XG4gIChmdW5jdGlvbiAoU3RyZWFtU3RhdGUpIHtcbiAgICBTdHJlYW1TdGF0ZVtcIkFjdGl2ZVwiXSA9IFwiYWN0aXZlXCI7XG4gICAgU3RyZWFtU3RhdGVbXCJQYXVzZWRcIl0gPSBcInBhdXNlZFwiO1xuICAgIFN0cmVhbVN0YXRlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShTdHJlYW1TdGF0ZSQxID0gVHJhY2suU3RyZWFtU3RhdGUgfHwgKFRyYWNrLlN0cmVhbVN0YXRlID0ge30pKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kVG9Qcm90byhrKSB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlIEtpbmQuQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XG4gICAgICBjYXNlIEtpbmQuVmlkZW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuVklERU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRSB0aGlzIHdhcyBVTlJFQ09HTklaRUQgYmVmb3JlXG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuREFUQTtcbiAgICB9XG4gIH1cbiAgVHJhY2sua2luZFRvUHJvdG8gPSBraW5kVG9Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQpIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcbiAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBLaW5kLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLmtpbmRGcm9tUHJvdG8gPSBraW5kRnJvbVByb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHNvdXJjZVRvUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuQ0FNRVJBO1xuICAgICAgY2FzZSBTb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc291cmNlVG9Qcm90byA9IHNvdXJjZVRvUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc291cmNlRnJvbVByb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgICByZXR1cm4gU291cmNlLkNhbWVyYTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zb3VyY2VGcm9tUHJvdG8gPSBzb3VyY2VGcm9tUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc3RyZWFtU3RhdGVGcm9tUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5BQ1RJVkU6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLkFjdGl2ZTtcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuUEFVU0VEOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5QYXVzZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byA9IHN0cmVhbVN0YXRlRnJvbVByb3RvO1xufSkoVHJhY2sgfHwgKFRyYWNrID0ge30pKTtjb25zdCBzZXBhcmF0b3IgPSAnfCc7XG5jb25zdCBkZEV4dGVuc2lvblVSSSA9ICdodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLXJ0cC1zcGVjLyNkZXBlbmRlbmN5LWRlc2NyaXB0b3ItcnRwLWhlYWRlci1leHRlbnNpb24nO1xuZnVuY3Rpb24gdW5wYWNrU3RyZWFtSWQocGFja2VkKSB7XG4gIGNvbnN0IHBhcnRzID0gcGFja2VkLnNwbGl0KHNlcGFyYXRvcik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFja2VkLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggKyAxKV07XG4gIH1cbiAgcmV0dXJuIFtwYWNrZWQsICcnXTtcbn1cbmZ1bmN0aW9uIHNsZWVwKGR1cmF0aW9uKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xuICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB7XG4gIHJldHVybiAnYWRkVHJhbnNjZWl2ZXInIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHN1cHBvcnRzQWRkVHJhY2soKSB7XG4gIHJldHVybiAnYWRkVHJhY2snIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0oKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzRHluYWNhc3QoKSB7XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCk7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0FWMSgpIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkge1xuICAgIC8vIFNhZmFyaSAxNyBvbiBpUGhvbmUxNCByZXBvcnRzIEFWMSBjYXBhYmlsaXR5LCBidXQgZG9lcyBub3QgYWN0dWFsbHkgc3VwcG9ydCBpdFxuICAgIC8vIEZpcmVmb3ggZG9lcyBzdXBwb3J0IEFWMSwgYnV0IFNWQyBwdWJsaXNoaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcbiAgbGV0IGhhc0FWMSA9IGZhbHNlO1xuICBpZiAoY2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICBpZiAoY29kZWMubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2F2MScpIHtcbiAgICAgICAgaGFzQVYxID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBVjE7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1ZQOSgpIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXJlRm94KCkpIHtcbiAgICAvLyB0ZWNobmljYWxseSBzcGVha2luZyBGaXJlRm94IHN1cHBvcnRzIFZQOSwgYnV0IFNWQyBwdWJsaXNoaW5nIGlzIGJyb2tlblxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MzM4NzZcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIGlmICgoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxNicpIDwgMCkge1xuICAgICAgLy8gU2FmYXJpIDE2IGFuZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IFZQOVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5vcykgPT09ICdpT1MnICYmIChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIub3NWZXJzaW9uKSAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci5vc1ZlcnNpb24sICcxNicpIDwgMCkge1xuICAgICAgLy8gU2FmYXJpIDE2IGFuZCBiZWxvdyBvbiBpT1MgZG9lcyBub3Qgc3VwcG9ydCBWUDkgd2UgbmVlZCB0aGUgaU9TIGNoZWNrIHRvIGFjY291bnQgZm9yIG90aGVyIGJyb3dzZXJzIHJ1bm5pbmcgd2Via2l0IHVuZGVyIHRoZSBob29kXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDknKSB7XG4gICAgICAgIGhhc1ZQOSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzVlA5O1xufVxuZnVuY3Rpb24gaXNTVkNDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29kZWMgPT09ICdhdjEnIHx8IGNvZGVjID09PSAndnA5Jztcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzU2V0U2lua0lkKGVsbSkge1xuICBpZiAoIWRvY3VtZW50IHx8IGlzU2FmYXJpQmFzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVsbSkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIH1cbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHNldHRpbmcgYW4gYXVkaW8gb3V0cHV0IHZpYSB7QGxpbmsgUm9vbSNzZXRBY3RpdmVEZXZpY2V9XG4gKiBpcyBzdXBwb3J0ZWQgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRzQXVkaW9PdXRwdXRTZWxlY3Rpb24oKSB7XG4gIC8vIE5vdGU6IHRoaXMgaXMgbWV0aG9kIHB1YmxpY2x5IGV4cG9ydGVkIHVuZGVyIGEgdXNlciBmcmllbmRseSBuYW1lIGFuZCBjdXJyZW50bHkgb25seSBwcm94eWluZyBgc3VwcG9ydHNTZXRTaW5rSWRgXG4gIHJldHVybiBzdXBwb3J0c1NldFNpbmtJZCgpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHx8IHN1cHBvcnRzQWRkVHJhY2soKTtcbn1cbmZ1bmN0aW9uIGlzRmlyZUZveCgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnRmlyZWZveCc7XG59XG5mdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKSB7XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIHJldHVybiAhIWJyb3dzZXIgJiYgYnJvd3Nlci5uYW1lID09PSAnQ2hyb21lJyAmJiBicm93c2VyLm9zICE9PSAnaU9TJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdTYWZhcmknO1xufVxuZnVuY3Rpb24gaXNTYWZhcmlCYXNlZCgpIHtcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcbiAgcmV0dXJuIChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIubmFtZSkgPT09ICdTYWZhcmknIHx8IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIub3MpID09PSAnaU9TJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpMTdCYXNlZCgpIHtcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcbiAgcmV0dXJuIChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIubmFtZSkgPT09ICdTYWZhcmknICYmIGIudmVyc2lvbi5zdGFydHNXaXRoKCcxNy4nKSB8fCAoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm9zKSA9PT0gJ2lPUycgJiYgISEoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLm9zVmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGIub3NWZXJzaW9uLCAnMTcnKSA+PSAwO1xufVxuZnVuY3Rpb24gaXNTYWZhcmlTdmNBcGkoYnJvd3Nlcikge1xuICBpZiAoIWJyb3dzZXIpIHtcbiAgICBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICB9XG4gIC8vIFNhZmFyaSAxOC40IHJlcXVpcmVzIGxlZ2FjeSBzdmMgYXBpIGFuZCBzY2FsZVJlc29sdXRpb25Eb3duIHRvIGJlIHNldFxuICByZXR1cm4gKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE4LjMnKSA+IDAgfHwgKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5vcykgPT09ICdpT1MnICYmICEhKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5vc1ZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLm9zVmVyc2lvbiwgJzE4LjMnKSA+IDA7XG59XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKCFpc1dlYigpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgdXNlckFnZW50RGF0YWAgaXMgbm90IHlldCBwYXJ0IG9mIHR5cGVzY3JpcHRcbiAgICAoX2IgPSAoX2EgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vYmlsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogL1RhYmxldHxpUGFkfE1vYmlsZXxBbmRyb2lkfEJsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCgpIHtcbiAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgY29uc3Qgc3VwcG9ydGVkU2FmYXJpVmVyc2lvbiA9ICcxNy4yJzsgLy8gc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTc4MDNcbiAgaWYgKGJyb3dzZXIpIHtcbiAgICBpZiAoYnJvd3Nlci5uYW1lICE9PSAnU2FmYXJpJyAmJiBicm93c2VyLm9zICE9PSAnaU9TJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChicm93c2VyLm9zID09PSAnaU9TJyAmJiBicm93c2VyLm9zVmVyc2lvbiAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci5vc1ZlcnNpb24sIHN1cHBvcnRlZFNhZmFyaVZlcnNpb24pID49IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYnJvd3Nlci5uYW1lID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCBzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uKSA+PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNXZWIoKSB7XG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgLy8gbmF2aWdhdG9yLnByb2R1Y3QgaXMgZGVwcmVjYXRlZCBvbiBicm93c2VycywgYnV0IHdpbGwgYmUgc2V0IGFwcHJvcHJpYXRlbHkgZm9yIHJlYWN0LW5hdGl2ZS5cbiAgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0ID09ICdSZWFjdE5hdGl2ZSc7XG59XG5mdW5jdGlvbiBpc0Nsb3VkKHNlcnZlclVybCkge1xuICByZXR1cm4gc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5jbG91ZCcpIHx8IHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQucnVuJyk7XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvamVjdEZyb21Vcmwoc2VydmVyVXJsKSB7XG4gIGlmICghaXNDbG91ZChzZXJ2ZXJVcmwpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHNlcnZlclVybC5ob3N0bmFtZS5zcGxpdCgnLicpWzBdO1xufVxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKSB7XG4gIC8vIGdsb2JhbCBkZWZpbmVkIG9ubHkgZm9yIFJlYWN0TmF0aXZlLlxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpIHtcbiAgaWYgKCFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgaWYgKGlzV2ViKCkpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG4vKipcbiAqIEBwYXJhbSB2MSAtIFRoZSBmaXJzdCB2ZXJzaW9uIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIHYyIC0gVGhlIHNlY29uZCB2ZXJzaW9uIHN0cmluZyB0byBjb21wYXJlLlxuICogQHJldHVybnMgQSBudW1iZXIgaW5kaWNhdGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnNpb25zOlxuICogICAtIDEgaWYgdjEgaXMgZ3JlYXRlciB0aGFuIHYyXG4gKiAgIC0gLTEgaWYgdjEgaXMgbGVzcyB0aGFuIHYyXG4gKiAgIC0gMCBpZiB2MSBhbmQgdjIgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcbiAgY29uc3QgcGFydHMxID0gdjEuc3BsaXQoJy4nKTtcbiAgY29uc3QgcGFydHMyID0gdjIuc3BsaXQoJy4nKTtcbiAgY29uc3QgayA9IE1hdGgubWluKHBhcnRzMS5sZW5ndGgsIHBhcnRzMi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIGNvbnN0IHAxID0gcGFyc2VJbnQocGFydHMxW2ldLCAxMCk7XG4gICAgY29uc3QgcDIgPSBwYXJzZUludChwYXJ0czJbaV0sIDEwKTtcbiAgICBpZiAocDEgPiBwMikgcmV0dXJuIDE7XG4gICAgaWYgKHAxIDwgcDIpIHJldHVybiAtMTtcbiAgICBpZiAoaSA9PT0gayAtIDEgJiYgcDEgPT09IHAyKSByZXR1cm4gMDtcbiAgfVxuICBpZiAodjEgPT09ICcnICYmIHYyICE9PSAnJykge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmICh2MiA9PT0gJycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gcGFydHMxLmxlbmd0aCA9PSBwYXJ0czIubGVuZ3RoID8gMCA6IHBhcnRzMS5sZW5ndGggPCBwYXJ0czIubGVuZ3RoID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcm9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgZW50cnkudGFyZ2V0LmhhbmRsZVJlc2l6ZShlbnRyeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZChlbnRyeSk7XG4gIH1cbn1cbmxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG5jb25zdCBnZXRSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgaWYgKCFyZXNpemVPYnNlcnZlcikgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocm9EaXNwYXRjaENhbGxiYWNrKTtcbiAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufTtcbmxldCBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG51bGw7XG5jb25zdCBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICgpID0+IHtcbiAgaWYgKCFpbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGlvRGlzcGF0Y2hDYWxsYmFjaywge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIHJvb3RNYXJnaW46ICcwcHgnXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbk9ic2VydmVyO1xufTtcbmZ1bmN0aW9uIGdldENsaWVudEluZm8oKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaW5mbyA9IG5ldyBDbGllbnRJbmZvKHtcbiAgICBzZGs6IENsaWVudEluZm9fU0RLLkpTLFxuICAgIHByb3RvY29sOiBwcm90b2NvbFZlcnNpb24sXG4gICAgdmVyc2lvblxuICB9KTtcbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGluZm8ub3MgPSAoX2EgPSBnZXRSZWFjdE5hdGl2ZU9zKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxubGV0IGVtcHR5VmlkZW9TdHJlYW1UcmFjaztcbmZ1bmN0aW9uIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaygpIHtcbiAgaWYgKCFlbXB0eVZpZGVvU3RyZWFtVHJhY2spIHtcbiAgICBlbXB0eVZpZGVvU3RyZWFtVHJhY2sgPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soKTtcbiAgfVxuICByZXR1cm4gZW1wdHlWaWRlb1N0cmVhbVRyYWNrLmNsb25lKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGxldCB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTY7XG4gIGxldCBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE2O1xuICBsZXQgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGxldCBwYWludENvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgLy8gdGhlIGNhbnZhcyBzaXplIGlzIHNldCB0byAxNiBieSBkZWZhdWx0LCBiZWNhdXNlIGVsZWN0cm9uIGFwcHMgc2VlbSB0byBmYWlsIHdpdGggc21hbGxlciB2YWx1ZXNcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgaWYgKHBhaW50Q29udGVudCAmJiBjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDUwLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnZ3JleSc7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IGR1bW15U3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oKTtcbiAgY29uc3QgW2R1bW15VHJhY2tdID0gZHVtbXlTdHJlYW0uZ2V0VHJhY2tzKCk7XG4gIGlmICghZHVtbXlUcmFjaykge1xuICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSB2aWRlbyB0cmFjaycpO1xuICB9XG4gIGR1bW15VHJhY2suZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIHJldHVybiBkdW1teVRyYWNrO1xufVxubGV0IGVtcHR5QXVkaW9TdHJlYW1UcmFjaztcbmZ1bmN0aW9uIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpIHtcbiAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dlYnJ0Yy93YXJtLXVwLXdpdGgtcmVwbGFjZXRyYWNrL1xuICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICBjb25zdCBvc2NpbGxhdG9yID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICBjb25zdCBnYWluID0gY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICBnYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgMCk7XG4gICAgY29uc3QgZHN0ID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbik7XG4gICAgZ2Fpbi5jb25uZWN0KGRzdCk7XG4gICAgb3NjaWxsYXRvci5zdGFydCgpO1xuICAgIFtlbXB0eUF1ZGlvU3RyZWFtVHJhY2tdID0gZHN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gYXVkaW8gdHJhY2snKTtcbiAgICB9XG4gICAgZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmNsb25lKCk7XG59XG5jbGFzcyBGdXR1cmUge1xuICBnZXQgaXNSZXNvbHZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSZXNvbHZlZDtcbiAgfVxuICBjb25zdHJ1Y3RvcihmdXR1cmVCYXNlLCBvbkZpbmFsbHkpIHtcbiAgICB0aGlzLl9pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5vbkZpbmFsbHkgPSBvbkZpbmFsbHk7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcbiAgICAgICAgeWllbGQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuX2lzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgKF9hID0gdGhpcy5vbkZpbmFsbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYW5hbHlzZXIgd2ViIGF1ZGlvIG5vZGUgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdHJhY2suXG4gKiBBZGRpdGlvbmFsbHkgcmV0dXJucyBhIGNvbnZlbmllbmNlIG1ldGhvZCBgY2FsY3VsYXRlVm9sdW1lYCB0byBwZXJmb3JtIGluc3RhbnQgdm9sdW1lIHJlYWRpbmdzIG9uIHRoYXQgdHJhY2suXG4gKiBDYWxsIHRoZSByZXR1cm5lZCBgY2xlYW51cGAgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGhlbHBlclxuICovXG5mdW5jdGlvbiBjcmVhdGVBdWRpb0FuYWx5c2VyKHRyYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBjbG9uZVRyYWNrOiBmYWxzZSxcbiAgICBmZnRTaXplOiAyMDQ4LFxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxuICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgIG1heERlY2liZWxzOiAtODBcbiAgfSwgb3B0aW9ucyk7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXVkaW8gQ29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuICB9XG4gIGNvbnN0IHN0cmVhbVRyYWNrID0gb3B0cy5jbG9uZVRyYWNrID8gdHJhY2subWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpIDogdHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgY29uc3QgbWVkaWFTdHJlYW1Tb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFtzdHJlYW1UcmFja10pKTtcbiAgY29uc3QgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgYW5hbHlzZXIubWluRGVjaWJlbHMgPSBvcHRzLm1pbkRlY2liZWxzO1xuICBhbmFseXNlci5tYXhEZWNpYmVscyA9IG9wdHMubWF4RGVjaWJlbHM7XG4gIGFuYWx5c2VyLmZmdFNpemUgPSBvcHRzLmZmdFNpemU7XG4gIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG9wdHMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHRyYWNrIGluIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxuICAgKi9cbiAgY29uc3QgY2FsY3VsYXRlVm9sdW1lID0gKCkgPT4ge1xuICAgIGFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSk7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChjb25zdCBhbXBsaXR1ZGUgb2YgZGF0YUFycmF5KSB7XG4gICAgICBzdW0gKz0gTWF0aC5wb3coYW1wbGl0dWRlIC8gMjU1LCAyKTtcbiAgICB9XG4gICAgY29uc3Qgdm9sdW1lID0gTWF0aC5zcXJ0KHN1bSAvIGRhdGFBcnJheS5sZW5ndGgpO1xuICAgIHJldHVybiB2b2x1bWU7XG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgeWllbGQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgaWYgKG9wdHMuY2xvbmVUcmFjaykge1xuICAgICAgc3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsY3VsYXRlVm9sdW1lLFxuICAgIGFuYWx5c2VyLFxuICAgIGNsZWFudXBcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXVkaW9Db2RlYyhtYXliZUNvZGVjKSB7XG4gIHJldHVybiBhdWRpb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW9Db2RlYyhtYXliZUNvZGVjKSB7XG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjKTtcbn1cbmZ1bmN0aW9uIHVud3JhcENvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb25zdHJhaW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuZXhhY3QpKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWludC5leGFjdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3Q7XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuaWRlYWwpKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWw7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCB1bndyYXAgY29uc3RyYWludCcpO1xufVxuZnVuY3Rpb24gdG9XZWJzb2NrZXRVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHRvSHR0cFVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCd3cycpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKHdzKS8sICdodHRwJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2NyaXB0aW9uU2VnbWVudHModHJhbnNjcmlwdGlvbiwgZmlyc3RSZWNlaXZlZFRpbWVzTWFwKSB7XG4gIHJldHVybiB0cmFuc2NyaXB0aW9uLnNlZ21lbnRzLm1hcChfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgaWQsXG4gICAgICB0ZXh0LFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgZmluYWxcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmlyc3RSZWNlaXZlZFRpbWUgPSAoX2EgPSBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZ2V0KGlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZS5ub3coKTtcbiAgICBjb25zdCBsYXN0UmVjZWl2ZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5kZWxldGUoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuc2V0KGlkLCBmaXJzdFJlY2VpdmVkVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHRleHQsXG4gICAgICBzdGFydFRpbWU6IE51bWJlci5wYXJzZUludChzdGFydFRpbWUudG9TdHJpbmcoKSksXG4gICAgICBlbmRUaW1lOiBOdW1iZXIucGFyc2VJbnQoZW5kVGltZS50b1N0cmluZygpKSxcbiAgICAgIGZpbmFsLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBmaXJzdFJlY2VpdmVkVGltZSxcbiAgICAgIGxhc3RSZWNlaXZlZFRpbWVcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDaGF0TWVzc2FnZShtc2cpIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIHRpbWVzdGFtcCxcbiAgICBtZXNzYWdlLFxuICAgIGVkaXRUaW1lc3RhbXBcbiAgfSA9IG1zZztcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0aW1lc3RhbXA6IE51bWJlci5wYXJzZUludCh0aW1lc3RhbXAudG9TdHJpbmcoKSksXG4gICAgZWRpdFRpbWVzdGFtcDogZWRpdFRpbWVzdGFtcCA/IE51bWJlci5wYXJzZUludChlZGl0VGltZXN0YW1wLnRvU3RyaW5nKCkpIDogdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGUpIHtcbiAgc3dpdGNoIChlLnJlYXNvbikge1xuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdDpcbiAgICAgIHJldHVybiBlLmNvbnRleHQ7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkOlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRDtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkOlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uVVNFUl9SRUpFQ1RFRDtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZTpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkpPSU5fRkFJTFVSRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG4gIH1cbn1cbi8qKiBjb252ZXJ0IGJpZ2ludHMgdG8gbnVtYmVycyBwcmVzZXJ2aW5nIHVuZGVmaW5lZCB2YWx1ZXMgKi9cbmZ1bmN0aW9uIGJpZ0ludFRvTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKHZhbHVlKSA6IHVuZGVmaW5lZDtcbn1cbi8qKiBjb252ZXJ0IG51bWJlcnMgdG8gYmlnaW50cyBwcmVzZXJ2aW5nIHVuZGVmaW5lZCB2YWx1ZXMgKi9cbmZ1bmN0aW9uIG51bWJlclRvQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gQmlnSW50KHZhbHVlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxUcmFjayh0cmFjaykge1xuICByZXR1cm4gISF0cmFjayAmJiAhKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykgJiYgdHJhY2suaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzQXVkaW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gISF0cmFjayAmJiB0cmFjay5raW5kID09IFRyYWNrLktpbmQuQXVkaW87XG59XG5mdW5jdGlvbiBpc1ZpZGVvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgdHJhY2sua2luZCA9PSBUcmFjay5LaW5kLlZpZGVvO1xufVxuZnVuY3Rpb24gaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuIGlzTG9jYWxUcmFjayh0cmFjaykgJiYgaXNWaWRlb1RyYWNrKHRyYWNrKTtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiBpc0xvY2FsVHJhY2sodHJhY2spICYmIGlzQXVkaW9UcmFjayh0cmFjayk7XG59XG5mdW5jdGlvbiBpc1JlbW90ZVRyYWNrKHRyYWNrKSB7XG4gIHJldHVybiAhIXRyYWNrICYmICF0cmFjay5pc0xvY2FsO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVQdWIocHViKSB7XG4gIHJldHVybiAhIXB1YiAmJiAhcHViLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBpc1JlbW90ZVZpZGVvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuIGlzUmVtb3RlVHJhY2sodHJhY2spICYmIGlzVmlkZW9UcmFjayh0cmFjayk7XG59XG5mdW5jdGlvbiBpc0xvY2FsUGFydGljaXBhbnQocCkge1xuICByZXR1cm4gcC5pc0xvY2FsO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVQYXJ0aWNpcGFudChwKSB7XG4gIHJldHVybiAhcC5pc0xvY2FsO1xufVxuZnVuY3Rpb24gc3BsaXRVdGY4KHMsIG4pIHtcbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82MDQzNzk3XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTtcbiAgd2hpbGUgKGVuY29kZWQubGVuZ3RoID4gbikge1xuICAgIGxldCBrID0gbjtcbiAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSBlbmNvZGVkW2tdO1xuICAgICAgaWYgKGJ5dGUgIT09IHVuZGVmaW5lZCAmJiAoYnl0ZSAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgay0tO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChlbmNvZGVkLnNsaWNlKDAsIGspKTtcbiAgICBlbmNvZGVkID0gZW5jb2RlZC5zbGljZShrKTtcbiAgfVxuICBpZiAoZW5jb2RlZC5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LnB1c2goZW5jb2RlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RNYXhBZ2VGcm9tUmVxdWVzdEhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGNhY2hlQ29udHJvbCA9IGhlYWRlcnMuZ2V0KCdDYWNoZS1Db250cm9sJyk7XG4gIGlmIChjYWNoZUNvbnRyb2wpIHtcbiAgICBjb25zdCBtYXhBZ2UgPSAoX2EgPSBjYWNoZUNvbnRyb2wubWF0Y2goLyg/Ol58WyxcXHNdKW1heC1hZ2U9KFxcZCspLykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbiAgICBpZiAobWF4QWdlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQobWF4QWdlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59ZnVuY3Rpb24gY3JlYXRlUnRjVXJsKHVybCwgc2VhcmNoUGFyYW1zKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9XZWJzb2NrZXRVcmwodXJsKSk7XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgdXJsT2JqLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICdydGMnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1dzVXJsKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9IdHRwVXJsKHJ0Y1dzVXJsKSk7XG4gIHJldHVybiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgJ3ZhbGlkYXRlJyk7XG59XG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSA/IHBhdGggOiBcIlwiLmNvbmNhdChwYXRoLCBcIi9cIik7XG59XG5mdW5jdGlvbiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgcGF0aCkge1xuICB1cmxPYmoucGF0aG5hbWUgPSBcIlwiLmNvbmNhdChlbnN1cmVUcmFpbGluZ1NsYXNoKHVybE9iai5wYXRobmFtZSkpLmNvbmNhdChwYXRoKTtcbiAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcGFyc2VTaWduYWxSZXNwb25zZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTaWduYWxSZXNwb25zZS5mcm9tSnNvbihKU09OLnBhcnNlKHZhbHVlKSwge1xuICAgICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBkZWNvZGUgd2Vic29ja2V0IG1lc3NhZ2U6IFwiLmNvbmNhdCh0eXBlb2YgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldEFib3J0UmVhc29uQXNTdHJpbmcoc2lnbmFsKSB7XG4gIGxldCBkZWZhdWx0TWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ1Vua25vd24gcmVhc29uJztcbiAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNZXNzYWdlO1xuICB9XG4gIGNvbnN0IHJlYXNvbiA9IHNpZ25hbC5yZWFzb247XG4gIHN3aXRjaCAodHlwZW9mIHJlYXNvbikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gcmVhc29uO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24ubWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3RvU3RyaW5nJyBpbiByZWFzb24gPyByZWFzb24udG9TdHJpbmcoKSA6IGRlZmF1bHRNZXNzYWdlO1xuICB9XG59Y29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XG4vLyBIb3cgbWFueSBjb25zZWN1dGl2ZSBmcmFtZXMgY2FuIGZhaWwgZGVjcnlwdGluZyBiZWZvcmUgYSBwYXJ0aWN1bGFyIGtleSBnZXRzIG1hcmtlZCBhcyBpbnZhbGlkXG5jb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmNvbnN0IEUyRUVfRkxBRyA9ICdsa19lMmVlJztcbmNvbnN0IFNBTFQgPSAnTEtGcmFtZUVuY3J5cHRpb25LZXknO1xuY29uc3QgS0VZX1BST1ZJREVSX0RFRkFVTFRTID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UsXG4gIGtleXJpbmdTaXplOiAxNlxufTt2YXIgS2V5UHJvdmlkZXJFdmVudDtcbihmdW5jdGlvbiAoS2V5UHJvdmlkZXJFdmVudCkge1xuICBLZXlQcm92aWRlckV2ZW50W1wiU2V0S2V5XCJdID0gXCJzZXRLZXlcIjtcbiAgLyoqIEV2ZW50IGZvciByZXF1ZXN0aW5nIHRvIHJhdGNoZXQgdGhlIGtleSB1c2VkIHRvIGVuY3J5cHQgdGhlIHN0cmVhbSAqL1xuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XG4gIC8qKiBFbWl0dGVkIHdoZW4gYSBrZXkgaXMgcmF0Y2hldGVkLiBDb3VsZCBiZSBhZnRlciBhdXRvLXJhdGNoZXRpbmcgb24gZGVjcnlwdGlvbiBmYWlsdXJlIG9yXG4gICAqICBmb2xsb3dpbmcgYSBgUmF0Y2hldFJlcXVlc3RgLCB3aWxsIGNvbnRhaW4gdGhlIHJhdGNoZXRlZCBrZXkgbWF0ZXJpYWwgKi9cbiAgS2V5UHJvdmlkZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlQcm92aWRlckV2ZW50IHx8IChLZXlQcm92aWRlckV2ZW50ID0ge30pKTtcbnZhciBLZXlIYW5kbGVyRXZlbnQ7XG4oZnVuY3Rpb24gKEtleUhhbmRsZXJFdmVudCkge1xuICAvKiogRW1pdHRlZCB3aGVuIGEga2V5IGhhcyBiZWVuIHJhdGNoZXRlZC4gSXMgZW1pdHRlZCB3aGVuIGFueSBrZXkgaGFzIGJlZW4gcmF0Y2hldGVkXG4gICAqIGkuZS4gd2hlbiB0aGUgRnJhbWVDcnlwdG9yIHRyaWVkIHRvIHJhdGNoZXQgd2hlbiBkZWNyeXB0aW9uIGlzIGZhaWxpbmcgICovXG4gIEtleUhhbmRsZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XG59KShLZXlIYW5kbGVyRXZlbnQgfHwgKEtleUhhbmRsZXJFdmVudCA9IHt9KSk7XG52YXIgRW5jcnlwdGlvbkV2ZW50O1xuKGZ1bmN0aW9uIChFbmNyeXB0aW9uRXZlbnQpIHtcbiAgRW5jcnlwdGlvbkV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICBFbmNyeXB0aW9uRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xufSkoRW5jcnlwdGlvbkV2ZW50IHx8IChFbmNyeXB0aW9uRXZlbnQgPSB7fSkpO1xudmFyIENyeXB0b3JFdmVudDtcbihmdW5jdGlvbiAoQ3J5cHRvckV2ZW50KSB7XG4gIENyeXB0b3JFdmVudFtcIkVycm9yXCJdID0gXCJjcnlwdG9yRXJyb3JcIjtcbn0pKENyeXB0b3JFdmVudCB8fCAoQ3J5cHRvckV2ZW50ID0ge30pKTtmdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1ZpZGVvRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEtleShrZXlCeXRlc18xKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChrZXlCeXRlcykge1xuICAgIGxldCBhbGdvcml0aG0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNXG4gICAgfTtcbiAgICBsZXQgdXNhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdlbmNyeXB0JztcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5XG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleUJ5dGVzLCBhbGdvcml0aG0sIGZhbHNlLCB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICB9KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKHBhc3N3b3JkKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGtleU1hdGVyaWFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGVuYy5lbmNvZGUocGFzc3dvcmQpLCB7XG4gICAgICBuYW1lOiAnUEJLREYyJ1xuICAgIH0sIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xuICAgIHJldHVybiBrZXlNYXRlcmlhbDtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoY3J5cHRvQnVmZmVyKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xuICAgIHJldHVybiBrZXlNYXRlcmlhbDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbGdvT3B0aW9ucyhhbGdvcml0aG1OYW1lLCBzYWx0KSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xuICBzd2l0Y2ggKGFsZ29yaXRobU5hbWUpIHtcbiAgICBjYXNlICdIS0RGJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaW5mbzogbmV3IEFycmF5QnVmZmVyKDEyOClcbiAgICAgIH07XG4gICAgY2FzZSAnUEJLREYyJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFsZ29yaXRobSBcIi5jb25jYXQoYWxnb3JpdGhtTmFtZSwgXCIgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkXCIpKTtcbiAgfVxufVxuLyoqXG4gKiBEZXJpdmVzIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgbWFzdGVyIGtleS5cbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjFcbiAqL1xuZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbCwgc2FsdCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVLZXkjSEtERlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXG4gICAgY29uc3QgZW5jcnlwdGlvbktleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KGFsZ29yaXRobU9wdGlvbnMsIG1hdGVyaWFsLCB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSxcbiAgICAgIGxlbmd0aDogMTI4XG4gICAgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRlcmlhbCxcbiAgICAgIGVuY3J5cHRpb25LZXlcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUUyRUVLZXkoKSB7XG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpO1xufVxuLyoqXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjUuMVxuICovXG5mdW5jdGlvbiByYXRjaGV0KG1hdGVyaWFsLCBzYWx0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUJpdHNcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKGFsZ29yaXRobU9wdGlvbnMsIG1hdGVyaWFsLCAyNTYpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5lZWRzUmJzcFVuZXNjYXBpbmcoZnJhbWVEYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVEYXRhLmxlbmd0aCAtIDM7IGkrKykge1xuICAgIGlmIChmcmFtZURhdGFbaV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDFdID09IDAgJiYgZnJhbWVEYXRhW2kgKyAyXSA9PSAzKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZVJic3Aoc3RyZWFtKSB7XG4gIGNvbnN0IGRhdGFPdXQgPSBbXTtcbiAgdmFyIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLmxlbmd0aDspIHtcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXG4gICAgLy8gYWJvdmUsIGFuZCB0aGF0IGV4cHJlc3Npb24gd2lsbCBwcm9kdWNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCBpblxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xuICAgICAgLy8gVHdvIHJic3AgYnl0ZXMuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIC8vIFNraXAgdGhlIGVtdWxhdGlvbiBieXRlLlxuICAgICAgaSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcmJzcCBieXRlLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuY29uc3Qga1plcm9zSW5TdGFydFNlcXVlbmNlID0gMjtcbmNvbnN0IGtFbXVsYXRpb25CeXRlID0gMztcbmZ1bmN0aW9uIHdyaXRlUmJzcChkYXRhX2luKSB7XG4gIGNvbnN0IGRhdGFPdXQgPSBbXTtcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnl0ZSA9IGRhdGFfaW5baV07XG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxuICAgICAgZGF0YU91dC5wdXNoKGtFbXVsYXRpb25CeXRlKTtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgICBkYXRhT3V0LnB1c2goYnl0ZSk7XG4gICAgaWYgKGJ5dGUgPT0gMCkge1xuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuZnVuY3Rpb24gYXNFbmNyeXB0YWJsZVBhY2tldChwYWNrZXQpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgaWYgKCgoX2EgPSBwYWNrZXQudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYXNlKSAhPT0gJ3NpcER0bWYnICYmICgoX2IgPSBwYWNrZXQudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSAhPT0gJ21ldHJpY3MnICYmICgoX2MgPSBwYWNrZXQudmFsdWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXNlKSAhPT0gJ3NwZWFrZXInICYmICgoX2QgPSBwYWNrZXQudmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYXNlKSAhPT0gJ3RyYW5zY3JpcHRpb24nICYmICgoX2UgPSBwYWNrZXQudmFsdWUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYXNlKSAhPT0gJ2VuY3J5cHRlZFBhY2tldCcpIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRlZFBhY2tldFBheWxvYWQoe1xuICAgICAgdmFsdWU6IHBhY2tldC52YWx1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59LyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEJhc2VLZXlQcm92aWRlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgYmVpbmcgaW52b2tlZCBhZnRlciBhIGtleSBoYXMgYmVlbiByYXRjaGV0ZWQuXG4gICAgICogQ2FuIGhhcHBlbiB3aGVuOlxuICAgICAqIC0gQSBkZWNyeXB0aW9uIGZhaWx1cmUgb2NjdXJzIGFuZCB0aGUga2V5IGlzIGF1dG8tcmF0Y2hldGVkXG4gICAgICogLSBBIHJhdGNoZXQgcmVxdWVzdCBpcyBzZW50IChzZWUge0BsaW5rIHJhdGNoZXRLZXkoKX0pXG4gICAgICogQHBhcmFtIHJhdGNoZXRSZXN1bHQgQ29udGFpbnMgdGhlIHJhdGNoZXRlZCBjaGFpbiBrZXkgKGV4cG9ydGFibGUgdG8gb3RoZXIgcGFydGljaXBhbnRzKSBhbmQgdGhlIGRlcml2ZWQgbmV3IGtleSBtYXRlcmlhbC5cbiAgICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZFxuICAgICAqIEBwYXJhbSBrZXlJbmRleFxuICAgICAqL1xuICAgIHRoaXMub25LZXlSYXRjaGV0ZWQgPSAocmF0Y2hldFJlc3VsdCwgcGFydGljaXBhbnRJZCwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2tleSByYXRjaGV0ZWQgZXZlbnQgcmVjZWl2ZWQnLCB7XG4gICAgICAgIHJhdGNoZXRSZXN1bHQsXG4gICAgICAgIHBhcnRpY2lwYW50SWQsXG4gICAgICAgIGtleUluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMua2V5SW5mb01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEtFWV9QUk9WSURFUl9ERUZBVUxUUyksIG9wdGlvbnMpO1xuICAgIHRoaXMub24oS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIHRoaXMub25LZXlSYXRjaGV0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsYmFjayB0byBpbnZva2Ugb25jZSBhIGtleSBoYXMgYmVlbiBzZXQgZm9yIGEgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZGVudGl0eVxuICAgKiBAcGFyYW0ga2V5SW5kZXhcbiAgICovXG4gIG9uU2V0RW5jcnlwdGlvbktleShrZXksIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgY29uc3Qga2V5SW5mbyA9IHtcbiAgICAgIGtleSxcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlJbmRleFxuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hhcmVkS2V5ICYmICFwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpY2lwYW50IGlkZW50aXR5IG5lZWRzIHRvIGJlIHBhc3NlZCBmb3IgZW5jcnlwdGlvbiBrZXkgaWYgc2hhcmVkS2V5IG9wdGlvbiBpcyBmYWxzZScpO1xuICAgIH1cbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KFwiXCIuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IG51bGwgJiYgcGFydGljaXBhbnRJZGVudGl0eSAhPT0gdm9pZCAwID8gcGFydGljaXBhbnRJZGVudGl0eSA6ICdzaGFyZWQnLCBcIi1cIikuY29uY2F0KGtleUluZGV4ICE9PSBudWxsICYmIGtleUluZGV4ICE9PSB2b2lkIDAgPyBrZXlJbmRleCA6IDApLCBrZXlJbmZvKTtcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8pO1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlJbmZvTWFwLnZhbHVlcygpKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gIH1cbn1cbi8qKlxuICogQSBiYXNpYyBLZXlQcm92aWRlciBpbXBsZW1lbnRhdGlvbiBpbnRlbmRlZCBmb3IgYSBzaW5nbGUgc2hhcmVkXG4gKiBwYXNzcGhyYXNlIGJldHdlZW4gYWxsIHBhcnRpY2lwYW50c1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgc2hhcmVkS2V5OiB0cnVlLFxuICAgICAgLy8gZm9yIGEgc2hhcmVkIGtleSBwcm92aWRlciBmYWlsaW5nIHRvIGRlY3J5cHQgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnRcbiAgICAgIC8vIHNob3VsZCBub3QgbWFyayB0aGUga2V5IGFzIGludmFsaWQsIHNvIHdlIGFjY2VwdCB3cm9uZyBrZXlzIGZvcmV2ZXJcbiAgICAgIC8vIGFuZCB3b24ndCB0cnkgdG8gYXV0by1yYXRjaGV0XG4gICAgICByYXRjaGV0V2luZG93U2l6ZTogMCxcbiAgICAgIGZhaWx1cmVUb2xlcmFuY2U6IC0xXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBzZXRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHlpZWxkIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhrZXkpIDogeWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGtleSk7XG4gICAgICB0aGlzLm9uU2V0RW5jcnlwdGlvbktleShkZXJpdmVkS2V5KTtcbiAgICB9KTtcbiAgfVxufXZhciBDcnlwdG9yRXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKENyeXB0b3JFcnJvclJlYXNvbikge1xuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiSW52YWxpZEtleVwiXSA9IDBdID0gXCJJbnZhbGlkS2V5XCI7XG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJNaXNzaW5nS2V5XCJdID0gMV0gPSBcIk1pc3NpbmdLZXlcIjtcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIkludGVybmFsRXJyb3JcIl0gPSAyXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xufSkoQ3J5cHRvckVycm9yUmVhc29uIHx8IChDcnlwdG9yRXJyb3JSZWFzb24gPSB7fSkpO1xuY2xhc3MgQ3J5cHRvckVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IENyeXB0b3JFcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yO1xuICAgIGxldCBwYXJ0aWNpcGFudElkZW50aXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIoNDAsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIH1cbn0vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuY2xhc3MgRTJFRU1hbmFnZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGRjRW5jcnlwdGlvbkVuYWJsZWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVjcnlwdERhdGFSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuY3J5cHREYXRhUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vbldvcmtlck1lc3NhZ2UgPSBldiA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3Qge1xuICAgICAgICBraW5kLFxuICAgICAgICBkYXRhXG4gICAgICB9ID0gZXYuZGF0YTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIC8vIElmIGVycm9yIGhhcyB1dWlkLCBpdCdzIGZyb20gYW4gYXN5bmMgb3BlcmF0aW9uIChlbmNyeXB0L2RlY3J5cHQpXG4gICAgICAgICAgLy8gUmVqZWN0IHRoZSBjb3JyZXNwb25kaW5nIGZ1dHVyZVxuICAgICAgICAgIGlmIChkYXRhLnV1aWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRGdXR1cmUgPSB0aGlzLmRlY3J5cHREYXRhUmVxdWVzdHMuZ2V0KGRhdGEudXVpZCk7XG4gICAgICAgICAgICBpZiAoZGVjcnlwdEZ1dHVyZSA9PT0gbnVsbCB8fCBkZWNyeXB0RnV0dXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNyeXB0RnV0dXJlLnJlamVjdCkge1xuICAgICAgICAgICAgICBkZWNyeXB0RnV0dXJlLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7IC8vIERvbid0IGVtaXQgZ2VuZXJhbCBlcnJvciBpZiBpdCdzIGhhbmRsZWQgYnkgZnV0dXJlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0RnV0dXJlID0gdGhpcy5lbmNyeXB0RGF0YVJlcXVlc3RzLmdldChkYXRhLnV1aWQpO1xuICAgICAgICAgICAgaWYgKGVuY3J5cHRGdXR1cmUgPT09IG51bGwgfHwgZW5jcnlwdEZ1dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5jcnlwdEZ1dHVyZS5yZWplY3QpIHtcbiAgICAgICAgICAgICAgZW5jcnlwdEZ1dHVyZS5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgIGJyZWFrOyAvLyBEb24ndCBlbWl0IGdlbmVyYWwgZXJyb3IgaWYgaXQncyBoYW5kbGVkIGJ5IGZ1dHVyZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbWl0IGdlbmVyYWwgZXJyb3IgZXZlbnQgZm9yIHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZGF0YS5lcnJvciwgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdEFjayc6XG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbmFibGUnOlxuICAgICAgICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSAoX2IgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY291bGRuJ3Qgc2V0IGVuY3J5cHRpb24gc3RhdHVzLCBwYXJ0aWNpcGFudCBub3QgZm91bmRcIi5jb25jYXQoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmF0Y2hldEtleSc6XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLnJhdGNoZXRSZXN1bHQsIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSwgZGF0YS5rZXlJbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlY3J5cHREYXRhUmVzcG9uc2UnOlxuICAgICAgICAgIGNvbnN0IGRlY3J5cHRGdXR1cmUgPSB0aGlzLmRlY3J5cHREYXRhUmVxdWVzdHMuZ2V0KGRhdGEudXVpZCk7XG4gICAgICAgICAgaWYgKGRlY3J5cHRGdXR1cmUgPT09IG51bGwgfHwgZGVjcnlwdEZ1dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVjcnlwdEZ1dHVyZS5yZXNvbHZlKSB7XG4gICAgICAgICAgICBkZWNyeXB0RnV0dXJlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbmNyeXB0RGF0YVJlc3BvbnNlJzpcbiAgICAgICAgICBjb25zdCBlbmNyeXB0RnV0dXJlID0gdGhpcy5lbmNyeXB0RGF0YVJlcXVlc3RzLmdldChkYXRhLnV1aWQpO1xuICAgICAgICAgIGlmIChlbmNyeXB0RnV0dXJlID09PSBudWxsIHx8IGVuY3J5cHRGdXR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuY3J5cHRGdXR1cmUucmVzb2x2ZSkge1xuICAgICAgICAgICAgZW5jcnlwdEZ1dHVyZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25Xb3JrZXJFcnJvciA9IGV2ID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoJ2UyZWUgd29ya2VyIGVuY291bnRlcmVkIGFuIGVycm9yOicsIHtcbiAgICAgICAgZXJyb3I6IGV2LmVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBldi5lcnJvciwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHRoaXMua2V5UHJvdmlkZXIgPSBvcHRpb25zLmtleVByb3ZpZGVyO1xuICAgIHRoaXMud29ya2VyID0gb3B0aW9ucy53b3JrZXI7XG4gICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YUNoYW5uZWxFbmNyeXB0aW9uRW5hYmxlZCA9IGRjRW5jcnlwdGlvbkVuYWJsZWQ7XG4gIH1cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uRW5hYmxlZDtcbiAgfVxuICBnZXQgaXNEYXRhQ2hhbm5lbEVuY3J5cHRpb25FbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCAmJiB0aGlzLmRhdGFDaGFubmVsRW5jcnlwdGlvbkVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0dXAocm9vbSkge1xuICAgIGlmICghaXNFMkVFU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCd0cmllZCB0byBzZXR1cCBlbmQtdG8tZW5kIGVuY3J5cHRpb24gb24gYW4gdW5zdXBwb3J0ZWQgYnJvd3NlcicpO1xuICAgIH1cbiAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ3NldHRpbmcgdXAgZTJlZScpO1xuICAgIGlmIChyb29tICE9PSB0aGlzLnJvb20pIHtcbiAgICAgIHRoaXMucm9vbSA9IHJvb207XG4gICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwgdGhpcy5rZXlQcm92aWRlcik7XG4gICAgICAvLyB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoJycpO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBrZXlQcm92aWRlck9wdGlvbnM6IHRoaXMua2V5UHJvdmlkZXIuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgIGxvZ2xldmVsOiB3b3JrZXJMb2dnZXIuZ2V0TGV2ZWwoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcImluaXRpYWxpemluZyB3b3JrZXJcIiwge1xuICAgICAgICAgIHdvcmtlcjogdGhpcy53b3JrZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMub25Xb3JrZXJNZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5vbldvcmtlckVycm9yO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0IGUyZWUgdG8gXCIuY29uY2F0KGVuYWJsZWQsIFwiIGZvciBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0U2lmVHJhaWxlcih0cmFpbGVyKSB7XG4gICAgaWYgKCF0cmFpbGVyIHx8IHRyYWlsZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJpZ25vcmluZyBzZXJ2ZXIgc2VudCB0cmFpbGVyIGFzIGl0J3MgZW1wdHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zdFNpZlRyYWlsZXIodHJhaWxlcik7XG4gICAgfVxuICB9XG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xuICAgIGVuZ2luZS5vbihFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwID0+IHtcbiAgICAgIHRoaXMucG9zdFJUUE1hcChydHBNYXApO1xuICAgIH0pO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwga2V5UHJvdmlkZXIpIHtcbiAgICByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHB1YiwgcGFydGljaXBhbnQpID0+IHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSkpO1xuICAgIHJvb20ub24oUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHN0YXRlID0+IHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICByb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQocHViLnRyYWNrSW5mby5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSwgcGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsICh0cmFjaywgXywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ3JlbW92ZVRyYW5zZm9ybScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgICB0cmFja0lkOiB0cmFjay5tZWRpYVN0cmVhbUlEXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoX2EgPSB0aGlzLndvcmtlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSkub24oUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWIsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB0aGlzLnNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCBwYXJ0aWNpcGFudC5pZGVudGl0eSwgcHViLnRyYWNrSW5mbyk7XG4gICAgfSkub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJvb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGVkIHJvb20gdG8gYmUgcHJlc2VudCBvbiBzaWduYWwgY29ubmVjdFwiKTtcbiAgICAgIH1cbiAgICAgIGtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xuICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZCh0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pc0UyRUVFbmFibGVkLCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgfSk7XG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxTZW5kZXJDcmVhdGVkLCAoc2VuZGVyLCB0cmFjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zZXR1cEUyRUVTZW5kZXIodHJhY2ssIHNlbmRlcik7XG4gICAgfSkpO1xuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgcmV0cmlldmluZyBwYXlsb2FkIGluZm9ybWF0aW9uIG9uIFJUQ0VuY29kZWRWaWRlb0ZyYW1lLCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY29kZWMgbWFudWFsbHkgb25jZSB3ZSBoYXZlIHRoZSB0cmFja0luZm8gZnJvbSB0aGUgc2VydmVyXG4gICAgICBpZiAoIWlzVmlkZW9UcmFjayhwdWJsaWNhdGlvbi50cmFjaykgfHwgIWlzU2FmYXJpQmFzZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0cmFja0lkOiBwdWJsaWNhdGlvbi50cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgICAgIGNvZGVjOiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhwdWJsaWNhdGlvbi50cmFja0luZm8uY29kZWNzWzBdLm1pbWVUeXBlKSxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9KTtcbiAgICBrZXlQcm92aWRlci5vbihLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyA9PiB0aGlzLnBvc3RLZXkoa2V5SW5mbykpLm9uKEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4gdGhpcy5wb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZCwga2V5SW5kZXgpKTtcbiAgfVxuICBlbmNyeXB0RGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBlbmNyeXB0IGRhdGEsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB1dWlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2VuY3J5cHREYXRhUmVxdWVzdCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1dWlkLFxuICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgIGZ1dHVyZS5vbkZpbmFsbHkgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW5jcnlwdERhdGFSZXF1ZXN0cy5kZWxldGUodXVpZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbmNyeXB0RGF0YVJlcXVlc3RzLnNldCh1dWlkLCBmdXR1cmUpO1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIHJldHVybiBmdXR1cmUucHJvbWlzZTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVFbmNyeXB0ZWREYXRhKHBheWxvYWQsIGl2LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgaGFuZGxlIGVuY3J5cHRlZCBkYXRhLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCB1dWlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAnZGVjcnlwdERhdGFSZXF1ZXN0JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdXVpZCxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgaXYsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGtleUluZGV4XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgZnV0dXJlLm9uRmluYWxseSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGVjcnlwdERhdGFSZXF1ZXN0cy5kZWxldGUodXVpZCk7XG4gICAgfTtcbiAgICB0aGlzLmRlY3J5cHREYXRhUmVxdWVzdHMuc2V0KHV1aWQsIGZ1dHVyZSk7XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICByZXR1cm4gZnV0dXJlLnByb21pc2U7XG4gIH1cbiAgcG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCByYXRjaGV0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEtleShfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlJbmRleFxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHNldCBrZXksIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRLZXknLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBpc1B1Ymxpc2hlcjogcGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpLFxuICAgICAgICBrZXksXG4gICAgICAgIGtleUluZGV4XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgY29uc3QgZW5hYmxlTXNnID0ge1xuICAgICAgICBraW5kOiAnZW5hYmxlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYWJsZWQsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZW5hYmxlTXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdmYWlsZWQgdG8gZW5hYmxlIGUyZWUsIHdvcmtlciBpcyBub3QgcmVhZHknKTtcbiAgICB9XG4gIH1cbiAgcG9zdFJUUE1hcChtYXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdjb3VsZCBub3QgcG9zdCBydHAgbWFwLCBsb2NhbCBwYXJ0aWNpcGFudCBpZGVudGl0eSBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRSVFBNYXAnLFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXAsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHBvc3QgU0lGIHRyYWlsZXIsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIGtpbmQ6ICdzZXRTaWZUcmFpbGVyJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHJhaWxlclxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBzZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcmVtb3RlSWQsIHRyYWNrSW5mbykge1xuICAgIGlmICghdHJhY2sucmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodHJhY2tJbmZvID09PSBudWxsIHx8IHRyYWNrSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tJbmZvLm1pbWVUeXBlKSB8fCB0cmFja0luZm8ubWltZVR5cGUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaW1lVHlwZSBtaXNzaW5nIGZyb20gdHJhY2tJbmZvLCBjYW5ub3Qgc2V0IHVwIEUyRUUgY3J5cHRvcicpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVJlY2VpdmVyKHRyYWNrLnJlY2VpdmVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCByZW1vdGVJZCwgdHJhY2sua2luZCA9PT0gJ3ZpZGVvJyA/IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHRyYWNrSW5mby5taW1lVHlwZSkgOiB1bmRlZmluZWQpO1xuICB9XG4gIHNldHVwRTJFRVNlbmRlcih0cmFjaywgc2VuZGVyKSB7XG4gICAgaWYgKCFpc0xvY2FsVHJhY2sodHJhY2spIHx8ICFzZW5kZXIpIHtcbiAgICAgIGlmICghc2VuZGVyKSBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vhcmx5IHJldHVybiBiZWNhdXNlIHNlbmRlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlUmVjZWl2ZXIocmVjZWl2ZXIsIHRyYWNrSWQsIHBhcnRpY2lwYW50SWRlbnRpdHksIGNvZGVjKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkgJiZcbiAgICAgIC8vIENocm9tZSBvY2Nhc2lvbmFsbHkgdGhyb3dzIGFuIGBJbnZhbGlkU3RhdGVgIGVycm9yIHdoZW4gdXNpbmcgc2NyaXB0IHRyYW5zZm9ybXMgZGlyZWN0bHkgYWZ0ZXIgaW50cm9kdWNpbmcgdGhpcyBBUEkgaW4gMTQxLlxuICAgICAgLy8gRGlzYWJsaW5nIGl0IGZvciBDaHJvbWUgYmFzZWQgYnJvd3NlcnMgdW50aWwgdGhlIEFQSSBoYXMgc3RhYmlsaXplZFxuICAgICAgIWlzQ2hyb21pdW1CYXNlZCgpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIGNvZGVjXG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoRTJFRV9GTEFHIGluIHJlY2VpdmVyICYmIGNvZGVjKSB7XG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgY29kZWNcbiAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICBraW5kOiAndXBkYXRlQ29kZWMnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgd3JpdGFibGUgPSByZWNlaXZlci53cml0YWJsZVN0cmVhbTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcmVhZGFibGUgPSByZWNlaXZlci5yZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCF3cml0YWJsZSB8fCAhcmVhZGFibGUpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJTdHJlYW1zID0gcmVjZWl2ZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIud3JpdGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgd3JpdGFibGUgPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICAgIHJlYWRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbTogcmVhZGFibGUsXG4gICAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgICAgaXNSZXVzZTogRTJFRV9GTEFHIGluIHJlY2VpdmVyXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtyZWFkYWJsZSwgd3JpdGFibGVdKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlY2VpdmVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZW5jb2Rlci5cbiAgICpcbiAgICovXG4gIGhhbmRsZVNlbmRlcihzZW5kZXIsIHRyYWNrSWQsIGNvZGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB8fCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignbG9jYWwgaWRlbnRpdHkgbmVlZHMgdG8gYmUga25vd24gaW4gb3JkZXIgdG8gc2V0IHVwIGVuY3J5cHRlZCBzZW5kZXInKTtcbiAgICB9XG4gICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkgJiZcbiAgICAvLyBDaHJvbWUgb2NjYXNpb25hbGx5IHRocm93cyBhbiBgSW52YWxpZFN0YXRlYCBlcnJvciB3aGVuIHVzaW5nIHNjcmlwdCB0cmFuc2Zvcm1zIGRpcmVjdGx5IGFmdGVyIGludHJvZHVjaW5nIHRoaXMgQVBJIGluIDE0MS5cbiAgICAvLyBEaXNhYmxpbmcgaXQgZm9yIENocm9tZSBiYXNlZCBicm93c2VycyB1bnRpbCB0aGUgQVBJIGhhcyBzdGFiaWxpemVkXG4gICAgIWlzQ2hyb21pdW1CYXNlZCgpKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgc2NyaXB0IHRyYW5zZm9ybScpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogJ2VuY29kZScsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICB0cmFja0lkLFxuICAgICAgICBjb2RlY1xuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNlbmRlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIGVuY29kZWQgc3RyZWFtcycpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3Qgc2VuZGVyU3RyZWFtcyA9IHNlbmRlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiBzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLFxuICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiBzZW5kZXJTdHJlYW1zLndyaXRhYmxlLFxuICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgaXNSZXVzZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3NlbmRlclN0cmVhbXMucmVhZGFibGUsIHNlbmRlclN0cmVhbXMud3JpdGFibGVdKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNlbmRlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxufWNvbnN0IENPTk5FQ1RJT05fQkFDS09GRl9NSU5fTVMgPSA1MDA7XG5jb25zdCBDT05ORUNUSU9OX0JBQ0tPRkZfTUFYX01TID0gMTUwMDA7XG4vKipcbiAqIEJhY2tPZmZTdHJhdGVneSBpbXBsZW1lbnRzIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIGNvbm5lY3Rpb24gZmFpbHVyZXMuXG4gKlxuICogV2hlbiBzZXZlcmUgY29ubmVjdGlvbiBmYWlsdXJlcyBvY2N1ciAoZS5nLiwgbmV0d29yayBpc3N1ZXMsIHNlcnZlciB1bmF2YWlsYWJpbGl0eSksXG4gKiB0aGlzIHN0cmF0ZWd5IGludHJvZHVjZXMgaW5jcmVhc2luZyBkZWxheXMgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gYXZvaWRcbiAqIG92ZXJ3aGVsbWluZyB0aGUgc2VydmVyIGFuZCB0byBnaXZlIHRyYW5zaWVudCBpc3N1ZXMgdGltZSB0byByZXNvbHZlLlxuICpcbiAqIFRoaXMgc3RyYXRlZ3kgaXMgb25seSBhcHBsaWVkIHRvIExpdmVLaXQgQ2xvdWQgcHJvamVjdHMuIEl0IGlkZW50aWZpZXNcbiAqIHByb2plY3RzIGJ5IGV4dHJhY3RpbmcgdGhlIHByb2plY3QgbmFtZSBmcm9tIHRoZSBjb25uZWN0aW9uIFVSTCBhbmQgdHJhY2tzIGZhaWx1cmVzXG4gKiBwZXIgcHJvamVjdC4gU2VsZi1ob3N0ZWQgZGVwbG95bWVudHMgKFVSTHMgd2l0aG91dCBhIHByb2plY3QgaWRlbnRpZmllcikgYXJlIG5vdFxuICogc3ViamVjdCB0byBiYWNrb2ZmIGRlbGF5cy5cbiAqXG4gKiBUaGUgY2xhc3MgaXMgaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gdG8gbWFpbnRhaW4gY29uc2lzdGVudCBiYWNrb2ZmIHN0YXRlIGFjcm9zc1xuICogdGhlIGVudGlyZSBhcHBsaWNhdGlvbiBsaWZlY3ljbGUgaW5zdGVhZCBvZiByb29tIGluc3RhbmNlIGxpZmVjeWNsZS5cbiAqL1xuY2xhc3MgQmFja09mZlN0cmF0ZWd5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJhY2tPZmZQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgQmFja09mZlN0cmF0ZWd5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuICBhZGRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdCh1cmxTdHJpbmcpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gZXh0cmFjdFByb2plY3RGcm9tVXJsKHVybCk7XG4gICAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmFpbHVyZUNvdW50ID0gKF9hID0gdGhpcy5mYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMuZ2V0KHByb2plY3ROYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICB0aGlzLmZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cy5zZXQocHJvamVjdE5hbWUsIGZhaWx1cmVDb3VudCArIDEpO1xuICAgIHRoaXMuYmFja09mZlByb21pc2VzLnNldChwcm9qZWN0TmFtZSwgc2xlZXAoTWF0aC5taW4oQ09OTkVDVElPTl9CQUNLT0ZGX01JTl9NUyAqIE1hdGgucG93KDIsIGZhaWx1cmVDb3VudCksIENPTk5FQ1RJT05fQkFDS09GRl9NQVhfTVMpKSk7XG4gIH1cbiAgZ2V0QmFja09mZlByb21pc2UodXJsU3RyaW5nKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gdXJsICYmIGV4dHJhY3RQcm9qZWN0RnJvbVVybCh1cmwpO1xuICAgIGNvbnN0IGJhY2tvZmZQcm9taXNlID0gcHJvamVjdE5hbWUgJiYgdGhpcy5iYWNrT2ZmUHJvbWlzZXMuZ2V0KHByb2plY3ROYW1lKTtcbiAgICByZXR1cm4gYmFja29mZlByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVzZXRGYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHModXJsU3RyaW5nKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIGNvbnN0IHByb2plY3ROYW1lID0gdXJsICYmIGV4dHJhY3RQcm9qZWN0RnJvbVVybCh1cmwpO1xuICAgIGlmIChwcm9qZWN0TmFtZSkge1xuICAgICAgdGhpcy5mYWlsZWRDb25uZWN0aW9uQXR0ZW1wdHMuc2V0KHByb2plY3ROYW1lLCAwKTtcbiAgICAgIHRoaXMuYmFja09mZlByb21pc2VzLnNldChwcm9qZWN0TmFtZSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIH1cbiAgfVxuICByZXNldEFsbCgpIHtcbiAgICB0aGlzLmJhY2tPZmZQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmFpbGVkQ29ubmVjdGlvbkF0dGVtcHRzLmNsZWFyKCk7XG4gIH1cbn1cbkJhY2tPZmZTdHJhdGVneS5faW5zdGFuY2UgPSBudWxsO2NvbnN0IGRlZmF1bHRJZCA9ICdkZWZhdWx0JztcbmNsYXNzIERldmljZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wcmV2aW91c0RldmljZXMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBEZXZpY2VNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG4gIGdldCBwcmV2aW91c0RldmljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGV2aWNlcztcbiAgfVxuICBnZXREZXZpY2VzKGtpbmRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgPiAwKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnYXdhaXRpbmcgZ2V0VXNlck1lZGlhIHByb21pc2UnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGtpbmQpIHtcbiAgICAgICAgICAgICAgeWllbGQgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmdldChraW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdlcnJvciB3YWl0aW5nIGZvciBtZWRpYSBwZXJtaXNzb25zJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMgJiZcbiAgICAgICAgLy8gZm9yIHNhZmFyaSB3ZSBuZWVkIHRvIHNraXAgdGhpcyBjaGVjaywgYXMgb3RoZXJ3aXNlIGl0IHdpbGwgcmUtYWNxdWlyZSB1c2VyIG1lZGlhIGFuZCBmYWlsIG9uIGlPUyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgICAgICEoaXNTYWZhcmkoKSAmJiBfdGhpcy5oYXNEZXZpY2VJblVzZShraW5kKSkpIHtcbiAgICAgICAgICBjb25zdCBpc0R1bW15RGV2aWNlT3JFbXB0eSA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSBraW5kKS5sZW5ndGggPT09IDAgfHwgZGV2aWNlcy5zb21lKGRldmljZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub0xhYmVsID0gZGV2aWNlLmxhYmVsID09PSAnJztcbiAgICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBraW5kID8gZGV2aWNlLmtpbmQgPT09IGtpbmQgOiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNEdW1teURldmljZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zVG9BY3F1aXJlID0ge1xuICAgICAgICAgICAgICB2aWRlbzoga2luZCAhPT0gJ2F1ZGlvaW5wdXQnICYmIGtpbmQgIT09ICdhdWRpb291dHB1dCcsXG4gICAgICAgICAgICAgIGF1ZGlvOiBraW5kICE9PSAndmlkZW9pbnB1dCcgJiYge1xuICAgICAgICAgICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xuICAgICAgICAgICAgZGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3ByZXZpb3VzRGV2aWNlcyA9IGRldmljZXM7XG4gICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcbiAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgfVxuICAgICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXG4gICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5nZXREZXZpY2VzKGtpbmQpO1xuICAgICAgY29uc3QgZGVmYXVsdERldmljZSA9IGRldmljZXMuZmluZChkID0+IGQuZGV2aWNlSWQgPT09IGRlZmF1bHRJZCk7XG4gICAgICBpZiAoIWRlZmF1bHREZXZpY2UpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgcmVsaWFibHkgZGV0ZXJtaW5lIGRlZmF1bHQgZGV2aWNlJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzLmZpbmQoZCA9PiBkLmRldmljZUlkICE9PSBkZWZhdWx0SWQgJiYgZC5ncm91cElkID09PSAoZ3JvdXBJZCAhPT0gbnVsbCAmJiBncm91cElkICE9PSB2b2lkIDAgPyBncm91cElkIDogZGVmYXVsdERldmljZS5ncm91cElkKSk7XG4gICAgICBpZiAoIWRldmljZSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZWxpYWJseSBkZXRlcm1pbmUgZGVmYXVsdCBkZXZpY2UnKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2UgPT09IG51bGwgfHwgZGV2aWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXZpY2UuZGV2aWNlSWQ7XG4gICAgfSk7XG4gIH1cbiAgaGFzRGV2aWNlSW5Vc2Uoa2luZCkge1xuICAgIHJldHVybiBraW5kID8gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmhhcyhraW5kKSA6IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zaXplID4gMDtcbiAgfVxufVxuRGV2aWNlTWFuYWdlci5tZWRpYURldmljZUtpbmRzID0gWydhdWRpb2lucHV0JywgJ2F1ZGlvb3V0cHV0JywgJ3ZpZGVvaW5wdXQnXTtcbkRldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcCA9IG5ldyBNYXAoKTt2YXIgUXVldWVUYXNrU3RhdHVzO1xuKGZ1bmN0aW9uIChRdWV1ZVRhc2tTdGF0dXMpIHtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIldBSVRJTkdcIl0gPSAwXSA9IFwiV0FJVElOR1wiO1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJDT01QTEVURURcIl0gPSAyXSA9IFwiQ09NUExFVEVEXCI7XG59KShRdWV1ZVRhc2tTdGF0dXMgfHwgKFF1ZXVlVGFza1N0YXR1cyA9IHt9KSk7XG5jbGFzcyBBc3luY1F1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wZW5kaW5nVGFza3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50YXNrTXV0ZXggPSBuZXcgXygpO1xuICAgIHRoaXMubmV4dFRhc2tJbmRleCA9IDA7XG4gIH1cbiAgcnVuKHRhc2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdGFza0luZm8gPSB7XG4gICAgICAgIGlkOiB0aGlzLm5leHRUYXNrSW5kZXgrKyxcbiAgICAgICAgZW5xdWV1ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgc3RhdHVzOiBRdWV1ZVRhc2tTdGF0dXMuV0FJVElOR1xuICAgICAgfTtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSW5mby5pZCwgdGFza0luZm8pO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy50YXNrTXV0ZXgubG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGFza0luZm8uZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5SVU5OSU5HO1xuICAgICAgICByZXR1cm4geWllbGQgdGFzaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLkNPTVBMRVRFRDtcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHRhc2tJbmZvLmlkKTtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7fSkpO1xuICAgIH0pO1xuICB9XG4gIHNuYXBzaG90KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKTtcbiAgfVxufS8qKlxuICogW1dlYlNvY2tldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldCkgd2l0aCBbU3RyZWFtcyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSSlcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd2ViLmRldi93ZWJzb2NrZXRzdHJlYW0vXG4gKi9cbmNsYXNzIFdlYlNvY2tldFN0cmVhbSB7XG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLndzLnJlYWR5U3RhdGU7XG4gIH1cbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKChfYSA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgIH1cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsLCAoX2IgPSBvcHRpb25zLnByb3RvY29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xuICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHRoaXMud3MgPSB3cztcbiAgICBjb25zdCBjbG9zZVdpdGhJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgY2xvc2VDb2RlOiBjb2RlLFxuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIHdzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfTtcbiAgICB0aGlzLm9wZW5lZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgcmVhZGFibGU6IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHdzLm9ubWVzc2FnZSA9IF9yZWYgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgd3Mub25lcnJvciA9IGUgPT4gY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGNsb3NlV2l0aEluZm9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB3cml0YWJsZTogbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIHdzLnNlbmQoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZVdpdGhJbmZvXG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJvdG9jb2w6IHdzLnByb3RvY29sLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHdzLmV4dGVuc2lvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH07XG4gICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZWplY3RIYW5kbGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47ZWxzZSB7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGNsb3NlRXYgPT4ge1xuICAgICAgICAgICAgICByZXMoY2xvc2VFdik7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IHlpZWxkIFByb21pc2UucmFjZShbc2xlZXAoMjUwKSwgY2xvc2VQcm9taXNlXSk7XG4gICAgICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRW5jb3VudGVyZWQgdW5zcGVjaWZpZWQgd2Vic29ja2V0IGVycm9yIHdpdGhvdXQgYSB0aW1lbHkgY2xvc2UgZXZlbnQnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuIGluZmVyIHRoZSBjbG9zZSByZWFzb24gZnJvbSB0aGUgY2xvc2UgZXZlbnQgdGhlbiByZXNvbHZlIHRoZSBwcm9taXNlLCB3ZSBkb24ndCBuZWVkIHRvIHRocm93XG4gICAgICAgICAgcmVzb2x2ZShyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdzLm9uY2xvc2UgPSBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBjbG9zZUNvZGU6IGNvZGUsXG4gICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdEhhbmRsZXIpO1xuICAgICAgfTtcbiAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0SGFuZGxlcik7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICBvcHRpb25zLnNpZ25hbC5vbmFib3J0ID0gKCkgPT4gd3MuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZSA9IGNsb3NlV2l0aEluZm87XG4gIH1cbn1jb25zdCBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyA9IFsnc3luY1N0YXRlJywgJ3RyaWNrbGUnLCAnb2ZmZXInLCAnYW5zd2VyJywgJ3NpbXVsYXRlJywgJ2xlYXZlJ107XG5mdW5jdGlvbiBjYW5QYXNzVGhyb3VnaFF1ZXVlKHJlcSkge1xuICBjb25zdCBjYW5QYXNzID0gcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMuaW5kZXhPZihyZXEuY2FzZSkgPj0gMDtcbiAgbGl2ZWtpdExvZ2dlci50cmFjZSgncmVxdWVzdCBhbGxvd2VkIHRvIGJ5cGFzcyBxdWV1ZTonLCB7XG4gICAgY2FuUGFzcyxcbiAgICByZXFcbiAgfSk7XG4gIHJldHVybiBjYW5QYXNzO1xufVxudmFyIFNpZ25hbENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoU2lnbmFsQ29ubmVjdGlvblN0YXRlKSB7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDFdID0gXCJDT05ORUNURURcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkRJU0NPTk5FQ1RJTkdcIl0gPSAzXSA9IFwiRElTQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVEVEXCJdID0gNF0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xufSkoU2lnbmFsQ29ubmVjdGlvblN0YXRlIHx8IChTaWduYWxDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuLyoqIHNwZWNpZmllcyBob3cgbXVjaCB0aW1lIChpbiBtcykgd2UgYWxsb3cgZm9yIHRoZSB3cyB0byBjbG9zZSBpdHMgY29ubmVjdGlvbiBncmFjZWZ1bGx5IGJlZm9yZSBjb250aW51aW5nICovXG5jb25zdCBNQVhfV1NfQ0xPU0VfVElNRSA9IDI1MDtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFNpZ25hbENsaWVudCB7XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cbiAgZ2V0IGlzRGlzY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fCB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG4gIGdldCBpc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gIH1cbiAgZ2V0TmV4dFJlcXVlc3RJZCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgKz0gMTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdElkO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB1c2VKU09OID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9hO1xuICAgIC8qKiBzaWduYWwgcnR0IGluIG1pbGxpc2Vjb25kcyAqL1xuICAgIHRoaXMucnR0ID0gMDtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5yZXNldENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICAgIHRoaXMub25BbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTGVhdmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uTmVnb3RpYXRlUmVxdWVzdGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbk9mZmVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRva2VuUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Ucmlja2xlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuU2lnbmFsKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMudXNlSlNPTiA9IHVzZUpTT047XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgIHRoaXMucXVldWVkUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Mb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICB9XG4gIGpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gZHVyaW5nIGEgZnVsbCByZWNvbm5lY3QsIHdlJ2Qgd2FudCB0byBzdGFydCB0aGUgc2VxdWVuY2UgZXZlbiBpZiBjdXJyZW50bHlcbiAgICAgIC8vIGNvbm5lY3RlZFxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG4gIHJlY29ubmVjdCh1cmwsIHRva2VuLCBzaWQsIHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdhdHRlbXB0ZWQgdG8gcmVjb25uZWN0IHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgYmVpbmcgc2V0LCBpZ25vcmluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xuICAgICAgLy8gY2xlYXIgcGluZyBpbnRlcnZhbCBhbmQgcmVzdGFydCBpdCBvbmNlIHJlY29ubmVjdGVkXG4gICAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7XG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgc2lkLFxuICAgICAgICByZWNvbm5lY3RSZWFzb246IHJlYXNvblxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbkxvY2subG9jaygpO1xuICAgICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdHM7XG4gICAgICBjb25zdCBjbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbygpO1xuICAgICAgY29uc3QgcGFyYW1zID0gb3B0cy5zaW5nbGVQZWVyQ29ubmVjdGlvbiA/IGNyZWF0ZUpvaW5SZXF1ZXN0Q29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cykgOiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBjbGllbnRJbmZvLCBvcHRzKTtcbiAgICAgIGNvbnN0IHJ0Y1VybCA9IGNyZWF0ZVJ0Y1VybCh1cmwsIHBhcmFtcyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZVVybCA9IGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1VybCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBhbHJlYWR5QWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9IGV2ZW50T3JFcnJvciA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeUFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRPckVycm9yIGluc3RhbmNlb2YgRXZlbnQgPyBldmVudE9yRXJyb3IuY3VycmVudFRhcmdldCA6IGV2ZW50T3JFcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGdldEFib3J0UmVhc29uQXNTdHJpbmcodGFyZ2V0LCAnQWJvcnQgaGFuZGxlciBjYWxsZWQnKTtcbiAgICAgICAgICAgIC8vIHNlbmQgbGVhdmUgaWYgd2UgaGF2ZSBhbiBhY3RpdmUgc3RyZWFtIHdyaXRlciAoY29ubmVjdGlvbiBpcyBvcGVuKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtV3JpdGVyICYmICF0aGlzLmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VuZExlYXZlKCkudGhlbigoKSA9PiB0aGlzLmNsb3NlKHJlYXNvbikpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwQWJvcnRIYW5kbGVycygpO1xuICAgICAgICAgICAgcmVqZWN0KENvbm5lY3Rpb25FcnJvci5jYW5jZWxsZWQocmVhc29uKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwQWJvcnRIYW5kbGVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHdzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRIYW5kbGVyKENvbm5lY3Rpb25FcnJvci50aW1lb3V0KCdyb29tIGNvbm5lY3Rpb24gaGFzIHRpbWVkIG91dCAoc2lnbmFsKScpKTtcbiAgICAgICAgICB9LCBvcHRzLndlYnNvY2tldFRpbWVvdXQpO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZVNpZ25hbENvbm5lY3RlZCA9IChjb25uZWN0aW9uLCBmaXJzdE1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsQ29ubmVjdGVkKGNvbm5lY3Rpb24sIHdzVGltZW91dCwgZmlyc3RNZXNzYWdlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHJlZGFjdGVkVXJsID0gbmV3IFVSTChydGNVcmwpO1xuICAgICAgICAgIGlmIChyZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuaGFzKCdhY2Nlc3NfdG9rZW4nKSkge1xuICAgICAgICAgICAgcmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgJzxyZWRhY3RlZD4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdChyZWRhY3RlZFVybCksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcmVjb25uZWN0OiBvcHRzLnJlY29ubmVjdCxcbiAgICAgICAgICAgIHJlY29ubmVjdFJlYXNvbjogb3B0cy5yZWNvbm5lY3RSZWFzb25cbiAgICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jbG9zZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0U3RyZWFtKHJ0Y1VybCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2VkLnRoZW4oY2xvc2VJbmZvID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZWplY3QoQ29ubmVjdGlvbkVycm9yLmludGVybmFsKFwiV2Vic29ja2V0IGdvdCBjbG9zZWQgZHVyaW5nIGEgKHJlKWNvbm5lY3Rpb24gYXR0ZW1wdDogXCIuY29uY2F0KGNsb3NlSW5mby5yZWFzb24pKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNsb3NlSW5mby5jbG9zZUNvZGUgIT09IDEwMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwid2Vic29ja2V0IGNsb3NlZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogY2xvc2VJbmZvLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGNvZGU6IGNsb3NlSW5mby5jbG9zZUNvZGUsXG4gICAgICAgICAgICAgICAgICB3YXNDbGVhbjogY2xvc2VJbmZvLmNsb3NlQ29kZSA9PT0gMTAwMCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoKF9hID0gY2xvc2VJbmZvLnJlYXNvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ1VuZXhwZWN0ZWQgV1MgZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KENvbm5lY3Rpb25FcnJvci5pbnRlcm5hbChcIldlYnNvY2tldCBlcnJvciBkdXJpbmcgYSAocmUpY29ubmVjdGlvbiBhdHRlbXB0OiBcIi5jb25jYXQocmVhc29uKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLndzLm9wZW5lZC5jYXRjaChyZWFzb24gPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0geWllbGQgdGhpcy5oYW5kbGVDb25uZWN0aW9uRXJyb3IocmVhc29uLCB2YWxpZGF0ZVVybCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gb3RoZXIgZXJyb3JzLCBoYW5kbGVcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVXU0Vycm9yKHJlYXNvbik7XG4gICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWduYWxSZWFkZXIgPSBjb25uZWN0aW9uLnJlYWRhYmxlLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Xcml0ZXIgPSBjb25uZWN0aW9uLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RNZXNzYWdlID0geWllbGQgc2lnbmFsUmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIHNpZ25hbFJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdE1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgQ29ubmVjdGlvbkVycm9yLmludGVybmFsKCdubyBtZXNzYWdlIHJlY2VpdmVkIGFzIGZpcnN0IG1lc3NhZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2lnbmFsUmVzcG9uc2UgPSBwYXJzZVNpZ25hbFJlc3BvbnNlKGZpcnN0TWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZmlyc3QgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVGaXJzdE1lc3NhZ2UoZmlyc3RTaWduYWxSZXNwb25zZSwgKF9hID0gb3B0cy5yZWNvbm5lY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHJlamVjdCh2YWxpZGF0aW9uLmVycm9yKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGpvaW4gcmVzcG9uc2UgLSBzZXQgdXAgcGluZyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICBpZiAoKChfYiA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlLnZhbHVlLnBpbmdUaW1lb3V0O1xuICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlLnZhbHVlLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BpbmcgY29uZmlnJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3QgZmlyc3RNZXNzYWdlVG9Qcm9jZXNzID0gdmFsaWRhdGlvbi5zaG91bGRQcm9jZXNzRmlyc3RNZXNzYWdlID8gZmlyc3RTaWduYWxSZXNwb25zZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGhhbmRsZVNpZ25hbENvbm5lY3RlZChjb25uZWN0aW9uLCBmaXJzdE1lc3NhZ2VUb1Byb2Nlc3MpO1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWxpZGF0aW9uLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFudXBBYm9ydEhhbmRsZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhcnRSZWFkaW5nTG9vcChzaWduYWxSZWFkZXIsIGZpcnN0TWVzc2FnZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoZmlyc3RNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzcG9uc2UoZmlyc3RNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB5aWVsZCBzaWduYWxSZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBwYXJzZVNpZ25hbFJlc3BvbnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHVwZGF0ZVN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ0Nsb3NlIG1ldGhvZCBjYWxsZWQgb24gc2lnbmFsIGNsaWVudCc7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKFtTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fCBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEXS5pbmNsdWRlcyhfdGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJpZ25vcmluZyBzaWduYWwgY2xvc2UgYXMgaXQncyBhbHJlYWR5IGluIGRpc2Nvbm5lY3Rpbmcgc3RhdGVcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLndzKSB7XG4gICAgICAgICAgICBfdGhpcy53cy5jbG9zZSh7XG4gICAgICAgICAgICAgIGNsb3NlQ29kZTogMTAwMCxcbiAgICAgICAgICAgICAgcmVhc29uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYHdzLmNsb3NlKClgIG9ubHkgc3RhcnRzIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSAoQ0xPU0lORyBzdGF0ZSksIHByZWZlciB0byB3YWl0IHVudGlsIHN0YXRlIGlzIGFjdHVhbGx5IENMT1NFRFxuICAgICAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlID0gX3RoaXMud3MuY2xvc2VkO1xuICAgICAgICAgICAgX3RoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfdGhpcy5zdHJlYW1Xcml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW2Nsb3NlUHJvbWlzZSwgc2xlZXAoTUFYX1dTX0NMT1NFX1RJTUUpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX3RoaXMubG9nLmRlYnVnKCd3ZWJzb2NrZXQgZXJyb3Igd2hpbGUgY2xvc2luZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIGluaXRpYWwgb2ZmZXIgYWZ0ZXIgam9pbmluZ1xuICBzZW5kT2ZmZXIob2ZmZXIsIG9mZmVySWQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgb2ZmZXJTZHA6IG9mZmVyLnNkcFxuICAgIH0pKTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdvZmZlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlciwgb2ZmZXJJZClcbiAgICB9KTtcbiAgfVxuICAvLyBhbnN3ZXIgYSBzZXJ2ZXItaW5pdGlhdGVkIG9mZmVyXG4gIHNlbmRBbnN3ZXIoYW5zd2VyLCBvZmZlcklkKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBhbnN3ZXJTZHA6IGFuc3dlci5zZHBcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2Fuc3dlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihhbnN3ZXIsIG9mZmVySWQpXG4gICAgfSk7XG4gIH1cbiAgc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGljZSBjYW5kaWRhdGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGNhbmRpZGF0ZVxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJpY2tsZScsXG4gICAgICB2YWx1ZTogbmV3IFRyaWNrbGVSZXF1ZXN0KHtcbiAgICAgICAgY2FuZGlkYXRlSW5pdDogSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ211dGUnLFxuICAgICAgdmFsdWU6IG5ldyBNdXRlVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgc2lkOiB0cmFja1NpZCxcbiAgICAgICAgbXV0ZWRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZEFkZFRyYWNrKHJlcSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhZGRUcmFjaycsXG4gICAgICB2YWx1ZTogcmVxXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEobWV0YWRhdGFfMSwgbmFtZV8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBfdGhpczIuZ2V0TmV4dFJlcXVlc3RJZCgpO1xuICAgICAgICB5aWVsZCBfdGhpczIuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgIGNhc2U6ICd1cGRhdGVNZXRhZGF0YScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJZDtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyYWNrU2V0dGluZycsXG4gICAgICB2YWx1ZTogc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgdmFsdWU6IHN1YlxuICAgIH0pO1xuICB9XG4gIHNlbmRTeW5jU3RhdGUoc3luYykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzeW5jU3RhdGUnLFxuICAgICAgdmFsdWU6IHN5bmNcbiAgICB9KTtcbiAgfVxuICBzZW5kVXBkYXRlVmlkZW9MYXllcnModHJhY2tTaWQsIGxheWVycykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd1cGRhdGVMYXllcnMnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVWaWRlb0xheWVycyh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBsYXllcnNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50cywgdHJhY2tQZXJtaXNzaW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uJyxcbiAgICAgIHZhbHVlOiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbih7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50cyxcbiAgICAgICAgdHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzaW11bGF0ZScsXG4gICAgICB2YWx1ZTogc2NlbmFyaW9cbiAgICB9KTtcbiAgfVxuICBzZW5kUGluZygpIHtcbiAgICAvKiogc2VuZCBib3RoIG9mIHBpbmcgYW5kIHBpbmdSZXEgZm9yIGNvbXBhdGliaWxpdHkgdG8gb2xkIGFuZCBuZXcgc2VydmVyICovXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdwaW5nJyxcbiAgICAgIHZhbHVlOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgfSksIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3BpbmdSZXEnLFxuICAgICAgdmFsdWU6IG5ldyBQaW5nKHtcbiAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpLFxuICAgICAgICBydHQ6IHByb3RvSW50NjQucGFyc2UodGhpcy5ydHQpXG4gICAgICB9KVxuICAgIH0pXSk7XG4gIH1cbiAgc2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh0cmFja1NpZCwgZmVhdHVyZXMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlQXVkaW9UcmFjaycsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh7XG4gICAgICAgIHRyYWNrU2lkLFxuICAgICAgICBmZWF0dXJlc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kTGVhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2xlYXZlJyxcbiAgICAgIHZhbHVlOiBuZXcgTGVhdmVSZXF1ZXN0KHtcbiAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgIC8vIHNlcnZlciBkb2Vzbid0IHByb2Nlc3MgdGhpcyBmaWVsZCwga2VlcGluZyBpdCBoZXJlIHRvIGluZGljYXRlIHRoZSBpbnRlbnQgb2YgYSBmdWxsIGRpc2Nvbm5lY3RcbiAgICAgICAgYWN0aW9uOiBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1RcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFJlcXVlc3QobWVzc2FnZV8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgbGV0IGZyb21RdWV1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gY2FwdHVyZSBhbGwgcmVxdWVzdHMgd2hpbGUgcmVjb25uZWN0aW5nIGFuZCBwdXQgdGhlbSBpbiBhIHF1ZXVlXG4gICAgICAgIC8vIHVubGVzcyB0aGUgcmVxdWVzdCBvcmlnaW5hdGVzIGZyb20gdGhlIHF1ZXVlLCB0aGVuIGRvbid0IGVucXVldWUgYWdhaW5cbiAgICAgICAgY29uc3QgY2FuUXVldWUgPSAhZnJvbVF1ZXVlICYmICFjYW5QYXNzVGhyb3VnaFF1ZXVlKG1lc3NhZ2UpO1xuICAgICAgICBpZiAoY2FuUXVldWUgJiYgX3RoaXMzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgICAgX3RoaXMzLnF1ZXVlZFJlcXVlc3RzLnB1c2goKCkgPT4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KG1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHByZXZpb3VzbHkgcXVldWVkIHJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGZpcnN0XG4gICAgICAgIGlmICghZnJvbVF1ZXVlKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcXVlc3RRdWV1ZS5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgIHlpZWxkIHNsZWVwKF90aGlzMy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgLy8gU2tpcCByZXF1ZXN0cyBpZiB0aGUgc2lnbmFsIGxheWVyIGlzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBhbiBldmVudCBpcyBzZW50IGluIHRoZSBtaXN0IG9mIHJvb20uY29ubmVjdCgpIGluaXRpYWxpemluZ1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoXCJza2lwcGluZyBzaWduYWwgcmVxdWVzdCAodHlwZTogXCIuY29uY2F0KG1lc3NhZ2UuY2FzZSwgXCIpIC0gU2lnbmFsQ2xpZW50IGRpc2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMzLnN0cmVhbVdyaXRlcikge1xuICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoXCJjYW5ub3Qgc2VuZCBzaWduYWwgcmVxdWVzdCBiZWZvcmUgY29ubmVjdGVkLCB0eXBlOiBcIi5jb25jYXQobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLmNhc2UpLCBfdGhpczMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBTaWduYWxSZXF1ZXN0KHtcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfdGhpczMudXNlSlNPTikge1xuICAgICAgICAgICAgeWllbGQgX3RoaXMzLnN0cmVhbVdyaXRlci53cml0ZShyZXEudG9Kc29uU3RyaW5nKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuc3RyZWFtV3JpdGVyLndyaXRlKHJlcS50b0JpbmFyeSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfdGhpczMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBtc2cgPSByZXMubWVzc2FnZTtcbiAgICBpZiAobXNnID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGluZ0hhbmRsZWQgPSBmYWxzZTtcbiAgICBpZiAobXNnLmNhc2UgPT09ICdhbnN3ZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25BbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5vbkFuc3dlcihzZCwgbXNnLnZhbHVlLmlkLCBtc2cudmFsdWUubWlkVG9UcmFja0lkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnb2ZmZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25PZmZlcikge1xuICAgICAgICB0aGlzLm9uT2ZmZXIoc2QsIG1zZy52YWx1ZS5pZCwgbXNnLnZhbHVlLm1pZFRvVHJhY2tJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZXF1ZXN0UmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblJlcXVlc3RSZXNwb25zZSkge1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrU3Vic2NyaWJlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKG1zZy52YWx1ZS50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21Nb3ZlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9uUm9vbU1vdmVkKSB7XG4gICAgICAgIHRoaXMub25Sb29tTW92ZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbWVkaWFTZWN0aW9uc1JlcXVpcmVtZW50Jykge1xuICAgICAgaWYgKHRoaXMub25NZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQpIHtcbiAgICAgICAgdGhpcy5vbk1lZGlhU2VjdGlvbnNSZXF1aXJlbWVudChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBtc2dDYXNlOiBtc2cuY2FzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXBpbmdIYW5kbGVkKSB7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gIH1cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlT25DbG9zZShyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpIHJldHVybjtcbiAgICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICAgIHlpZWxkIHRoaXMuY2xvc2UodW5kZWZpbmVkLCByZWFzb24pO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQ6IFwiLmNvbmNhdChyZWFzb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVdTRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBlcnJvclxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwaW5nIHRpbWVvdXQgYW5kIHN0YXJ0cyBhIG5ldyB0aW1lb3V0LlxuICAgKiBDYWxsIHRoaXMgYWZ0ZXIgcmVjZWl2aW5nIGEgcG9uZyBtZXNzYWdlXG4gICAqL1xuICByZXNldFBpbmdUaW1lb3V0KCkge1xuICAgIHRoaXMuY2xlYXJQaW5nVGltZW91dCgpO1xuICAgIGlmICghdGhpcy5waW5nVGltZW91dER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIHRpbWVvdXQgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGluZ1RpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubG9nLndhcm4oXCJwaW5nIHRpbWVvdXQgdHJpZ2dlcmVkLiBsYXN0IHBvbmcgcmVjZWl2ZWQgYXQ6IFwiLmNvbmNhdChuZXcgRGF0ZShEYXRlLm5vdygpIC0gdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCkudG9VVENTdHJpbmcoKSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICAgIH0sIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgcGluZyB0aW1lb3V0IChkb2VzIG5vdCBzdGFydCBhIG5ldyB0aW1lb3V0KVxuICAgKi9cbiAgY2xlYXJQaW5nVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5waW5nVGltZW91dCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBzdGFydFBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbmRQaW5nKCk7XG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiAqIDEwMDApO1xuICB9XG4gIGNsZWFyUGluZ0ludGVydmFsKCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdjbGVhcmluZyBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5waW5nSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5waW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWwgc2VydmVyXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gdGltZW91dEhhbmRsZSBUaGUgdGltZW91dCBoYW5kbGUgdG8gY2xlYXJcbiAgICogQHBhcmFtIGZpcnN0TWVzc2FnZSBPcHRpb25hbCBmaXJzdCBtZXNzYWdlIHRvIHByb2Nlc3NcbiAgICogQGludGVybmFsXG4gICAqL1xuICBoYW5kbGVTaWduYWxDb25uZWN0ZWQoY29ubmVjdGlvbiwgdGltZW91dEhhbmRsZSwgZmlyc3RNZXNzYWdlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICB0aGlzLnN0YXJ0UmVhZGluZ0xvb3AoY29ubmVjdGlvbi5yZWFkYWJsZS5nZXRSZWFkZXIoKSwgZmlyc3RNZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBmaXJzdCBtZXNzYWdlIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbCBzZXJ2ZXJcbiAgICogQHBhcmFtIGZpcnN0U2lnbmFsUmVzcG9uc2UgVGhlIGZpcnN0IHNpZ25hbCByZXNwb25zZSByZWNlaXZlZFxuICAgKiBAcGFyYW0gaXNSZWNvbm5lY3QgV2hldGhlciB0aGlzIGlzIGEgcmVjb25uZWN0aW9uIGF0dGVtcHRcbiAgICogQHJldHVybnMgVmFsaWRhdGlvbiByZXN1bHQgd2l0aCByZXNwb25zZSBvciBlcnJvclxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhbGlkYXRlRmlyc3RNZXNzYWdlKGZpcnN0U2lnbmFsUmVzcG9uc2UsIGlzUmVjb25uZWN0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoKChfYSA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnam9pbicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIHJlc3BvbnNlOiBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UudmFsdWVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmICgoX2IgPSBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSAhPT0gJ2xlYXZlJykge1xuICAgICAgaWYgKCgoX2MgPSBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXNlKSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgIHJlc3BvbnNlOiBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIHJlY29ubmVjdGluZywgYW55IG1lc3NhZ2UgcmVjZWl2ZWQgbWVhbnMgc2lnbmFsIHJlY29ubmVjdGVkIGFuZCB3ZSBzdGlsbCBuZWVkIHRvIHByb2Nlc3MgaXRcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlY2xhcmluZyBzaWduYWwgcmVjb25uZWN0ZWQgd2l0aG91dCByZWNvbm5lY3QgcmVzcG9uc2UgcmVjZWl2ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzaG91bGRQcm9jZXNzRmlyc3RNZXNzYWdlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiAmJiAoKF9kID0gZmlyc3RTaWduYWxSZXNwb25zZS5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FzZSkgPT09ICdsZWF2ZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogQ29ubmVjdGlvbkVycm9yLmxlYXZlUmVxdWVzdCgnUmVjZWl2ZWQgbGVhdmUgcmVxdWVzdCB3aGlsZSB0cnlpbmcgdG8gKHJlKWNvbm5lY3QnLCBmaXJzdFNpZ25hbFJlc3BvbnNlLm1lc3NhZ2UudmFsdWUucmVhc29uKVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFpc1JlY29ubmVjdCkge1xuICAgICAgLy8gbm9uLXJlY29ubmVjdCBjYXNlLCBzaG91bGQgcmVjZWl2ZSBqb2luIHJlc3BvbnNlIGZpcnN0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IENvbm5lY3Rpb25FcnJvci5pbnRlcm5hbChcImRpZCBub3QgcmVjZWl2ZSBqb2luIHJlc3BvbnNlLCBnb3QgXCIuY29uY2F0KChfZSA9IGZpcnN0U2lnbmFsUmVzcG9uc2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhc2UsIFwiIGluc3RlYWRcIikpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogQ29ubmVjdGlvbkVycm9yLmludGVybmFsKCdVbmV4cGVjdGVkIGZpcnN0IG1lc3NhZ2UnKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3JzIGJ5IHZhbGlkYXRpbmcgd2l0aCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSByZWFzb24gVGhlIGVycm9yIHRoYXQgb2NjdXJyZWRcbiAgICogQHBhcmFtIHZhbGlkYXRlVXJsIFRoZSBVUkwgdG8gdmFsaWRhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aFxuICAgKiBAcmV0dXJucyBBIENvbm5lY3Rpb25FcnJvciB3aXRoIGFwcHJvcHJpYXRlIHJlYXNvbiBhbmQgc3RhdHVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaGFuZGxlQ29ubmVjdGlvbkVycm9yKHJlYXNvbiwgdmFsaWRhdGVVcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIGZldGNoKHZhbGlkYXRlVXJsKTtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25FcnJvci5ub3RBbGxvd2VkKG1zZywgcmVzcC5zdGF0dXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25FcnJvci5pbnRlcm5hbChcIkVuY291bnRlcmVkIHVua25vd24gd2Vic29ja2V0IGVycm9yIGR1cmluZyBjb25uZWN0aW9uOiBcIi5jb25jYXQocmVhc29uKSwge1xuICAgICAgICAgICAgc3RhdHVzOiByZXNwLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3Auc3RhdHVzVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yID8gZSA6IENvbm5lY3Rpb25FcnJvci5zZXJ2ZXJVbnJlYWNoYWJsZShlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihzZCkge1xuICBjb25zdCByc2QgPSB7XG4gICAgdHlwZTogJ29mZmVyJyxcbiAgICBzZHA6IHNkLnNkcFxuICB9O1xuICBzd2l0Y2ggKHNkLnR5cGUpIHtcbiAgICBjYXNlICdhbnN3ZXInOlxuICAgIGNhc2UgJ29mZmVyJzpcbiAgICBjYXNlICdwcmFuc3dlcic6XG4gICAgY2FzZSAncm9sbGJhY2snOlxuICAgICAgcnNkLnR5cGUgPSBzZC50eXBlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cbmZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ocnNkLCBpZCkge1xuICBjb25zdCBzZCA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgIHNkcDogcnNkLnNkcCxcbiAgICB0eXBlOiByc2QudHlwZSxcbiAgICBpZFxuICB9KTtcbiAgcmV0dXJuIHNkO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgaW5mbywgb3B0cykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xuICAvLyBvcHRzXG4gIGlmIChvcHRzLnJlY29ubmVjdCkge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdCcsICcxJyk7XG4gICAgaWYgKG9wdHMuc2lkKSB7XG4gICAgICBwYXJhbXMuc2V0KCdzaWQnLCBvcHRzLnNpZCk7XG4gICAgfVxuICB9XG4gIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcbiAgLy8gQ2xpZW50SW5mb1xuICBwYXJhbXMuc2V0KCdzZGsnLCBpc1JlYWN0TmF0aXZlKCkgPyAncmVhY3RuYXRpdmUnIDogJ2pzJyk7XG4gIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24pO1xuICBwYXJhbXMuc2V0KCdwcm90b2NvbCcsIGluZm8ucHJvdG9jb2wudG9TdHJpbmcoKSk7XG4gIGlmIChpbmZvLmRldmljZU1vZGVsKSB7XG4gICAgcGFyYW1zLnNldCgnZGV2aWNlX21vZGVsJywgaW5mby5kZXZpY2VNb2RlbCk7XG4gIH1cbiAgaWYgKGluZm8ub3MpIHtcbiAgICBwYXJhbXMuc2V0KCdvcycsIGluZm8ub3MpO1xuICB9XG4gIGlmIChpbmZvLm9zVmVyc2lvbikge1xuICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3Nlcikge1xuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXInLCBpbmZvLmJyb3dzZXIpO1xuICB9XG4gIGlmIChpbmZvLmJyb3dzZXJWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3Nlcl92ZXJzaW9uJywgaW5mby5icm93c2VyVmVyc2lvbik7XG4gIH1cbiAgaWYgKG9wdHMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICBwYXJhbXMuc2V0KCdhZGFwdGl2ZV9zdHJlYW0nLCAnMScpO1xuICB9XG4gIGlmIChvcHRzLnJlY29ubmVjdFJlYXNvbikge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdF9yZWFzb24nLCBvcHRzLnJlY29ubmVjdFJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIGlmICgoX2EgPSBuYXZpZ2F0b3IuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGFyYW1zLnNldCgnbmV0d29yaycsIG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVKb2luUmVxdWVzdENvbm5lY3Rpb25QYXJhbXModG9rZW4sIGluZm8sIG9wdHMpIHtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG4gIGNvbnN0IGpvaW5SZXF1ZXN0ID0gbmV3IEpvaW5SZXF1ZXN0KHtcbiAgICBjbGllbnRJbmZvOiBpbmZvLFxuICAgIGNvbm5lY3Rpb25TZXR0aW5nczogbmV3IENvbm5lY3Rpb25TZXR0aW5ncyh7XG4gICAgICBhdXRvU3Vic2NyaWJlOiAhIW9wdHMuYXV0b1N1YnNjcmliZSxcbiAgICAgIGFkYXB0aXZlU3RyZWFtOiAhIW9wdHMuYWRhcHRpdmVTdHJlYW1cbiAgICB9KSxcbiAgICByZWNvbm5lY3Q6ICEhb3B0cy5yZWNvbm5lY3QsXG4gICAgcGFydGljaXBhbnRTaWQ6IG9wdHMuc2lkID8gb3B0cy5zaWQgOiB1bmRlZmluZWRcbiAgfSk7XG4gIGlmIChvcHRzLnJlY29ubmVjdFJlYXNvbikge1xuICAgIGpvaW5SZXF1ZXN0LnJlY29ubmVjdFJlYXNvbiA9IG9wdHMucmVjb25uZWN0UmVhc29uO1xuICB9XG4gIGNvbnN0IHdyYXBwZWRKb2luUmVxdWVzdCA9IG5ldyBXcmFwcGVkSm9pblJlcXVlc3Qoe1xuICAgIGpvaW5SZXF1ZXN0OiBqb2luUmVxdWVzdC50b0JpbmFyeSgpXG4gIH0pO1xuICBwYXJhbXMuc2V0KCdqb2luX3JlcXVlc3QnLCBidG9hKG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUod3JhcHBlZEpvaW5SZXF1ZXN0LnRvQmluYXJ5KCkpKSk7XG4gIHJldHVybiBwYXJhbXM7XG59Y2xhc3MgRGF0YVBhY2tldEJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5fdG90YWxTaXplID0gMDtcbiAgfVxuICBwdXNoKGl0ZW0pIHtcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSArPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICBwb3AoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuYnVmZmVyLnNoaWZ0KCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX3RvdGFsU2l6ZSAtPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHBvcFRvU2VxdWVuY2Uoc2VxdWVuY2UpIHtcbiAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcbiAgICAgIGlmIChmaXJzdC5zZXF1ZW5jZSA8PSBzZXF1ZW5jZSkge1xuICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFsaWduQnVmZmVyZWRBbW91bnQoYnVmZmVyZWRBbW91bnQpIHtcbiAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcbiAgICAgIGlmICh0aGlzLl90b3RhbFNpemUgLSBmaXJzdC5kYXRhLmJ5dGVMZW5ndGggPD0gYnVmZmVyZWRBbW91bnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gIH1cbn1jbGFzcyBUVExNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHR0bCB0dGwgb2YgdGhlIGtleSAobXMpXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0dGwpIHtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbGFzdENsZWFudXAgPSAwO1xuICAgIHRoaXMudHRsID0gdHRsO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5fbGFzdENsZWFudXAgPiB0aGlzLnR0bCAvIDIpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgICBjb25zdCBleHBpcmVzQXQgPSBub3cgKyB0aGlzLnR0bDtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwge1xuICAgICAgdmFsdWUsXG4gICAgICBleHBpcmVzQXRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZW50cnkuZXhwaXJlc0F0IDwgRGF0ZS5ub3coKSkge1xuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGVudHJ5LmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHtcbiAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMuX21hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPCBub3cpIHtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sYXN0Q2xlYW51cCA9IG5vdztcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMuX21hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPj0gRGF0ZS5ub3coKSkge1xuICAgICAgICBjYWxsYmFjayhlbnRyeS52YWx1ZSwga2V5LCB0aGlzLmFzVmFsdWVNYXAoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1hcChjYWxsYmFjaykge1xuICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHZhbHVlTWFwID0gdGhpcy5hc1ZhbHVlTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsdWVNYXAuZW50cmllcygpKSB7XG4gICAgICByZXN1bHQucHVzaChjYWxsYmFjayh2YWx1ZSwga2V5LCB2YWx1ZU1hcCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzVmFsdWVNYXAoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMuX21hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPj0gRGF0ZS5ub3coKSkge1xuICAgICAgICByZXN1bHQuc2V0KGtleSwgZW50cnkudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59dmFyIGxpYiA9IHt9O3ZhciBwYXJzZXIgPSB7fTt2YXIgZ3JhbW1hciA9IHtleHBvcnRzOiB7fX07dmFyIGhhc1JlcXVpcmVkR3JhbW1hcjtcbmZ1bmN0aW9uIHJlcXVpcmVHcmFtbWFyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRHcmFtbWFyKSByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEdyYW1tYXIgPSAxO1xuICB2YXIgZ3JhbW1hciQxID0gZ3JhbW1hci5leHBvcnRzID0ge1xuICAgIHY6IFt7XG4gICAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgICByZWc6IC9eKFxcZCopJC9cbiAgICB9XSxcbiAgICBvOiBbe1xuICAgICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICAgIH1dLFxuICAgIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICAgIHM6IFt7XG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9XSxcbiAgICBpOiBbe1xuICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJ1xuICAgIH1dLFxuICAgIHU6IFt7XG4gICAgICBuYW1lOiAndXJpJ1xuICAgIH1dLFxuICAgIGU6IFt7XG4gICAgICBuYW1lOiAnZW1haWwnXG4gICAgfV0sXG4gICAgcDogW3tcbiAgICAgIG5hbWU6ICdwaG9uZSdcbiAgICB9XSxcbiAgICB6OiBbe1xuICAgICAgbmFtZTogJ3RpbWV6b25lcydcbiAgICB9XSxcbiAgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXG4gICAgcjogW3tcbiAgICAgIG5hbWU6ICdyZXBlYXRzJ1xuICAgIH1dLFxuICAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgICB0OiBbe1xuICAgICAgLy8gdD0wIDBcbiAgICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgICAgZm9ybWF0OiAnJWQgJWQnXG4gICAgfV0sXG4gICAgYzogW3tcbiAgICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gICAgfV0sXG4gICAgYjogW3tcbiAgICAgIC8vIGI9QVM6NDAwMFxuICAgICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgICBmb3JtYXQ6ICclczolcydcbiAgICB9XSxcbiAgICBtOiBbe1xuICAgICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICAgIH1dLFxuICAgIGE6IFt7XG4gICAgICAvLyBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgICBwdXNoOiAncnRwJyxcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvZGVjJywgJ3JhdGUnLCAnZW5jb2RpbmcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uZW5jb2RpbmcgPyAncnRwbWFwOiVkICVzLyVzLyVzJyA6IG8ucmF0ZSA/ICdydHBtYXA6JWQgJXMvJXMnIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb250cm9sOnN0cmVhbWlkPTBcbiAgICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5hZGRyZXNzICE9IG51bGwgPyAncnRjcDolZCAlcyBJUCVkICVzJyA6ICdydGNwOiVkJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIChbXFx3LV9dKikoPzogKFtcXHctX10qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndHlwZScsICdzdWJ0eXBlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnN1YnR5cGUgIT0gbnVsbCA/ICdydGNwLWZiOiVzICVzICVzJyA6ICdydGNwLWZiOiVzICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdleHRtYXA6JWQnICsgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArICcgJXMnICsgKG8uY29uZmlnID8gJyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1leHRtYXAtYWxsb3ctbWl4ZWRcbiAgICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICAgIHJlZzogL14oZXh0bWFwLWFsbG93LW1peGVkKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnNlc3Npb25Db25maWcgIT0gbnVsbCA/ICdjcnlwdG86JWQgJXMgJXMgJXMnIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNvbm5lY3Rpb246bmV3XG4gICAgICBuYW1lOiAnY29ubmVjdGlvblR5cGUnLFxuICAgICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgICAgZm9ybWF0OiAnY29ubmVjdGlvbjolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cHRpbWU6MjBcbiAgICAgIG5hbWU6ICdwdGltZScsXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2UtbGl0ZVxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxuICAgICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgcHVzaDogJ2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcbiAgICAgICAgc3RyICs9IG8ucmFkZHIgIT0gbnVsbCA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAgIC8vIE5COiBjYW5kaWRhdGUgaGFzIHRocmVlIG9wdGlvbmFsIGNodW5rcywgc28gJXZvaWQgbWlkZGxlcyBvbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIHN0ciArPSBvLnRjcHR5cGUgIT0gbnVsbCA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyBnZW5lcmF0aW9uICVkJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gb1snbmV0d29yay1pZCddICE9IG51bGwgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IG9bJ25ldHdvcmstY29zdCddICE9IG51bGwgPyAnIG5ldHdvcmstY29zdCAlZCcgOiAnJXYnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgICByZWc6IC9eaWNlLW9wdGlvbnM6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAgIC8vIHRva2VuLWNoYXIgPSAleDIxIC8gJXgyMy0yNyAvICV4MkEtMkIgLyAleDJELTJFIC8gJXgzMC0zOSAvICV4NDEtNUEgLyAleDVFLTdFXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgICBmb3JtYXQ6ICdzc3JjLWdyb3VwOiVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgICAgbmFtZTogJ21zaWRTZW1hbnRpYycsXG4gICAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgICAgZm9ybWF0OiAnbXNpZC1zZW1hbnRpYzogJXMgJXMnIC8vIHNwYWNlIGFmdGVyICc6JyBpcyBub3QgYWNjaWRlbnRhbFxuICAgIH0sIHtcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgICBwdXNoOiAnZ3JvdXBzJyxcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICAgIGZvcm1hdDogJ2dyb3VwOiVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1tdXhcbiAgICAgIG5hbWU6ICdydGNwTXV4JyxcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1yc2l6ZVxuICAgICAgbmFtZTogJ3J0Y3BSc2l6ZScsXG4gICAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgICByZWc6IC9ec2N0cG1hcDooW1xcd18vXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5tYXhNZXNzYWdlU2l6ZSAhPSBudWxsID8gJ3NjdHBtYXA6JXMgJXMgJXMnIDogJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICAgIHB1c2g6ICdyaWRzJyxcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnBhcmFtcyA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgICAgLy8gYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgLy8gYT1pbWFnZWF0dHI6OTdcbiAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgICAnW1xcXFxzXFxcXHRdKyhzZW5kfHJlY3YpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKiknICtcbiAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nKSxcbiAgICAgIG5hbWVzOiBbJ3B0JywgJ2RpcjEnLCAnYXR0cnMxJywgJ2RpcjInLCAnYXR0cnMyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy8gYT1zaW11bGNhc3Q6cmVjdiAxOzQsNSBzZW5kIDY7N1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAvLyBhPXNpbXVsY2FzdDpcbiAgICAgICdec2ltdWxjYXN0OicgK1xuICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgJyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspJyArXG4gICAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAgIC8vIGVuZFxuICAgICAgJyQnKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiByZWN2IHB0PTk3Ozk4IHNlbmQgcHQ9OTdcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyNVxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICAgIG5hbWU6ICdmcmFtZXJhdGUnLFxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkM0NTcwXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgICBuYW1lOiAnYnVuZGxlT25seScsXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWxhYmVsOjFcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdsYWJlbDolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTVcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnc2N0cC1wb3J0OiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNlxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnbWF4LW1lc3NhZ2Utc2l6ZTolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPXRzLXJlZmNsazpwdHA9SUVFRTE1ODgtMjAwODozOS1BNy05NC1GRi1GRS0wNy1DQi1EMDozN1xuICAgICAgcHVzaDogJ3RzUmVmQ2xvY2tzJyxcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgICBuYW1lczogWydjbGtzcmMnLCAnY2xrc3JjRXh0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT1tZWRpYWNsazpkaXJlY3Q9OTYzMjE0NDI0XG4gICAgICBuYW1lOiAnbWVkaWFDbGsnLFxuICAgICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21lZGlhQ2xvY2tOYW1lJywgJ21lZGlhQ2xvY2tWYWx1ZScsICdyYXRlTnVtZXJhdG9yJywgJ3JhdGVEZW5vbWluYXRvciddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICAgIHN0ciArPSBvLmlkICE9IG51bGwgPyAnaWQ9JXMgJXMnIDogJyV2JXMnO1xuICAgICAgICBzdHIgKz0gby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJyc7XG4gICAgICAgIHN0ciArPSBvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJztcbiAgICAgICAgc3RyICs9IG8ucmF0ZURlbm9taW5hdG9yICE9IG51bGwgPyAnLyVzJyA6ICcnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgICAgcmVnOiAvXmtleXdkczooLispJC8sXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb250ZW50Om1haW5cbiAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgICAgZm9ybWF0OiAnY29udGVudDolcydcbiAgICB9LFxuICAgIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAgICB7XG4gICAgICAvLyBhPWZsb29yY3RybDpjLXNcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICAgIHJlZzogL15mbG9vcmN0cmw6KGMtb25seXxzLW9ubHl8Yy1zKS8sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb25maWQ6MVxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAnY29uZmlkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9dXNlcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwVXNlcklkJyxcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZsb29yaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICAgIHJlZzogL15mbG9vcmlkOiguKykgKD86bS1zdHJlYW18bXN0cm0pOiguKykvLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxuICAgICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgICB9LCB7XG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1dXG4gIH07XG5cbiAgLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG4gIE9iamVjdC5rZXlzKGdyYW1tYXIkMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG9ianMgPSBncmFtbWFyJDFba2V5XTtcbiAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgICB9XG4gICAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xufXZhciBoYXNSZXF1aXJlZFBhcnNlcjtcbmZ1bmN0aW9uIHJlcXVpcmVQYXJzZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFBhcnNlcikgcmV0dXJuIHBhcnNlcjtcbiAgaGFzUmVxdWlyZWRQYXJzZXIgPSAxO1xuICAoZnVuY3Rpb24gKGV4cG9ydHMkMSkge1xuICAgIHZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XG4gICAgICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICAgICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAobWF0Y2hbaSArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcbiAgICAgIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcbiAgICAgICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gICAgICB9XG4gICAgICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/IHt9IDpcbiAgICAgIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gICAgICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcbiAgICAgIGlmIChvYmoucHVzaCkge1xuICAgICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG4gICAgdmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG4gICAgZXhwb3J0cyQxLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgdmFyIHNlc3Npb24gPSB7fSxcbiAgICAgICAgbWVkaWEgPSBbXSxcbiAgICAgICAgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcblxuICAgICAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICAgICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgdHlwZSA9IGxbMF07XG4gICAgICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgICAgIG1lZGlhLnB1c2goe1xuICAgICAgICAgICAgcnRwOiBbXSxcbiAgICAgICAgICAgIGZtdHA6IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGggLSAxXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IChncmFtbWFyW3R5cGVdIHx8IFtdKS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJlZyhvYmosIGxvY2F0aW9uLCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9O1xuICAgIHZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gICAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbiAgICB9O1xuXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbiAgICBleHBvcnRzJDEucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cyQxLnBhcnNlUGFyYW1zO1xuICAgIGV4cG9ydHMkMS5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxuICAgICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aCAtIDEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzJDEucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHZhciBzY2lkLFxuICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2lkOiBzY2lkLFxuICAgICAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKHBhcnNlcik7XG4gIHJldHVybiBwYXJzZXI7XG59dmFyIHdyaXRlcjtcbnZhciBoYXNSZXF1aXJlZFdyaXRlcjtcbmZ1bmN0aW9uIHJlcXVpcmVXcml0ZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFdyaXRlcikgcmV0dXJuIHdyaXRlcjtcbiAgaGFzUmVxdWlyZWRXcml0ZXIgPSAxO1xuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG5cbiAgLy8gY3VzdG9taXplZCB1dGlsLmZvcm1hdCAtIGRpc2NhcmRzIGV4Y2VzcyBhcmd1bWVudHMgYW5kIGNhbiB2b2lkIG1pZGRsZSBvbmVzXG4gIHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xuICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgcmV0dXJuIGZvcm1hdFN0ci5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmIChpID49IGxlbikge1xuICAgICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgICAgfVxuICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICBpICs9IDE7XG4gICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgY2FzZSAnJSUnOlxuICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIGNhc2UgJyVzJzpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgICAgIGNhc2UgJyVkJzpcbiAgICAgICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgICAgIGNhc2UgJyV2JzpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxuICB9O1xuICB2YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICAgIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pIDogb2JqLmZvcm1hdDtcbiAgICB2YXIgYXJncyA9IFt0eXBlICsgJz0nICsgc3RyXTtcbiAgICBpZiAob2JqLm5hbWVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IG9iai5uYW1lc1tpXTtcbiAgICAgICAgaWYgKG9iai5uYW1lKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuICAvLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxuICB2YXIgZGVmYXVsdE91dGVyT3JkZXIgPSBbJ3YnLCAnbycsICdzJywgJ2knLCAndScsICdlJywgJ3AnLCAnYycsICdiJywgJ3QnLCAncicsICd6JywgJ2EnXTtcbiAgdmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG4gIHdyaXRlciA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICAgIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgc2Vzc2lvbi52ZXJzaW9uID0gMDsgLy8gJ3Y9MCcgbXVzdCBiZSB0aGVyZSAob25seSBkZWZpbmVkIHZlcnNpb24gYXRtKVxuICAgIH1cbiAgICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICAgIHNlc3Npb24ubmFtZSA9ICcgJzsgLy8gJ3M9ICcgbXVzdCBiZSB0aGVyZSBpZiBubyBtZWFuaW5nZnVsIG5hbWUgc2V0XG4gICAgfVxuICAgIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICAgIGlmIChtTGluZS5wYXlsb2FkcyA9PSBudWxsKSB7XG4gICAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XG4gICAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gICAgdmFyIHNkcCA9IFtdO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIG91dGVyT3JkZXIgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMgb24gc2Vzc2lvblxuICAgIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iai5uYW1lIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5wdXNoIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgICBzZHAucHVzaChtYWtlTGluZSgnbScsIGdyYW1tYXIubVswXSwgbUxpbmUpKTtcbiAgICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGlmIChvYmoubmFtZSBpbiBtTGluZSAmJiBtTGluZVtvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1MaW5lW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xuICB9O1xuICByZXR1cm4gd3JpdGVyO1xufXZhciBoYXNSZXF1aXJlZExpYjtcbmZ1bmN0aW9uIHJlcXVpcmVMaWIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZExpYikgcmV0dXJuIGxpYjtcbiAgaGFzUmVxdWlyZWRMaWIgPSAxO1xuICB2YXIgcGFyc2VyID0gcmVxdWlyZVBhcnNlcigpO1xuICB2YXIgd3JpdGVyID0gcmVxdWlyZVdyaXRlcigpO1xuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG4gIGxpYi5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgbGliLndyaXRlID0gd3JpdGVyO1xuICBsaWIucGFyc2UgPSBwYXJzZXIucGFyc2U7XG4gIGxpYi5wYXJzZVBhcmFtcyA9IHBhcnNlci5wYXJzZVBhcmFtcztcbiAgbGliLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7IC8vIEFsaWFzIG9mIHBhcnNlUGFyYW1zKCkuXG4gIGxpYi5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG4gIGxpYi5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBwYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xuICBsaWIucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBwYXJzZXIucGFyc2VJbWFnZUF0dHJpYnV0ZXM7XG4gIGxpYi5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuICByZXR1cm4gbGliO1xufXZhciBsaWJFeHBvcnRzID0gcmVxdWlyZUxpYigpO2Z1bmN0aW9uIHIociwgZSwgbikge1xuICB2YXIgaSwgdCwgbztcbiAgdm9pZCAwID09PSBlICYmIChlID0gNTApLCB2b2lkIDAgPT09IG4gJiYgKG4gPSB7fSk7XG4gIHZhciBhID0gbnVsbCAhPSAoaSA9IG4uaXNJbW1lZGlhdGUpICYmIGksXG4gICAgdSA9IG51bGwgIT0gKHQgPSBuLmNhbGxiYWNrKSAmJiB0LFxuICAgIGMgPSBuLm1heFdhaXQsXG4gICAgdiA9IERhdGUubm93KCksXG4gICAgbCA9IFtdO1xuICBmdW5jdGlvbiBmKCkge1xuICAgIGlmICh2b2lkIDAgIT09IGMpIHtcbiAgICAgIHZhciByID0gRGF0ZS5ub3coKSAtIHY7XG4gICAgICBpZiAociArIGUgPj0gYykgcmV0dXJuIGMgLSByO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICB2YXIgZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgIG4gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoaSwgdCkge1xuICAgICAgdmFyIGMgPSBhICYmIHZvaWQgMCA9PT0gbztcbiAgICAgIGlmICh2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvID0gdm9pZCAwLCB2ID0gRGF0ZS5ub3coKSwgIWEpIHtcbiAgICAgICAgICB2YXIgaSA9IHIuYXBwbHkobiwgZSk7XG4gICAgICAgICAgdSAmJiB1KGkpLCBsLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgci5yZXNvbHZlKShpKTtcbiAgICAgICAgICB9KSwgbCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9LCBmKCkpLCBjKSB7XG4gICAgICAgIHZhciBkID0gci5hcHBseShuLCBlKTtcbiAgICAgICAgcmV0dXJuIHUgJiYgdShkKSwgaShkKTtcbiAgICAgIH1cbiAgICAgIGwucHVzaCh7XG4gICAgICAgIHJlc29sdmU6IGksXG4gICAgICAgIHJlamVjdDogdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBkLmNhbmNlbCA9IGZ1bmN0aW9uIChyKSB7XG4gICAgdm9pZCAwICE9PSBvICYmIGNsZWFyVGltZW91dChvKSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gKDAsIGUucmVqZWN0KShyKTtcbiAgICB9KSwgbCA9IFtdO1xuICB9LCBkO1xufS8qIFRoZSBzdmMgY29kZWMgKGF2MS92cDkpIHdvdWxkIHVzZSBhIHZlcnkgbG93IGJpdHJhdGUgYXQgdGhlIGJlZ2luaW5nIGFuZFxuaW5jcmVhc2Ugc2xvd2x5IGJ5IHRoZSBiYW5kd2lkdGggZXN0aW1hdG9yIHVudGlsIGl0IHJlYWNoIHRoZSB0YXJnZXQgYml0cmF0ZS4gVGhlXG5wcm9jZXNzIGNvbW1vbmx5IGNvc3QgbW9yZSB0aGFuIDEwIHNlY29uZHMgY2F1c2Ugc3Vic2NyaWJlciB3aWxsIGdldCBibHVyIHZpZGVvIGF0XG50aGUgZmlyc3QgZmV3IHNlY29uZHMuIFNvIHdlIHVzZSBhIDcwJSBvZiB0YXJnZXQgYml0cmF0ZSBoZXJlIGFzIHRoZSBzdGFydCBiaXRyYXRlIHRvXG5lbGltaW5hdGUgdGhpcyBpc3N1ZS5cbiovXG5jb25zdCBzdGFydEJpdHJhdGVGb3JTVkMgPSAwLjc7XG5jb25zdCBkZWJvdW5jZUludGVydmFsID0gMjA7XG5jb25zdCBQQ0V2ZW50cyA9IHtcbiAgTmVnb3RpYXRpb25TdGFydGVkOiAnbmVnb3RpYXRpb25TdGFydGVkJyxcbiAgTmVnb3RpYXRpb25Db21wbGV0ZTogJ25lZ290aWF0aW9uQ29tcGxldGUnLFxuICBSVFBWaWRlb1BheWxvYWRUeXBlczogJ3J0cFZpZGVvUGF5bG9hZFR5cGVzJ1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFBDVHJhbnNwb3J0IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgcGMoKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYztcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuZGRFeHRJRCA9IDA7XG4gICAgdGhpcy5sYXRlc3RPZmZlcklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzID0gW107XG4gICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tCaXRyYXRlcyA9IFtdO1xuICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IFtdO1xuICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBbXTtcbiAgICAvLyBkZWJvdW5jZWQgbmVnb3RpYXRlIGludGVyZmFjZVxuICAgIHRoaXMubmVnb3RpYXRlID0gcihvbkVycm9yID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgZGVib3VuY2VJbnRlcnZhbCk7XG4gICAgdGhpcy5jbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbnRyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjID0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUENUcmFuc3BvcnQpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gICAgdGhpcy5vZmZlckxvY2sgPSBuZXcgXygpO1xuICB9XG4gIGNyZWF0ZVBDKCkge1xuICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKTtcbiAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldi5jYW5kaWRhdGUpO1xuICAgIH07XG4gICAgcGMub25pY2VjYW5kaWRhdGVlcnJvciA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25TaWduYWxpbmdTdGF0ZWNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25kYXRhY2hhbm5lbCA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub250cmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIHBjO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIGdldCBpc0lDRUNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMgIT09IG51bGwgJiYgKHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24gJiYgIXRoaXMucmVzdGFydGluZ0ljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0pO1xuICB9XG4gIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkLCBvZmZlcklkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzZC50eXBlID09PSAnYW5zd2VyJyAmJiB0aGlzLmxhdGVzdE9mZmVySWQgPiAwICYmIG9mZmVySWQgPiAwICYmIG9mZmVySWQgIT09IHRoaXMubGF0ZXN0T2ZmZXJJZCkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdpZ25vcmluZyBhbnN3ZXIgZm9yIG9sZCBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIG9mZmVySWQsXG4gICAgICAgICAgbGF0ZXN0T2ZmZXJJZDogdGhpcy5sYXRlc3RPZmZlcklkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IG11bmdlZFNEUCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc3RlcmVvTWlkcyxcbiAgICAgICAgICBuYWNrTWlkc1xuICAgICAgICB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IHN0ZXJlb01pZHM7XG4gICAgICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBuYWNrTWlkcztcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBzZC5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICAgIGNvbnN0IG1pZCA9IGdldE1pZFN0cmluZyhtZWRpYS5taWQpO1xuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAvLyBtdW5nZSBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XG4gICAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtaWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyA9IGZtdHAuY29uZmlnLnNwbGl0KCc7JykuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaW5jbHVkZXMoJ21heGF2ZXJhZ2ViaXRyYXRlJykpLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjttYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IFwibWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbXVuZ2VkU0RQID0gbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAoc2QsIG11bmdlZFNEUCwgdHJ1ZSk7XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlKTtcbiAgICAgICAgaWYgKHNkLnNkcCkge1xuICAgICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2Uoc2Quc2RwKTtcbiAgICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIG1lZGlhLnJ0cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMub2ZmZXJMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLm9uT2ZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBJQ0UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjICYmIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgICAvLyB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgcGVlciB0byBhY2NlcHQgb3VyIG9mZmVyLCBzbyB3ZSdsbCBqdXN0IHdhaXRcbiAgICAgICAgICAvLyB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZFxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTRCA9IHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpICYmIGN1cnJlbnRTRCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAvLyB0aGUgYmVzdCB0aGluZyB0byBkbyBpcyB0byByZWNyZWF0ZSB0aGUgcGVlcmNvbm5lY3Rpb25cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGN1cnJlbnRTRCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fcGMgfHwgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGNyZWF0ZU9mZmVyIHdpdGggY2xvc2VkIHBlZXIgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIG9mZmVyIGlkIGF0IHRoZSBzdGFydCB0byBlbnN1cmUgdGhlIG9mZmVyIGlzIGFsd2F5cyA+IDAgc28gdGhhdCB3ZSBjYW4gdXNlIDAgYXMgYSBkZWZhdWx0IHZhbHVlIGZvciBsZWdhY3kgYmVoYXZpb3JcbiAgICAgICAgY29uc3Qgb2ZmZXJJZCA9IHRoaXMubGF0ZXN0T2ZmZXJJZCArIDE7XG4gICAgICAgIHRoaXMubGF0ZXN0T2ZmZXJJZCA9IG9mZmVySWQ7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geWllbGQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ29yaWdpbmFsIG9mZmVyJywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgc2RwOiBvZmZlci5zZHBcbiAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpO1xuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFsnYWxsJ10sIFtdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKHRyYWNrYnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoIW1lZGlhLm1zaWQgfHwgIXRyYWNrYnIuY2lkIHx8ICFtZWRpYS5tc2lkLmluY2x1ZGVzKHRyYWNrYnIuY2lkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgY29kZWNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1NWQ0NvZGVjKHRyYWNrYnIuY29kZWMpICYmICFpc1NhZmFyaSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDKG1lZGlhLCBzZHBQYXJzZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIG11bmcgc2RwIGZvciBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcbiAgICAgICAgICAgICAgaWYgKCFpc1NWQ0NvZGVjKHRyYWNrYnIuY29kZWMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRCaXRyYXRlID0gTWF0aC5yb3VuZCh0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGFub3RoZXIgdHJhY2sncyBmbXRwIGFscmVhZHkgaXMgc2V0LCB3ZSBjYW5ub3Qgb3ZlcnJpZGUgdGhlIGJpdHJhdGVcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHRoZSB1bmZvcnR1bmF0ZSBjb25zZXF1ZW5jZSBvZiBiZWluZyBmb3JjZWQgdG8gdXNlIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbCB0cmFjaydzIGJpdHJhdGUgZm9yIGFsbCB0cmFja3NcbiAgICAgICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjt4LWdvb2dsZS1zdGFydC1iaXRyYXRlPVwiLmNvbmNhdChzdGFydEJpdHJhdGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0T2ZmZXJJZCA+IG9mZmVySWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdsYXRlc3RPZmZlcklkIG1pc21hdGNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBsYXRlc3RPZmZlcklkOiB0aGlzLmxhdGVzdE9mZmVySWQsXG4gICAgICAgICAgICBvZmZlcklkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChvZmZlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcbiAgICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyLCB0aGlzLmxhdGVzdE9mZmVySWQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQW5kU2V0QW5zd2VyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBhbnN3ZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpO1xuICB9XG4gIGFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cbiAgYWRkVHJhbnNjZWl2ZXJPZktpbmQoa2luZCwgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIoa2luZCwgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFja0NvZGVjQml0cmF0ZShpbmZvKSB7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzLnB1c2goaW5mbyk7XG4gIH1cbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gIH1cbiAgY2FuUmVtb3ZlVHJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldElDRUNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmljZUNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsaW5nU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldFRyYW5zY2VpdmVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRTZW5kZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VuZGVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uO1xuICB9XG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZURlc2NyaXB0aW9uO1xuICB9XG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXJzID0gbmV3IE1hcCgpO1xuICAgICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgc3dpdGNoICh2LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJyAmJiB2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgY2FuZGlkYXRlcy5zZXQodi5pZCwgXCJcIi5jb25jYXQodi5hZGRyZXNzLCBcIjpcIikuY29uY2F0KHYucG9ydCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRJRCA9IChfYSA9IGNhbmRpZGF0ZVBhaXJzLmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVDYW5kaWRhdGVJZDtcbiAgICAgIGlmIChzZWxlY3RlZElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGVzLmdldChzZWxlY3RlZElEKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNdW5nZWRTRFAoc2QsIG11bmdlZCwgcmVtb3RlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChtdW5nZWQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTZHAgPSBzZC5zZHA7XG4gICAgICAgIHNkLnNkcCA9IG11bmdlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgbXVuZ2VkIFwiLmNvbmNhdChyZW1vdGUgPyAncmVtb3RlJyA6ICdsb2NhbCcsIFwiIGRlc2NyaXB0aW9uXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwibm90IGFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlLCBcIiwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgc2RwOiBtdW5nZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgc2Quc2RwID0gb3JpZ2luYWxTZHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBtc2cgPSAndW5rbm93biBlcnJvcic7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtc2cgPSBlLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbXNnID0gZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZHMgPSB7XG4gICAgICAgICAgZXJyb3I6IG1zZyxcbiAgICAgICAgICBzZHA6IHNkLnNkcFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXJlbW90ZSAmJiB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgZmllbGRzLnJlbW90ZVNkcCA9IHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZmllbGRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDKG1lZGlhLCBzZHApIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRkRm91bmQgPSAoX2EgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGV4dCA9PiB7XG4gICAgICBpZiAoZXh0LnVyaSA9PT0gZGRFeHRlbnNpb25VUkkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKCFkZEZvdW5kKSB7XG4gICAgICBpZiAodGhpcy5kZEV4dElEID09PSAwKSB7XG4gICAgICAgIGxldCBtYXhJRCA9IDA7XG4gICAgICAgIHNkcC5tZWRpYS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAobS50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYSA9IG0uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChleHQgPT4ge1xuICAgICAgICAgICAgaWYgKGV4dC52YWx1ZSA+IG1heElEKSB7XG4gICAgICAgICAgICAgIG1heElEID0gZXh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZEV4dElEID0gbWF4SUQgKyAxO1xuICAgICAgfVxuICAgICAgKF9iID0gbWVkaWEuZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRkRXh0SUQsXG4gICAgICAgIHVyaTogZGRFeHRlbnNpb25VUklcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBzdGVyZW9NaWRzLCBuYWNrTWlkcykge1xuICAvLyBzZHAtdHJhbnNmb3JtIHR5cGVzIGRvbid0IGluY2x1ZGUgbnVtYmVyIGhvd2V2ZXIgdGhlIHBhcnNlciBvdXRwdXRzIG1pZHMgYXMgbnVtYmVycyBpbiBzb21lIGNhc2VzXG4gIGNvbnN0IG1pZCA9IGdldE1pZFN0cmluZyhtZWRpYS5taWQpO1xuICAvLyBmb3VuZCBvcHVzIGNvZGVjIHRvIGFkZCBuYWNrIGZiXG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIC8vIGFkZCBuYWNrIHJ0Y3BmYiBpZiBub3QgZXhpc3RcbiAgaWYgKG9wdXNQYXlsb2FkID4gMCkge1xuICAgIGlmICghbWVkaWEucnRjcEZiKSB7XG4gICAgICBtZWRpYS5ydGNwRmIgPSBbXTtcbiAgICB9XG4gICAgaWYgKG5hY2tNaWRzLmluY2x1ZGVzKG1pZCkgJiYgIW1lZGlhLnJ0Y3BGYi5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgcGF5bG9hZDogb3B1c1BheWxvYWQsXG4gICAgICAgIHR5cGU6ICduYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVyZW9NaWRzLmluY2x1ZGVzKG1pZCkgfHwgc3RlcmVvTWlkcy5sZW5ndGggPT09IDEgJiYgc3RlcmVvTWlkc1swXSA9PT0gJ2FsbCcpIHtcbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCdzdGVyZW89MScpKSB7XG4gICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnO3N0ZXJlbz0xJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKG9mZmVyKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc3RlcmVvTWlkcyA9IFtdO1xuICBjb25zdCBuYWNrTWlkcyA9IFtdO1xuICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IG9mZmVyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG1pZCA9IGdldE1pZFN0cmluZyhtZWRpYS5taWQpO1xuICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKChfYSA9IG1lZGlhLnJ0Y3BGYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZmIgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgICBuYWNrTWlkcy5wdXNoKG1pZCk7XG4gICAgICB9XG4gICAgICBtZWRpYS5mbXRwLnNvbWUoZm10cCA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKGZtdHAuY29uZmlnLmluY2x1ZGVzKCdzcHJvcC1zdGVyZW89MScpKSB7XG4gICAgICAgICAgICBzdGVyZW9NaWRzLnB1c2gobWlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGVyZW9NaWRzLFxuICAgIG5hY2tNaWRzXG4gIH07XG59XG5mdW5jdGlvbiBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpIHtcbiAgLy8gQ2hyb21lIGNvdWxkIGdlbmVyYXRlIHNkcCB3aXRoIGMgPSBJTiBJUDQgPGlwdjYgYWRkcj5cbiAgLy8gaW4gZWRnZSBjYXNlIGFuZCByZXR1cm4gZXJyb3Igd2hlbiBzZXQgc2RwLlRoaXMgaXMgbm90IGFcbiAgLy8gc2RrIGVycm9yIGJ1dCBjb3JyZWN0IGl0IGlmIHRoZSBpc3N1ZSBkZXRlY3RlZC5cbiAgaWYgKG1lZGlhLmNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBpc1Y2ID0gbWVkaWEuY29ubmVjdGlvbi5pcC5pbmRleE9mKCc6JykgPj0gMDtcbiAgICBpZiAobWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA0ICYmIGlzVjYgfHwgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA2ICYmICFpc1Y2KSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBkdW1teSBhZGRyZXNzXG4gICAgICBtZWRpYS5jb25uZWN0aW9uLmlwID0gJzAuMC4wLjAnO1xuICAgICAgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID0gNDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1pZFN0cmluZyhtaWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBtaWQgPT09ICdudW1iZXInID8gbWlkLnRvRml4ZWQoMCkgOiBtaWQ7XG59Y29uc3QgZGVmYXVsdFZpZGVvQ29kZWMgPSAndnA4JztcbmNvbnN0IHB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcbiAgZHR4OiB0cnVlLFxuICByZWQ6IHRydWUsXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcbiAgc2ltdWxjYXN0OiB0cnVlLFxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcbiAgdmlkZW9Db2RlYzogZGVmYXVsdFZpZGVvQ29kZWMsXG4gIGJhY2t1cENvZGVjOiB0cnVlLFxuICBwcmVDb25uZWN0QnVmZmVyOiBmYWxzZVxufTtcbmNvbnN0IGF1ZGlvRGVmYXVsdHMgPSB7XG4gIGRldmljZUlkOiB7XG4gICAgaWRlYWw6ICdkZWZhdWx0J1xuICB9LFxuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gIHZvaWNlSXNvbGF0aW9uOiB0cnVlXG59O1xuY29uc3QgdmlkZW9EZWZhdWx0cyA9IHtcbiAgZGV2aWNlSWQ6IHtcbiAgICBpZGVhbDogJ2RlZmF1bHQnXG4gIH0sXG4gIHJlc29sdXRpb246IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb25cbn07XG5jb25zdCByb29tT3B0aW9uRGVmYXVsdHMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgd2ViQXVkaW9NaXg6IGZhbHNlLFxuICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogZmFsc2Vcbn07XG5jb25zdCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1MDAwLFxuICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxufTt2YXIgUENUcmFuc3BvcnRTdGF0ZTtcbihmdW5jdGlvbiAoUENUcmFuc3BvcnRTdGF0ZSkge1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJORVdcIl0gPSAwXSA9IFwiTkVXXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDT05ORUNURURcIl0gPSAyXSA9IFwiQ09OTkVDVEVEXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkZBSUxFRFwiXSA9IDNdID0gXCJGQUlMRURcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0lOR1wiXSA9IDRdID0gXCJDTE9TSU5HXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNMT1NFRFwiXSA9IDVdID0gXCJDTE9TRURcIjtcbn0pKFBDVHJhbnNwb3J0U3RhdGUgfHwgKFBDVHJhbnNwb3J0U3RhdGUgPSB7fSkpO1xuY2xhc3MgUENUcmFuc3BvcnRNYW5hZ2VyIHtcbiAgZ2V0IG5lZWRzUHVibGlzaGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG4gIGdldCBuZWVkc1N1YnNjcmliZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkO1xuICB9XG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cbiAgY29uc3RydWN0b3IocnRjQ29uZmlnLCBtb2RlLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMudXBkYXRlU3RhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKHRyID0+IHRyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY29ubmVjdGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuc29tZShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnbmV3JykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwYyBzdGF0ZSBjaGFuZ2U6IGZyb20gXCIuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbcHJldmlvdXNTdGF0ZV0sIFwiIHRvIFwiKS5jb25jYXQoUENUcmFuc3BvcnRTdGF0ZVt0aGlzLnN0YXRlXSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIChfYSA9IHRoaXMub25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksIChfYiA9IHRoaXMuc3Vic2NyaWJlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUENNYW5hZ2VyKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSBtb2RlICE9PSAnc3Vic2NyaWJlci1wcmltYXJ5JztcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IG1vZGUgPT09ICdzdWJzY3JpYmVyLXByaW1hcnknO1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgaWYgKG1vZGUgIT09ICdwdWJsaXNoZXItb25seScpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgICB0aGlzLnN1YnNjcmliZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgICAgfTtcbiAgICAgIC8vIGluIHN1YnNjcmliZXIgcHJpbWFyeSBtb2RlLCBzZXJ2ZXIgc2lkZSBvcGVucyBzdWIgZGF0YSBjaGFubmVscy5cbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vbkRhdGFDaGFubmVsID0gZXYgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5wdWJsaXNoZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIub25PZmZlciA9IChvZmZlciwgb2ZmZXJJZCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vblB1Ymxpc2hlck9mZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBvZmZlciwgb2ZmZXJJZCk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5ORVc7XG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5yZW1vdGVPZmZlckxvY2sgPSBuZXcgXygpO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIHJlcXVpcmVQdWJsaXNoZXIoKSB7XG4gICAgbGV0IHJlcXVpcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcbiAgfVxuICBzZXRQdWJsaXNoZXJBbnN3ZXIoc2QsIG9mZmVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QsIG9mZmVySWQpO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBoYXZlIHJlbW92ZVRyYWNrIHlldC5cbiAgICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xuICAgICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLnB1Ymxpc2hlci5jbG9zZSgpLCAoX2EgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpXSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJpZ2dlckljZVJlc3RhcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gb25seSByZXN0YXJ0IHB1Ymxpc2hlciBpZiBpdCdzIG5lZWRlZFxuICAgICAgaWYgKHRoaXMubmVlZHNQdWJsaXNoZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIoe1xuICAgICAgICAgIGljZVJlc3RhcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCAoX2EgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkLCBvZmZlcklkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxuICAgICAgICBzZHA6IHNkLnNkcCxcbiAgICAgICAgc2lnbmFsaW5nU3RhdGU6IChfYSA9IHRoaXMuc3Vic2NyaWJlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNpZ25hbGxpbmdTdGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucmVtb3RlT2ZmZXJMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB5aWVsZCAoX2IgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCwgb2ZmZXJJZCk7XG4gICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5zd2VyIHRoZSBvZmZlclxuICAgICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCAoX2MgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnLCBpY2VSZXN0YXJ0KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMucHVibGlzaGVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICAoX2EgPSB0aGlzLnN1YnNjcmliZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgaWYgKGljZVJlc3RhcnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ25lZ290aWF0aW9uIHJlcXVpcmVkLCBzdGFydCBuZWdvdGlhdGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoKF9hID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAodHJhbnNwb3J0ID0+IHRoaXMuZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHRyYW5zcG9ydCwgYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBuZWdvdGlhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKGUgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRQdWJsaXNoZXJUcmFuc2NlaXZlck9mS2luZChraW5kLCB0cmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXJPZktpbmQoa2luZCwgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBnZXRNaWRGb3JSZWNlaXZlcihyZWNlaXZlcikge1xuICAgIGNvbnN0IHRyYW5zY2VpdmVycyA9IHRoaXMuc3Vic2NyaWJlciA/IHRoaXMuc3Vic2NyaWJlci5nZXRUcmFuc2NlaXZlcnMoKSA6IHRoaXMucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpO1xuICAgIGNvbnN0IG1hdGNoaW5nVHJhbnNjZWl2ZXIgPSB0cmFuc2NlaXZlcnMuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlciA9PT0gcmVjZWl2ZXIpO1xuICAgIHJldHVybiBtYXRjaGluZ1RyYW5zY2VpdmVyID09PSBudWxsIHx8IG1hdGNoaW5nVHJhbnNjZWl2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoaW5nVHJhbnNjZWl2ZXIubWlkO1xuICB9XG4gIGFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBjcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCByZXF1aXJlZCB0cmFuc3BvcnQncyBhZGRyZXNzIGlmIG5vIGV4cGxpY2l0IHRhcmdldCBpcyBzcGVjaWZpZWRcbiAgICovXG4gIGdldENvbm5lY3RlZEFkZHJlc3ModGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0c1swXS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gIH1cbiAgZ2V0IHJlcXVpcmVkVHJhbnNwb3J0cygpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0gW107XG4gICAgaWYgKHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnB1Ymxpc2hlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCAmJiB0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQocGNUcmFuc3BvcnRfMSwgYWJvcnRDb250cm9sbGVyXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocGNUcmFuc3BvcnQsIGFib3J0Q29udHJvbGxlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGUgPSBwY1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHJlamVjdChDb25uZWN0aW9uRXJyb3IuY2FuY2VsbGVkKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJykpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlamVjdChDb25uZWN0aW9uRXJyb3IuaW50ZXJuYWwoJ2NvdWxkIG5vdCBlc3RhYmxpc2ggcGMgY29ubmVjdGlvbicpKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTsgLy8gRklYTUUgd2Ugc2hvdWxkbid0IHJlbHkgb24gYHNsZWVwYCBpbiB0aGUgY29ubmVjdGlvbiBwYXRocywgYXMgaXQgaW52b2tlcyBgc2V0VGltZW91dGAgd2hpY2ggY2FuIGJlIGRyYXN0aWNhbGx5IHRocm90dGxlZCBieSBicm93c2VyIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICByZWplY3QoQ29ubmVjdGlvbkVycm9yLmNhbmNlbGxlZCgncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59Y29uc3QgREVGQVVMVF9NQVhfQUdFX01TID0gNTAwMDtcbmNvbnN0IFNUT1BfUkVGRVRDSF9ERUxBWV9NUyA9IDMwMDAwO1xuY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBzdGF0aWMgZmV0Y2hSZWdpb25TZXR0aW5ncyhzZXJ2ZXJVcmwsIHRva2VuLCBzaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgUmVnaW9uVXJsUHJvdmlkZXIuZmV0Y2hMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzUmVzcG9uc2UgPSB5aWVsZCBmZXRjaChcIlwiLmNvbmNhdChnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpLCBcIi9yZWdpb25zXCIpLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRva2VuKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IG1heEFnZSA9IGV4dHJhY3RNYXhBZ2VGcm9tUmVxdWVzdEhlYWRlcnMocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICBjb25zdCBtYXhBZ2VJbk1zID0gbWF4QWdlID8gbWF4QWdlICogMTAwMCA6IERFRkFVTFRfTUFYX0FHRV9NUztcbiAgICAgICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IHlpZWxkIHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWdpb25TZXR0aW5ncyxcbiAgICAgICAgICAgIHVwZGF0ZWRBdEluTXM6IERhdGUubm93KCksXG4gICAgICAgICAgICBtYXhBZ2VJbk1zXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgdGhyb3cgQ29ubmVjdGlvbkVycm9yLm5vdEFsbG93ZWQoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBDb25uZWN0aW9uRXJyb3IuaW50ZXJuYWwoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgLy8gcmV0aHJvdyBjb25uZWN0aW9uIGVycm9yc1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBDb25uZWN0aW9uRXJyb3IuY2FuY2VsbGVkKFwiUmVnaW9uIGZldGNoaW5nIHdhcyBhYm9ydGVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdyYXAgb3RoZXIgZXJyb3JzIGFzIGNvbm5lY3Rpb24gZXJyb3JzXG4gICAgICAgICAgdGhyb3cgQ29ubmVjdGlvbkVycm9yLnNlcnZlclVucmVhY2hhYmxlKFwiQ291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5ncywgXCIuY29uY2F0KGUgaW5zdGFuY2VvZiBFcnJvciA/IFwiXCIuY29uY2F0KGUubmFtZSwgXCI6IFwiKS5jb25jYXQoZS5tZXNzYWdlKSA6IGUpKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNjaGVkdWxlUmVmZXRjaCh1cmwsIHRva2VuLCBtYXhBZ2VJbk1zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBSZWdpb25VcmxQcm92aWRlci5zZXR0aW5nc1RpbWVvdXRzLmdldCh1cmwuaG9zdG5hbWUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cy5zZXQodXJsLmhvc3RuYW1lLCBzZXRUaW1lb3V0KCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHlpZWxkIFJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3ModXJsLCB0b2tlbik7XG4gICAgICAgICAgUmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlQ2FjaGVkUmVnaW9uU2V0dGluZ3ModXJsLCB0b2tlbiwgbmV3U2V0dGluZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd0b2tlbiBpcyBub3QgdmFsaWQsIGNhbmNlbGxpbmcgYXV0byByZWdpb24gcmVmcmVzaCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdhdXRvIHJlZmV0Y2hpbmcgb2YgcmVnaW9uIHNldHRpbmdzIGZhaWxlZCcsIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcgd2l0aCB0aGUgc2FtZSBtYXggYWdlXG4gICAgICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2NoZWR1bGVSZWZldGNoKHVybCwgdG9rZW4sIG1heEFnZUluTXMpO1xuICAgICAgICB9XG4gICAgICB9KSwgbWF4QWdlSW5NcykpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVDYWNoZWRSZWdpb25TZXR0aW5ncyh1cmwsIHRva2VuLCBzZXR0aW5ncykge1xuICAgIFJlZ2lvblVybFByb3ZpZGVyLmNhY2hlLnNldCh1cmwuaG9zdG5hbWUsIHNldHRpbmdzKTtcbiAgICBSZWdpb25VcmxQcm92aWRlci5zY2hlZHVsZVJlZmV0Y2godXJsLCB0b2tlbiwgc2V0dGluZ3MubWF4QWdlSW5Ncyk7XG4gIH1cbiAgc3RhdGljIHN0b3BSZWZldGNoKGhvc3RuYW1lKSB7XG4gICAgY29uc3QgdGltZW91dCA9IFJlZ2lvblVybFByb3ZpZGVyLnNldHRpbmdzVGltZW91dHMuZ2V0KGhvc3RuYW1lKTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cy5kZWxldGUoaG9zdG5hbWUpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2NoZWR1bGVDbGVhbnVwKGhvc3RuYW1lKSB7XG4gICAgbGV0IHRyYWNrZXIgPSBSZWdpb25VcmxQcm92aWRlci5jb25uZWN0aW9uVHJhY2tlcnMuZ2V0KGhvc3RuYW1lKTtcbiAgICBpZiAoIXRyYWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2FuY2VsIGFueSBleGlzdGluZyBjbGVhbnVwIHRpbWVvdXRcbiAgICBpZiAodHJhY2tlci5jbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrZXIuY2xlYW51cFRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBTY2hlZHVsZSBjbGVhbnVwIHRvIHN0b3AgcmVmZXRjaCBhZnRlciBkZWxheVxuICAgIHRyYWNrZXIuY2xlYW51cFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgICBpZiAoY3VycmVudFRyYWNrZXIgJiYgY3VycmVudFRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3N0b3BwaW5nIHJlZ2lvbiByZWZldGNoIGFmdGVyIGRpc2Nvbm5lY3QgZGVsYXknLCB7XG4gICAgICAgICAgaG9zdG5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlZ2lvblVybFByb3ZpZGVyLnN0b3BSZWZldGNoKGhvc3RuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhY2tlcikge1xuICAgICAgICBjdXJyZW50VHJhY2tlci5jbGVhbnVwVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCBTVE9QX1JFRkVUQ0hfREVMQVlfTVMpO1xuICB9XG4gIHN0YXRpYyBjYW5jZWxDbGVhbnVwKGhvc3RuYW1lKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IFJlZ2lvblVybFByb3ZpZGVyLmNvbm5lY3Rpb25UcmFja2Vycy5nZXQoaG9zdG5hbWUpO1xuICAgIGlmICh0cmFja2VyID09PSBudWxsIHx8IHRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrZXIuY2xlYW51cFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFja2VyLmNsZWFudXBUaW1lb3V0KTtcbiAgICAgIHRyYWNrZXIuY2xlYW51cFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG5vdGlmeUNvbm5lY3RlZCgpIHtcbiAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuc2VydmVyVXJsLmhvc3RuYW1lO1xuICAgIGxldCB0cmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICB0cmFja2VyID0ge1xuICAgICAgICBjb25uZWN0aW9uQ291bnQ6IDBcbiAgICAgIH07XG4gICAgICBSZWdpb25VcmxQcm92aWRlci5jb25uZWN0aW9uVHJhY2tlcnMuc2V0KGhvc3RuYW1lLCB0cmFja2VyKTtcbiAgICB9XG4gICAgdHJhY2tlci5jb25uZWN0aW9uQ291bnQrKztcbiAgICAvLyBDYW5jZWwgYW55IHNjaGVkdWxlZCBjbGVhbnVwIHNpbmNlIHdlIGhhdmUgYW4gYWN0aXZlIGNvbm5lY3Rpb25cbiAgICBSZWdpb25VcmxQcm92aWRlci5jYW5jZWxDbGVhbnVwKGhvc3RuYW1lKTtcbiAgfVxuICBub3RpZnlEaXNjb25uZWN0ZWQoKSB7XG4gICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLnNlcnZlclVybC5ob3N0bmFtZTtcbiAgICBjb25zdCB0cmFja2VyID0gUmVnaW9uVXJsUHJvdmlkZXIuY29ubmVjdGlvblRyYWNrZXJzLmdldChob3N0bmFtZSk7XG4gICAgaWYgKCF0cmFja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID0gTWF0aC5tYXgoMCwgdHJhY2tlci5jb25uZWN0aW9uQ291bnQgLSAxKTtcbiAgICAvLyBJZiBubyBtb3JlIGNvbm5lY3Rpb25zLCBzY2hlZHVsZSBjbGVhbnVwXG4gICAgaWYgKHRyYWNrZXIuY29ubmVjdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICBSZWdpb25VcmxQcm92aWRlci5zY2hlZHVsZUNsZWFudXAoaG9zdG5hbWUpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIHVwZGF0ZVRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGlzQ2xvdWQoKSB7XG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xuICB9XG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBSZWdpb25VcmxQcm92aWRlci5mZXRjaFJlZ2lvblNldHRpbmdzKHRoaXMuc2VydmVyVXJsLCB0aGlzLnRva2VuLCBhYm9ydFNpZ25hbCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dEJlc3RSZWdpb25VcmwoYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XG4gICAgICB9XG4gICAgICBsZXQgY2FjaGVkU2V0dGluZ3MgPSBSZWdpb25VcmxQcm92aWRlci5jYWNoZS5nZXQodGhpcy5zZXJ2ZXJVcmwuaG9zdG5hbWUpO1xuICAgICAgaWYgKCFjYWNoZWRTZXR0aW5ncyB8fCBEYXRlLm5vdygpIC0gY2FjaGVkU2V0dGluZ3MudXBkYXRlZEF0SW5NcyA+IGNhY2hlZFNldHRpbmdzLm1heEFnZUluTXMpIHtcbiAgICAgICAgY2FjaGVkU2V0dGluZ3MgPSB5aWVsZCB0aGlzLmZldGNoUmVnaW9uU2V0dGluZ3MoYWJvcnRTaWduYWwpO1xuICAgICAgICBSZWdpb25VcmxQcm92aWRlci51cGRhdGVDYWNoZWRSZWdpb25TZXR0aW5ncyh0aGlzLnNlcnZlclVybCwgdGhpcy50b2tlbiwgY2FjaGVkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uc0xlZnQgPSBjYWNoZWRTZXR0aW5ncy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihyZWdpb24gPT4gIXRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5maW5kKGF0dGVtcHRlZCA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSk7XG4gICAgICBpZiAocmVnaW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5wdXNoKG5leHRSZWdpb24pO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwibmV4dCByZWdpb246IFwiLmNvbmNhdChuZXh0UmVnaW9uLnJlZ2lvbikpO1xuICAgICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXNldEF0dGVtcHRzKCkge1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICB9XG4gIHNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhzZXR0aW5ncykge1xuICAgIFJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZUNhY2hlZFJlZ2lvblNldHRpbmdzKHRoaXMuc2VydmVyVXJsLCB0aGlzLnRva2VuLCBzZXR0aW5ncyk7XG4gIH1cbn1cblJlZ2lvblVybFByb3ZpZGVyLmNhY2hlID0gbmV3IE1hcCgpO1xuUmVnaW9uVXJsUHJvdmlkZXIuc2V0dGluZ3NUaW1lb3V0cyA9IG5ldyBNYXAoKTtcblJlZ2lvblVybFByb3ZpZGVyLmNvbm5lY3Rpb25UcmFja2VycyA9IG5ldyBNYXAoKTtcblJlZ2lvblVybFByb3ZpZGVyLmZldGNoTG9jayA9IG5ldyBfKCk7XG5mdW5jdGlvbiBnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyksIFwiLy9cIikuY29uY2F0KHNlcnZlclVybC5ob3N0LCBcIi9zZXR0aW5nc1wiKTtcbn0vLyBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiAyMDI0IExpdmVLaXQsIEluYy5cbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuLyoqXG4gKiBTcGVjaWFsaXplZCBlcnJvciBoYW5kbGluZyBmb3IgUlBDIG1ldGhvZHMuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgdHlwZSwgd2hlbiB0aHJvd24gaW4gYSBtZXRob2QgaGFuZGxlciwgd2lsbCBoYXZlIHRoZWlyIGBtZXNzYWdlYFxuICogc2VyaWFsaXplZCBhbmQgc2VudCBhY3Jvc3MgdGhlIHdpcmUuIFRoZSBzZW5kZXIgd2lsbCByZWNlaXZlIGFuIGVxdWl2YWxlbnQgZXJyb3Igb24gdGhlIG90aGVyIHNpZGUuXG4gKlxuICogQnVpbHQtaW4gdHlwZXMgYXJlIGluY2x1ZGVkIGJ1dCBkZXZlbG9wZXJzIG1heSB1c2UgYW55IHN0cmluZywgd2l0aCBhIG1heCBsZW5ndGggb2YgMjU2IGJ5dGVzLlxuICovXG5jbGFzcyBScGNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZGUgYW5kIG1lc3NhZ2UsIHBsdXMgYW4gb3B0aW9uYWwgZGF0YSBwYXlsb2FkLlxuICAgKlxuICAgKiBJZiB0aHJvd24gaW4gYW4gUlBDIG1ldGhvZCBoYW5kbGVyLCB0aGUgZXJyb3Igd2lsbCBiZSBzZW50IGJhY2sgdG8gdGhlIGNhbGxlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgMTAwMS0xOTk5IGFyZSByZXNlcnZlZCBmb3IgYnVpbHQtaW4gZXJyb3JzIChzZWUgUnBjRXJyb3IuRXJyb3JDb2RlIGZvciB0aGVpciBtZWFuaW5ncykuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0cnVuY2F0ZUJ5dGVzKG1lc3NhZ2UsIFJwY0Vycm9yLk1BWF9NRVNTQUdFX0JZVEVTKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhID8gdHJ1bmNhdGVCeXRlcyhkYXRhLCBScGNFcnJvci5NQVhfREFUQV9CWVRFUykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGZyb21Qcm90byhwcm90bykge1xuICAgIHJldHVybiBuZXcgUnBjRXJyb3IocHJvdG8uY29kZSwgcHJvdG8ubWVzc2FnZSwgcHJvdG8uZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9Qcm90bygpIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yJDEoe1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IGZyb20gdGhlIGNvZGUsIHdpdGggYW4gYXV0by1wb3B1bGF0ZWQgbWVzc2FnZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgYnVpbHRJbihrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKFJwY0Vycm9yLkVycm9yQ29kZVtrZXldLCBScGNFcnJvci5FcnJvck1lc3NhZ2Vba2V5XSwgZGF0YSk7XG4gIH1cbn1cblJwY0Vycm9yLk1BWF9NRVNTQUdFX0JZVEVTID0gMjU2O1xuUnBjRXJyb3IuTUFYX0RBVEFfQllURVMgPSAxNTM2MDsgLy8gMTUgS0JcblJwY0Vycm9yLkVycm9yQ29kZSA9IHtcbiAgQVBQTElDQVRJT05fRVJST1I6IDE1MDAsXG4gIENPTk5FQ1RJT05fVElNRU9VVDogMTUwMSxcbiAgUkVTUE9OU0VfVElNRU9VVDogMTUwMixcbiAgUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRDogMTUwMyxcbiAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6IDE1MDQsXG4gIFNFTkRfRkFJTEVEOiAxNTA1LFxuICBVTlNVUFBPUlRFRF9NRVRIT0Q6IDE0MDAsXG4gIFJFQ0lQSUVOVF9OT1RfRk9VTkQ6IDE0MDEsXG4gIFJFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0U6IDE0MDIsXG4gIFVOU1VQUE9SVEVEX1NFUlZFUjogMTQwMyxcbiAgVU5TVVBQT1JURURfVkVSU0lPTjogMTQwNFxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblJwY0Vycm9yLkVycm9yTWVzc2FnZSA9IHtcbiAgQVBQTElDQVRJT05fRVJST1I6ICdBcHBsaWNhdGlvbiBlcnJvciBpbiBtZXRob2QgaGFuZGxlcicsXG4gIENPTk5FQ1RJT05fVElNRU9VVDogJ0Nvbm5lY3Rpb24gdGltZW91dCcsXG4gIFJFU1BPTlNFX1RJTUVPVVQ6ICdSZXNwb25zZSB0aW1lb3V0JyxcbiAgUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRDogJ1JlY2lwaWVudCBkaXNjb25uZWN0ZWQnLFxuICBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRTogJ1Jlc3BvbnNlIHBheWxvYWQgdG9vIGxhcmdlJyxcbiAgU0VORF9GQUlMRUQ6ICdGYWlsZWQgdG8gc2VuZCcsXG4gIFVOU1VQUE9SVEVEX01FVEhPRDogJ01ldGhvZCBub3Qgc3VwcG9ydGVkIGF0IGRlc3RpbmF0aW9uJyxcbiAgUkVDSVBJRU5UX05PVF9GT1VORDogJ1JlY2lwaWVudCBub3QgZm91bmQnLFxuICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAnUmVxdWVzdCBwYXlsb2FkIHRvbyBsYXJnZScsXG4gIFVOU1VQUE9SVEVEX1NFUlZFUjogJ1JQQyBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZlcicsXG4gIFVOU1VQUE9SVEVEX1ZFUlNJT046ICdVbnN1cHBvcnRlZCBSUEMgdmVyc2lvbidcbn07XG4vKlxuICogTWF4aW11bSBwYXlsb2FkIHNpemUgZm9yIFJQQyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLiBJZiBhIHBheWxvYWQgZXhjZWVkcyB0aGlzIHNpemUsXG4gKiB0aGUgUlBDIGNhbGwgd2lsbCBmYWlsIHdpdGggYSBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFKDE0MDIpIG9yIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFKDE1MDQpIGVycm9yLlxuICovXG5jb25zdCBNQVhfUEFZTE9BRF9CWVRFUyA9IDE1MzYwOyAvLyAxNSBLQlxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHIpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKS5sZW5ndGg7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cnVuY2F0ZUJ5dGVzKHN0ciwgbWF4Qnl0ZXMpIHtcbiAgaWYgKGJ5dGVMZW5ndGgoc3RyKSA8PSBtYXhCeXRlcykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2ggKyAxKSAvIDIpO1xuICAgIGlmIChlbmNvZGVyLmVuY29kZShzdHIuc2xpY2UoMCwgbWlkKSkubGVuZ3RoIDw9IG1heEJ5dGVzKSB7XG4gICAgICBsb3cgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyLnNsaWNlKDAsIGxvdyk7XG59Y29uc3QgbW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XG5mdW5jdGlvbiBjb21wdXRlQml0cmF0ZShjdXJyZW50U3RhdHMsIHByZXZTdGF0cykge1xuICBpZiAoIXByZXZTdGF0cykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBieXRlc05vdztcbiAgbGV0IGJ5dGVzUHJldjtcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICB9IGVsc2UgaWYgKCdieXRlc1NlbnQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzU2VudDtcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNTZW50O1xuICB9XG4gIGlmIChieXRlc05vdyA9PT0gdW5kZWZpbmVkIHx8IGJ5dGVzUHJldiA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCB8fCBwcmV2U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gKGJ5dGVzTm93IC0gYnl0ZXNQcmV2KSAqIDggKiAxMDAwIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn0vLyBDaGVjayBpZiBNZWRpYVJlY29yZGVyIGlzIGF2YWlsYWJsZVxuY29uc3QgaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlID0gdHlwZW9mIE1lZGlhUmVjb3JkZXIgIT09ICd1bmRlZmluZWQnO1xuLy8gRmFsbGJhY2sgY2xhc3MgZm9yIGVudmlyb25tZW50cyB3aXRob3V0IE1lZGlhUmVjb3JkZXJcbmNsYXNzIEZhbGxiYWNrUmVjb3JkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIH1cbn1cbi8vIFVzZSBjb25kaXRpb25hbCBpbmhlcml0YW5jZSB0byBhdm9pZCBwYXJzZS10aW1lIGVycm9yc1xuY29uc3QgUmVjb3JkZXJCYXNlID0gaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlID8gTWVkaWFSZWNvcmRlciA6IEZhbGxiYWNrUmVjb3JkZXI7XG5jbGFzcyBMb2NhbFRyYWNrUmVjb3JkZXIgZXh0ZW5kcyBSZWNvcmRlckJhc2Uge1xuICBjb25zdHJ1Y3Rvcih0cmFjaywgb3B0aW9ucykge1xuICAgIGlmICghaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICAgIHN1cGVyKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pLCBvcHRpb25zKTtcbiAgICBsZXQgZGF0YUxpc3RlbmVyO1xuICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xuICAgIGNvbnN0IGlzQ2xvc2VkID0gKCkgPT4gc3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGRhdGFMaXN0ZW5lcik7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3AnLCBvblN0b3ApO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgc3RyZWFtQ29udHJvbGxlciA9PT0gbnVsbCB8fCBzdHJlYW1Db250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBzdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3Qgb25FcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPT09IG51bGwgfHwgc3RyZWFtQ29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RyZWFtQ29udHJvbGxlci5lcnJvcihldmVudCk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCBkYXRhTGlzdGVuZXIpO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9wJywgb25TdG9wKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLmJ5dGVTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgZGF0YUxpc3RlbmVyID0gZXZlbnQgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgIGlmIChldmVudC5kYXRhLmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IHlpZWxkIGV2ZW50LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWN0LW5hdGl2ZSBwYXNzZXMgb3ZlciBVaW50OEFycmF5cyBkaXJlY3RseVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5ieXRlQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGRhdGEgPSBldmVudC5kYXRhLmJ5dGVBcnJheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBkYXRhIGF2YWlsYWJsZSEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZGF0YUxpc3RlbmVyKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgb25TdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgb25TdG9wKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gIH1cbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiByZWNvcmRpbmcgaXMgc3VwcG9ydGVkXG5mdW5jdGlvbiBpc1JlY29yZGluZ1N1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGlzTWVkaWFSZWNvcmRlckF2YWlsYWJsZTtcbn1jb25zdCBERUZBVUxUX0RJTUVOU0lPTlNfVElNRU9VVCA9IDEwMDA7XG5jb25zdCBQUkVfQ09OTkVDVF9CVUZGRVJfVElNRU9VVCA9IDEwMDAwO1xuY2xhc3MgTG9jYWxUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgc2VuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zZW5kZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXQgc2VuZGVyKHNlbmRlcikge1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgfVxuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICB9XG4gIGdldCBoYXNQcmVDb25uZWN0QnVmZmVyKCkge1xuICAgIHJldHVybiAhIXRoaXMubG9jYWxUcmFja1JlY29yZGVyO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQgPSAoKSA9PiB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIoKS5jYXRjaCgoKSA9PiB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgbXV0ZSBib3VuY2UgZ290IGNhbmNlbGxlZCBieSBhbiB1bm11dGUgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIgPSByKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbSgpO1xuICAgIH0pLCA1MDAwKTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCd1bm11dGUnKTtcbiAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUVuZGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQpIHtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XG4gICAgdGhpcy5tdXRlTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5wYXVzZVVwc3RyZWFtTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy50cmFja0NoYW5nZUxvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMudHJhY2tDaGFuZ2VMb2NrLmxvY2soKS50aGVuKHVubG9jayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobWVkaWFUcmFjaywgdHJ1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgLy8gYWRkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciwgY29uc3RyYWludHMgYXJlIHN5bmNlZCB3aXRoIE1lZGlhU3RyZWFtVHJhY2tcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgfVxuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5pZDtcbiAgfVxuICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5raW5kICE9PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgaXNVcHN0cmVhbVBhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVcHN0cmVhbVBhdXNlZDtcbiAgfVxuICBnZXQgaXNVc2VyUHJvdmlkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZWRCeVVzZXI7XG4gIH1cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9jZXNzZWRUcmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHJldHVybnMgbWVkaWFTdHJlYW1UcmFjayBzZXR0aW5ncyBvZiB0aGUgY2FwdHVyaW5nIG1lZGlhc3RyZWFtdHJhY2sgc291cmNlIC0gaWdub3JpbmcgcHJvY2Vzc29yc1xuICAgKi9cbiAgZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICB9XG4gIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2ssIGZvcmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgLy8gZGV0YWNoXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCduZXctdHJhY2snKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBtZWRpYS4gSW4gdGhpcyBjYXNlIHdlJ2xsIG5lZWQgdG8gc2lnbmFsIHdpdGggcmVtb3RlIHRoYXRcbiAgICAgICAgLy8gdGhlIHRyYWNrIGlzIFwibXV0ZWRcIlxuICAgICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gdG91Y2ggTWVkaWFTdHJlYW1UcmFjay5lbmFibGVkXG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBuZXdUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3NlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIG5ld1RyYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yRWxlbWVudCkge1xuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChuZXdUcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgICAvLyBlbnN1cmUgdGhlIHByb2Nlc3NvckVsZW1lbnQgaXRzZWxmIHN0YXlzIG11dGVkXG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3Nvci5yZXN0YXJ0KHtcbiAgICAgICAgICB0cmFjazogbmV3VHJhY2ssXG4gICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgIGVsZW1lbnQ6IHRoaXMucHJvY2Vzc29yRWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzc2VkVHJhY2sgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbmRlciAmJiAoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2socHJvY2Vzc2VkVHJhY2sgIT09IG51bGwgJiYgcHJvY2Vzc2VkVHJhY2sgIT09IHZvaWQgMCA/IHByb2Nlc3NlZFRyYWNrIDogbmV3VHJhY2spO1xuICAgICAgfVxuICAgICAgLy8gaWYgYG5ld1RyYWNrYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdHJhY2ssIHN0b3AgdGhlXG4gICAgICAvLyBvbGRlciB0cmFjayBqdXN0IGJlZm9yZSByZXBsYWNpbmcgaXRcbiAgICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICAvLyBzeW5jIG11dGVkIHN0YXRlIHdpdGggdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG5ld2x5IHByb3ZpZGVkIHRyYWNrXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXG4gICAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IERFRkFVTFRfRElNRU5TSU9OU19USU1FT1VUO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKF90aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZGltZW5zaW9ucyBmb3IgYXVkaW8gdHJhY2tzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcykgPT09ICdpT1MnKSB7XG4gICAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXG4gICAgICAgICAgLy8gd2hlbiBzbGlnaHRseSBkZWxheWluZyB0aGUgY2FsbCB0byAuZ2V0U2V0dGluZ3MoKSwgdGhlIGNvcnJlY3QgcmVzb2x1dGlvbiBpcyBiZWluZyByZXBvcnRlZFxuICAgICAgICAgIHlpZWxkIHNsZWVwKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydGVkIDwgdGltZW91dCkge1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSBfdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gZGltcztcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIGdldCB0cmFjayBkaW1lbnNpb25zIGFmdGVyIHRpbWVvdXQnKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgLy8gd2hlbiB0cmFjayBpcyBtdXRlZCwgdW5kZXJseWluZyBtZWRpYSBzdHJlYW0gdHJhY2sgaXMgc3RvcHBlZCBhbmRcbiAgICAgIC8vIHdpbGwgYmUgcmVzdGFydGVkIGxhdGVyXG4gICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgIHJldHVybiB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldERldmljZUlkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IG5vcm1hbGl6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgICAgICBpZiAoX3RoaXMyLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICBncm91cElkXG4gICAgICAgIH0gPSBfdGhpczIuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgY29uc3Qga2luZCA9IF90aGlzMi5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvID8gJ2F1ZGlvaW5wdXQnIDogJ3ZpZGVvaW5wdXQnO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplID8gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSA6IGRldmljZUlkO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zZXRUcmFja011dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHJlcGxhY2VUcmFjayh0cmFjaywgdXNlclByb3ZpZGVkT3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMudHJhY2tDaGFuZ2VMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byByZXBsYWNlIGFuIHVucHVibGlzaGVkIHRyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgICAgICBsZXQgc3RvcFByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyUHJvdmlkZWRPck9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdXNlclByb3ZpZGVkT3JPcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm92aWRlZE9yT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXNlclByb3ZpZGVkVHJhY2sgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMudXNlclByb3ZpZGVkVHJhY2s7XG4gICAgICAgICAgc3RvcFByb2Nlc3NvciA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy5zdG9wUHJvY2Vzc29yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjayAhPT0gbnVsbCAmJiB1c2VyUHJvdmlkZWRUcmFjayAhPT0gdm9pZCAwID8gdXNlclByb3ZpZGVkVHJhY2sgOiB0cnVlO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKHRyYWNrKTtcbiAgICAgICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXG4gICAgICAgIC8vIG9uIHRoZSBwcmV2aW91cyBzdGF0ZSBpbiBvcmRlciB0byBjbGVhbnVwXG4gICAgICAgIGlmIChzdG9wUHJvY2Vzc29yICYmIHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5pbnRlcm5hbFN0b3BQcm9jZXNzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMudHJhY2tDaGFuZ2VMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHRoaXMuX2NvbnN0cmFpbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRldmljZUlkLFxuICAgICAgICAgICAgZmFjaW5nTW9kZVxuICAgICAgICAgIH0gPSBjb25zdHJhaW50cyxcbiAgICAgICAgICBvdGhlckNvbnN0cmFpbnRzID0gX19yZXN0KGNvbnN0cmFpbnRzLCBbXCJkZXZpY2VJZFwiLCBcImZhY2luZ01vZGVcIl0pO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyB0cmFjayB3aXRoIGNvbnN0cmFpbnRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgY29uc3RyYWludHNcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgdmlkZW86IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICBzdHJlYW1Db25zdHJhaW50cy52aWRlbyA9IGRldmljZUlkIHx8IGZhY2luZ01vZGUgPyB7XG4gICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgIGZhY2luZ01vZGVcbiAgICAgICAgICB9IDogdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyA9IGRldmljZUlkID8gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkZXZpY2VJZFxuICAgICAgICAgIH0sIG90aGVyQ29uc3RyYWludHMpIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBzdGVwcyBhcmUgZHVwbGljYXRlZCBmcm9tIHNldE1lZGlhU3RyZWFtVHJhY2sgYmVjYXVzZSB3ZSBtdXN0IHN0b3BcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRyYWNrcyBiZWZvcmUgbmV3IHRyYWNrcyBjYW4gYmUgYWNxdWlyZWRcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyBvbiBTYWZhcmksIHRoZSBvbGQgYXVkaW8gdHJhY2sgbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjcXVpcmVcbiAgICAgICAgLy8gdGhlIG5ldyB0cmFjaywgb3RoZXJ3aXNlIHRoZSBuZXcgdHJhY2sgd2lsbCBzdG9wIHdpdGhcbiAgICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IHRyYWNrIGFuZCBhdHRhY2hcbiAgICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzdHJlYW1Db25zdHJhaW50cyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGNhcHR1cmVkIHRoZSBhdWRpbyB0cmFjayB3aXRoIHRoZSBjb25zdHJhaW50cywgc28gd2Ugb25seSBuZWVkIHRvIGFwcGx5IHRoZSB2aWRlbyBjb25zdHJhaW50c1xuICAgICAgICAgIHlpZWxkIG5ld1RyYWNrLmFwcGx5Q29uc3RyYWludHMob3RoZXJDb25zdHJhaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlLWFjcXVpcmVkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2spO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5tYW51YWxseVN0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgc3RvcHBlZCBkdXJpbmcgYSByZXN0YXJ0LCBzdG9wcGluZyByZXN0YXJ0ZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBcIi5jb25jYXQodGhpcy5raW5kLCBcIiB0cmFjayBcIikuY29uY2F0KG11dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gIH1cbiAgZ2V0IG5lZWRzUmVBY3F1aXNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlICE9PSAnbGl2ZScgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5tdXRlZCB8fCAhdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkIHx8IHRoaXMucmVhY3F1aXJlVHJhY2s7XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInZpc2liaWxpdHkgY2hhbmdlZCwgaXMgaW4gQmFja2dyb3VuZDogXCIuY29uY2F0KHRoaXMuaXNJbkJhY2tncm91bmQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMubmVlZHNSZUFjcXVpc2l0aW9uICYmICF0aGlzLmlzVXNlclByb3ZpZGVkICYmICF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nIFwiLmNvbmNhdCh0aGlzLnNvdXJjZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSB0cnVlO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBwYXVzZXMgcHVibGlzaGluZyB0byB0aGUgc2VydmVyIHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xuICAgKiB0aGUgc2VydmVyLlxuICAgKiB0aGlzIEFQSSBpcyB1bnN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMiBkdWUgdG8gYSBidWdcbiAgICoqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcGF1c2UgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDkxMVxuICAgICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBub29wIGlmIG1lZGlhc3RyZWFtdHJhY2sgaXMgYWxyZWFkeSBiZWluZyBzZW50XG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIExvY2FsVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFNlbmRlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcHJvY2Vzc29yIG9uIHRoaXMgdHJhY2suXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9jZXNzb3JcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMy50cmFja0NoYW5nZUxvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KF90aGlzMy5raW5kKTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgICAga2luZDogX3RoaXMzLmtpbmQsXG4gICAgICAgICAgICB0cmFjazogX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgZWxlbWVudDogcHJvY2Vzc29yRWxlbWVudCxcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogX3RoaXMzLmF1ZGlvQ29udGV4dFxuICAgICAgICAgIH07XG4gICAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgICAgX3RoaXMzLmxvZy5kZWJ1ZygncHJvY2Vzc29yIGluaXRpYWxpemVkJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGhpczMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLCBwcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzb3JFbGVtZW50LnBsYXkoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBvbiBTYWZhcmkgd2hlbiB0aGUgcHJvY2Vzc29yIGlzIHJlc3RhcnRlZCwgdHJ5IGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgICAgX3RoaXMzLmxvZy53YXJuKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCwgcmV0cnlpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBwbGF5IHByb2Nlc3NvciBlbGVtZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMubG9nLmVycm9yKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgICAgX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgPSBwcm9jZXNzb3JFbGVtZW50O1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIF90aGlzMy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIGlmIChlbCAhPT0gX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hUcmFjayhfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVRyYWNrKF90aGlzMy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCBfdGhpczMucHJvY2Vzc29yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGdldFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB0cmFjayBwcm9jZXNzb3JcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICovXG4gIHN0b3BQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBsZXQga2VlcEVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgX3RoaXM0LnRyYWNrQ2hhbmdlTG9jay5sb2NrKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgX3RoaXM0LmludGVybmFsU3RvcFByb2Nlc3NvcihrZWVwRWxlbWVudCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhlIGNhbGxlciBoYXMgYWNxdWlyZWQgYSB0cmFja0NoYW5nZUxvY2sgYWxyZWFkeS5cbiAgICogVGhlIHB1YmxpYyBmYWNpbmcgbWV0aG9kIGZvciBzdG9wcGluZyB0aGUgcHJvY2Vzc29yIGlzIGBzdG9wUHJvY2Vzc29yYCBhbmQgaXQgd3JhcHMgdGhpcyBtZXRob2QgaW4gdGhlIHRyYWNrQ2hhbmdlTG9jay5cbiAgICovXG4gIGludGVybmFsU3RvcFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIGxldCBrZWVwRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIV90aGlzNS5wcm9jZXNzb3IpIHJldHVybjtcbiAgICAgICAgX3RoaXM1LmxvZy5kZWJ1Zygnc3RvcHBpbmcgcHJvY2Vzc29yJywgX3RoaXM1LmxvZ0NvbnRleHQpO1xuICAgICAgICAoX2EgPSBfdGhpczUucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgICB5aWVsZCBfdGhpczUucHJvY2Vzc29yLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXM1LnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFrZWVwRWxlbWVudCkge1xuICAgICAgICAgIChfYiA9IF90aGlzNS5wcm9jZXNzb3JFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICAgICAgX3RoaXM1LnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgb3JpZ2luYWwgdHJhY2sgY29uc3RyYWludHMgaW4gY2FzZSB0aGUgcHJvY2Vzc29yIGNoYW5nZWQgdGhlbVxuICAgICAgICB5aWVsZCBfdGhpczUuX21lZGlhU3RyZWFtVHJhY2suYXBwbHlDb25zdHJhaW50cyhfdGhpczUuX2NvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gZm9yY2UgcmUtc2V0dGluZyBvZiB0aGUgbWVkaWFTdHJlYW1UcmFjayBvbiB0aGUgc2VuZGVyXG4gICAgICAgIHlpZWxkIF90aGlzNS5zZXRNZWRpYVN0cmVhbVRyYWNrKF90aGlzNS5fbWVkaWFTdHJlYW1UcmFjaywgdHJ1ZSk7XG4gICAgICAgIF90aGlzNS5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRQcmVDb25uZWN0QnVmZmVyKCkge1xuICAgIGxldCB0aW1lc2xpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEwMDtcbiAgICBpZiAoIWlzUmVjb3JkaW5nU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSwgY2Fubm90IHN0YXJ0IHByZWNvbm5lY3QgYnVmZmVyJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikge1xuICAgICAgbGV0IG1pbWVUeXBlID0gJ2F1ZGlvL3dlYm07Y29kZWNzPW9wdXMnO1xuICAgICAgaWYgKCFNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZSkpIHtcbiAgICAgICAgLy8gaU9TIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHZpZGVvL21wNCBhcyBhIG1pbWUgdHlwZSAtIGV2ZW4gZm9yIGF1ZGlvLlxuICAgICAgICBtaW1lVHlwZSA9ICd2aWRlby9tcDQnO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIgPSBuZXcgTG9jYWxUcmFja1JlY29yZGVyKHRoaXMsIHtcbiAgICAgICAgbWltZVR5cGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwcmVjb25uZWN0IGJ1ZmZlciBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIuc3RhcnQodGltZXNsaWNlKTtcbiAgICB0aGlzLmF1dG9TdG9wUHJlQ29ubmVjdEJ1ZmZlciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybigncHJlY29ubmVjdCBidWZmZXIgdGltZWQgb3V0LCBzdG9wcGluZyByZWNvcmRpbmcgYXV0b21hdGljYWxseScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnN0b3BQcmVDb25uZWN0QnVmZmVyKCk7XG4gICAgfSwgUFJFX0NPTk5FQ1RfQlVGRkVSX1RJTUVPVVQpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RvcFByZUNvbm5lY3RCdWZmZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b1N0b3BQcmVDb25uZWN0QnVmZmVyKTtcbiAgICBpZiAodGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIpIHtcbiAgICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyLnN0b3AoKTtcbiAgICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldFByZUNvbm5lY3RCdWZmZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJ5dGVTdHJlYW07XG4gIH1cbiAgZ2V0UHJlQ29ubmVjdEJ1ZmZlck1pbWVUeXBlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5taW1lVHlwZTtcbiAgfVxufWNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgZW5oYW5jZWQgbm9pc2UgY2FuY2VsbGF0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIG9uIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldCBlbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgbGV0IGF1ZGlvQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2suS2luZC5BdWRpbywgY29uc3RyYWludHMsIHVzZXJQcm92aWRlZFRyYWNrLCBsb2dnZXJPcHRpb25zKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XG4gICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cykge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBlbmFibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiS3Jpc3Agbm9pc2UgZmlsdGVyIGRpc2FibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZWQgc3BlY2lhbCBoYW5kbGluZyBhcyBpdCB3aWxsIGNhdXNlIEJUIGhlYWRzZXRzIHRvIHN3aXRjaCBjb21tdW5pY2F0aW9uIG1vZGVzXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBtaWNyb3Bob25lIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICB1bm11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPSB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09IHVud3JhcENvbnN0cmFpbnQodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQpO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgX3N1cGVyLnJlc3RhcnQuY2FsbCh0aGlzLCBjb25zdHJhaW50cyk7XG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy50cmFja0NoYW5nZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc1JlYWN0TmF0aXZlKCkgJiYgIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuaW50ZXJuYWxTdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgLy8gUk4gd29uJ3QgaGF2ZSBvciB1c2UgQXVkaW9Db250ZXh0XG4gICAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yIFwiLmNvbmNhdChwcm9jZXNzb3IubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUpO1xuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2FibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJywgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRGlzYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMucHJvY2Vzc29yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgbGV0IGF1ZGlvU3RhdHM7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGF1ZGlvU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lOiB2LnJvdW5kVHJpcFRpbWUsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXVkaW9TdGF0cztcbiAgICB9KTtcbiAgfVxuICBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRoaXMpO1xuICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc2lsZW5jZSBkZXRlY3RlZCBvbiBsb2NhbCBhdWRpbyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrSXNTaWxlbnQ7XG4gICAgfSk7XG4gIH1cbn0vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBsb2dnZXJPcHRpb25zKSB7XG4gIHN3aXRjaCAobWVkaWFTdHJlYW1UcmFjay5raW5kKSB7XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbEF1ZGlvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCB1bmRlZmluZWQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxWaWRlb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6IFwiLmNvbmNhdChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpKTtcbiAgfVxufVxuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0c1NjcmVlblNoYXJlID0gT2JqZWN0LnZhbHVlcyhTY3JlZW5TaGFyZVByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyA9IGZyb21QcmVzZXQgPT4ge1xuICBjb25zdCBsYXllcnMgPSBbe1xuICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMixcbiAgICBmcHM6IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlXG4gIH1dO1xuICByZXR1cm4gbGF5ZXJzLm1hcCh0ID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBuZXcgVmlkZW9QcmVzZXQoTWF0aC5mbG9vcihmcm9tUHJlc2V0LndpZHRoIC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuaGVpZ2h0IC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLm1heCgxNTAwMDAsIE1hdGguZmxvb3IoZnJvbVByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlIC8gKE1hdGgucG93KHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5LCAyKSAqICgoKF9hID0gZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDMwKSAvICgoX2IgPSB0LmZwcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMzApKSkpKSwgdC5mcHMsIGZyb21QcmVzZXQuZW5jb2RpbmcucHJpb3JpdHkpO1xuICB9KTtcbn07XG4vLyAvKipcbi8vICAqXG4vLyAgKiBAaW50ZXJuYWxcbi8vICAqIEBleHBlcmltZW50YWxcbi8vICAqL1xuLy8gY29uc3QgY29tcHV0ZURlZmF1bHRNdWx0aUNvZGVjU2ltdWxjYXN0RW5jb2RpbmdzID0gKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XG4vLyAgIC8vIHVzZSB2cDggYXMgYSBkZWZhdWx0XG4vLyAgIGNvbnN0IHZwOCA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xuLy8gICBjb25zdCB2cDkgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjkgfTtcbi8vICAgY29uc3QgaDI2NCA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDEuMSB9O1xuLy8gICBjb25zdCBhdjEgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjcgfTtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB2cDgsXG4vLyAgICAgdnA5LFxuLy8gICAgIGgyNjQsXG4vLyAgICAgYXYxLFxuLy8gICB9O1xuLy8gfTtcbmNvbnN0IHZpZGVvUmlkcyA9IFsncScsICdoJywgJ2YnXTtcbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9FbmNvZGluZztcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcmVlblNoYXJlRW5jb2Rpbmc7XG4gIH1cbiAgY29uc3QgdXNlU2ltdWxjYXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpbXVsY2FzdDtcbiAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjYWxhYmlsaXR5TW9kZTtcbiAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NvZGVjO1xuICBpZiAoIXZpZGVvRW5jb2RpbmcgJiYgIXVzZVNpbXVsY2FzdCAmJiAhc2NhbGFiaWxpdHlNb2RlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgLy8gd2hlbiB3ZSBhcmVuJ3Qgc2ltdWxjYXN0aW5nIG9yIHN2Yywgd2lsbCBuZWVkIHRvIHJldHVybiBhIHNpbmdsZSBlbmNvZGluZyB3aXRob3V0XG4gICAgLy8gY2FwcGluZyBiYW5kd2lkdGguIHdlIGFsd2F5cyByZXF1aXJlIGEgZW5jb2RpbmcgZm9yIGR5bmFjYXN0XG4gICAgcmV0dXJuIFt7fV07XG4gIH1cbiAgaWYgKCF2aWRlb0VuY29kaW5nKSB7XG4gICAgLy8gZmluZCB0aGUgcmlnaHQgZW5jb2RpbmcgYmFzZWQgb24gd2lkdGgvaGVpZ2h0XG4gICAgdmlkZW9FbmNvZGluZyA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgdmlkZW9Db2RlYyk7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygndXNpbmcgdmlkZW8gZW5jb2RpbmcnLCB2aWRlb0VuY29kaW5nKTtcbiAgfVxuICBjb25zdCBzb3VyY2VGcmFtZXJhdGUgPSB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQod2lkdGgsIGhlaWdodCwgdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLCB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSwgdmlkZW9FbmNvZGluZy5wcmlvcml0eSk7XG4gIGlmIChzY2FsYWJpbGl0eU1vZGUgJiYgaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIGlmIChzbS5zcGF0aWFsID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NhbGFiaWxpdHlNb2RlOiBcIi5jb25jYXQoc2NhbGFiaWxpdHlNb2RlKSk7XG4gICAgfVxuICAgIC8vIEJlZm9yZSBNMTEzIGluIENocm9tZSwgZGVmaW5pbmcgbXVsdGlwbGUgZW5jb2RpbmdzIHdpdGggYW4gU1ZDIGNvZGVjIGluZGljYXRlZFxuICAgIC8vIHRoYXQgU1ZDIG1vZGUgc2hvdWxkIGJlIHVzZWQuIFNhZmFyaSBzdGlsbCB3b3JrcyB0aGlzIHdheS5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGNvbmZ1c2luZyBidXQgaXMgZHVlIHRvIGhvdyBsaWJ3ZWJydGMgaW50ZXJwcmV0ZWQgdGhlIGVuY29kaW5ncyBmaWVsZFxuICAgIC8vIGJlZm9yZSBNMTEzLlxuICAgIC8vIEFubm91bmNlZCBoZXJlOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2cvZGlzY3Vzcy13ZWJydGMvYy8tUVEzcHhybC1mdz9wbGk9MVxuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKGlzU2FmYXJpQmFzZWQoKSB8fFxuICAgIC8vIEV2ZW4gdGhvIFJOIHJ1bnMgTTExNCwgaXQgZG9lcyBub3QgcHJvZHVjZSBTVkMgbGF5ZXJzIHdoZW4gYSBzaW5nbGUgZW5jb2RpbmdcbiAgICAvLyBpcyBwcm92aWRlZC4gU28gd2UnbGwgdXNlIHRoZSBsZWdhY3kgU1ZDIHNwZWNpZmljYXRpb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPOiB3aGVuIHdlIHVwc3RyZWFtIGxpYndlYnJ0YywgdGhpcyB3aWxsIG5lZWQgYWRkaXRpb25hbCB2ZXJpZmljYXRpb25cbiAgICBpc1JlYWN0TmF0aXZlKCkgfHwgKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uLCAnMTEzJykgPCAwKSB7XG4gICAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xuICAgICAgLy8gc2FmYXJpIDE4LjQgdXNlcyBhIGRpZmZlcmVudCBzdmMgQVBJIHRoYXQgcmVxdWlyZXMgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IHRvIGJlIHNldC5cbiAgICAgIGNvbnN0IHJlcXVpcmVTY2FsZSA9IGlzU2FmYXJpU3ZjQXBpKGJyb3dzZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcbiAgICAgICAgLy8gaW4gbGVnYWN5IFNWQywgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IGNhbm5vdCBiZSBzZXRcbiAgICAgICAgZW5jb2RpbmdzLnB1c2goe1xuICAgICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgICBtYXhCaXRyYXRlOiB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUgLyBNYXRoLnBvdyhiaXRyYXRlc1JhdGlvLCBpKSxcbiAgICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IHJlcXVpcmVTY2FsZSA/IE1hdGgucG93KDIsIGkpIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gbGVnYWN5IFNWQywgc2NhbGFiaWxpdHlNb2RlIGlzIHNldCBvbmx5IG9uIHRoZSBmaXJzdCBlbmNvZGluZ1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSA9IHNjYWxhYmlsaXR5TW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmdzLnB1c2goe1xuICAgICAgICBtYXhCaXRyYXRlOiB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIHNjYWxhYmlsaXR5TW9kZTogc2NhbGFiaWxpdHlNb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsLmVuY29kaW5nLnByaW9yaXR5KSB7XG4gICAgICBlbmNvZGluZ3NbMF0ucHJpb3JpdHkgPSBvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICAgIGVuY29kaW5nc1swXS5uZXR3b3JrUHJpb3JpdHkgPSBvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInVzaW5nIHN2YyBlbmNvZGluZ1wiLCB7XG4gICAgICBlbmNvZGluZ3NcbiAgICB9KTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xuICB9XG4gIGlmICghdXNlU2ltdWxjYXN0KSB7XG4gICAgcmV0dXJuIFt2aWRlb0VuY29kaW5nXTtcbiAgfVxuICBsZXQgcHJlc2V0cyA9IFtdO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHByZXNldHMgPSAoX2EgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzZXRzID0gKF9iID0gc29ydFByZXNldHMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCk7XG4gIH1cbiAgbGV0IG1pZFByZXNldDtcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XG4gICAgaWYgKHByZXNldHMubGVuZ3RoID4gMSkge1xuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuICAgIC8vIE5PVEU6XG4gICAgLy8gICAxLiBPcmRlcmluZyBvZiB0aGVzZSBlbmNvZGluZ3MgaXMgaW1wb3J0YW50LiBDaHJvbWUgc2VlbXNcbiAgICAvLyAgICAgIHRvIHVzZSB0aGUgaW5kZXggaW50byBlbmNvZGluZ3MgdG8gZGVjaWRlIHdoaWNoIGxheWVyXG4gICAgLy8gICAgICB0byBkaXNhYmxlIHdoZW4gQ1BVIGNvbnN0cmFpbmVkLlxuICAgIC8vICAgICAgU28gZW5jb2RpbmdzIHNob3VsZCBiZSBvcmRlcmVkIGluIGluY3JlYXNpbmcgc3BhdGlhbFxuICAgIC8vICAgICAgcmVzb2x1dGlvbiBvcmRlci5cbiAgICAvLyAgIDIuIGxpdmVraXQtc2VydmVyIHRyYW5zbGF0ZXMgcmlkcyBpbnRvIGxheWVycy4gU28sIGFsbCBlbmNvZGluZ3NcbiAgICAvLyAgICAgIHNob3VsZCBoYXZlIHRoZSBiYXNlIGxheWVyIGBxYCBhbmQgdGhlbiBtb3JlIGFkZGVkXG4gICAgLy8gICAgICBiYXNlZCBvbiBvdGhlciBjb25kaXRpb25zLlxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoc2l6ZSA+PSA5NjAgJiYgbWlkUHJlc2V0KSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgbWlkUHJlc2V0LCBvcmlnaW5hbF0sIHNvdXJjZUZyYW1lcmF0ZSk7XG4gICAgfVxuICAgIGlmIChzaXplID49IDQ4MCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG9yaWdpbmFsXSwgc291cmNlRnJhbWVyYXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgLy8gYmFja3VwQ29kZWMgc2hvdWxkIG5vdCBiZSB0cnVlIGFueW1vcmUsIGRlZmF1bHQgY29kZWMgaXMgc2V0IGluIExvY2FsUGFydGljaXBhbnQucHVibGlzaFxuICBpZiAoIW9wdHMuYmFja3VwQ29kZWMgfHwgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fCBvcHRzLmJhY2t1cENvZGVjLmNvZGVjID09PSBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xuICAgIGxpdmVraXRMb2dnZXIud2FybigncmVxdWVzdGVkIGEgZGlmZmVyZW50IGNvZGVjIHRoYW4gc3BlY2lmaWVkIGFzIGJhY2t1cCcsIHtcbiAgICAgIHNlcnZlclJlcXVlc3RlZDogdmlkZW9Db2RlYyxcbiAgICAgIGJhY2t1cDogb3B0cy5iYWNrdXBDb2RlYy5jb2RlY1xuICAgIH0pO1xuICB9XG4gIG9wdHMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gIC8vIHVzZSBiYWNrdXAgZW5jb2Rpbmcgc2V0dGluZyBhcyB2aWRlb0VuY29kaW5nIGZvciBiYWNrdXAgY29kZWMgcHVibGlzaGluZ1xuICBvcHRzLnZpZGVvRW5jb2RpbmcgPSBvcHRzLmJhY2t1cENvZGVjLmVuY29kaW5nO1xuICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgY29uc3Qgd2lkdGggPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdHJhY2suZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSAoX2MgPSBzZXR0aW5ncy5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQ7XG4gIC8vIGRpc2FibGUgc2ltdWxjYXN0IGZvciBzY3JlZW5zaGFyZSBiYWNrdXAgY29kZWMgc2luY2UgTDFUeCBpcyB1c2VkIGJ5IHByaW1hcnkgY29kZWNcbiAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIG9wdHMuc2ltdWxjYXN0KSB7XG4gICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIG9wdHMpO1xuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIGNvZGVjKSB7XG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IHtcbiAgICBlbmNvZGluZ1xuICB9ID0gcHJlc2V0c1swXTtcbiAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXNldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmVzZXQgPSBwcmVzZXRzW2ldO1xuICAgIGVuY29kaW5nID0gcHJlc2V0LmVuY29kaW5nO1xuICAgIGlmIChwcmVzZXQud2lkdGggPj0gc2l6ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIHByZXNldHMgYXJlIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIG9mIHZwOCBhcyBhIGNvZGVjXG4gIC8vIGZvciBvdGhlciBjb2RlY3Mgd2UgYWRqdXN0IHRoZSBtYXhCaXRyYXRlIGlmIG5vIHNwZWNpZmljIHZpZGVvRW5jb2RpbmcgaGFzIGJlZW4gcHJvdmlkZWRcbiAgLy8gdXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRoZXNlIHdpdGggb25lcyB0aGF0IGFyZSBvcHRpbWl6ZWQgZm9yIHRoZWlyIHVzZSBjYXNlXG4gIC8vIE5PVEU6IFNWQyBjb2RlYyBiaXRyYXRlcyBhcmUgaW5jbHVzaXZlIG9mIGFsbCBzY2FsYWJpbGl0eSBsYXllcnMuIHdoaWxlXG4gIC8vIGJpdHJhdGUgZm9yIG5vbi1TVkMgY29kZWNzIGRvZXMgbm90IGluY2x1ZGUgb3RoZXIgc2ltdWxjYXN0IGxheWVycy5cbiAgaWYgKGNvZGVjKSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnYXYxJzpcbiAgICAgIGNhc2UgJ2gyNjUnOlxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzKG9yaWdpbmFsKTtcbiAgfVxuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBvcmlnaW5hbDtcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDM7XG59XG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBwcmVzZXRzLCBzb3VyY2VGcmFtZXJhdGUpIHtcbiAgY29uc3QgZW5jb2RpbmdzID0gW107XG4gIHByZXNldHMuZm9yRWFjaCgocHJlc2V0LCBpZHgpID0+IHtcbiAgICBpZiAoaWR4ID49IHZpZGVvUmlkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHJpZCA9IHZpZGVvUmlkc1tpZHhdO1xuICAgIGNvbnN0IGVuY29kaW5nID0ge1xuICAgICAgcmlkLFxuICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBNYXRoLm1heCgxLCBzaXplIC8gTWF0aC5taW4ocHJlc2V0LndpZHRoLCBwcmVzZXQuaGVpZ2h0KSksXG4gICAgICBtYXhCaXRyYXRlOiBwcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZVxuICAgIH07XG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIHNvdXJjZUZyYW1lcmF0ZSBpcyB0aGUgaGlnaGVzdCBmcmFtZXJhdGUgYXBwbGllZCBhY3Jvc3MgYWxsIGxheWVycyBzbyB0aGF0IHRoZVxuICAgIC8vIG9yaWdpbmFsIGVuY29kaW5nIGRvZXNuJ3QgZ2V0IGJ1bXBlZCB1bmludGVudGlvbmFsbHkgYnkgYW55IG9mIHRoZSBvdGhlciBsYXllcnNcbiAgICBjb25zdCBtYXhGcmFtZXJhdGUgPSBzb3VyY2VGcmFtZXJhdGUgJiYgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSA/IE1hdGgubWluKHNvdXJjZUZyYW1lcmF0ZSwgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkgOiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgIGlmIChtYXhGcmFtZXJhdGUpIHtcbiAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IG1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG4gIC8vIFJOIGlvcyBzaW11bGNhc3QgcmVxdWlyZXMgYWxsIHNhbWUgZnJhbWVyYXRlcy5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSAmJiBnZXRSZWFjdE5hdGl2ZU9zKCkgPT09ICdpb3MnKSB7XG4gICAgbGV0IHRvcEZyYW1lcmF0ZSA9IHVuZGVmaW5lZDtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBub3RpZnlPbmNlID0gdHJ1ZTtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICE9IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICBpZiAobm90aWZ5T25jZSkge1xuICAgICAgICAgIG5vdGlmeU9uY2UgPSBmYWxzZTtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTaW11bGNhc3Qgb24gaU9TIFJlYWN0LU5hdGl2ZSByZXF1aXJlcyBhbGwgZW5jb2RpbmdzIHRvIHNoYXJlIHRoZSBzYW1lIGZyYW1lcmF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2V0dGluZyBmcmFtZXJhdGUgb2YgZW5jb2RpbmcgXFxcIlwiLmNvbmNhdCgoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBcIlxcXCIgdG8gXCIpLmNvbmNhdCh0b3BGcmFtZXJhdGUpKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzb3J0UHJlc2V0cyhwcmVzZXRzKSB7XG4gIGlmICghcHJlc2V0cykgcmV0dXJuO1xuICByZXR1cm4gcHJlc2V0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2Rpbmc6IGFFbmNcbiAgICB9ID0gYTtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYkVuY1xuICAgIH0gPSBiO1xuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHNjYWxhYmlsaXR5TW9kZS5tYXRjaCgvXkwoXFxkKVQoXFxkKShofF9LRVl8X0tFWV9TSElGVCl7MCwxfSQvKTtcbiAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYWJpbGl0eSBtb2RlJyk7XG4gICAgfVxuICAgIHRoaXMuc3BhdGlhbCA9IHBhcnNlSW50KHJlc3VsdHNbMV0pO1xuICAgIHRoaXMudGVtcG9yYWwgPSBwYXJzZUludChyZXN1bHRzWzJdKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAzKSB7XG4gICAgICBzd2l0Y2ggKHJlc3VsdHNbM10pIHtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ19LRVknOlxuICAgICAgICBjYXNlICdfS0VZX1NISUZUJzpcbiAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHJlc3VsdHNbM107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gXCJMXCIuY29uY2F0KHRoaXMuc3BhdGlhbCwgXCJUXCIpLmNvbmNhdCh0aGlzLnRlbXBvcmFsKS5jb25jYXQoKF9hID0gdGhpcy5zdWZmaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjaykge1xuICAvLyBhIGZldyBvZiByZWFzb25zIHdlIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgcGF0aHM6XG4gIC8vIDEuIHdpdGhvdXQgdGhpcywgQ2hyb21lIHNlZW1zIHRvIGFnZ3Jlc3NpdmVseSByZXNpemUgdGhlIFNWQyB2aWRlbyBzdGF0aW5nIGBxdWFsaXR5LWxpbWl0YXRpb246IGJhbmR3aWR0aGAgZXZlbiB3aGVuIEJXIGlzbid0IGFuIGlzc3VlXG4gIC8vIDIuIHNpbmNlIHdlIGFyZSBvdmVycmlkaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiAodG8gd29ya2Fyb3VuZCBMMVQzIHB1Ymxpc2hpbmcpLCBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZGVncmFkYXRpb25QcmVmZXJlbmNlIHRvIGBiYWxhbmNlZGBcbiAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCAmJiB1bndyYXBDb25zdHJhaW50KHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCkgPj0gMTA4MCkge1xuICAgIHJldHVybiAnbWFpbnRhaW4tcmVzb2x1dGlvbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdiYWxhbmNlZCc7XG4gIH1cbn1jb25zdCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyA9IDUwMDA7XG5jbGFzcyBMb2NhbFZpZGVvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgZ2V0IHNlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xuICB9XG4gIHNldCBzZW5kZXIoc2VuZGVyKSB7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICAgIGlmICh0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSkge1xuICAgICAgdGhpcy5zZXREZWdyYWRhdGlvblByZWZlcmVuY2UodGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuVmlkZW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgLyogQGludGVybmFsICovXG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSAnYmFsYW5jZWQnO1xuICAgIHRoaXMuaXNDcHVDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW1pemVGb3JQZXJmb3JtYW5jZSA9IGZhbHNlO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgdmlkZW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXAoc3RhdHMubWFwKHMgPT4gW3MucmlkLCBzXSkpO1xuICAgICAgY29uc3QgaXNDcHVDb25zdHJhaW5lZCA9IHN0YXRzLnNvbWUocyA9PiBzLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uID09PSAnY3B1Jyk7XG4gICAgICBpZiAoaXNDcHVDb25zdHJhaW5lZCAhPT0gdGhpcy5pc0NwdUNvbnN0cmFpbmVkKSB7XG4gICAgICAgIHRoaXMuaXNDcHVDb25zdHJhaW5lZCA9IGlzQ3B1Q29uc3RyYWluZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzQ3B1Q29uc3RyYWluZWQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5DcHVDb25zdHJhaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZXZTdGF0cykge1xuICAgICAgICBsZXQgdG90YWxCaXRyYXRlID0gMDtcbiAgICAgICAgc3RhdHNNYXAuZm9yRWFjaCgocywga2V5KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xuICAgICAgICAgIHRvdGFsQml0cmF0ZSArPSBjb21wdXRlQml0cmF0ZShzLCBwcmV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gdG90YWxCaXRyYXRlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0c01hcDtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmRlckxvY2sgPSBuZXcgXygpO1xuICB9XG4gIGdldCBpc1NpbXVsY2FzdCgpIHtcbiAgICBpZiAodGhpcy5zZW5kZXIgJiYgdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpLmVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzYXZlIG9yaWdpbmFsIGVuY29kaW5nc1xuICAgIC8vIFRPRE8gOiBtZXJnZSBzaW11bGNhc3QgdHJhY2tzIHN0YXRzXG4gICAgY29uc3QgcGFyYW1zID0gKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5mb3JFYWNoKHRyYWNrSW5mbyA9PiB7XG4gICAgICB0cmFja0luZm8ubWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG4gIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBwYXVzZVVwc3RyZWFtOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucGF1c2VVcHN0cmVhbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgdmFyIF9kO1xuICAgICAgeWllbGQgX3N1cGVyLnBhdXNlVXBzdHJlYW0uY2FsbCh0aGlzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgeWllbGQgKF9kID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgcmVzdW1lVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN1bWVVcHN0cmVhbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgdmFyIF9kO1xuICAgICAgeWllbGQgX3N1cGVyLnJlc3VtZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgZV8yID0ge1xuICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgbXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICB1bm11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICBzdXBlci5zZXRUcmFja011dGVkKG11dGVkKTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgfVxuICB9XG4gIGdldFNlbmRlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGNvbnN0IHZzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHYuZnJhbWVzUGVyU2Vjb25kLFxuICAgICAgICAgICAgZnJhbWVzU2VudDogdi5mcmFtZXNTZW50LFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB2LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogdi5xdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzLFxuICAgICAgICAgICAgcmlkOiAoX2EgPSB2LnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdi5pZCxcbiAgICAgICAgICAgIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogdi5yZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQsXG4gICAgICAgICAgICB0YXJnZXRCaXRyYXRlOiB2LnRhcmdldEJpdHJhdGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL8KgbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSByZW1vdGUtaW5ib3VuZC1ydHAgaXRlbVxuICAgICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHZzLmppdHRlciA9IHIuaml0dGVyO1xuICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXMucHVzaCh2cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gbWFrZSBzdXJlIGhpZ2hlc3QgcmVzIGxheWVyIGlzIGFsd2F5cyBmaXJzdFxuICAgICAgaXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKChfYSA9IGIuZnJhbWVXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSAoKF9iID0gYS5mcmFtZVdpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0pO1xuICB9XG4gIHNldFB1Ymxpc2hpbmdRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxID0gVmlkZW9RdWFsaXR5LkxPVzsgcSA8PSBWaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XG4gICAgICBxdWFsaXRpZXMucHVzaChuZXcgU3Vic2NyaWJlZFF1YWxpdHkoe1xuICAgICAgICBxdWFsaXR5OiBxLFxuICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHlcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIHB1Ymxpc2hpbmcgcXVhbGl0eS4gbWF4IHF1YWxpdHkgXCIuY29uY2F0KG1heFF1YWxpdHkpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhpc1NWQ0NvZGVjKHRoaXMuY29kZWMpLCBxdWFsaXRpZXMpO1xuICB9XG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XG4gICAgICAgICAgdmlkZW86IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMudmlkZW8gIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgICAvLyByZXNldCBjcHUgY29uc3RyYWluZWQgc3RhdGUgYWZ0ZXIgdHJhY2sgaXMgcmVzdGFydGVkXG4gICAgICB0aGlzLmlzQ3B1Q29uc3RyYWluZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgaWYgKHNjLnNlbmRlciAmJiAoKF9kID0gc2Muc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHlpZWxkIHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICBlXzMgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3JfMSkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgc2V0UHJvY2Vzc29yOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuc2V0UHJvY2Vzc29yXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHByb2Nlc3Nvcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICB5aWVsZCBfc3VwZXIuc2V0UHJvY2Vzc29yLmNhbGwoX3RoaXMsIHByb2Nlc3Nvciwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpO1xuICAgICAgICBpZiAoKF9kID0gX3RoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMoX3RoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2g7IF9oID0geWllbGQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgICAgIHlpZWxkIChfZSA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2VUcmFjayhfdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVfNF8xKSB7XG4gICAgICAgICAgICBlXzQgPSB7XG4gICAgICAgICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKHByZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgICAgaWYgKHRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZSB0byBcIi5jb25jYXQocHJlZmVyZW5jZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgIHBhcmFtcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgICAgICAgIHRoaXMuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJmYWlsZWQgdG8gc2V0IGRlZ3JhZGF0aW9uUHJlZmVyZW5jZVwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRTaW11bGNhc3RUcmFjayhjb2RlYywgZW5jb2RpbmdzKSB7XG4gICAgaWYgKHRoaXMuc2ltdWxjYXN0Q29kZWNzLmhhcyhjb2RlYykpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKFwiXCIuY29uY2F0KGNvZGVjLCBcIiBhbHJlYWR5IGFkZGVkLCBza2lwcGluZyBhZGRpbmcgc2ltdWxjYXN0IGNvZGVjXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB7XG4gICAgICBjb2RlYyxcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxuICAgICAgc2VuZGVyOiB1bmRlZmluZWQsXG4gICAgICBlbmNvZGluZ3NcbiAgICB9O1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnNldChjb2RlYywgc2ltdWxjYXN0Q29kZWNJbmZvKTtcbiAgICByZXR1cm4gc2ltdWxjYXN0Q29kZWNJbmZvO1xuICB9XG4gIHNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKGNvZGVjLCBzZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG4gICAgLy8gYnJvd3NlciB3aWxsIHJlZW5hYmxlIGRpc2FibGVkIGNvZGVjL2xheWVycyBhZnRlciBuZXcgY29kZWMgaGFzIGJlZW4gcHVibGlzaGVkLFxuICAgIC8vIHNvIHJlZnJlc2ggc3Vic2NyaWJlZENvZGVjcyBhZnRlciBwdWJsaXNoIGEgbmV3IGNvZGVjXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVkQ29kZWNzKSB7XG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGluZ0NvZGVjcyh0aGlzLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgfVxuICAgIH0sIHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxuICAgKiBiZWVuIHB1Ymxpc2hlZFxuICAgKi9cbiAgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBjb2RlY3NfMSwgY29kZWNzXzFfMTtcbiAgICAgIHZhciBfYiwgZV81LCBfYywgX2Q7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGNvZGVjcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjb2RlY3MsXG4gICAgICAgIGN1cnJlbnRDb2RlYzogdGhpcy5jb2RlY1xuICAgICAgfSkpO1xuICAgICAgLy8gb25seSBlbmFibGUgc2ltdWxjYXN0IGNvZGVjIGZvciBwcmVmZXJlbmNlIGNvZGVjIHNldHRlZFxuICAgICAgaWYgKCF0aGlzLmNvZGVjICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhpc1NWQ0NvZGVjKGNvZGVjc1swXS5jb2RlYyksIGNvZGVjc1swXS5xdWFsaXRpZXMpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZWRDb2RlY3MgPSBjb2RlY3M7XG4gICAgICBjb25zdCBuZXdDb2RlY3MgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2EgPSB0cnVlLCBjb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMoY29kZWNzKTsgY29kZWNzXzFfMSA9IHlpZWxkIGNvZGVjc18xLm5leHQoKSwgX2IgPSBjb2RlY3NfMV8xLmRvbmUsICFfYjsgX2EgPSB0cnVlKSB7XG4gICAgICAgICAgX2QgPSBjb2RlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgIF9hID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY29kZWMgPSBfZDtcbiAgICAgICAgICBpZiAoIXRoaXMuY29kZWMgfHwgdGhpcy5jb2RlYyA9PT0gY29kZWMuY29kZWMpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhpc1NWQ0NvZGVjKGNvZGVjLmNvZGVjKSwgY29kZWMucXVhbGl0aWVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mb1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8gfHwgIXNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBxIG9mIGNvZGVjLnF1YWxpdGllcykge1xuICAgICAgICAgICAgICAgIGlmIChxLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0NvZGVjcy5wdXNoKGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyLCBzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzLCBjb2RlYy5xdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jaywgaXNTVkNDb2RlYyhjb2RlYy5jb2RlYyksIHRoaXMubG9nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV81XzEpIHtcbiAgICAgICAgZV81ID0ge1xuICAgICAgICAgIGVycm9yOiBlXzVfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9hICYmICFfYiAmJiAoX2MgPSBjb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYy5jYWxsKGNvZGVjc18xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdDb2RlY3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGxheWVycyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nXG4gICAqL1xuICBzZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU3ZjLCBxdWFsaXRpZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW1pemVGb3JQZXJmb3JtYW5jZSkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBzZXRQdWJsaXNoaW5nTGF5ZXJzIGR1ZSB0byBvcHRpbWl6ZWQgcHVibGlzaGluZyBwZXJmb3JtYW5jZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHF1YWxpdGllc1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHF1YWxpdGllc1xuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnNlbmRlciB8fCAhdGhpcy5lbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcih0aGlzLnNlbmRlciwgdGhpcy5lbmNvZGluZ3MsIHF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCBpc1N2YywgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2lnbmVkIGZvciBsb3dlciBwb3dlcmVkIGRldmljZXMsIHJlZHVjZXMgdmlkZW8gcHVibGlzaGluZyBxdWFsaXR5IGFuZCBkaXNhYmxlcyBzaW11bGNhc3QuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHByaW9yaXRpemVQZXJmb3JtYW5jZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbmRlciBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuc2VuZGVyTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wdGltaXplRm9yUGVyZm9ybWFuY2UgPSB0cnVlO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzLm1hcCgoZSwgaWR4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGlkeCA9PT0gMCxcbiAgICAgICAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgTWF0aC5jZWlsKCgoX2EgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5oZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDM2MCkgLyAzNjApKSxcbiAgICAgICAgICAgIHNjYWxhYmlsaXR5TW9kZTogaWR4ID09PSAwICYmIGlzU1ZDQ29kZWModGhpcy5jb2RlYykgPyAnTDFUMycgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXhGcmFtZXJhdGU6IGlkeCA9PT0gMCA/IDE1IDogMCxcbiAgICAgICAgICAgIG1heEJpdHJhdGU6IGlkeCA9PT0gMCA/IGUubWF4Qml0cmF0ZSA6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHBlcmZvcm1hbmNlIG9wdGltaXNlZCBlbmNvZGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlbmNvZGluZ3M6IHBhcmFtcy5lbmNvZGluZ3NcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XG4gICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBzZXQgcGVyZm9ybWFuY2Ugb3B0aW1pc2VkIGVuY29kaW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5vcHRpbWl6ZUZvclBlcmZvcm1hbmNlID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIWlzTW9iaWxlKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNlbmRlciwgc2VuZGVyRW5jb2RpbmdzLCBxdWFsaXRpZXMsIHNlbmRlckxvY2ssIGlzU1ZDLCBsb2csIGxvZ0NvbnRleHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBzZW5kZXJMb2NrLmxvY2soKTtcbiAgICBsb2cuZGVidWcoJ3NldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XG4gICAgICBzZW5kZXIsXG4gICAgICBxdWFsaXRpZXMsXG4gICAgICBzZW5kZXJFbmNvZGluZ3NcbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuY29kaW5nc1xuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoICE9PSBzZW5kZXJFbmNvZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGxvZy53YXJuKCdjYW5ub3Qgc2V0IHB1Ymxpc2hpbmcgbGF5ZXJzLCBlbmNvZGluZ3MgbWlzbWF0Y2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAvKiBkaXNhYmxlIGNsb3NhYmxlIHNwYXRpYWwgbGF5ZXIgYXMgaXQgaGFzIHZpZGVvIGJsdXIgLyBmcm96ZW4gaXNzdWUgd2l0aCBjdXJyZW50IHNlcnZlciAvIGNsaWVudFxuICAgICAgMS4gY2hyb21lIDExMzogd2hlbiBzd2l0Y2hpbmcgdG8gdXAgbGF5ZXIgd2l0aCBzY2FsYWJpbGl0eSBNb2RlIGNoYW5nZSwgaXQgd2lsbCBnZW5lcmF0ZSBhXG4gICAgICAgICAgICBsb3cgcmVzb2x1dGlvbiBmcmFtZSBhbmQgcmVjb3ZlciB2ZXJ5IHF1aWNrbHksIGJ1dCBub3RpY2FibGVcbiAgICAgIDIuIGxpdmVraXQgc2Z1OiBhZGRpdGlvbmFsIHBsaSByZXF1ZXN0IGNhdXNlIHZpZGVvIGZyb3plbiBmb3IgYSBmZXcgZnJhbWVzLCBhbHNvIG5vdGljYWJsZSAqL1xuICAgICAgY29uc3QgY2xvc2FibGVTcGF0aWFsID0gZmFsc2U7XG4gICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICBpZiAoY2xvc2FibGVTcGF0aWFsICYmIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpIDsgZWxzZSB7XG4gICAgICAgIGlmIChpc1NWQykge1xuICAgICAgICAgIGNvbnN0IGhhc0VuYWJsZWRFbmNvZGluZyA9IHF1YWxpdGllcy5zb21lKHEgPT4gcS5lbmFibGVkKTtcbiAgICAgICAgICBpZiAoaGFzRW5hYmxlZEVuY29kaW5nKSB7XG4gICAgICAgICAgICBxdWFsaXRpZXMuZm9yRWFjaChxID0+IHEuZW5hYmxlZCA9IHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaW11bGNhc3QgZHluYWNhc3QgZW5jb2RpbmdzXG4gICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGxldCByaWQgPSAoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgIGlmIChyaWQgPT09ICcnKSB7XG4gICAgICAgICAgICByaWQgPSAncSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKTtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVhbGl0eSA9IHF1YWxpdGllcy5maW5kKHEgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcbiAgICAgICAgICBpZiAoIXN1YnNjcmliZWRRdWFsaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgIT09IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcInNldHRpbmcgbGF5ZXIgXCIuY29uY2F0KHN1YnNjcmliZWRRdWFsaXR5LnF1YWxpdHksIFwiIHRvIFwiKS5jb25jYXQoZW5jb2RpbmcuYWN0aXZlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJyksIGxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgLy8gRmlyZUZveCBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgZW5jb2RpbmcuYWN0aXZlIHRvIGZhbHNlLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSBhIHdvcmthcm91bmQgb2YgbG93ZXJpbmcgaXRzIGJpdHJhdGUgYW5kIHJlc29sdXRpb24gdG8gdGhlIG1pbi5cbiAgICAgICAgICAgIGlmIChpc0ZpcmVGb3goKSkge1xuICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4RnJhbWVSYXRlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDQ7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IDEwO1xuICAgICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIGxvZy5kZWJ1ZyhcInNldHRpbmcgZW5jb2RpbmdzXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlbmNvZGluZ3M6IHBhcmFtcy5lbmNvZGluZ3NcbiAgICAgICAgfSkpO1xuICAgICAgICB5aWVsZCBzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCkge1xuICBzd2l0Y2ggKHJpZCkge1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5NRURJVU07XG4gICAgY2FzZSAncSc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkxPVztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xuICB9XG59XG5mdW5jdGlvbiB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3Mod2lkdGgsIGhlaWdodCwgZW5jb2RpbmdzLCBzdmMpIHtcbiAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcbiAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gW25ldyBWaWRlb0xheWVyKHtcbiAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdILFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBiaXRyYXRlOiAwLFxuICAgICAgc3NyYzogMFxuICAgIH0pXTtcbiAgfVxuICBpZiAoc3ZjKSB7XG4gICAgLy8gc3ZjIGxheWVyc1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBjb25zdCBlbmNvZGluZ1NNID0gZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZTtcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2RpbmdTTSk7XG4gICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgY29uc3QgcmVzUmF0aW8gPSBzbS5zdWZmaXggPT0gJ2gnID8gMS41IDogMjtcbiAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBsYXllcnMucHVzaChuZXcgVmlkZW9MYXllcih7XG4gICAgICAgIHF1YWxpdHk6IE1hdGgubWluKFZpZGVvUXVhbGl0eS5ISUdILCBzbS5zcGF0aWFsIC0gMSkgLSBpLFxuICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gTWF0aC5wb3cocmVzUmF0aW8sIGkpKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0IC8gTWF0aC5wb3cocmVzUmF0aW8sIGkpKSxcbiAgICAgICAgYml0cmF0ZTogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgPyBNYXRoLmNlaWwoZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyBNYXRoLnBvdyhiaXRyYXRlc1JhdGlvLCBpKSkgOiAwLFxuICAgICAgICBzc3JjOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoZW5jb2RpbmcgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHNjYWxlID0gKF9hID0gZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgIGxldCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKChfYiA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IChfYyA9IGVuY29kaW5nLm1heEJpdHJhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSk7XG4gIH0pO1xufWNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG5jb25zdCByZWxpYWJlUmVjZWl2ZVN0YXRlVFRMID0gMzAwMDA7XG5jb25zdCBsb3NzeURhdGFDaGFubmVsQnVmZmVyVGhyZXNob2xkTWluID0gOCAqIDEwMjQ7XG5jb25zdCBsb3NzeURhdGFDaGFubmVsQnVmZmVyVGhyZXNob2xkTWF4ID0gMjU2ICogMTAyNDtcbnZhciBQQ1N0YXRlO1xuKGZ1bmN0aW9uIChQQ1N0YXRlKSB7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIk5ld1wiXSA9IDBdID0gXCJOZXdcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiQ29ubmVjdGVkXCJdID0gMV0gPSBcIkNvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSAyXSA9IFwiRGlzY29ubmVjdGVkXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IDNdID0gXCJSZWNvbm5lY3RpbmdcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiQ2xvc2VkXCJdID0gNF0gPSBcIkNsb3NlZFwiO1xufSkoUENTdGF0ZSB8fCAoUENTdGF0ZSA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5jbGFzcyBSVENFbmdpbmUgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBpc0Nsb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNDbG9zZWQ7XG4gIH1cbiAgZ2V0IHBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZWNvbm5lY3RUaW1lb3V0O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnRjQ29uZmlnID0ge307XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmxhdGVzdFJlbW90ZU9mZmVySWQgPSAwO1xuICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBmYWxzZTtcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLk5ldztcbiAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnMgPSB7fTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAvKioga2VlcHMgdHJhY2sgb2YgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGhhcyBiZWVuIHRyaWVkICovXG4gICAgdGhpcy5qb2luQXR0ZW1wdHMgPSAwO1xuICAgIC8qKiBzcGVjaWZpZXMgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gcmV0cnkgKi9cbiAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IDE7XG4gICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlID0gMTtcbiAgICB0aGlzLnJlbGlhYmxlTWVzc2FnZUJ1ZmZlciA9IG5ldyBEYXRhUGFja2V0QnVmZmVyKCk7XG4gICAgdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUgPSBuZXcgVFRMTWFwKHJlbGlhYmVSZWNlaXZlU3RhdGVUVEwpO1xuICAgIHRoaXMubG9zc3lEYXRhU3RhdEN1cnJlbnRCeXRlcyA9IDA7XG4gICAgdGhpcy5sb3NzeURhdGFTdGF0Qnl0ZXJhdGUgPSAwO1xuICAgIHRoaXMubG9zc3lEYXRhRHJvcENvdW50ID0gMDtcbiAgICB0aGlzLm1pZFRvVHJhY2tJZCA9IHt9O1xuICAgIC8qKiB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IHdhaXRpbmcgdG8gcmVjb25uZWN0ICovXG4gICAgdGhpcy5pc1dhaXRpbmdGb3JOZXR3b3JrUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCA9IF9hID0+IF9fYXdhaXRlcih0aGlzLCBbX2FdLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHtcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgX3RoaXMucmVsaWFibGVEQ1N1YiA9IGNoYW5uZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gbG9zc3lEYXRhQ2hhbm5lbCkge1xuICAgICAgICAgIF90aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJvbiBkYXRhIGNoYW5uZWwgXCIuY29uY2F0KGNoYW5uZWwuaWQsIFwiLCBcIikuY29uY2F0KGNoYW5uZWwubGFiZWwpLCBfdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZURhdGFNZXNzYWdlID0gbWVzc2FnZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc3BlY3QgaW5jb21pbmcgZGF0YSBtZXNzYWdlIG9yZGVyIGJ5IHByb2Nlc3NpbmcgbWVzc2FnZSBldmVudHMgb25lIGFmdGVyIHRoZSBvdGhlclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5kYXRhUHJvY2Vzc0xvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZGVjb2RlXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgYnVmZmVyID0geWllbGQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3Vuc3VwcG9ydGVkIGRhdGEgdHlwZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcCA9IERhdGFQYWNrZXQuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgaWYgKGRwLnNlcXVlbmNlID4gMCAmJiBkcC5wYXJ0aWNpcGFudFNpZCAhPT0gJycpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U2VxID0gdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUuZ2V0KGRwLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgICAgICBpZiAobGFzdFNlcSAmJiBkcC5zZXF1ZW5jZSA8PSBsYXN0U2VxKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZHVwbGljYXRlIG9yIG91dC1vZi1vcmRlciBwYWNrZXRzIGluIHJlbGlhYmxlIGNoYW5uZWxcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUuc2V0KGRwLnBhcnRpY2lwYW50U2lkLCBkcC5zZXF1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBzcGVha2VyIHVwZGF0ZXNcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKF9iID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ2VuY3J5cHRlZFBhY2tldCcpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdSZWNlaXZlZCBlbmNyeXB0ZWQgcGFja2V0IGJ1dCBFMkVFIG5vdCBzZXQgdXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0geWllbGQgKF9jID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmhhbmRsZUVuY3J5cHRlZERhdGEoZHAudmFsdWUudmFsdWUuZW5jcnlwdGVkVmFsdWUsIGRwLnZhbHVlLnZhbHVlLml2LCBkcC5wYXJ0aWNpcGFudElkZW50aXR5LCBkcC52YWx1ZS52YWx1ZS5rZXlJbmRleCk7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkUGFja2V0ID0gRW5jcnlwdGVkUGFja2V0UGF5bG9hZC5mcm9tQmluYXJ5KGRlY3J5cHRlZERhdGEucGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgbmV3RHAgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICB2YWx1ZTogZGVjcnlwdGVkUGFja2V0LnZhbHVlLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZHAucGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50U2lkOiBkcC5wYXJ0aWNpcGFudFNpZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICgoKF9kID0gbmV3RHAudmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYXNlKSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBhcHBseVVzZXJEYXRhQ29tcGF0KG5ld0RwLCBuZXdEcC52YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIG5ld0RwLCBkcC52YWx1ZS52YWx1ZS5lbmNyeXB0aW9uVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCgoX2UgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhc2UpID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGFwcGx5VXNlckRhdGFDb21wYXQoZHAsIGRwLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgZHAsIEVuY3J5cHRpb25fVHlwZS5OT05FKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVEYXRhRXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBldmVudC5lcnJvcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IGV2ZW50LmVycm9yO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIkRhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCwgXCI6IFwiKS5jb25jYXQoZXZlbnQubWVzc2FnZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiVW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyBEYXRhUGFja2V0X0tpbmQuTE9TU1kgOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XG4gICAgfTtcbiAgICAvLyB3ZWJzb2NrZXQgcmVjb25uZWN0IGJlaGF2aW9yLiBpZiB3ZWJzb2NrZXQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aGUgUGVlckNvbm5lY3Rpb25cbiAgICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IChjb25uZWN0aW9uLCBkaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cud2FybihcIlwiLmNvbmNhdChjb25uZWN0aW9uLCBcIiBkaXNjb25uZWN0ZWRcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAvLyBvbmx5IHJlc2V0IHN0YXJ0IHRpbWUgb24gdGhlIGZpcnN0IHRyeVxuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChkdXJhdGlvbiwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XG4gICAgICBsZXQgZGVsYXkgPSB0aGlzLmdldE5leHRSZXRyeURlbGF5KHtcbiAgICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgICAgcmV0cnlDb3VudDogdGhpcy5yZWNvbm5lY3RBdHRlbXB0c1xuICAgICAgfSk7XG4gICAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgZGlzY29ubmVjdChkdXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uZWN0aW9uID09PSBsZWF2ZVJlY29ubmVjdCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY29ubmVjdGluZyBpbiBcIi5jb25jYXQoZGVsYXksIFwibXNcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBjdXJyZW50IGVuZ2luZSBtYXkgaGF2ZSBpbmhlcml0ZWQgYSByZWdpb25hbCB1cmxcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLmZpbmFsbHkoKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkKSwgZGVsYXkpO1xuICAgIH07XG4gICAgdGhpcy53YWl0Rm9yUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25SZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzID0ga2luZCA9PiB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICAgIGlmIChkYykge1xuICAgICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLmFsaWduQnVmZmVyZWRBbW91bnQoZGMuYnVmZmVyZWRBbW91bnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIHN0YXR1cyAhPT0gdGhpcy5kY0J1ZmZlclN0YXR1cy5nZXQoa2luZCkpIHtcbiAgICAgICAgdGhpcy5kY0J1ZmZlclN0YXR1cy5zZXQoa2luZCwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaXNCdWZmZXJTdGF0dXNMb3cgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICBpZiAoZGMpIHtcbiAgICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoYXNOZXR3b3JrQ29ubmVjdGlvbiA9IHlpZWxkIGZldGNoKHRvSHR0cFVybCh0aGlzLnVybCksIHtcbiAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgIH0pLnRoZW4ocmVzcCA9PiByZXNwLm9rKS5jYXRjaCgoKSA9PiBmYWxzZSk7XG4gICAgICBpZiAoIWhhc05ldHdvcmtDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmluZm8oJ2RldGVjdGVkIG5ldHdvcmsgcmVjb25uZWN0ZWQnKTtcbiAgICAgIGlmIChcbiAgICAgIC8vIGluIGNhc2UgdGhlIGVuZ2luZSBpcyBjdXJyZW50bHkgcmVjb25uZWN0aW5nLCBhdHRlbXB0IGEgcmVjb25uZWN0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBicm93c2VyIHN0YXRlIGhhcyBjaGFuZ2VkIHRvICdvbkxpbmUnXG4gICAgICB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcgfHxcbiAgICAgIC8vIGFsc28gaWYgdGhlIGJyb3dzZXIgd2VudCBvZmZsaW5lIGJlZm9yZSBhbmQgdGhlIGVuZ2luZSBzdGlsbCB0aGlua3MgaXQncyBpbiBhIGNvbm5lY3RlZCBzdGF0ZSwgdHJlYXQgaXQgYXMgYSBuZXR3b3JrIGludGVycnVwdGlvbiB0aGF0IHdlIGhhdmVuJ3Qgbm90aWNlZCB5ZXRcbiAgICAgIHRoaXMuaXNXYWl0aW5nRm9yTmV0d29ya1JlY29ubmVjdCAmJiB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICAgICAgdGhpcy5pc1dhaXRpbmdGb3JOZXR3b3JrUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT2ZmbGluZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFtmZXRjaCh0b0h0dHBVcmwodGhpcy51cmwpLCB7XG4gICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gaW50ZXJuZXQgY29ubmVjdGlvbiB0aGUgZmV0Y2ggcmVqZWN0cyBpbW1lZGlhdGVseSwgc28gd2Ugb25seSB1c2UgYSBzaG9ydCB0aW1lb3V0IGhlcmVcbiAgICAgICAgc2xlZXAoNDAwMCkudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdCgpKV0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBvbmx5IHNldCBpZiB0aGUgYnJvd3NlciBzdGlsbCB0aGlua3MgaXQncyBvZmZsaW5lIGFmdGVyIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbygnZGV0ZWN0ZWQgbmV0d29yayBpbnRlcnJ1cHRpb24nKTtcbiAgICAgICAgICB0aGlzLmlzV2FpdGluZ0Zvck5ldHdvcmtSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gb3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5FbmdpbmUpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTaWduYWxDbGllbnQodW5kZWZpbmVkLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMgPSBuZXcgTWFwKFtbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSwgW0RhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZV1dKTtcbiAgICB0aGlzLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdXBkYXRlcyA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHVwZGF0ZXMpO1xuICAgIHRoaXMuY2xpZW50Lm9uQ29ubmVjdGlvblF1YWxpdHkgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uUm9vbVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gcmVzcCA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3RyZWFtU3RhdGVVcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXF1ZXN0UmVzcG9uc2UsIHJlc3BvbnNlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiAoX2IgPSAoX2EgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lLFxuICAgICAgcm9vbUlEOiAoX2QgPSAoX2MgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJvb20pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zaWQsXG4gICAgICBwYXJ0aWNpcGFudDogKF9mID0gKF9lID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkZW50aXR5LFxuICAgICAgcElEOiB0aGlzLnBhcnRpY2lwYW50U2lkXG4gICAgfTtcbiAgfVxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgdGhpcy5zaWduYWxPcHRzID0gb3B0cztcbiAgICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgICAgdGhpcy5faXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnk7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNvbmZpZ3VyZShqb2luUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBvZmZlclxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkgfHwgam9pblJlc3BvbnNlLmZhc3RQdWJsaXNoKSB7XG4gICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihlcnIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbiA9IGpvaW5SZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiQ291bGRuJ3QgY29ubmVjdCB0byBzZXJ2ZXIsIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMuam9pbkF0dGVtcHRzLCBcIiBvZiBcIikuY29uY2F0KHRoaXMubWF4Sm9pbkF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNsb3NpbmcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFudXBMb3NzeURhdGFTdGF0cygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwUGVlckNvbm5lY3Rpb25zKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICB0aGlzLnBjTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGRjQ2xlYW51cCA9IGRjID0+IHtcbiAgICAgICAgaWYgKCFkYykgcmV0dXJuO1xuICAgICAgICBkYy5jbG9zZSgpO1xuICAgICAgICBkYy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zZSA9IG51bGw7XG4gICAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICAgIGRjLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBkYy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLmxvc3N5REMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgICBkY0NsZWFudXAodGhpcy5yZWxpYWJsZURDKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlRENTdWIpO1xuICAgICAgdGhpcy5sb3NzeURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIgPSBuZXcgRGF0YVBhY2tldEJ1ZmZlcigpO1xuICAgICAgdGhpcy5yZWxpYWJsZURhdGFTZXF1ZW5jZSA9IDE7XG4gICAgICB0aGlzLnJlbGlhYmxlUmVjZWl2ZWRTdGF0ZS5jbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFudXBMb3NzeURhdGFTdGF0cygpIHtcbiAgICB0aGlzLmxvc3N5RGF0YVN0YXRCeXRlcmF0ZSA9IDA7XG4gICAgdGhpcy5sb3NzeURhdGFTdGF0Q3VycmVudEJ5dGVzID0gMDtcbiAgICBpZiAodGhpcy5sb3NzeURhdGFTdGF0SW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5sb3NzeURhdGFTdGF0SW50ZXJ2YWwpO1xuICAgICAgdGhpcy5sb3NzeURhdGFTdGF0SW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMubG9zc3lEYXRhRHJvcENvdW50ID0gMDtcbiAgfVxuICBjbGVhbnVwQ2xpZW50KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmNsaWVudC5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGllbnQucmVzZXRDYWxsYmFja3MoKTtcbiAgICB9KTtcbiAgfVxuICBhZGRUcmFjayhyZXEpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwdWJsaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdO1xuICAgICAgICByZWplY3QoQ29ubmVjdGlvbkVycm9yLnRpbWVvdXQoJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInKSk7XG4gICAgICB9LCAxMDAwMCk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSA9IHtcbiAgICAgICAgcmVzb2x2ZTogaW5mbyA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2FuY2VsbGVkIHB1YmxpY2F0aW9uIGJ5IGNhbGxpbmcgdW5wdWJsaXNoJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2VuZGVyIGZyb20gUGVlckNvbm5lY3Rpb24sIHJldHVybmluZyB0cnVlIGlmIGl0IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseVxuICAgKiBhbmQgYSBuZWdvdGlhdGlvbiBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHNlbmRlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlci50cmFjayAmJiB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlamVjdFxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBjTWFuYWdlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHJlbW92ZSB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlcnJvcjogZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlTXV0ZVN0YXR1cyh0cmFja1NpZCwgbXV0ZWQpIHtcbiAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XG4gIH1cbiAgZ2V0IGRhdGFTdWJzY3JpYmVyUmVhZHlTdGF0ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmVsaWFibGVEQ1N1YikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGU7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZXRSZWdpb25VcmxQcm92aWRlcihwcm92aWRlcikge1xuICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgfVxuICBjb25maWd1cmUoam9pblJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAvLyBhbHJlYWR5IGNvbmZpZ3VyZWRcbiAgICAgIGlmICh0aGlzLnBjTWFuYWdlciAmJiB0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSAoX2EgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWQ7XG4gICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKGpvaW5SZXNwb25zZSk7XG4gICAgICB0aGlzLnBjTWFuYWdlciA9IG5ldyBQQ1RyYW5zcG9ydE1hbmFnZXIocnRjQ29uZmlnLCB0aGlzLm9wdGlvbnMuc2luZ2xlUGVlckNvbm5lY3Rpb24gPyAncHVibGlzaGVyLW9ubHknIDogam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5ID8gJ3N1YnNjcmliZXItcHJpbWFyeScgOiAncHVibGlzaGVyLXByaW1hcnknLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlRyYW5zcG9ydHNDcmVhdGVkLCB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIsIHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wY01hbmFnZXIub25QdWJsaXNoZXJPZmZlciA9IChvZmZlciwgb2ZmZXJJZCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kT2ZmZXIob2ZmZXIsIG9mZmVySWQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25TdGF0ZUNoYW5nZSA9IChjb25uZWN0aW9uU3RhdGUsIHB1Ymxpc2hlclN0YXRlLCBzdWJzY3JpYmVyU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmltYXJ5IFBDIHN0YXRlIGNoYW5nZWQgXCIuY29uY2F0KGNvbm5lY3Rpb25TdGF0ZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmIChbJ2Nsb3NlZCcsICdkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10uaW5jbHVkZXMocHVibGlzaGVyU3RhdGUpKSB7XG4gICAgICAgICAgLy8gcmVzZXQgcHVibGlzaGVyIGNvbm5lY3Rpb24gcHJvbWlzZVxuICAgICAgICAgIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gdGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLk5ldztcbiAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkNvbm5lY3RlZDtcbiAgICAgICAgICBpZiAoc2hvdWxkRW1pdCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCkge1xuICAgICAgICAgIC8vIG9uIFNhZmFyaSwgUGVlckNvbm5lY3Rpb24gd2lsbCBzd2l0Y2ggdG8gJ2Rpc2Nvbm5lY3RlZCcgZHVyaW5nIHJlbmVnb3RpYXRpb25cbiAgICAgICAgICBpZiAodGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLkNvbm5lY3RlZCB8fCB0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncGVlcmNvbm5lY3Rpb24gZmFpbGVkJywgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJyA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRCA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGV0ZWN0IGNhc2VzIHdoZXJlIGJvdGggc2lnbmFsIGNsaWVudCBhbmQgcGVlciBjb25uZWN0aW9uIGFyZSBzZXZlcmVkIGFuZCBhc3N1bWUgdGhhdCB1c2VyIGhhcyBsb3N0IG5ldHdvcmsgY29ubmVjdGlvblxuICAgICAgICBjb25zdCBpc1NpZ25hbFNldmVyZWQgPSB0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCB8fCB0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgICAgIGNvbnN0IGlzUENTZXZlcmVkID0gW1BDVHJhbnNwb3J0U3RhdGUuRkFJTEVELCBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NJTkcsIFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEXS5pbmNsdWRlcyhjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoaXNTaWduYWxTZXZlcmVkICYmIGlzUENTZXZlcmVkICYmICF0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5PZmZsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgICAvLyB0aGlzIGZpcmVzIGFmdGVyIHRoZSB1bmRlcmx5aW5nIHRyYW5zY2VpdmVyIGlzIHN0b3BwZWQgYW5kIHBvdGVudGlhbGx5XG4gICAgICAgIC8vIHBlZXIgY29ubmVjdGlvbiBjbG9zZWQsIHNvIGRvIG5vdCBidWJibGUgdXAgaWYgdGhlcmUgYXJlIG5vIHN0cmVhbXNcbiAgICAgICAgaWYgKGV2LnN0cmVhbXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIGV2LnRyYWNrLCBldi5zdHJlYW1zWzBdLCBldi5yZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgaWYgKCFzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbCgoX2IgPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnByb3RvY29sKSkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSAoc2QsIG9mZmVySWQsIG1pZFRvVHJhY2tJZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxuICAgICAgICBzZHA6IHNkLnNkcCxcbiAgICAgICAgbWlkVG9UcmFja0lkXG4gICAgICB9KSk7XG4gICAgICB0aGlzLm1pZFRvVHJhY2tJZCA9IG1pZFRvVHJhY2tJZDtcbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCwgb2ZmZXJJZCk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGNhbmRpZGF0ZSBvbiB0cmlja2xlXG4gICAgdGhpcy5jbGllbnQub25Ucmlja2xlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdnb3QgSUNFIGNhbmRpZGF0ZSBmcm9tIHBlZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNlcnZlciBjcmVhdGVzIGFuIG9mZmVyIGZvciB0aGUgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25PZmZlciA9IChzZCwgb2ZmZXJJZCwgbWlkVG9UcmFja0lkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxhdGVzdFJlbW90ZU9mZmVySWQgPSBvZmZlcklkO1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1pZFRvVHJhY2tJZCA9IG1pZFRvVHJhY2tJZDtcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QsIG9mZmVySWQpO1xuICAgICAgaWYgKGFuc3dlcikge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlciwgb2ZmZXJJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcmVzID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IChfYSA9IHJlcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZFxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIm1pc3NpbmcgdHJhY2sgcmVzb2x2ZXIgZm9yIFwiLmNvbmNhdChyZXMuY2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgY2lkOiByZXMuY2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXNvbHZlXG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICByZXNvbHZlKHJlcy50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHJlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1N1YnNjcmliZWQgPSB0cmFja1NpZCA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrU2lkKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uVG9rZW5SZWZyZXNoID0gdG9rZW4gPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVRva2VuKHRva2VuKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgdHJhY2tTaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25Sb29tTW92ZWQgPSByZXMgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IHJlcy5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcbiAgICAgIGlmICh0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkge1xuICAgICAgICB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZS5yb29tID0gcmVzLnJvb207XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbU1vdmVkLCByZXMpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25NZWRpYVNlY3Rpb25zUmVxdWlyZW1lbnQgPSByZXF1aXJlbWVudCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVtZW50Lm51bUF1ZGlvczsgaSsrKSB7XG4gICAgICAgIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXJPZktpbmQoJ2F1ZGlvJywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZW1lbnQubnVtVmlkZW9zOyBpKyspIHtcbiAgICAgICAgKF9iID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlck9mS2luZCgndmlkZW8nLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3NpZ25hbCcsIFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTGVhdmUgPSBsZWF2ZSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnY2xpZW50IGxlYXZlIHJlcXVlc3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uOiBsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUucmVhc29uXG4gICAgICB9KSk7XG4gICAgICBpZiAobGVhdmUucmVnaW9ucyAmJiB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyByZWdpb25zJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5zZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMoe1xuICAgICAgICAgIHVwZGF0ZWRBdEluTXM6IERhdGUubm93KCksXG4gICAgICAgICAgbWF4QWdlSW5NczogREVGQVVMVF9NQVhfQUdFX01TLFxuICAgICAgICAgIHJlZ2lvblNldHRpbmdzOiBsZWF2ZS5yZWdpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChsZWF2ZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvbik7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVDT05ORUNUOlxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbmV4dCBhdHRlbXB0XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLlJFU1VNRTpcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbWFrZVJUQ0NvbmZpZ3VyYXRpb24oc2VydmVyUmVzcG9uc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcnRjQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ydGNDb25maWcpO1xuICAgIGlmICgoX2EgPSB0aGlzLnNpZ25hbE9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lMmVlRW5hYmxlZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ0UyRUUgLSBzZXR0aW5nIHVwIHRyYW5zcG9ydHMgd2l0aCBpbnNlcnRhYmxlIHN0cmVhbXMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gIHRoaXMgbWFrZXMgc3VyZSB0aGF0IG5vIGRhdGEgaXMgc2VudCBiZWZvcmUgdGhlIHRyYW5zZm9ybXMgYXJlIHJlYWR5XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBydGNDb25maWcuZW5jb2RlZEluc2VydGFibGVTdHJlYW1zID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIElDRSBzZXJ2ZXJzIGJlZm9yZSBjcmVhdGluZyBQZWVyQ29ubmVjdGlvblxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzICYmICFydGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgcnRjSWNlU2VydmVycyA9IFtdO1xuICAgICAgc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycy5mb3JFYWNoKGljZVNlcnZlciA9PiB7XG4gICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlciA9IHtcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJsc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKSBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIuY3JlZGVudGlhbCkge1xuICAgICAgICAgIHJ0Y0ljZVNlcnZlci5jcmVkZW50aWFsID0gaWNlU2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcnRjSWNlU2VydmVycy5wdXNoKHJ0Y0ljZVNlcnZlcik7XG4gICAgICB9KTtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcbiAgICB9XG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24gJiYgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbi5mb3JjZVJlbGF5ID09PSBDbGllbnRDb25maWdTZXR0aW5nLkVOQUJMRUQpIHtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLnNkcFNlbWFudGljcyA9ICd1bmlmaWVkLXBsYW4nO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuY29udGludWFsR2F0aGVyaW5nUG9saWN5ID0gJ2dhdGhlcl9jb250aW51YWxseSc7XG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbHMoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjbGVhciBvbGQgZGF0YSBjaGFubmVsIGNhbGxiYWNrcyBpZiByZWNyZWF0ZVxuICAgIGlmICh0aGlzLmxvc3N5REMpIHtcbiAgICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XG4gICAgICBvcmRlcmVkOiBmYWxzZSxcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwXG4gICAgfSk7XG4gICAgdGhpcy5yZWxpYWJsZURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwocmVsaWFibGVEYXRhQ2hhbm5lbCwge1xuICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIGFsc28gaGFuZGxlIG1lc3NhZ2VzIG92ZXIgdGhlIHB1YiBjaGFubmVsLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAvLyBoYW5kbGUgZGF0YWNoYW5uZWwgZXJyb3JzXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIC8vIHNldCB1cCBkYyBidWZmZXIgdGhyZXNob2xkLCBzZXQgdG8gNjRrQiAob3RoZXJ3aXNlIDAgYnkgZGVmYXVsdClcbiAgICB0aGlzLmxvc3N5REMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICB0aGlzLnJlbGlhYmxlREMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICAvLyBoYW5kbGUgYnVmZmVyIGFtb3VudCBsb3cgZXZlbnRzXG4gICAgdGhpcy5sb3NzeURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgICB0aGlzLmNsZWFudXBMb3NzeURhdGFTdGF0cygpO1xuICAgIHRoaXMubG9zc3lEYXRhU3RhdEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5sb3NzeURhdGFTdGF0Qnl0ZXJhdGUgPSB0aGlzLmxvc3N5RGF0YVN0YXRDdXJyZW50Qnl0ZXM7XG4gICAgICB0aGlzLmxvc3N5RGF0YVN0YXRDdXJyZW50Qnl0ZXMgPSAwO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIC8vIGNvbnRyb2wgYnVmZmVyZWQgbGF0ZW5jeSB0byB+MTAwbXNcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5sb3NzeURhdGFTdGF0Qnl0ZXJhdGUgLyAxMDtcbiAgICAgICAgZGMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQsIGxvc3N5RGF0YUNoYW5uZWxCdWZmZXJUaHJlc2hvbGRNaW4pLCBsb3NzeURhdGFDaGFubmVsQnVmZmVyVGhyZXNob2xkTWF4KTtcbiAgICAgIH1cbiAgICB9LCAxMDAwKTtcbiAgfVxuICBjcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1JlcXVpcmVkIHdlYlJUQyBBUElzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gc3RvcmUgUlRDUnRwU2VuZGVyXG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgICBpZiAodHJhY2subWVkaWFTdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKHRyYWNrLm1lZGlhU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyYWNrLmNvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgIHN0cmVhbXNcbiAgICAgIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5J1xuICAgICAgfTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICBpZiAoIW9wdHMudmlkZW9Db2RlYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhY2sodHJhY2spO1xuICAgIH0pO1xuICB9XG4gIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcbiAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhbHJlYWR5IGF0dGVtcHRpbmcgcmVjb25uZWN0LCByZXR1cm5pbmcgZWFybHknLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKChfYSA9IHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZUNvbm5lY3Rpb24pID09PSBDbGllbnRDb25maWdTZXR0aW5nLkRJU0FCTEVEIHx8XG4gICAgICAvLyBzaWduYWxpbmcgc3RhdGUgY291bGQgY2hhbmdlIHRvIGNsb3NlZCBkdWUgdG8gaGFyZHdhcmUgc2xlZXBcbiAgICAgIC8vIHRob3NlIGNvbm5lY3Rpb25zIGNhbm5vdCBiZSByZXN1bWVkXG4gICAgICAoKF9jID0gKF9iID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXJyZW50U3RhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN1bWVDb25uZWN0aW9uKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgbGV0IHJlY292ZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVucmVjb3ZlcmFibGUgZXJyb3InLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIC8vIHVucmVjb3ZlcmFibGVcbiAgICAgICAgICByZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xuICAgICAgICAgIC8vIGNhbm5vdCByZXN1bWVcbiAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncmVjb25uZWN0JywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydCwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dFJldHJ5RGVsYXkoY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RQb2xpY3kubmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2VuY291bnRlcmVkIGVycm9yIGluIHJlY29ubmVjdCBwb2xpY3knLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gZXJyb3IgaW4gdXNlciBjb2RlIHdpdGggcHJvdmlkZWQgcmVjb25uZWN0IHBvbGljeSwgc3RvcCByZWNvbm5lY3RpbmdcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN0YXJ0Q29ubmVjdGlvbihyZWdpb25VcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwicmVjb25uZWN0aW5nLCBhdHRlbXB0OiBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBDbGllbnQoKTtcbiAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2lnbmFsT3B0cykge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIGNvbm5lY3Rpb24gcmVzdGFydCwgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBwcmVzZW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbiBjYXNlIGEgcmVnaW9uVXJsIGlzIHBhc3NlZCwgdGhlIHJlZ2lvbiBVUkwgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgIGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuam9pbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcbiAgICAgICAgLy8gcmUtY2hlY2sgc2lnbmFsIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgZW5naW5lIGFzIHJlc3VtZWRcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgIC8vIHJlY29ubmVjdCBzdWNjZXNzXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbmV4dFJlZ2lvblVybCA9IHlpZWxkIChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICBpZiAobmV4dFJlZ2lvblVybCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydENvbm5lY3Rpb24obmV4dFJlZ2lvblVybCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgcmVnaW9ucyB0byB0cnkgKG9yIHdlJ3JlIG5vdCBvbiBjbG91ZClcbiAgICAgICAgICAoX2MgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lQ29ubmVjdGlvbihyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGFuZCBzdWJzY3JpYmVyIGNvbm5lY3Rpb25zIHVuc2V0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKFwicmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24sIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtaW5nKTtcbiAgICAgIGxldCByZXM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCk7XG4gICAgICAgIHJlcyA9IHlpZWxkIHRoaXMuY2xpZW50LnJlY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5wYXJ0aWNpcGFudFNpZCwgcmVhc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IubWVzc2FnZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci51cGRhdGVDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkge1xuICAgICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlLnNlcnZlckluZm8gPSByZXMuc2VydmVySW5mbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignRGlkIG5vdCByZWNlaXZlIHJlY29ubmVjdCByZXNwb25zZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xuICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2ltdWxhdGVkIGZhaWx1cmUnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XG4gICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG4gICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICAvLyByZWNyZWF0ZSBwdWJsaXNoIGRhdGFjaGFubmVsIGlmIGl0J3MgaWQgaXMgbnVsbFxuICAgICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcbiAgICAgIGlmICgoKF9hID0gdGhpcy5yZWxpYWJsZURDKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJyAmJiB0aGlzLnJlbGlhYmxlREMuaWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMubGFzdE1lc3NhZ2VTZXEpIHtcbiAgICAgICAgdGhpcy5yZXNlbmRSZWxpYWJsZU1lc3NhZ2VzRm9yUmVzdW1lKHJlcy5sYXN0TWVzc2FnZVNlcSk7XG4gICAgICB9XG4gICAgICAvLyByZXN1bWUgc3VjY2Vzc1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtZWQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRpbWVvdXQsIGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCk7XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvclBDUmVjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuUmVjb25uZWN0aW5nO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3dhaXRpbmcgZm9yIHBlZXIgY29ubmVjdGlvbiB0byByZWNvbm5lY3QnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKHVuZGVmaW5lZCwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkNvbm5lY3RlZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xuICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgdGhyb3cgQ29ubmVjdGlvbkVycm9yLmludGVybmFsKFwiY291bGQgbm90IGVzdGFibGlzaCBQQyBjb25uZWN0aW9uLCBcIi5jb25jYXQoZS5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaXNoUnBjUmVzcG9uc2UoZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3JwY1Jlc3BvbnNlJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY1Jlc3BvbnNlKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIHZhbHVlOiBlcnJvciA/IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGVycm9yLnRvUHJvdG8oKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3BheWxvYWQnLFxuICAgICAgICAgICAgICB2YWx1ZTogcGF5bG9hZCAhPT0gbnVsbCAmJiBwYXlsb2FkICE9PSB2b2lkIDAgPyBwYXlsb2FkIDogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGlzaFJwY0FjayhkZXN0aW5hdGlvbklkZW50aXR5LCByZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNBY2snLFxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjQWNrKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgZG8gaGF2ZSBhIGRhdGEgY29ubmVjdGlvblxuICAgICAgeWllbGQgdGhpcy5lbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCk7XG4gICAgICBpZiAodGhpcy5lMmVlTWFuYWdlciAmJiB0aGlzLmUyZWVNYW5hZ2VyLmlzRGF0YUNoYW5uZWxFbmNyeXB0aW9uRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBlbmNyeXB0YWJsZVBhY2tldCA9IGFzRW5jcnlwdGFibGVQYWNrZXQocGFja2V0KTtcbiAgICAgICAgaWYgKGVuY3J5cHRhYmxlUGFja2V0KSB7XG4gICAgICAgICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHlpZWxkIHRoaXMuZTJlZU1hbmFnZXIuZW5jcnlwdERhdGEoZW5jcnlwdGFibGVQYWNrZXQudG9CaW5hcnkoKSk7XG4gICAgICAgICAgcGFja2V0LnZhbHVlID0ge1xuICAgICAgICAgICAgY2FzZTogJ2VuY3J5cHRlZFBhY2tldCcsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEVuY3J5cHRlZFBhY2tldCh7XG4gICAgICAgICAgICAgIGVuY3J5cHRlZFZhbHVlOiBlbmNyeXB0ZWREYXRhLnBheWxvYWQsXG4gICAgICAgICAgICAgIGl2OiBlbmNyeXB0ZWREYXRhLml2LFxuICAgICAgICAgICAgICBrZXlJbmRleDogZW5jcnlwdGVkRGF0YS5rZXlJbmRleFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHBhY2tldC5zZXF1ZW5jZSA9IHRoaXMucmVsaWFibGVEYXRhU2VxdWVuY2U7XG4gICAgICAgIHRoaXMucmVsaWFibGVEYXRhU2VxdWVuY2UgKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1zZyA9IHBhY2tldC50b0JpbmFyeSgpO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICAgICAgc2VxdWVuY2U6IHBhY2tldC5zZXF1ZW5jZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvc3N5IGNoYW5uZWwsIGRyb3AgbWVzc2FnZXMgdG8gcmVkdWNlIGxhdGVuY3lcbiAgICAgICAgICBpZiAoIXRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9zc3lEYXRhRHJvcENvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5sb3NzeURhdGFEcm9wQ291bnQgJSAxMDAgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihcImRyb3BwaW5nIGxvc3N5IGRhdGEgY2hhbm5lbCBtZXNzYWdlcywgdG90YWwgZHJvcHBlZDogXCIuY29uY2F0KHRoaXMubG9zc3lEYXRhRHJvcENvdW50KSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb3NzeURhdGFTdGF0Q3VycmVudEJ5dGVzICs9IG1zZy5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGMuc2VuZChtc2cpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoa2luZCk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZW5kUmVsaWFibGVNZXNzYWdlc0ZvclJlc3VtZShsYXN0TWVzc2FnZVNlcSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnBvcFRvU2VxdWVuY2UobGFzdE1lc3NhZ2VTZXEpO1xuICAgICAgICB0aGlzLnJlbGlhYmxlTWVzc2FnZUJ1ZmZlci5nZXRBbGwoKS5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgZGMuc2VuZChtc2cuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yQnVmZmVyU3RhdHVzTG93KGtpbmQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25DbG9zaW5nID0gKCkgPT4gcmVqZWN0KCdFbmdpbmUgY2xvc2VkJyk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkNsb3NpbmcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICAgICAgeWllbGQgc2xlZXAoMTApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uQ2xvc2luZyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBsZXQgc3Vic2NyaWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghX3RoaXMyLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyBfdGhpczIucGNNYW5hZ2VyLnN1YnNjcmliZXIgOiBfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlcjtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHN1YnNjcmliZXIgPyAnU3Vic2NyaWJlcicgOiAnUHVibGlzaGVyJztcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICB0aHJvdyBDb25uZWN0aW9uRXJyb3IuaW50ZXJuYWwoXCJcIi5jb25jYXQodHJhbnNwb3J0TmFtZSwgXCIgY29ubmVjdGlvbiBub3Qgc2V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmVlZE5lZ290aWF0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICghc3Vic2NyaWJlciAmJiAhX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkge1xuICAgICAgICAgIF90aGlzMi5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmVlZE5lZ290aWF0aW9uICYmICFzdWJzY3JpYmVyICYmICFfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlci5pc0lDRUNvbm5lY3RlZCAmJiBfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgIG5lZWROZWdvdGlhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWROZWdvdGlhdGlvbikge1xuICAgICAgICAgIC8vIHN0YXJ0IG5lZ290aWF0aW9uXG4gICAgICAgICAgX3RoaXMyLm5lZ290aWF0ZSgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKGVyciwgX3RoaXMyLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSBfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoKHRhcmdldENoYW5uZWwgPT09IG51bGwgfHwgdGFyZ2V0Q2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2hhbm5lbC5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhaXQgdW50aWwgSUNFIGNvbm5lY3RlZFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBfdGhpczIucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgICB3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBlbmRUaW1lKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJiAoKF9hID0gX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IENvbm5lY3Rpb25FcnJvci5pbnRlcm5hbChcImNvdWxkIG5vdCBlc3RhYmxpc2ggXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24sIHN0YXRlOiBcIikuY29uY2F0KHRyYW5zcG9ydC5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5lbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2U7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHZlcmlmeVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBzaWduYWwgaXMgY29ubmVjdGVkXG4gICAgaWYgKCF0aGlzLmNsaWVudC53cyB8fCB0aGlzLmNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmVnb3RpYXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnJlcXVpcmVQdWJsaXNoZXIoKTtcbiAgICAgICAgLy8gZG9uJ3QgbmVnb3RpYXRlIHdpdGhvdXQgYW55IHRyYW5zY2VpdmVycyBvciBkYXRhIGNoYW5uZWwsIGl0IHdpbGwgZ2VuZXJhdGUgc2RwIHdpdGhvdXQgaWNlIGZyYWcgdGhlbiBuZWdvdGlhdGUgZmFpbGVkXG4gICAgICAgIGlmICh0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkubGVuZ3RoID09IDAgJiYgIXRoaXMubG9zc3lEQyAmJiAhdGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlZCA9ICgpID0+IHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZW5naW5lIGRpc2Nvbm5lY3RlZCB3aGlsZSBuZWdvdGlhdGlvbiB3YXMgb25nb2luZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICByZWplY3QoJ2Nhbm5vdCBuZWdvdGlhdGUgb24gY2xvc2VkIGVuZ2luZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub24oRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgICAgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLm9uY2UoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIHJ0cFR5cGVzID0+IHtcbiAgICAgICAgICBjb25zdCBydHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgcnRwVHlwZXMuZm9yRWFjaChydHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSBydHAuY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChpc1ZpZGVvQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHJ0cE1hcC5zZXQocnRwLnBheWxvYWQsIGNvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLm5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCduZWdvdGlhdGlvbicsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWIpIHtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5RENTdWI7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlRENTdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N5bmMgc3RhdGUgY2Fubm90IGJlIHNlbnQgd2l0aG91dCBwZWVyIGNvbm5lY3Rpb24gc2V0dXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1B1Ymxpc2hlck9mZmVyID0gdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLmdldExvY2FsRGVzY3JpcHRpb24oKTtcbiAgICBjb25zdCBwcmV2aW91c1B1Ymxpc2hlckFuc3dlciA9IHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRSZW1vdGVEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzU3Vic2NyaWJlck9mZmVyID0gKF9hID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgcHJldmlvdXNTdWJzY3JpYmVyQW5zd2VyID0gKF9iID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldExvY2FsRGVzY3JpcHRpb24oKTtcbiAgICAvKiAxLiBhdXRvc3Vic2NyaWJlIG9uLCBzbyBzdWJzY3JpYmVkIHRyYWNrcyA9IGFsbCB0cmFja3MgLSB1bnN1YiB0cmFja3MsXG4gICAgICAgICAgaW4gdGhpcyBjYXNlLCB3ZSBzZW5kIHVuc3ViIHRyYWNrcywgc28gc2VydmVyIGFkZCBhbGwgdHJhY2tzIHRvIHRoaXNcbiAgICAgICAgICBzdWJzY3JpYmUgcGMgYW5kIHVuc3ViIHNwZWNpYWwgdHJhY2tzIGZyb20gaXQuXG4gICAgICAgMi4gYXV0b3N1YnNjcmliZSBvZmYsIHdlIHNlbmQgc3Vic2NyaWJlZCB0cmFja3MuXG4gICAgKi9cbiAgICBjb25zdCBhdXRvU3Vic2NyaWJlID0gKF9kID0gKF9jID0gdGhpcy5zaWduYWxPcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYXV0b1N1YnNjcmliZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZTtcbiAgICBjb25zdCB0cmFja1NpZHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCB0cmFja1NpZHNEaXNhYmxlZCA9IG5ldyBBcnJheSgpO1xuICAgIHJlbW90ZVRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmICh0cmFjay5pc0Rlc2lyZWQgIT09IGF1dG9TdWJzY3JpYmUpIHtcbiAgICAgICAgdHJhY2tTaWRzLnB1c2godHJhY2sudHJhY2tTaWQpO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5pc0VuYWJsZWQpIHtcbiAgICAgICAgdHJhY2tTaWRzRGlzYWJsZWQucHVzaCh0cmFjay50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQuc2VuZFN5bmNTdGF0ZShuZXcgU3luY1N0YXRlKHtcbiAgICAgIGFuc3dlcjogdGhpcy5vcHRpb25zLnNpbmdsZVBlZXJDb25uZWN0aW9uID8gcHJldmlvdXNQdWJsaXNoZXJBbnN3ZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c1B1Ymxpc2hlckFuc3dlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzUHVibGlzaGVyQW5zd2VyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkIDogcHJldmlvdXNTdWJzY3JpYmVyQW5zd2VyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNTdWJzY3JpYmVyQW5zd2VyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNTdWJzY3JpYmVyQW5zd2VyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgb2ZmZXI6IHRoaXMub3B0aW9ucy5zaW5nbGVQZWVyQ29ubmVjdGlvbiA/IHByZXZpb3VzUHVibGlzaGVyT2ZmZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c1B1Ymxpc2hlck9mZmVyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNQdWJsaXNoZXJPZmZlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCA6IHByZXZpb3VzU3Vic2NyaWJlck9mZmVyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNTdWJzY3JpYmVyT2ZmZXIuc2RwLFxuICAgICAgICB0eXBlOiBwcmV2aW91c1N1YnNjcmliZXJPZmZlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIHRyYWNrU2lkcyxcbiAgICAgICAgc3Vic2NyaWJlOiAhYXV0b1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtdXG4gICAgICB9KSxcbiAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcbiAgICAgIGRhdGFDaGFubmVsczogdGhpcy5kYXRhQ2hhbm5lbHNJbmZvKCksXG4gICAgICB0cmFja1NpZHNEaXNhYmxlZCxcbiAgICAgIGRhdGFjaGFubmVsUmVjZWl2ZVN0YXRlczogdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUubWFwKChzZXEsIHNpZCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFubmVsUmVjZWl2ZVN0YXRlKHtcbiAgICAgICAgICBwdWJsaXNoZXJTaWQ6IHNpZCxcbiAgICAgICAgICBsYXN0U2VxOiBzZXFcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIH0pKTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmFpbE5leHQoKSB7XG4gICAgLy8gZGVidWdnaW5nIG1ldGhvZCB0byBmYWlsIHRoZSBuZXh0IHJlY29ubmVjdC9yZXN1bWUgYXR0ZW1wdFxuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSB0cnVlO1xuICB9XG4gIGRhdGFDaGFubmVsc0luZm8oKSB7XG4gICAgY29uc3QgaW5mb3MgPSBbXTtcbiAgICBjb25zdCBnZXRJbmZvID0gKGRjLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmICgoZGMgPT09IG51bGwgfHwgZGMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRjLmlkKSAhPT0gdW5kZWZpbmVkICYmIGRjLmlkICE9PSBudWxsKSB7XG4gICAgICAgIGluZm9zLnB1c2gobmV3IERhdGFDaGFubmVsSW5mbyh7XG4gICAgICAgICAgbGFiZWw6IGRjLmxhYmVsLFxuICAgICAgICAgIGlkOiBkYy5pZCxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIHJldHVybiBpbmZvcztcbiAgfVxuICBjbGVhclJlY29ubmVjdFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgfVxuICB9XG4gIGNsZWFyUGVuZGluZ1JlY29ubmVjdCgpIHtcbiAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICB9XG4gIHJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPZmZsaW5lKTtcbiAgICB9XG4gIH1cbiAgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT2ZmbGluZSk7XG4gICAgfVxuICB9XG4gIGdldFRyYWNrSWRGb3JSZWNlaXZlcihyZWNlaXZlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtaWQgPSAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldE1pZEZvclJlY2VpdmVyKHJlY2VpdmVyKTtcbiAgICBpZiAobWlkKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IE9iamVjdC5lbnRyaWVzKHRoaXMubWlkVG9UcmFja0lkKS5maW5kKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IFtrZXldID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBrZXkgPT09IG1pZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCAhPT0gdW5kZWZpbmVkICYmIHByb3RvY29sID4gMTM7XG59XG5mdW5jdGlvbiBhcHBseVVzZXJEYXRhQ29tcGF0KG5ld09iaiwgb2xkT2JqKSB7XG4gIGNvbnN0IHBhcnRpY2lwYW50SWRlbnRpdHkgPSBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA/IG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5IDogb2xkT2JqLnBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgb2xkT2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xuICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzLmxlbmd0aCAhPT0gMCA/IG5ld09iai5kZXN0aW5hdGlvbklkZW50aXRpZXMgOiBvbGRPYmouZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICBvbGRPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xufWNsYXNzIEJhc2VTdHJlYW1SZWFkZXIge1xuICBnZXQgaW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5mbztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHZhbGlkYXRlQnl0ZXNSZWNlaXZlZCgpIHtcbiAgICBsZXQgZG9uZVJlY2VpdmluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvdGFsQnl0ZVNpemUgIT09ICdudW1iZXInIHx8IHRoaXMudG90YWxCeXRlU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZG9uZVJlY2VpdmluZyAmJiB0aGlzLmJ5dGVzUmVjZWl2ZWQgPCB0aGlzLnRvdGFsQnl0ZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJOb3QgZW5vdWdoIGNodW5rKHMpIHJlY2VpdmVkIC0gZXhwZWN0ZWQgXCIuY29uY2F0KHRoaXMudG90YWxCeXRlU2l6ZSwgXCIgYnl0ZXMgb2YgZGF0YSB0b3RhbCwgb25seSByZWNlaXZlZCBcIikuY29uY2F0KHRoaXMuYnl0ZXNSZWNlaXZlZCwgXCIgYnl0ZXNcIiksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5JbmNvbXBsZXRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNSZWNlaXZlZCA+IHRoaXMudG90YWxCeXRlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGFTdHJlYW1FcnJvcihcIkV4dHJhIGNodW5rKHMpIHJlY2VpdmVkIC0gZXhwZWN0ZWQgXCIuY29uY2F0KHRoaXMudG90YWxCeXRlU2l6ZSwgXCIgYnl0ZXMgb2YgZGF0YSB0b3RhbCwgcmVjZWl2ZWQgXCIpLmNvbmNhdCh0aGlzLmJ5dGVzUmVjZWl2ZWQsIFwiIGJ5dGVzXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uTGVuZ3RoRXhjZWVkZWQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihpbmZvLCBzdHJlYW0sIHRvdGFsQnl0ZVNpemUsIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpIHtcbiAgICB0aGlzLnJlYWRlciA9IHN0cmVhbTtcbiAgICB0aGlzLnRvdGFsQnl0ZVNpemUgPSB0b3RhbEJ5dGVTaXplO1xuICAgIHRoaXMuX2luZm8gPSBpbmZvO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XG4gICAgdGhpcy5vdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlID0gb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZTtcbiAgfVxufVxuY2xhc3MgQnl0ZVN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xuICBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XG4gICAgdGhpcy52YWxpZGF0ZUJ5dGVzUmVjZWl2ZWQoKTtcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemUgPyB0aGlzLmJ5dGVzUmVjZWl2ZWQgLyB0aGlzLnRvdGFsQnl0ZVNpemUgOiB1bmRlZmluZWQ7XG4gICAgKF9hID0gdGhpcy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50UHJvZ3Jlc3MpO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XG4gICAgbGV0IHJlamVjdGluZ1NpZ25hbEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICBsZXQgYWN0aXZlU2lnbmFsID0gbnVsbDtcbiAgICBsZXQgb25BYm9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2lnbmFsKSB7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLnNpZ25hbDtcbiAgICAgIG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gcmVqZWN0aW5nU2lnbmFsRnV0dXJlLnJlamVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocmVqZWN0aW5nU2lnbmFsRnV0dXJlLCBzaWduYWwucmVhc29uKTtcbiAgICAgIH07XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICAgIGFjdGl2ZVNpZ25hbCA9IHNpZ25hbDtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgaWYgKGFjdGl2ZVNpZ25hbCAmJiBvbkFib3J0KSB7XG4gICAgICAgIGFjdGl2ZVNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYWwgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSB5aWVsZCBQcm9taXNlLnJhY2UoW3JlYWRlci5yZWFkKCksXG4gICAgICAgICAgLy8gUmVqZWN0cyBpZiB0aGlzLnNpZ25hbCBpcyBhYm9ydGVkXG4gICAgICAgICAgcmVqZWN0aW5nU2lnbmFsRnV0dXJlLnByb21pc2UsXG4gICAgICAgICAgLy8gUmVqZWN0cyBpZiBzb21ldGhpbmcgZXh0ZXJuYWwgc2F5cyBpdCBzaG91bGQsIGxpa2UgYSBwYXJ0aWNpcGFudCBkaXNjb25uZWN0aW5nLCBldGNcbiAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9taXNlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAvKiBuZXZlciByZXNvbHZlcyAqL1xuICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVCeXRlc1JlY2VpdmVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaHVua1JlY2VpdmVkKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuY29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgLy8gbm90ZTogYHJldHVybmAgcnVucyBvbmx5IGZvciBwcmVtYXR1cmUgZXhpdHMsIHNlZTpcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMjZXJyb3JzX2R1cmluZ19pdGVyYXRpb25cbiAgICAgIHJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5qZWN0cyBhbiBBYm9ydFNpZ25hbCwgd2hpY2ggaWYgYWJvcnRlZCwgd2lsbCB0ZXJtaW5hdGUgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgICogc3RyZWFtIGl0ZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3aGVuIHVzaW5nIEFib3J0U2lnbmFsLnRpbWVvdXQoLi4uKSwgdGhlIHRpbWVvdXQgYXBwbGllcyBhY3Jvc3NcbiAgICogdGhlIHdob2xlIGl0ZXJhdGlvbiBvcGVyYXRpb24sIG5vdCBqdXN0IG9uZSBpbmRpdmlkdWFsIGNodW5rIHJlYWQuXG4gICAqL1xuICB3aXRoQWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVhZEFsbCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGxldCBjaHVua3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gb3B0cy5zaWduYWwgPyBfdGhpcy53aXRoQWJvcnRTaWduYWwob3B0cy5zaWduYWwpIDogX3RoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYXRvcl8xID0gX19hc3luY1ZhbHVlcyhpdGVyYXRvciksIGl0ZXJhdG9yXzFfMTsgaXRlcmF0b3JfMV8xID0geWllbGQgaXRlcmF0b3JfMS5uZXh0KCksIF9hID0gaXRlcmF0b3JfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICBfYyA9IGl0ZXJhdG9yXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgY2h1bmtzLmFkZChjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgIGVfMSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhdG9yXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChpdGVyYXRvcl8xKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShjaHVua3MpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdG8gcmVhZCBjaHVua3MgZnJvbSBhIFJlYWRhYmxlU3RyZWFtIGFuZCBwcm92aWRlIHRoZW0gaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC5cbiAqL1xuY2xhc3MgVGV4dFN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xuICAvKipcbiAgICogQSBUZXh0U3RyZWFtUmVhZGVyIGluc3RhbmNlIGNhbiBiZSB1c2VkIGFzIGFuIEFzeW5jSXRlcmF0b3IgdGhhdCByZXR1cm5zIHRoZSBlbnRpcmUgc3RyaW5nXG4gICAqIHRoYXQgaGFzIGJlZW4gcmVjZWl2ZWQgdXAgdG8gdGhlIGN1cnJlbnQgcG9pbnQgaW4gdGltZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluZm8sIHN0cmVhbSwgdG90YWxDaHVua0NvdW50LCBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlKSB7XG4gICAgc3VwZXIoaW5mbywgc3RyZWFtLCB0b3RhbENodW5rQ291bnQsIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpO1xuICAgIHRoaXMucmVjZWl2ZWRDaHVua3MgPSBuZXcgTWFwKCk7XG4gIH1cbiAgaGFuZGxlQ2h1bmtSZWNlaXZlZChjaHVuaykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpbmRleCA9IGJpZ0ludFRvTnVtYmVyKGNodW5rLmNodW5rSW5kZXgpO1xuICAgIGNvbnN0IHByZXZpb3VzQ2h1bmtBdEluZGV4ID0gdGhpcy5yZWNlaXZlZENodW5rcy5nZXQoaW5kZXgpO1xuICAgIGlmIChwcmV2aW91c0NodW5rQXRJbmRleCAmJiBwcmV2aW91c0NodW5rQXRJbmRleC52ZXJzaW9uID4gY2h1bmsudmVyc2lvbikge1xuICAgICAgLy8gd2UgaGF2ZSBhIG5ld2VyIHZlcnNpb24gYWxyZWFkeSwgZHJvcHBpbmcgdGhlIG9sZCBvbmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWNlaXZlZENodW5rcy5zZXQoaW5kZXgsIGNodW5rKTtcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gY2h1bmsuY29udGVudC5ieXRlTGVuZ3RoO1xuICAgIHRoaXMudmFsaWRhdGVCeXRlc1JlY2VpdmVkKCk7XG4gICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy50b3RhbEJ5dGVTaXplID8gdGhpcy5ieXRlc1JlY2VpdmVkIC8gdGhpcy50b3RhbEJ5dGVTaXplIDogdW5kZWZpbmVkO1xuICAgIChfYSA9IHRoaXMub25Qcm9ncmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY3VycmVudFByb2dyZXNzKTtcbiAgfVxuICAvKipcbiAgICogQXN5bmMgaXRlcmF0b3IgaW1wbGVtZW50YXRpb24gdG8gYWxsb3cgdXNhZ2Ugb2YgYGZvciBhd2FpdC4uLm9mYCBzeW50YXguXG4gICAqIFlpZWxkcyBzdHJ1Y3R1cmVkIGNodW5rcyBmcm9tIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqL1xuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMucmVhZGVyLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jywge1xuICAgICAgZmF0YWw6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgcmVqZWN0aW5nU2lnbmFsRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgIGxldCBhY3RpdmVTaWduYWwgPSBudWxsO1xuICAgIGxldCBvbkFib3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaWduYWwpIHtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuc2lnbmFsO1xuICAgICAgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSByZWplY3RpbmdTaWduYWxGdXR1cmUucmVqZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZWplY3RpbmdTaWduYWxGdXR1cmUsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICAgICAgYWN0aXZlU2lnbmFsID0gc2lnbmFsO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoYWN0aXZlU2lnbmFsICYmIG9uQWJvcnQpIHtcbiAgICAgICAgYWN0aXZlU2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hbCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHlpZWxkIFByb21pc2UucmFjZShbcmVhZGVyLnJlYWQoKSxcbiAgICAgICAgICAvLyBSZWplY3RzIGlmIHRoaXMuc2lnbmFsIGlzIGFib3J0ZWRcbiAgICAgICAgICByZWplY3RpbmdTaWduYWxGdXR1cmUucHJvbWlzZSxcbiAgICAgICAgICAvLyBSZWplY3RzIGlmIHNvbWV0aGluZyBleHRlcm5hbCBzYXlzIGl0IHNob3VsZCwgbGlrZSBhIHBhcnRpY2lwYW50IGRpc2Nvbm5lY3RpbmcsIGV0Y1xuICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMub3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgIC8qIG5ldmVyIHJlc29sdmVzICovXG4gICAgICAgICAgfSldKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUJ5dGVzUmVjZWl2ZWQodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNodW5rUmVjZWl2ZWQodmFsdWUpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRSZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZWNvZGVkUmVzdWx0ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUuY29udGVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IERhdGFTdHJlYW1FcnJvcihcIkNhbm5vdCBkZWNvZGUgZGF0YXN0cmVhbSBjaHVuayBcIi5jb25jYXQodmFsdWUuY2h1bmtJbmRleCwgXCIgYXMgdGV4dDogXCIpLmNvbmNhdChlcnIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRGVjb2RlRmFpbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogZGVjb2RlZFJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgLy8gbm90ZTogYHJldHVybmAgcnVucyBvbmx5IGZvciBwcmVtYXR1cmUgZXhpdHMsIHNlZTpcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMjZXJyb3JzX2R1cmluZ19pdGVyYXRpb25cbiAgICAgIHJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5qZWN0cyBhbiBBYm9ydFNpZ25hbCwgd2hpY2ggaWYgYWJvcnRlZCwgd2lsbCB0ZXJtaW5hdGUgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgICogc3RyZWFtIGl0ZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3aGVuIHVzaW5nIEFib3J0U2lnbmFsLnRpbWVvdXQoLi4uKSwgdGhlIHRpbWVvdXQgYXBwbGllcyBhY3Jvc3NcbiAgICogdGhlIHdob2xlIGl0ZXJhdGlvbiBvcGVyYXRpb24sIG5vdCBqdXN0IG9uZSBpbmRpdmlkdWFsIGNodW5rIHJlYWQuXG4gICAqL1xuICB3aXRoQWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVhZEFsbCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICBsZXQgZmluYWxTdHJpbmcgPSAnJztcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBvcHRzLnNpZ25hbCA/IF90aGlzMi53aXRoQWJvcnRTaWduYWwob3B0cy5zaWduYWwpIDogX3RoaXMyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmF0b3JfMiA9IF9fYXN5bmNWYWx1ZXMoaXRlcmF0b3IpLCBpdGVyYXRvcl8yXzE7IGl0ZXJhdG9yXzJfMSA9IHlpZWxkIGl0ZXJhdG9yXzIubmV4dCgpLCBfYSA9IGl0ZXJhdG9yXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2MgPSBpdGVyYXRvcl8yXzEudmFsdWU7XG4gICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgIGZpbmFsU3RyaW5nICs9IGNodW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgICBlcnJvcjogZV8yXzFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYXRvcl8yLnJldHVybikpIHlpZWxkIF9iLmNhbGwoaXRlcmF0b3JfMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsU3RyaW5nO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59Y2xhc3MgSW5jb21pbmdEYXRhU3RyZWFtTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRleHRTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSB0ZXh0IHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uSGFuZGxlckFscmVhZHlSZWdpc3RlcmVkKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSBieXRlIHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uSGFuZGxlckFscmVhZHlSZWdpc3RlcmVkKTtcbiAgICB9XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICBjbGVhckNvbnRyb2xsZXJzKCkge1xuICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuY2xlYXIoKTtcbiAgfVxuICB2YWxpZGF0ZVBhcnRpY2lwYW50SGFzTm9BY3RpdmVEYXRhU3RyZWFtcyhwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIC8vIFRlcm1pbmF0ZSBhbnkgaW4gZmxpZ2h0IGRhdGEgc3RyZWFtIHJlY2VpdmVzIGZyb20gdGhlIGdpdmVuIHBhcnRpY2lwYW50XG4gICAgY29uc3QgdGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZW50cmllcygpKS5maWx0ZXIoZW50cnkgPT4gZW50cnlbMV0uc2VuZGluZ1BhcnRpY2lwYW50SWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgIGNvbnN0IGJ5dGVTdHJlYW1zQmVpbmdTZW50QnlEaXNjb25uZWN0aW5nUGFydGljaXBhbnQgPSBBcnJheS5mcm9tKHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmVudHJpZXMoKSkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5WzFdLnNlbmRpbmdQYXJ0aWNpcGFudElkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICBpZiAodGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudC5sZW5ndGggPiAwIHx8IGJ5dGVTdHJlYW1zQmVpbmdTZW50QnlEaXNjb25uZWN0aW5nUGFydGljaXBhbnQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWJub3JtYWxFbmRFcnJvciA9IG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJQYXJ0aWNpcGFudCBcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSwgXCIgdW5leHBlY3RlZGx5IGRpc2Nvbm5lY3RlZCBpbiB0aGUgbWlkZGxlIG9mIHNlbmRpbmcgZGF0YVwiKSwgRGF0YVN0cmVhbUVycm9yUmVhc29uLkFibm9ybWFsRW5kKTtcbiAgICAgIGZvciAoY29uc3QgW2lkLCBjb250cm9sbGVyXSBvZiBieXRlU3RyZWFtc0JlaW5nU2VudEJ5RGlzY29ubmVjdGluZ1BhcnRpY2lwYW50KSB7XG4gICAgICAgIChfYiA9IChfYSA9IGNvbnRyb2xsZXIub3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSkucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgYWJub3JtYWxFbmRFcnJvcik7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpZCwgY29udHJvbGxlcl0gb2YgdGV4dFN0cmVhbXNCZWluZ1NlbnRCeURpc2Nvbm5lY3RpbmdQYXJ0aWNpcGFudCkge1xuICAgICAgICAoX2QgPSAoX2MgPSBjb250cm9sbGVyLm91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIGFibm9ybWFsRW5kRXJyb3IpO1xuICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVEYXRhU3RyZWFtUGFja2V0KHBhY2tldCwgZW5jcnlwdGlvblR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgc3dpdGNoIChwYWNrZXQudmFsdWUuY2FzZSkge1xuICAgICAgICBjYXNlICdzdHJlYW1IZWFkZXInOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUhlYWRlcihwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5LCBlbmNyeXB0aW9uVHlwZSk7XG4gICAgICAgIGNhc2UgJ3N0cmVhbUNodW5rJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DaHVuayhwYWNrZXQudmFsdWUudmFsdWUsIGVuY3J5cHRpb25UeXBlKTtcbiAgICAgICAgY2FzZSAnc3RyZWFtVHJhaWxlcic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtVHJhaWxlcihwYWNrZXQudmFsdWUudmFsdWUsIGVuY3J5cHRpb25UeXBlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhUGFja2V0IG9mIHZhbHVlIFxcXCJcIi5jb25jYXQocGFja2V0LnZhbHVlLmNhc2UsIFwiXFxcIiBpcyBub3QgZGF0YSBzdHJlYW0gcmVsYXRlZCFcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVN0cmVhbUhlYWRlcihzdHJlYW1IZWFkZXIsIHBhcnRpY2lwYW50SWRlbnRpdHksIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci5jYXNlID09PSAnYnl0ZUhlYWRlcicpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSGFuZGxlckNhbGxiYWNrID0gdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZ2V0KHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2lnbm9yaW5nIGluY29taW5nIGJ5dGUgc3RyZWFtIGR1ZSB0byBubyBoYW5kbGVyIGZvciB0b3BpYycsIHN0cmVhbUhlYWRlci50b3BpYyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBjb25zdCBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgICBvdXRPZkJhbmRGYWlsdXJlUmVqZWN0aW5nRnV0dXJlLnByb21pc2UuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICBpZDogc3RyZWFtSGVhZGVyLnN0cmVhbUlkLFxuICAgICAgICAgIG5hbWU6IChfYSA9IHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLnZhbHVlLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1bmtub3duJyxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudGltZXN0YW1wKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlcyxcbiAgICAgICAgICBlbmNyeXB0aW9uVHlwZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmhhcyhzdHJlYW1IZWFkZXIuc3RyZWFtSWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJBIGRhdGEgc3RyZWFtIHJlYWQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgYSBzdHJlYW0gd2l0aCBpZCBcIi5jb25jYXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCBcIi5cIiksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5BbHJlYWR5T3BlbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcbiAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBzZW5kaW5nUGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICAgICAgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKG5ldyBCeXRlU3RyZWFtUmVhZGVyKGluZm8sIHN0cmVhbSwgYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSwgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSksIHtcbiAgICAgICAgICBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIuY2FzZSA9PT0gJ3RleHRIZWFkZXInKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUhhbmRsZXJDYWxsYmFjayA9IHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmdldChzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICBpZiAoIXN0cmVhbUhhbmRsZXJDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdpZ25vcmluZyBpbmNvbWluZyB0ZXh0IHN0cmVhbSBkdWUgdG8gbm8gaGFuZGxlciBmb3IgdG9waWMnLCBzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICAgICAgb3V0T2ZCYW5kRmFpbHVyZVJlamVjdGluZ0Z1dHVyZS5wcm9taXNlLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXG4gICAgICAgICAgYXR0cmlidXRlczogc3RyZWFtSGVhZGVyLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgZW5jcnlwdGlvblR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5oYXMoc3RyZWFtSGVhZGVyLnN0cmVhbUlkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRGF0YVN0cmVhbUVycm9yKFwiQSBkYXRhIHN0cmVhbSByZWFkIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgZm9yIGEgc3RyZWFtIHdpdGggaWQgXCIuY29uY2F0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwgXCIuXCIpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uQWxyZWFkeU9wZW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5zZXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCB7XG4gICAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgc2VuZGluZ1BhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICAgICAgIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhuZXcgVGV4dFN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCksIG91dE9mQmFuZEZhaWx1cmVSZWplY3RpbmdGdXR1cmUpLCB7XG4gICAgICAgICAgaWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU3RyZWFtQ2h1bmsoY2h1bmssIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIGlmIChmaWxlQnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUgIT09IGVuY3J5cHRpb25UeXBlKSB7XG4gICAgICAgIGZpbGVCdWZmZXIuY29udHJvbGxlci5lcnJvcihuZXcgRGF0YVN0cmVhbUVycm9yKFwiRW5jcnlwdGlvbiB0eXBlIG1pc21hdGNoIGZvciBzdHJlYW0gXCIuY29uY2F0KGNodW5rLnN0cmVhbUlkLCBcIi4gRXhwZWN0ZWQgXCIpLmNvbmNhdChlbmNyeXB0aW9uVHlwZSwgXCIsIGdvdCBcIikuY29uY2F0KGZpbGVCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSksIERhdGFTdHJlYW1FcnJvclJlYXNvbi5FbmNyeXB0aW9uVHlwZU1pc21hdGNoKSk7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZShjaHVuay5zdHJlYW1JZCk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWxlQnVmZmVyLmNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHRCdWZmZXIgPSB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5nZXQoY2h1bmsuc3RyZWFtSWQpO1xuICAgIGlmICh0ZXh0QnVmZmVyKSB7XG4gICAgICBpZiAodGV4dEJ1ZmZlci5pbmZvLmVuY3J5cHRpb25UeXBlICE9PSBlbmNyeXB0aW9uVHlwZSkge1xuICAgICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuZXJyb3IobmV3IERhdGFTdHJlYW1FcnJvcihcIkVuY3J5cHRpb24gdHlwZSBtaXNtYXRjaCBmb3Igc3RyZWFtIFwiLmNvbmNhdChjaHVuay5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdCh0ZXh0QnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUoY2h1bmsuc3RyZWFtSWQpO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVTdHJlYW1UcmFpbGVyKHRyYWlsZXIsIGVuY3J5cHRpb25UeXBlKSB7XG4gICAgY29uc3QgdGV4dEJ1ZmZlciA9IHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICBpZiAodGV4dEJ1ZmZlcikge1xuICAgICAgaWYgKHRleHRCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSAhPT0gZW5jcnlwdGlvblR5cGUpIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVycm9yKG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJFbmNyeXB0aW9uIHR5cGUgbWlzbWF0Y2ggZm9yIHN0cmVhbSBcIi5jb25jYXQodHJhaWxlci5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdCh0ZXh0QnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICBpZiAoZmlsZUJ1ZmZlcikge1xuICAgICAgaWYgKGZpbGVCdWZmZXIuaW5mby5lbmNyeXB0aW9uVHlwZSAhPT0gZW5jcnlwdGlvblR5cGUpIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmVycm9yKG5ldyBEYXRhU3RyZWFtRXJyb3IoXCJFbmNyeXB0aW9uIHR5cGUgbWlzbWF0Y2ggZm9yIHN0cmVhbSBcIi5jb25jYXQodHJhaWxlci5zdHJlYW1JZCwgXCIuIEV4cGVjdGVkIFwiKS5jb25jYXQoZW5jcnlwdGlvblR5cGUsIFwiLCBnb3QgXCIpLmNvbmNhdChmaWxlQnVmZmVyLmluZm8uZW5jcnlwdGlvblR5cGUpLCBEYXRhU3RyZWFtRXJyb3JSZWFzb24uRW5jcnlwdGlvblR5cGVNaXNtYXRjaCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5kZWxldGUodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgfVxuICB9XG59Y2xhc3MgQmFzZVN0cmVhbVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKHdyaXRhYmxlU3RyZWFtLCBpbmZvLCBvbkNsb3NlKSB7XG4gICAgdGhpcy53cml0YWJsZVN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xuICAgIHRoaXMuZGVmYXVsdFdyaXRlciA9IHdyaXRhYmxlU3RyZWFtLmdldFdyaXRlcigpO1xuICAgIHRoaXMub25DbG9zZSA9IG9uQ2xvc2U7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuICB3cml0ZShjaHVuaykge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRXcml0ZXIud3JpdGUoY2h1bmspO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCB0aGlzLmRlZmF1bHRXcml0ZXIuY2xvc2UoKTtcbiAgICAgIHRoaXMuZGVmYXVsdFdyaXRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgKF9hID0gdGhpcy5vbkNsb3NlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVGV4dFN0cmVhbVdyaXRlciBleHRlbmRzIEJhc2VTdHJlYW1Xcml0ZXIge31cbmNsYXNzIEJ5dGVTdHJlYW1Xcml0ZXIgZXh0ZW5kcyBCYXNlU3RyZWFtV3JpdGVyIHt9Y29uc3QgU1RSRUFNX0NIVU5LX1NJWkUgPSAxNTAwMDtcbi8qKlxuICogTWFuYWdlcyBzZW5kaW5nIGN1c3RvbSB1c2VyIGRhdGEgdmlhIGRhdGEgY2hhbm5lbHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVuZ2luZSwgbG9nKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5sb2cgPSBsb2c7XG4gIH1cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gIH1cbiAgLyoqIHtAaW5oZXJpdERvYyBMb2NhbFBhcnRpY2lwYW50LnNlbmRUZXh0fSAqL1xuICBzZW5kVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHN0cmVhbUlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgIGNvbnN0IHRleHRJbkJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgICAgY29uc3QgdG90YWxUZXh0TGVuZ3RoID0gdGV4dEluQnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIGNvbnN0IGZpbGVJZHMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKCkgPT4gY3J5cHRvLnJhbmRvbVVVSUQoKSk7XG4gICAgICBjb25zdCBwcm9ncmVzc2VzID0gbmV3IEFycmF5KGZpbGVJZHMgPyBmaWxlSWRzLmxlbmd0aCArIDEgOiAxKS5maWxsKDApO1xuICAgICAgY29uc3QgaGFuZGxlUHJvZ3Jlc3MgPSAocHJvZ3Jlc3MsIGlkeCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHByb2dyZXNzZXNbaWR4XSA9IHByb2dyZXNzO1xuICAgICAgICBjb25zdCB0b3RhbFByb2dyZXNzID0gcHJvZ3Jlc3Nlcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25Qcm9ncmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdG90YWxQcm9ncmVzcyk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5zdHJlYW1UZXh0KHtcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHRvdGFsU2l6ZTogdG90YWxUZXh0TGVuZ3RoLFxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgIHRvcGljOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMsXG4gICAgICAgIGF0dGFjaGVkU3RyZWFtSWRzOiBmaWxlSWRzLFxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgICB5aWVsZCB3cml0ZXIud3JpdGUodGV4dCk7XG4gICAgICAvLyBzZXQgdGV4dCBwYXJ0IG9mIHByb2dyZXNzIHRvIDFcbiAgICAgIGhhbmRsZVByb2dyZXNzKDEsIDApO1xuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2htZW50cykgJiYgZmlsZUlkcykge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChvcHRpb25zLmF0dGFjaG1lbnRzLm1hcCgoZmlsZSwgaWR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRGaWxlKGZpbGVJZHNbaWR4XSwgZmlsZSwge1xuICAgICAgICAgICAgdG9waWM6IG9wdGlvbnMudG9waWMsXG4gICAgICAgICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgb25Qcm9ncmVzczogcHJvZ3Jlc3MgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVQcm9ncmVzcyhwcm9ncmVzcywgaWR4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyLmluZm87XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RyZWFtVGV4dChvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgdG9waWM6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICBlbmNyeXB0aW9uVHlwZTogKChfYyA9IHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaXNEYXRhQ2hhbm5lbEVuY3J5cHRpb25FbmFibGVkKSA/IEVuY3J5cHRpb25fVHlwZS5HQ00gOiBFbmNyeXB0aW9uX1R5cGUuTk9ORVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhU3RyZWFtX0hlYWRlcih7XG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcbiAgICAgICAgdG9waWM6IGluZm8udG9waWMsXG4gICAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoaW5mby50aW1lc3RhbXApLFxuICAgICAgICB0b3RhbExlbmd0aDogbnVtYmVyVG9CaWdJbnQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvdGFsU2l6ZSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGluZm8uYXR0cmlidXRlcyxcbiAgICAgICAgY29udGVudEhlYWRlcjoge1xuICAgICAgICAgIGNhc2U6ICd0ZXh0SGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fVGV4dEhlYWRlcih7XG4gICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICAgIGF0dGFjaGVkU3RyZWFtSWRzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNoZWRTdHJlYW1JZHMsXG4gICAgICAgICAgICByZXBseVRvU3RyZWFtSWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBseVRvU3RyZWFtSWQsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUpID09PSAndXBkYXRlJyA/IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5VUERBVEUgOiBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUuQ1JFQVRFXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3N0cmVhbUhlYWRlcicsXG4gICAgICAgICAgdmFsdWU6IGhlYWRlclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIGxldCBjaHVua0lkID0gMDtcbiAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuZW5naW5lO1xuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAvLyBJbXBsZW1lbnQgdGhlIHNpbmtcbiAgICAgICAgd3JpdGUodGV4dCkge1xuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRleHRCeXRlQ2h1bmsgb2Ygc3BsaXRVdGY4KHRleHQsIFNUUkVBTV9DSFVOS19TSVpFKSkge1xuICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBEYXRhU3RyZWFtX0NodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0Qnl0ZUNodW5rLFxuICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIGNodW5rSW5kZXg6IG51bWJlclRvQmlnSW50KGNodW5rSWQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB5aWVsZCBlbmdpbmUuc2VuZERhdGFQYWNrZXQoY2h1bmtQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICAgIGNodW5rSWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgRGF0YVN0cmVhbV9UcmFpbGVyKHtcbiAgICAgICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlclBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1UcmFpbGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhaWxlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldCh0cmFpbGVyUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhYm9ydChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2luayBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGFib3J0cyB0byBzaWduYWwgc29tZXRoaW5nIHRvIHJlY2VpdmVyIHNpZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgb25FbmdpbmVDbG9zZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIGVuZ2luZS5vbmNlKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpO1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFRleHRTdHJlYW1Xcml0ZXIod3JpdGFibGVTdHJlYW0sIGluZm8sICgpID0+IHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkVuZ2luZUNsb3NlKSk7XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0pO1xuICB9XG4gIHNlbmRGaWxlKGZpbGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgeWllbGQgdGhpcy5fc2VuZEZpbGUoc3RyZWFtSWQsIGZpbGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHN0cmVhbUlkXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIF9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbUJ5dGVzKHtcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHRvdGFsU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIG1pbWVUeXBlOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGUudHlwZSxcbiAgICAgICAgdG9waWM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYyxcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZG9uZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm4gd3JpdGVyLmluZm87XG4gICAgfSk7XG4gIH1cbiAgc3RyZWFtQnl0ZXMob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IHN0cmVhbUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0cmVhbUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgbWltZVR5cGU6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgIHRvcGljOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICBzaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplLFxuICAgICAgICBuYW1lOiAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJ3Vua25vd24nLFxuICAgICAgICBlbmNyeXB0aW9uVHlwZTogKChfZSA9IHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaXNEYXRhQ2hhbm5lbEVuY3J5cHRpb25FbmFibGVkKSA/IEVuY3J5cHRpb25fVHlwZS5HQ00gOiBFbmNyeXB0aW9uX1R5cGUuTk9ORVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhU3RyZWFtX0hlYWRlcih7XG4gICAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJUb0JpZ0ludCgoX2YgPSBpbmZvLnNpemUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDApLFxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHRvcGljOiBpbmZvLnRvcGljLFxuICAgICAgICB0aW1lc3RhbXA6IG51bWJlclRvQmlnSW50KERhdGUubm93KCkpLFxuICAgICAgICBhdHRyaWJ1dGVzOiBpbmZvLmF0dHJpYnV0ZXMsXG4gICAgICAgIGNvbnRlbnRIZWFkZXI6IHtcbiAgICAgICAgICBjYXNlOiAnYnl0ZUhlYWRlcicsXG4gICAgICAgICAgdmFsdWU6IG5ldyBEYXRhU3RyZWFtX0J5dGVIZWFkZXIoe1xuICAgICAgICAgICAgbmFtZTogaW5mby5uYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAnc3RyZWFtSGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogaGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgbGV0IGNodW5rSWQgPSAwO1xuICAgICAgY29uc3Qgd3JpdGVNdXRleCA9IG5ldyBfKCk7XG4gICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLmVuZ2luZTtcbiAgICAgIGNvbnN0IGxvZ0xvY2FsID0gdGhpcy5sb2c7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHdyaXRlTXV0ZXgubG9jaygpO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2hpbGUgKGJ5dGVPZmZzZXQgPCBjaHVuay5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQ2h1bmsgPSBjaHVuay5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgU1RSRUFNX0NIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbUNodW5rJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRhU3RyZWFtX0NodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzdWJDaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICAgICAgICBjaHVua0luZGV4OiBudW1iZXJUb0JpZ0ludChjaHVua0lkKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldChjaHVua1BhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgICAgICAgICAgICBjaHVua0lkICs9IDE7XG4gICAgICAgICAgICAgICAgYnl0ZU9mZnNldCArPSBzdWJDaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgRGF0YVN0cmVhbV9UcmFpbGVyKHtcbiAgICAgICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlclBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1UcmFpbGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhaWxlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldCh0cmFpbGVyUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhYm9ydChlcnIpIHtcbiAgICAgICAgICBsb2dMb2NhbC5lcnJvcignU2luayBlcnJvcjonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJ5dGVXcml0ZXIgPSBuZXcgQnl0ZVN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbyk7XG4gICAgICByZXR1cm4gYnl0ZVdyaXRlcjtcbiAgICB9KTtcbiAgfVxufWNsYXNzIFJlbW90ZVRyYWNrIGV4dGVuZHMgVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIGtpbmQsIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywga2luZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TWVkaWFTdHJlYW0oc3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICAgICAgICBpZiAodGhpcy5yZWNlaXZlciAmJiAncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZGlzYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5yZWNlaXZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c1JlcG9ydCA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRvIHNldCBhIHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIGZvciB0aGlzIHRyYWNrLlxuICAgKiBBIGhpZ2hlciB2YWx1ZSBhbGxvd3MgZm9yIG1vcmUgYnVmZmVyaW5nIG9mIHRoZSB0cmFjayBpbiB0aGUgYnJvd3NlclxuICAgKiBhbmQgd2lsbCByZXN1bHQgaW4gYSBkZWxheSBvZiBtZWRpYSBiZWluZyBwbGF5ZWQgYmFjayBvZiBgZGVsYXlJblNlY29uZHNgXG4gICAqL1xuICBzZXRQbGF5b3V0RGVsYXkoZGVsYXlJblNlY29uZHMpIHtcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IGRlbGF5SW5TZWNvbmRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3Qgc2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheW91dCBkZWxheSAoaW4gc2Vjb25kcykgb2YgdGhpcyB0cmFjay5cbiAgICovXG4gIGdldFBsYXlvdXREZWxheSgpIHtcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBnZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghdGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5tb25pdG9yUmVjZWl2ZXIoKSwgbW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSkge1xuICAgICAgdGhpcy5yZWdpc3RlclRpbWVTeW5jVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKSB7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMudGltZVN5bmNIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbG9vcCgpKTtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSAoX2EgPSB0aGlzLnJlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3luY2hyb25pemF0aW9uU291cmNlcygpWzBdO1xuICAgICAgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBydHBUaW1lc3RhbXBcbiAgICAgICAgfSA9IHNvdXJjZXM7XG4gICAgICAgIGlmIChydHBUaW1lc3RhbXAgJiYgdGhpcy5ydHBUaW1lc3RhbXAgIT09IHJ0cFRpbWVzdGFtcCkge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlRpbWVTeW5jVXBkYXRlLCB7XG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBydHBUaW1lc3RhbXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJ0cFRpbWVzdGFtcCA9IHJ0cFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbG9vcCgpO1xuICB9XG59Y2xhc3MgUmVtb3RlQXVkaW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYXVkaW9Db250ZXh0LCBhdWRpb091dHB1dCwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5BdWRpbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIGZvciBhbGwgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHNcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodm9sdW1lLCAwLCAwLjEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwudm9sdW1lID0gdm9sdW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLl9zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50Vm9sdW1lID0gdm9sdW1lO1xuICB9XG4gIC8qKlxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb2YgYXR0YWNoZWQgYXVkaW8gZWxlbWVudHMgKGxvdWRlc3QpXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQudm9sdW1lID4gaGlnaGVzdFZvbHVtZSkge1xuICAgICAgICBoaWdoZXN0Vm9sdW1lID0gZWxlbWVudC52b2x1bWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZ2hlc3RWb2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxzIHNldFNpbmtJZCBvbiBhbGwgYXR0YWNoZWQgZWxlbWVudHMsIGlmIHN1cHBvcnRlZFxuICAgKiBAcGFyYW0gZGV2aWNlSWQgYXVkaW8gb3V0cHV0IGRldmljZVxuICAgKi9cbiAgc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gZGV2aWNlSWQ7XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLmF0dGFjaGVkRWxlbWVudHMubWFwKGVsbSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIHJldHVybiBlbG0uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBhdHRhY2goZWxlbWVudCkge1xuICAgIGNvbnN0IG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ0ZhaWxlZCB0byBzZXQgc2luayBpZCBvbiByZW1vdGUgYXVkaW8gdHJhY2snLCBlLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbikge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGF1ZGlvIGNvbnRleHQgbWFwcGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnZvbHVtZSA9IDA7XG4gICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHZvbHVtZSBzZXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgdG8gdGhlIG5ld2x5IGF0dGFjaGVkIGVsZW1lbnRcbiAgICAgIHRoaXMuc2V0Vm9sdW1lKHRoaXMuZWxlbWVudFZvbHVtZSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgZGV0YWNoZWQgPSBzdXBlci5kZXRhY2goKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKGVsZW1lbnQpO1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIGFueSBhdHRhY2hlZCBlbGVtZW50cyBhZnRlciBkZXRhY2hpbmcsIGNvbm5lY3Qgd2ViYXVkaW8gdG8gdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCdzIGxlZnRcbiAgICAgIC8vIGRpc2Nvbm5lY3Qgd2ViYXVkaW8gb3RoZXJ3aXNlXG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGV0YWNoZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgaWYgKGF1ZGlvQ29udGV4dCAmJiB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8oYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgIH0gZWxzZSBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlW119IG5vZGVzIC0gQW4gYXJyYXkgb2YgV2ViQXVkaW8gbm9kZXMuIFRoZXNlIG5vZGVzIHNob3VsZCBub3QgYmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgd2hlbiBwYXNzZWQsIGFzIHRoZSBzZGsgd2lsbCB0YWtlIGNhcmUgb2YgY29ubmVjdGluZyB0aGVtIGluIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkuXG4gICAqL1xuICBzZXRXZWJBdWRpb1BsdWdpbnMobm9kZXMpIHtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBub2RlcztcbiAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgIH1cbiAgfVxuICBjb25uZWN0V2ViQXVkaW8oY29udGV4dCwgZWxlbWVudCkge1xuICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgLy8gQHRzLWlnbm9yZSBhdHRhY2hlZCBlbGVtZW50cyBhbHdheXMgaGF2ZSBhIHNyY09iamVjdCBzZXRcbiAgICB0aGlzLnNvdXJjZU5vZGUgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGVsZW1lbnQuc3JjT2JqZWN0KTtcbiAgICBsZXQgbGFzdE5vZGUgPSB0aGlzLnNvdXJjZU5vZGU7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBsYXN0Tm9kZS5jb25uZWN0KG5vZGUpO1xuICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICBsYXN0Tm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICB0aGlzLmdhaW5Ob2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHRoaXMuZWxlbWVudFZvbHVtZSwgMCwgMC4xKTtcbiAgICB9XG4gICAgLy8gdHJ5IHRvIHJlc3VtZSB0aGUgY29udGV4dCBpZiBpdCBpc24ndCBydW5uaW5nIGFscmVhZHlcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XG4gICAgICBjb250ZXh0LnJlc3VtZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgbmV3IEVycm9yKFwiQXVkaW8gQ29udGV4dCBjb3VsZG4ndCBiZSBzdGFydGVkIGF1dG9tYXRpY2FsbHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdFdlYkF1ZGlvKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gdGhpcy5nYWluTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAoX2IgPSB0aGlzLnNvdXJjZU5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5nYWluTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNvdXJjZU5vZGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyIHx8ICF0aGlzLnJlY2VpdmVyLmdldFN0YXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgY29uY2VhbGVkU2FtcGxlczogdi5jb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgICBzaWxlbnRDb25jZWFsZWRTYW1wbGVzOiB2LnNpbGVudENvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICBzaWxlbnRDb25jZWFsbWVudEV2ZW50czogdi5zaWxlbnRDb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcbiAgICAgICAgICAgIHRvdGFsU2FtcGxlc0R1cmF0aW9uOiB2LnRvdGFsU2FtcGxlc0R1cmF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgICB9KTtcbiAgfVxufWNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuY2xhc3MgUmVtb3RlVmlkZW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5WaWRlbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gW107XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSA9IHIoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gIH1cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIHNldFN0cmVhbVN0YXRlKHZhbHVlKSB7XG4gICAgc3VwZXIuc2V0U3RyZWFtU3RhdGUodmFsdWUpO1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZXRTdHJlYW1TdGF0ZScsIHZhbHVlKTtcbiAgICBpZiAodGhpcy5pc0FkYXB0aXZlU3RyZWFtICYmIHZhbHVlID09PSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSB2aXNpYmlsaXR5IGZvciBhZGFwdGl2ZSBzdHJlYW0gdHJhY2tzIHdoZW4gc3RyZWFtIHN0YXRlIHJlY2VpdmVkIGZyb20gc2VydmVyIGlzIGFjdGl2ZVxuICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZW5zdXJlIHRoZSB0cmFjayBpcyBzdG9wcGVkIHdoZW4gdGhlcmUncyBubyBlbGVtZW50IGF0dGFjaGVkIHRvIGl0IGF0IGFsbFxuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIGFkYXB0aXZlU3RyZWFtLCB5b3UgbmVlZCB0byB1c2UgcmVtb3RlVmlkZW9UcmFjay5hdHRhY2goKSB0byBhZGQgdGhlIHRyYWNrIHRvIGEgSFRNTFZpZGVvRWxlbWVudCwgb3RoZXJ3aXNlIHlvdXIgdmlkZW8gdHJhY2tzIG1pZ2h0IG5ldmVyIHN0YXJ0XG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gSXQncyBwb3NzaWJsZSBhdHRhY2ggaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGFuIGVsZW1lbnQuIFdoZW4gdGhhdCdzXG4gICAgLy8gdGhlIGNhc2UsIHdlJ2Qgd2FudCB0byBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIGVsZW1lbnRJbmZvc1xuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XG4gICAgICBlbGVtZW50SW5mby5vYnNlcnZlKCk7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3Zpc2liaWxpdHkgcmVzaXplIG9ic2VydmVyIG5vdCB0cmlnZ2VyZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCBvYnNlcnZpbmcgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8gaWdub3JlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbyk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIGluZm8uc3RvcE9ic2VydmluZygpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGRldGFjaGVkRWxlbWVudHMgPSBzdXBlci5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXREZWNvZGVySW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29kZXJJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIGxldCBjb2RlY0lEID0gJyc7XG4gICAgICBsZXQgY29kZWNzID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIGZyYW1lc0RlY29kZWQ6IHYuZnJhbWVzRGVjb2RlZCxcbiAgICAgICAgICAgIGZyYW1lc0Ryb3BwZWQ6IHYuZnJhbWVzRHJvcHBlZCxcbiAgICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxuICAgICAgICAgICAgcGFja2V0c1JlY2VpdmVkOiB2LnBhY2tldHNSZWNlaXZlZCxcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxuICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgZGVjb2RlckltcGxlbWVudGF0aW9uOiB2LmRlY29kZXJJbXBsZW1lbnRhdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSAnY29kZWMnKSB7XG4gICAgICAgICAgY29kZWNzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjZWl2ZXJTdGF0cyAmJiBjb2RlY0lEICE9PSAnJyAmJiBjb2RlY3MuZ2V0KGNvZGVjSUQpKSB7XG4gICAgICAgIHJlY2VpdmVyU3RhdHMubWltZVR5cGUgPSBjb2RlY3MuZ2V0KGNvZGVjSUQpLm1pbWVUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgfSk7XG4gIH1cbiAgc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHJldHVybjtcbiAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVZpc2liaWxpdHkoZm9yY2VFbWl0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBsYXN0VmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuZWxlbWVudEluZm9zLnJlZHVjZSgocHJldiwgaW5mbykgPT4gTWF0aC5tYXgocHJldiwgaW5mby52aXNpYmlsaXR5Q2hhbmdlZEF0IHx8IDApLCAwKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kUGF1c2UgPSAoKF9iID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VWaWRlb0luQmFja2dyb3VuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWVcbiAgICApID8gdGhpcy5pc0luQmFja2dyb3VuZCA6IGZhbHNlO1xuICAgIGNvbnN0IGlzUGlQTW9kZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoaW5mbyA9PiBpbmZvLnBpY3R1cmVJblBpY3R1cmUpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoaW5mbyA9PiBpbmZvLnZpc2libGUpICYmICFiYWNrZ3JvdW5kUGF1c2UgfHwgaXNQaVBNb2RlO1xuICAgIGlmICh0aGlzLmxhc3RWaXNpYmxlID09PSBpc1Zpc2libGUgJiYgIWZvcmNlRW1pdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVmlzaWJsZSAmJiBEYXRlLm5vdygpIC0gbGFzdFZpc2liaWxpdHlDaGFuZ2UgPCBSRUFDVElPTl9ERUxBWSkge1xuICAgICAgLy8gZGVsYXkgaGlkZGVuIGV2ZW50c1xuICAgICAgQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCBpc1Zpc2libGUsIHRoaXMpO1xuICB9XG4gIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxEZW5zaXR5KCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHRoaXMuZWxlbWVudEluZm9zKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudFdpZHRoID0gaW5mby53aWR0aCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRIZWlnaHQgPSBpbmZvLmhlaWdodCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50V2lkdGggKyBjdXJyZW50RWxlbWVudEhlaWdodCA+IG1heFdpZHRoICsgbWF4SGVpZ2h0KSB7XG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudEVsZW1lbnRXaWR0aDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudEVsZW1lbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gbWF4V2lkdGggJiYgKChfYiA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBtYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcbiAgfVxuICBnZXRQaXhlbERlbnNpdHkoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBpeGVsRGVuc2l0eTtcbiAgICBpZiAocGl4ZWxEZW5zaXR5ID09PSAnc2NyZWVuJykge1xuICAgICAgcmV0dXJuIGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB9IGVsc2UgaWYgKCFwaXhlbERlbnNpdHkpIHtcbiAgICAgIC8vIHdoZW4gdW5zZXQsIHdlJ2xsIHBpY2sgYSBzYW5lIGRlZmF1bHQgaGVyZS5cbiAgICAgIC8vIGZvciBoaWdoZXIgcGl4ZWwgZGVuc2l0eSBkZXZpY2VzIChtb2JpbGUgcGhvbmVzLCBldGMpLCB3ZSdsbCB1c2UgMlxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGRlZmF1bHRzIHRvIDFcbiAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyA+IDIpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpeGVsRGVuc2l0eTtcbiAgfVxufVxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIHtcbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaVAgfHwgdGhpcy5pc0ludGVyc2VjdGluZztcbiAgfVxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUDtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB2aXNpYmxlKSB7XG4gICAgdGhpcy5vblZpc2liaWxpdHlDaGFuZ2VkID0gZW50cnkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gZW50cnk7XG4gICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uRW50ZXJQaVAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIChfYiA9IChfYSA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aW5kb3cpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgIChfYyA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5vbkxlYXZlUGlQID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IHZpc2libGUgIT09IG51bGwgJiYgdmlzaWJsZSAhPT0gdm9pZCAwID8gdmlzaWJsZSA6IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgaXNFbGVtZW50SW5QaVAoZWxlbWVudCk7XG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gMDtcbiAgfVxuICB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoO1xuICB9XG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIGN1cnJlbnQgdmlzaWJsZSBzdGF0ZSBvbmNlIHdlIHN0YXJ0IHRvIG9ic2VydmVcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNFbGVtZW50SW5WaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVJlc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XG4gICAgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgZ2V0UmVzaXplT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gICAgKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICAoX2MgPSAoX2IgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2luZG93KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICB9XG4gIHN0b3BPYnNlcnZpbmcoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAoX2EgPSBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgKF9iID0gZ2V0UmVzaXplT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uRW50ZXJQaVApO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgIChfYyA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XG4gICAgKF9lID0gKF9kID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpbmRvdykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNFbGVtZW50SW5QaVAoZWwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgLy8gU2ltcGxlIHZpZGVvIFBpUFxuICBpZiAoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgLy8gRG9jdW1lbnQgUGlQXG4gIGlmICgoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2luZG93KSByZXR1cm4gaXNFbGVtZW50SW5WaWV3cG9ydChlbCwgKF9iID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpbmRvdyk7XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIGRvZXMgbm90IGFjY291bnQgZm9yIG9jY2x1c2lvbiBieSBvdGhlciBlbGVtZW50cyBvciBvcGFjaXR5IHByb3BlcnR5XG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCB3aW4pIHtcbiAgY29uc3Qgdmlld3BvcnRXaW5kb3cgPSB3aW4gfHwgd2luZG93O1xuICBsZXQgdG9wID0gZWwub2Zmc2V0VG9wO1xuICBsZXQgbGVmdCA9IGVsLm9mZnNldExlZnQ7XG4gIGNvbnN0IHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgY29uc3Qge1xuICAgIGhpZGRlblxuICB9ID0gZWw7XG4gIGNvbnN0IHtcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgd2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuICB9XG4gIHJldHVybiB0b3AgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWU9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVySGVpZ2h0ICYmIGxlZnQgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWE9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVyV2lkdGggJiYgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgJiYgbGVmdCArIHdpZHRoID4gdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgJiYgIWhpZGRlbiAmJiBkaXNwbGF5ICE9PSAnbm9uZSc7XG59Y2xhc3MgVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioa2luZCwgaWQsIG5hbWUsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5oYW5kbGVNdXRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVW5tdXRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBsb2dnZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlB1YmxpY2F0aW9uKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IHRoaXMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnRyYWNrU2lkID0gaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICB9XG4gICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgLy8gZm9yd2FyZCBldmVudHNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XG4gIH1cbiAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtBdWRpb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGFuIGF1ZGlvIHRyYWNrXG4gICAqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICBpZiAoaXNBdWRpb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcbiAgICovXG4gIGdldCB2aWRlb1RyYWNrKCkge1xuICAgIGlmIChpc1ZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHRoaXMudHJhY2tTaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IGluZm8ubmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLnNvdXJjZUZyb21Qcm90byhpbmZvLnNvdXJjZSk7XG4gICAgdGhpcy5taW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBpbmZvLndpZHRoID4gMCkge1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogaW5mby53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbmZvLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2ltdWxjYXN0ZWQgPSBpbmZvLnNpbXVsY2FzdDtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uID0gaW5mby5lbmNyeXB0aW9uO1xuICAgIHRoaXMudHJhY2tJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRlIHB1YmxpY2F0aW9uIGluZm8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGluZm9cbiAgICB9KSk7XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2tQdWJsaWNhdGlvbikge1xuICAoZnVuY3Rpb24gKFN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIkRlc2lyZWRcIl0gPSBcImRlc2lyZWRcIjtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiVW5zdWJzY3JpYmVkXCJdID0gXCJ1bnN1YnNjcmliZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzID0ge30pKTtcbiAgKGZ1bmN0aW9uIChQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIkFsbG93ZWRcIl0gPSBcImFsbG93ZWRcIjtcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiTm90QWxsb3dlZFwiXSA9IFwibm90X2FsbG93ZWRcIjtcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgPSB7fSkpO1xufSkoVHJhY2tQdWJsaWNhdGlvbiB8fCAoVHJhY2tQdWJsaWNhdGlvbiA9IHt9KSk7Y2xhc3MgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBzdHJlYW1QYXVzZWQ7XG4gIH1cbiAgY29uc3RydWN0b3Ioa2luZCwgdGksIHRyYWNrLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnRyYWNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ3B1Q29uc3RyYWluZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50cmFjayAmJiBpc1ZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQ3B1Q29uc3RyYWluZWQsIHRoaXMudHJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgICB0aGlzLnNldFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5DcHVDb25zdHJhaW5lZCwgdGhpcy5oYW5kbGVDcHVDb25zdHJhaW5lZCk7XG4gICAgfVxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkNwdUNvbnN0cmFpbmVkLCB0aGlzLmhhbmRsZUNwdUNvbnN0cmFpbmVkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrLmlzTXV0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc011dGVkO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrO1xuICB9XG4gIGdldCB2aWRlb1RyYWNrKCkge1xuICAgIHJldHVybiBzdXBlci52aWRlb1RyYWNrO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBNdXRlIHRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgbXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tdXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgdW5tdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubXV0ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgKiBhbmQgc2lnbmFscyBcIm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwYXVzZSB0aGUgc3RyZWFtIHdpdGhvdXQgcGF1c2luZyB0aGUgbG9jYWwgbWVkaWEgc3RyZWFtIHRyYWNrXG4gICAqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIHNlbmRpbmcgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiB0byB0aGUgc2VydmVyIGFmdGVyIGEgY2FsbCB0byBbW3BhdXNlVXBzdHJlYW0oKV1dXG4gICAqIGFuZCBzaWduYWxzIFwidW5tdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50cyAodW5sZXNzIHRoZSB0cmFjayBpcyBleHBsaWNpdGx5IG11dGVkKVxuICAgKi9cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIGdldFRyYWNrRmVhdHVyZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy50cmFjay5nZXRTb3VyY2VUcmFja1NldHRpbmdzKCk7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGlmIChzZXR0aW5ncy5hdXRvR2FpbkNvbnRyb2wpIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0FVVE9fR0FJTl9DT05UUk9MKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5lY2hvQ2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9FQ0hPX0NBTkNFTExBVElPTik7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3Mubm9pc2VTdXBwcmVzc2lvbikge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9JU0VfU1VQUFJFU1NJT04pO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLmNoYW5uZWxDb3VudCAmJiBzZXR0aW5ncy5jaGFubmVsQ291bnQgPiAxKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9TVEVSRU8pO1xuICAgICAgfVxuICAgICAgaWYgKCEoKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHR4KSkge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9fRFRYKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYWNrLmVuaGFuY2VkTm9pc2VDYW5jZWxsYXRpb24pIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTik7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShmZWF0dXJlcy52YWx1ZXMoKSk7XG4gICAgfSBlbHNlIHJldHVybiBbXTtcbiAgfVxufS8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXG4gKiB0aGUgdXNlciBpbnN0ZWFkIG9mIHR3byBzZXBhcmF0ZSBvbmVzLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucywgbG9nZ2VyT3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgYXR0ZW1wdEV4YWN0TWF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1Byb2Nlc3NvcixcbiAgICAgIHZpZGVvUHJvY2Vzc29yLFxuICAgICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGludGVybmFsT3B0aW9uc1xuICAgIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgIGxldCByZXRyeUF1ZGlvT3B0aW9ucyA9IGludGVybmFsT3B0aW9ucy5hdWRpbztcbiAgICBsZXQgcmV0cnlWaWRlb09wdGlvbnMgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW87XG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8ucHJvY2Vzc29yID0gYXVkaW9Qcm9jZXNzb3I7XG4gICAgfVxuICAgIGlmICh2aWRlb1Byb2Nlc3NvciAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLnByb2Nlc3NvciA9IHZpZGVvUHJvY2Vzc29yO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgdXNlciBwYXNzZXMgYSBkZXZpY2UgaWQgYXMgYSBzdHJpbmcsIHdlIGRlZmF1bHQgdG8gZXhhY3QgbWF0Y2hcbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGV2aWNlSWQgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQ7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPSB7XG4gICAgICAgIGV4YWN0OiBkZXZpY2VJZFxuICAgICAgfTtcbiAgICAgIGF0dGVtcHRFeGFjdE1hdGNoID0gdHJ1ZTtcbiAgICAgIHJldHJ5QXVkaW9PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbE9wdGlvbnMuYXVkaW8pLCB7XG4gICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgaWRlYWw6IGRldmljZUlkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkZXZpY2VJZCA9IGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZDtcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCA9IHtcbiAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICB9O1xuICAgICAgYXR0ZW1wdEV4YWN0TWF0Y2ggPSB0cnVlO1xuICAgICAgcmV0cnlWaWRlb09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsT3B0aW9ucy52aWRlbyksIHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogZGV2aWNlSWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09IHRydWUpIHtcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpbyA9IHtcbiAgICAgICAgZGV2aWNlSWQ6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIGludGVybmFsT3B0aW9ucy5hdWRpbyAhPT0gbnVsbCkge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbE9wdGlvbnMuYXVkaW8pLCB7XG4gICAgICAgIGRldmljZUlkOiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgfHwgJ2RlZmF1bHQnXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvID0ge1xuICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgIWludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCkge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhpbnRlcm5hbE9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHByb21pc2Ugb24gRGV2aWNlTWFuYWdlciBhbmQgYXdhaXQgaXQgaW4gZ2V0TG9jYWxEZXZpY2VzKClcbiAgICAvLyB3b3JrcyBhcm91bmQgaU9TIFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgIGNvbnN0IG1lZGlhUHJvbWlzZSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLmF1ZGlvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCdhdWRpb2lucHV0JykpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCd2aWRlb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbWVkaWFQcm9taXNlO1xuICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICAgIGxldCB0cmFja09wdGlvbnMgPSBpc0F1ZGlvID8gb3B0cy5hdWRpbyA6IG9wdHMudmlkZW87XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgICAgIHRyYWNrT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjb25zdHJhaW50cyB3aXRoIHRoZSBkZXZpY2UgaWQgdGhlIHVzZXIgZ2F2ZSBwZXJtaXNzaW9ucyB0byBpbiB0aGUgcGVybWlzc2lvbiBwcm9tcHRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggdHJhY2sgcmVzdGFydCAoZS5nLiBtdXRlIC0gdW5tdXRlKSB3aWxsIHRyeSB0byBpbml0aWFsaXplIHRoZSBkZXZpY2UgYWdhaW4gLT4gY2F1c2luZyBhZGRpdGlvbmFsIHBlcm1pc3Npb24gcHJvbXB0c1xuICAgICAgICBjb25zdCBuZXdEZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICAgICAgaWYgKCh0cmFja0NvbnN0cmFpbnRzID09PSBudWxsIHx8IHRyYWNrQ29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrQ29uc3RyYWludHMuZGV2aWNlSWQpICYmIHVud3JhcENvbnN0cmFpbnQodHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgIT09IG5ld0RldmljZUlkKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG5ld0RldmljZUlkO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmFja0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgIGRldmljZUlkOiBuZXdEZXZpY2VJZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSAmJiBhdWRpb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnNldFByb2Nlc3NvcihhdWRpb1Byb2Nlc3Nvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSAmJiB2aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnNldFByb2Nlc3Nvcih2aWRlb1Byb2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWF0dGVtcHRFeGFjdE1hdGNoKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFja3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBhdWRpbzogcmV0cnlBdWRpb09wdGlvbnMsXG4gICAgICAgIHZpZGVvOiByZXRyeVZpZGVvT3B0aW9uc1xuICAgICAgfSksIGxvZ2dlck9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgdmlkZW86IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tzWzBdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgICAgYXVkaW86IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHRydWUsXG4gICAgICB2aWRlbzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tzWzBdO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxuICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyhvcHRpb25zKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTdCYXNlZCgpKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFRyYWNrcztcbiAgfSk7XG59dmFyIENvbm5lY3Rpb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uUXVhbGl0eSkge1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkV4Y2VsbGVudFwiXSA9IFwiZXhjZWxsZW50XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiR29vZFwiXSA9IFwiZ29vZFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlBvb3JcIl0gPSBcInBvb3JcIjtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGEgcGFydGljaXBhbnQgaGFzIHRlbXBvcmFyaWx5IChvciBwZXJtYW5lbnRseSkgbG9zdCBjb25uZWN0aW9uIHRvIExpdmVLaXQuXG4gICAqIEZvciBwZXJtYW5lbnQgZGlzY29ubmVjdGlvbiBhIGBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIGFmdGVyIGEgdGltZW91dFxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJMb3N0XCJdID0gXCJsb3N0XCI7XG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xufSkoQ29ubmVjdGlvblF1YWxpdHkgfHwgKENvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcbmZ1bmN0aW9uIHF1YWxpdHlGcm9tUHJvdG8ocSkge1xuICBzd2l0Y2ggKHEpIHtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuRVhDRUxMRU5UOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuR09PRDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Hb29kO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5QT09SOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlBvb3I7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkxPU1Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gIH1cbn1cbmNsYXNzIFBhcnRpY2lwYW50IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gIH1cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLnNpemUgPiAwICYmIEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZXZlcnkodHIgPT4gdHIuaXNFbmNyeXB0ZWQpO1xuICB9XG4gIGdldCBpc0FnZW50KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2VudCkgfHwgdGhpcy5raW5kID09PSBQYXJ0aWNpcGFudEluZm9fS2luZC5BR0VOVDtcbiAgfVxuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5wYXJ0aWNpcGFudEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkU7XG4gIH1cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tpbmQ7XG4gIH1cbiAgLyoqIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMsIHNpbWlsYXIgdG8gbWV0YWRhdGEsIGJ1dCBhcyBhIGtleS92YWx1ZSBtYXAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYXR0cmlidXRlcykpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXG4gICAgdGhpcy5hdWRpb0xldmVsID0gMDtcbiAgICAvKiogaWYgcGFydGljaXBhbnQgaXMgY3VycmVudGx5IHNwZWFraW5nICovXG4gICAgdGhpcy5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUGFydGljaXBhbnQpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzICE9PSBudWxsICYmIGF0dHJpYnV0ZXMgIT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgc291cmNlIGZpbHRlciwgZm9yIGV4YW1wbGUsIGdldHRpbmdcbiAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xuICAgICAgaWYgKHB1Yi5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgdHJhY2sncyBuYW1lLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMpIHtcbiAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlIGFuZCByZWFkeSB0byByZWNlaXZlIGRhdGEgbWVzc2FnZXNcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlXG4gICAqL1xuICB3YWl0VW50aWxBY3RpdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlRnV0dXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVGdXR1cmUucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgdGhpcy5vbmNlKFBhcnRpY2lwYW50RXZlbnQuQWN0aXZlLCAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5hY3RpdmVGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICB0aGlzLmFjdGl2ZUZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGdXR1cmUucHJvbWlzZTtcbiAgfVxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICB9XG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNNaWNyb3Bob25lRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgfVxuICBnZXQgaXNTY3JlZW5TaGFyZUVuYWJsZWQoKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gIGdldCBqb2luZWRBdCgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy5wYXJ0aWNpcGFudEluZm8uam9pbmVkQXQudG9TdHJpbmcoKSkgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgdXBkYXRlIGNvdWxkIGJlIGFwcGxpZWQgb3V0IG9mIG9yZGVyIGR1ZSB0byBhd2FpdFxuICAgIC8vIGR1cmluZyByZWNvbm5lY3Qgc2VxdWVuY2VzLiB3aGVuIHRoYXQgaGFwcGVucywgaXQncyBwb3NzaWJsZSBmb3Igc2VydmVyXG4gICAgLy8gdG8gaGF2ZSBzZW50IG1vcmUgcmVjZW50IHZlcnNpb24gb2YgcGFydGljaXBhbnQgaW5mbyB3aGlsZSBKUyBpcyB3YWl0aW5nXG4gICAgLy8gdG8gcHJvY2VzcyB0aGUgZXhpc3RpbmcgcGF5bG9hZC5cbiAgICAvLyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBzaWQgcmVtYWlucyB0aGUgc2FtZSwgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIGxhdGVyIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgcGF5bG9hZCwgdGhleSBjYW4gYmUgc2FmZWx5IHNraXBwZWRcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8gJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8uc2lkID09PSBpbmZvLnNpZCAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby52ZXJzaW9uID4gaW5mby52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaWRlbnRpdHkgPSBpbmZvLmlkZW50aXR5O1xuICAgIHRoaXMuc2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy5fc2V0TmFtZShpbmZvLm5hbWUpO1xuICAgIHRoaXMuX3NldE1ldGFkYXRhKGluZm8ubWV0YWRhdGEpO1xuICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoaW5mby5hdHRyaWJ1dGVzKTtcbiAgICBpZiAoaW5mby5zdGF0ZSA9PT0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSAmJiAoKF9hID0gdGhpcy5wYXJ0aWNpcGFudEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkUpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkFjdGl2ZSk7XG4gICAgfVxuICAgIGlmIChpbmZvLnBlcm1pc3Npb24pIHtcbiAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMoaW5mby5wZXJtaXNzaW9uKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoaXMgbGFzdCBzbyBzZXRNZXRhZGF0YSBjYW4gZGV0ZWN0IGNoYW5nZXNcbiAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyA9IGluZm87XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0TWV0YWRhdGEobWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5tZXRhZGF0YSAhPT0gbWQ7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBwcmV2TWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBfc2V0TmFtZShuYW1lKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubmFtZSAhPT0gbmFtZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgZGlmZiA9IGRpZmZBdHRyaWJ1dGVzKHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgaWYgKE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBkaWZmKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHBlcm1pc3Npb25zLmNhblB1Ymxpc2ggIT09ICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUHVibGlzaCkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSAoKF9iID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhblN1YnNjcmliZSkgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaERhdGEgIT09ICgoX2MgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FuUHVibGlzaERhdGEpIHx8IHBlcm1pc3Npb25zLmhpZGRlbiAhPT0gKChfZCA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaWRkZW4pIHx8IHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSAoKF9lID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlY29yZGVyKSB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5sZW5ndGggIT09IHRoaXMucGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSk7XG4gICAgfSkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlTWV0cmljcyAhPT0gKChfZiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYW5TdWJzY3JpYmVNZXRyaWNzKTtcbiAgICB0aGlzLnBlcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldElzU3BlYWtpbmcoc3BlYWtpbmcpIHtcbiAgICBpZiAoc3BlYWtpbmcgPT09IHRoaXMuaXNTcGVha2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBzcGVha2luZztcbiAgICBpZiAoc3BlYWtpbmcpIHtcbiAgICAgIHRoaXMubGFzdFNwb2tlQXQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Jc1NwZWFraW5nQ2hhbmdlZCwgc3BlYWtpbmcpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0Q29ubmVjdGlvblF1YWxpdHkocSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREaXNjb25uZWN0ZWQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGhpcy5hY3RpdmVGdXR1cmUpIHtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMuYWN0aXZlRnV0dXJlKS5yZWplY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXcgRXJyb3IoJ1BhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZCcpKTtcbiAgICAgIHRoaXMuYWN0aXZlRnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoY3R4KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBjdHg7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHJhY2sgPT4gaXNBdWRpb1RyYWNrKHRyYWNrLnRyYWNrKSAmJiB0cmFjay50cmFjay5zZXRBdWRpb0NvbnRleHQoY3R4KSk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuTXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVubXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1mdW5jdGlvbiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHBlcm1zKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBpZiAoIXBlcm1zLnBhcnRpY2lwYW50U2lkICYmICFwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYWNrIHBlcm1pc3Npb24sIG11c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgcGFydGljaXBhbnRJZGVudGl0eSBhbmQgcGFydGljaXBhbnRTaWQnKTtcbiAgfVxuICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbih7XG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogKF9hID0gcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgcGFydGljaXBhbnRTaWQ6IChfYiA9IHBlcm1zLnBhcnRpY2lwYW50U2lkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICBhbGxUcmFja3M6IChfYyA9IHBlcm1zLmFsbG93QWxsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSxcbiAgICB0cmFja1NpZHM6IHBlcm1zLmFsbG93ZWRUcmFja1NpZHMgfHwgW11cbiAgfSk7XG59Y2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBlbmdpbmUsIG9wdGlvbnMsIHJvb21ScGNIYW5kbGVycywgcm9vbU91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMuZW5naW5lLmxvZ0NvbnRleHRcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gdHJ1ZTtcbiAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gW107XG4gICAgdGhpcy5wZW5kaW5nQWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNsb3NpbmcgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZS5wcm9taXNlLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlamVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcignR290IGRpc2Nvbm5lY3RlZCBkdXJpbmcgcmVjb25uZWN0aW9uIGF0dGVtcHQnKSk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKSB7XG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKS5yZWplY3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBuZXcgRXJyb3IoJ0dvdCBkaXNjb25uZWN0ZWQgd2l0aG91dCBzaWduYWwgY29ubmVjdGVkJykpO1xuICAgICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIChfZiA9IChfZSA9IHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWplY3QpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lLCBuZXcgRXJyb3IoJ0dvdCBkaXNjb25uZWN0ZWQgd2l0aG91dCBhY3RpdmUgYWdlbnQgcHJlc2VudCcpKTtcbiAgICAgIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNpZ25hbENvbm5lY3RlZCA9IGpvaW5SZXNwb25zZSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm8oam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgICB9XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBtZXNzYWdlXG4gICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICBjb25zdCB0YXJnZXRSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICBpZiAodGFyZ2V0UmVxdWVzdCkge1xuICAgICAgICBpZiAocmVhc29uICE9PSBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uLk9LKSB7XG4gICAgICAgICAgdGFyZ2V0UmVxdWVzdC5yZWplY3QobmV3IFNpZ25hbFJlcXVlc3RFcnJvcihtZXNzYWdlLCByZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YVBhY2tldCA9IHBhY2tldCA9PiB7XG4gICAgICBzd2l0Y2ggKHBhY2tldC52YWx1ZS5jYXNlKSB7XG4gICAgICAgIGNhc2UgJ3JwY1Jlc3BvbnNlJzpcbiAgICAgICAgICBsZXQgcnBjUmVzcG9uc2UgPSBwYWNrZXQudmFsdWUudmFsdWU7XG4gICAgICAgICAgbGV0IHBheWxvYWQgPSBudWxsO1xuICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgaWYgKHJwY1Jlc3BvbnNlLnZhbHVlLmNhc2UgPT09ICdwYXlsb2FkJykge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHJwY1Jlc3BvbnNlLnZhbHVlLnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnBjUmVzcG9uc2UudmFsdWUuY2FzZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgZXJyb3IgPSBScGNFcnJvci5mcm9tUHJvdG8ocnBjUmVzcG9uc2UudmFsdWUudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVzcG9uc2UocnBjUmVzcG9uc2UucmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JwY0Fjayc6XG4gICAgICAgICAgbGV0IHJwY0FjayA9IHBhY2tldC52YWx1ZS52YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjQWNrKHJwY0Fjay5yZXF1ZXN0SWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHRyYWNrIHN1YnNjcmlwdGlvbiBwZXJtaXNzaW9ucycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkOiB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyh0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSwgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMubWFwKHAgPT4gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwKSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMub25UcmFja1VubXV0ZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNVcHN0cmVhbVBhdXNlZCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHRoZSBsb2NhbCB0cmFjayBjaGFuZ2VzIGluIG11dGUgc3RhdHVzLCB3ZSdsbCBub3RpZnkgc2VydmVyIGFzIHN1Y2hcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrTXV0ZWQgPSAodHJhY2ssIG11dGVkKSA9PiB7XG4gICAgICBpZiAobXV0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtdXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLnNpZCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IHVwZGF0ZSBtdXRlIHN0YXR1cyBmb3IgdW5wdWJsaXNoZWQgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5naW5lLnVwZGF0ZU11dGVTdGF0dXModHJhY2suc2lkLCBtdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSBwYXVzZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcmVzdW1lZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc011dGVkKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUgPSB0cmFjayA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYWNrLnNpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKFwiQ291bGQgbm90IHVwZGF0ZSBsb2NhbCBhdWRpbyB0cmFjayBzZXR0aW5ncywgbWlzc2luZyBwdWJsaWNhdGlvbiBmb3IgdHJhY2sgXCIuY29uY2F0KHRyYWNrLnNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHB1Yi50cmFja1NpZCwgcHViLmdldFRyYWNrRmVhdHVyZXMoKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tDcHVDb25zdHJhaW5lZCA9ICh0cmFjaywgcHVibGljYXRpb24pID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd0cmFjayBjcHUgY29uc3RyYWluZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrQ3B1Q29uc3RyYWluZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICBpZiAoISgoX2QgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHluYWNhc3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFwdWIudmlkZW9UcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb2RlY3MgPSB5aWVsZCBwdWIudmlkZW9UcmFjay5zZXRQdWJsaXNoaW5nQ29kZWNzKHVwZGF0ZS5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgbmV3Q29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKG5ld0NvZGVjcyksIG5ld0NvZGVjc18xXzE7IG5ld0NvZGVjc18xXzEgPSB5aWVsZCBuZXdDb2RlY3NfMS5uZXh0KCksIF9hID0gbmV3Q29kZWNzXzFfMS5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gbmV3Q29kZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2M7XG4gICAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2ggXCIuY29uY2F0KGNvZGVjLCBcIiBmb3IgXCIpLmNvbmNhdChwdWIudmlkZW9UcmFjay5zaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSkpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2socHViLnZpZGVvVHJhY2ssIGNvZGVjLCBwdWIub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IG5ld0NvZGVjc18xLnJldHVybikpIHlpZWxkIF9iLmNhbGwobmV3Q29kZWNzXzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5wdWJsaXNoZWQgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh1bnB1Ymxpc2hlZC50cmFja1NpZCk7XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHVucHVibGlzaGVkIGV2ZW50IGZvciB1bmtub3duIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHVucHVibGlzaGVkLnRyYWNrU2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSB0cmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbykge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIGxvY2FsIHRyYWNrIGR1ZSB0byBUcmFja0VuZGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgfHwgaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQZXJtaXNzaW9ucyA9IHlpZWxkIG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBlcm1pc3Npb24gcXVlcnkgZm9yIGNhbWVyYSBhbmQgbWljcm9waG9uZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbmFtZTogdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhID8gJ2NhbWVyYScgOiAnbWljcm9waG9uZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnMgJiYgY3VycmVudFBlcm1pc3Npb25zLnN0YXRlID09PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJ1c2VyIGhhcyByZXZva2VkIGFjY2VzcyB0byBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBncmFudGVkIGNoYW5nZSBhZnRlciBwZXJtaXNzaW9ucyB3ZXJlIGRlbmllZCB0byB0cnkgYW5kIHJlc3VtZSB0aGVuXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSAhPT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0VXNlck1lZGlhIFBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMgcXVlcnkgZmFpbHMgZm9yIGZpcmVmb3gsIHdlIGNvbnRpbnVlIGFuZCB0cnkgdG8gcmVzdGFydCB0aGUgdHJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgZW5kZWQsIGF0dGVtcHRpbmcgdG8gdXNlIGEgZGlmZmVyZW50IGRldmljZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRlZmF1bHQgZGV2aWNlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soe1xuICAgICAgICAgICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlc3RhcnQgdHJhY2ssIG11dGluZyBpbnN0ZWFkXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5yb29tT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zZXR1cEVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuYWN0aXZlRGV2aWNlTWFwID0gbmV3IE1hcChbWydhdWRpb2lucHV0JywgJ2RlZmF1bHQnXSwgWyd2aWRlb2lucHV0JywgJ2RlZmF1bHQnXSwgWydhdWRpb291dHB1dCcsICdkZWZhdWx0J11dKTtcbiAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJwY0hhbmRsZXJzID0gcm9vbVJwY0hhbmRsZXJzO1xuICAgIHRoaXMucm9vbU91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIgPSByb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlcjtcbiAgfVxuICBnZXQgbGFzdENhbWVyYUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xuICB9XG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLm1pY3JvcGhvbmVFcnJvcjtcbiAgfVxuICBnZXQgaXNFMkVFRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgcHViLm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Yi51bm11dGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoKF9hID0gdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Jlc29sdmVkKSB7XG4gICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxDb25uZWN0ZWQsIHRoaXMuaGFuZGxlU2lnbmFsQ29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKS5vbihFbmdpbmVFdmVudC5SZXN1bWluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKS5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCB0aGlzLmhhbmRsZUNsb3NpbmcpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UpLm9uKEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgdGhpcy5oYW5kbGVEYXRhUGFja2V0KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnNcbiAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAqL1xuICBzZXROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBuYW1lXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIHVwZGF0ZSBwYXJ0aWNpcGFudCBhdHRyaWJ1dGVzLiBJdCB3aWxsIG1ha2UgdXBkYXRlcyBvbmx5IHRvIGtleXMgdGhhdFxuICAgKiBhcmUgcHJlc2VudCBpbiBgYXR0cmlidXRlc2AsIGFuZCB3aWxsIG5vdCBvdmVycmlkZSBvdGhlcnMuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBhdHRyaWJ1dGVzIHRvIHVwZGF0ZVxuICAgKi9cbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1ldGFkYXRhVXBkYXRlKF9hKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQge1xuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGlzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YSgoX2EgPSBtZXRhZGF0YSAhPT0gbnVsbCAmJiBtZXRhZGF0YSAhPT0gdm9pZCAwID8gbWV0YWRhdGEgOiB0aGlzLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgKF9iID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogdGhpcy5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgcmVqZWN0OiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICBpc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2hpbGUgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lIDwgNTAwMCAmJiAhaXNSZWplY3RlZCkge1xuICAgICAgICAgICAgICBpZiAoKCFuYW1lIHx8IHRoaXMubmFtZSA9PT0gbmFtZSkgJiYgKCFtZXRhZGF0YSB8fCB0aGlzLm1ldGFkYXRhID09PSBtZXRhZGF0YSkgJiYgKCFhdHRyaWJ1dGVzIHx8IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmV2ZXJ5KF9yZWYyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJycgJiYgIXRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKCdSZXF1ZXN0IHRvIHVwZGF0ZSBsb2NhbCBtZXRhZGF0YSB0aW1lZCBvdXQnLCAnVGltZW91dEVycm9yJykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBlbmFibGVkID8gRW5jcnlwdGlvbl9UeXBlLkdDTSA6IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgICAgeWllbGQgdGhpcy5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tFbmFibGVkKHNvdXJjZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXRUcmFja0VuYWJsZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9KSk7XG4gICAgICBpZiAodGhpcy5yZXB1Ymxpc2hQcm9taXNlKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgdHJhY2sudW5tdXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGxvY2FsVHJhY2tzO1xuICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhY2sgPSB5aWVsZCB0aGlzLndhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nVHJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBwZW5kaW5nVHJhY2sgPT09IG51bGwgfHwgcGVuZGluZ1RyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nVHJhY2sudW5tdXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gcGVuZGluZ1RyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChzb3VyY2UpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICB2aWRlbzogKF9hID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgICAgICAgICAgYXVkaW86IChfYiA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVNjcmVlblRyYWNrcyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9jYWxUcmFja3MgPT09IG51bGwgfHwgbG9jYWxUcmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsVHJhY2tzLmZvckVhY2godHIgPT4ge1xuICAgICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUsIHNvdXJjZVRvS2luZChzb3VyY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKHNvdXJjZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiBpc0F1ZGlvVHJhY2sobG9jYWxUcmFjaykgJiYgb3B0cy5wcmVDb25uZWN0QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3N0YXJ0aW5nIHByZWNvbm5lY3QgYnVmZmVyIGZvciBtaWNyb3Bob25lJywgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgICAgICAgIGxvY2FsVHJhY2suc3RhcnRQcmVDb25uZWN0QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9jYWxUcmFjayBvZiBsb2NhbFRyYWNrcykge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdwdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGxvY2FsVHJhY2spKSk7XG4gICAgICAgICAgICAgIHB1Ymxpc2hQcm9taXNlcy5wdXNoKHRoaXMucHVibGlzaFRyYWNrKGxvY2FsVHJhY2ssIHB1Ymxpc2hPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoZWRUcmFja3MgPSB5aWVsZCBQcm9taXNlLmFsbChwdWJsaXNoUHJvbWlzZXMpO1xuICAgICAgICAgICAgLy8gZm9yIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbnMgaW5jbHVkaW5nIGF1ZGlvLCB0aGlzIHdpbGwgb25seSByZXR1cm4gdGhlIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbiwgbm90IHRoZSBzY3JlZW4gc2hhcmUgYXVkaW8gb25lXG4gICAgICAgICAgICAvLyByZXZpc2l0IGlmIHdlIHdhbnQgdG8gcmV0dXJuIGFuIGFycmF5IG9mIHRyYWNrcyBpbnN0ZWFkIGZvciB2MlxuICAgICAgICAgICAgW3RyYWNrXSA9IHB1Ymxpc2hlZFRyYWNrcztcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2NhbFRyYWNrcyA9PT0gbnVsbCB8fCBsb2NhbFRyYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxUcmFja3MuZm9yRWFjaCh0ciA9PiB7XG4gICAgICAgICAgICAgIHRyLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay50cmFjaykgJiYgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gdHJhY2sgYXZhaWxhYmxlIHlldCBmaXJzdCB3YWl0IGZvciBwZW5kaW5nIHB1Ymxpc2hpbmcgcHJvbWlzZXMgb2YgdGhhdCBzb3VyY2UgdG8gc2VlIGlmIGl0IGJlY29tZXMgYXZhaWxhYmxlXG4gICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLndhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dhaXRpbmcgZm9yIHBlbmRpbmcgcHVibGljYXRpb24gcHJvbWlzZSB0aW1lZCBvdXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjayAmJiB0cmFjay50cmFjaykge1xuICAgICAgICAgIC8vIHNjcmVlbnNoYXJlIGNhbm5vdCBiZSBtdXRlZCwgdW5wdWJsaXNoIGluc3RlYWRcbiAgICAgICAgICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcbiAgICAgICAgICAgIHRyYWNrID0geWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgICAgICBjb25zdCBzY3JlZW5BdWRpb1RyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKTtcbiAgICAgICAgICAgIGlmIChzY3JlZW5BdWRpb1RyYWNrICYmIHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayhzY3JlZW5BdWRpb1RyYWNrLnRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGJvdGggY2FtZXJhIGFuZCBtaWNyb3Bob25lIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBkaXNwbGF5aW5nIGEgc2luZ2xlIFBlcm1pc3Npb24gRGlhbG9nIGJveCB0byB0aGUgZW5kIHVzZXIuXG4gICAqL1xuICBlbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHwgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpKSB7XG4gICAgICAgIC8vIG5vLW9wIGl0J3MgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0cmFjayA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjcmVhdGVUcmFja3Mob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogb3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgbWVyZ2VkT3B0aW9uc1dpdGhQcm9jZXNzb3JzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXVkaW9DYXB0dXJlRGVmYXVsdHMsIChfYiA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyhtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gdHJhY2tzLm1hcCh0cmFjayA9PiB7XG4gICAgICAgICAgaWYgKGlzQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJhY2suc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxuICAgKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZVNjcmVlblRyYWNrcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTdCYXNlZCgpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgICAvLyBkdWUgdG8gZW5jb2RpbmcgYSBodWdlIHZpZGVvLiBFbmNvZGluZyBzdWNoIGxhcmdlIHN1cmZhY2VzIGlzIHJlYWxseSBleHBlbnNpdmVcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSBTYWZhcmkgMTcgaGFzIGEgYnV0IGFuZCBjYW5ub3QgYmUgY29uc3RyYWluZWQgYnkgZGVmYXVsdFxuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgaWYgKG9wdGlvbnMuY29udGVudEhpbnQpIHtcbiAgICAgICAgc2NyZWVuVmlkZW8ubWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9IG9wdGlvbnMuY29udGVudEhpbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IFtzY3JlZW5WaWRlb107XG4gICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGEgbmV3IHRyYWNrIHRvIHRoZSByb29tXG4gICAqIEBwYXJhbSB0cmFja1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFja18xLCBvcHRpb25zXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAodHJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IGlzUmVwdWJsaXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQoX3RoaXMyLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgKF9hID0gX3RoaXMyLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2U7XG4gICAgICAgIGlmIChfdGhpczIucmVwdWJsaXNoUHJvbWlzZSAmJiAhaXNSZXB1Ymxpc2gpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczIucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5oYXModHJhY2spKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSB3YW50IHRvIGFjY2VzcyBjb25zdHJhaW50cyBkaXJlY3RseSBhcyBgdHJhY2subWVkaWFTdHJlYW1UcmFja2BcbiAgICAgICAgICAvLyBtaWdodCBiZSBwb2ludGluZyB0byBhIG5vbi1kZXZpY2UgdHJhY2sgKGUuZy4gcHJvY2Vzc2VkIHRyYWNrKSBhbHJlYWR5XG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suY29uc3RyYWludHM7XG4gICAgICAgICAgbGV0IGRldmljZUtpbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc3dpdGNoICh0cmFjay5zb3VyY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICAgIGRldmljZUtpbmQgPSAnYXVkaW9pbnB1dCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICBkZXZpY2VLaW5kID0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV2aWNlS2luZCAmJiBfdGhpczIuYWN0aXZlRGV2aWNlTWFwLmhhcyhkZXZpY2VLaW5kKSkge1xuICAgICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uc3RyYWludHMpLCB7XG4gICAgICAgICAgICAgIGRldmljZUlkOiBfdGhpczIuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgcmF3IG1lZGlhIHRyYWNrIGludG8gYXVkaW8gb3IgdmlkZW8gdHJhY2tcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgIHN3aXRjaCAodHJhY2sua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgX3RoaXMyLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwge1xuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kIFwiLmNvbmNhdCh0cmFjay5raW5kKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrLnVwZGF0ZUxvZ2dlck9wdGlvbnMoe1xuICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IF90aGlzMi5sb2dDb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXMgaXQgYWxyZWFkeSBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICAgIF90aGlzMi50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICAgIF90aGlzMi5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbikpKTtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPSAnY2hhbm5lbENvdW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY2hhbm5lbENvdW50YCBvbiBnZXRTZXR0aW5ncygpIGlzIGN1cnJlbnRseSBvbmx5IGF2YWlsYWJsZSBmb3IgU2FmYXJpLCBidXQgaXMgZ2VuZXJhbGx5IHRoZSBiZXN0IHdheSB0byBkZXRlcm1pbmUgYSBzdGVyZW8gdHJhY2sgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tTZXR0aW5ncy9jaGFubmVsQ291bnRcbiAgICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCA9PT0gMiB8fCB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCkuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgICBjb25zdCBpc1N0ZXJlbyA9IChfYiA9IG9wdHMuZm9yY2VTdGVyZW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzU3RlcmVvSW5wdXQ7XG4gICAgICAgIC8vIGRpc2FibGUgZHR4IGZvciBzdGVyZW8gdHJhY2sgaWYgbm90IGVuYWJsZWQgZXhwbGljaXRseVxuICAgICAgICBpZiAoaXNTdGVyZW8pIHtcbiAgICAgICAgICBpZiAob3B0cy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiT3B1cyBEVFggd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJPcHVzIFJFRCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9jID0gb3B0cy5kdHgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wdHMuZHR4ID0gZmFsc2U7XG4gICAgICAgICAgKF9kID0gb3B0cy5yZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG9wdHMucmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSAmJiBfdGhpczIucm9vbU9wdGlvbnMuZTJlZSkge1xuICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIkVuZC10by1lbmQgZW5jcnlwdGlvbiBpcyBzZXQgdXAsIHNpbXVsY2FzdCBwdWJsaXNoaW5nIHdpbGwgYmUgZGlzYWJsZWQgb24gU2FmYXJpIHZlcnNpb25zIGFuZCBpT1MgYnJvd3NlcnMgcnVubmluZyBpT1MgPCB2MTcuMlwiLCBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCkpO1xuICAgICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gb3B0cy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMyLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLmNsaWVudC5jdXJyZW50U3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlZmVycmluZyB0cmFjayBwdWJsaWNhdGlvbiB1bnRpbCBzaWduYWwgaXMgY29ubmVjdGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgdHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgbGV0IHB1YmxpY2F0aW9uVGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uVGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFB1Ymxpc2hUcmFja0Vycm9yKCdwdWJsaXNoaW5nIHJlamVjdGVkIGFzIGVuZ2luZSBub3QgY29ubmVjdGVkIHdpdGhpbiB0aW1lb3V0JywgNDA4KSk7XG4gICAgICAgICAgICAgIH0sIDE1MDAwKTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy53YWl0VW50aWxFbmdpbmVDb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICBpZiAocHVibGljYXRpb25UaW1lZE91dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xuICAgICAgICAgICAgICByZXNvbHZlKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcbiAgICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0VW50aWxFbmdpbmVDb25uZWN0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkge1xuICAgICAgdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZS5wcm9taXNlO1xuICB9XG4gIGhhc1Blcm1pc3Npb25zVG9QdWJsaXNoKHRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLnBlcm1pc3Npb25zKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdubyBwZXJtaXNzaW9ucyBwcmVzZW50IGZvciBwdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW5QdWJsaXNoLFxuICAgICAgY2FuUHVibGlzaFNvdXJjZXNcbiAgICB9ID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBpZiAoY2FuUHVibGlzaCAmJiAoY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoID09PSAwIHx8IGNhblB1Ymxpc2hTb3VyY2VzLm1hcChzb3VyY2UgPT4gZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8oc291cmNlKSkuaW5jbHVkZXModHJhY2suc291cmNlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmxvZy53YXJuKCdpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgdG8gcHVibGlzaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb25zVG9QdWJsaXNoKHRyYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ2ZhaWxlZCB0byBwdWJsaXNoIHRyYWNrLCBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnLCA0MDMpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IGlzTG9jYWxUcmFjayh0cmFjaykgJiYgcHVibGlzaGVkVHJhY2suc291cmNlID09PSB0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJwdWJsaXNoaW5nIGEgc2Vjb25kIHRyYWNrIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuc3RvcE1pY1RyYWNrT25NdXRlICYmIGlzQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgaXNGaXJlRm94KCkpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBzaW11bGNhc3RlZCBzY3JlZW4gc2hhcmVcbiAgICAgICAgLy8gd2UgZnJlcXVlbnRseSBnZXQgbm8gZGF0YSBvbiBsYXllciAwIHdoZW4gZW5hYmxlZFxuICAgICAgICBvcHRzLnNpbXVsY2FzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gcmVxdWlyZSBmdWxsIEFWMS9WUDkgU1ZDIHN1cHBvcnQgcHJpb3IgdG8gdXNpbmcgaXRcbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICdhdjEnICYmICFzdXBwb3J0c0FWMSgpKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICd2cDknICYmICFzdXBwb3J0c1ZQOSgpKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSBkZWZhdWx0VmlkZW9Db2RlYztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBmYWxsYmFjayB0byBhIHN1cHBvcnRlZCBjb2RlYyBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLnNvbWUoYyA9PiBvcHRzLnZpZGVvQ29kZWMgPT09IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKGMubWltZSkpKSB7XG4gICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzWzBdLm1pbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb0NvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgLy8gaGFuZGxlIHRyYWNrIGFjdGlvbnNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlLCB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlKTtcbiAgICAgIGNvbnN0IGF1ZGlvRmVhdHVyZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRpc2FibGVEdHggPSAhKChfYSA9IG9wdHMuZHR4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdHJhY2suZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpO1xuICAgICAgaWYgKHNldHRpbmdzLmF1dG9HYWluQ29udHJvbCkge1xuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfQVVUT19HQUlOX0NPTlRST0wpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLmVjaG9DYW5jZWxsYXRpb24pIHtcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VDSE9fQ0FOQ0VMTEFUSU9OKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5ub2lzZVN1cHByZXNzaW9uKSB7XG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT0lTRV9TVVBQUkVTU0lPTik7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuY2hhbm5lbENvdW50ICYmIHNldHRpbmdzLmNoYW5uZWxDb3VudCA+IDEpIHtcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1NURVJFTyk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZUR0eCkge1xuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9fRFRYKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgJiYgdHJhY2suaGFzUHJlQ29ubmVjdEJ1ZmZlcikge1xuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfUFJFQ09OTkVDVF9CVUZGRVIpO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICAvLyBnZXQgbG9jYWwgdHJhY2sgaWQgZm9yIHVzZSBkdXJpbmcgcHVibGlzaGluZ1xuICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgZGlzYWJsZUR0eCxcbiAgICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgZGlzYWJsZVJlZDogdGhpcy5pc0UyRUVFbmFibGVkIHx8ICEoKF9iID0gb3B0cy5yZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpLFxuICAgICAgICBzdHJlYW06IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zdHJlYW0sXG4gICAgICAgIGJhY2t1cENvZGVjUG9saWN5OiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYmFja3VwQ29kZWNQb2xpY3ksXG4gICAgICAgIGF1ZGlvRmVhdHVyZXNcbiAgICAgIH0pO1xuICAgICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICAgIGxldCBlbmNvZGluZ3M7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBsZXQgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaW1zID0geWllbGQgdHJhY2sud2FpdEZvckRpbWVuc2lvbnMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgICAvLyBzbyB1c2luZyBkZWZhdWx0IGRpbXMgYWNjb3JkaW5nIHRvIHB1Ymxpc2ggc2V0dGluZ3NcbiAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzID0gKF9kID0gKF9jID0gdGhpcy5yb29tT3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc29sdXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb247XG4gICAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBkZWZhdWx0UmVzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBkZWZhdWx0UmVzLmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gbG9nIGZhaWx1cmVcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBzaG91bGQgYmUgZGVmaW5lZCBmb3IgdmlkZW9cbiAgICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgICAgcmVxLmhlaWdodCA9IGRpbXMuaGVpZ2h0O1xuICAgICAgICAvLyBmb3Igc3ZjIGNvZGVjcywgZGlzYWJsZSBzaW11bGNhc3QgYW5kIHVzZSB2cDggZm9yIGJhY2t1cCBjb2RlY1xuICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgICAgICAvLyB2cDkgc3ZjIHdpdGggc2NyZWVuc2hhcmUgY2Fubm90IGVuY29kZSBtdWx0aXBsZSBzcGF0aWFsIGxheWVyc1xuICAgICAgICAgICAgICAvLyBkb2luZyBzbyByZWR1Y2VzIHB1Ymxpc2ggcmVzb2x1dGlvbiB0byBtaW5pbWFsIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICAgIC8vIENocm9tZSBkb2VzIG5vdCBhbGxvdyBtb3JlIHRoYW4gNSBmcHMgd2l0aCBMMVQzLCBhbmQgaXQgaGFzIGVuY29kaW5nIGJ1Z3Mgd2l0aCBMM1QzXG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIGRpZmZlcmVudCBwYXRoIGZvciBzY3JlZW5zaGFyZSBoYW5kbGluZyBhbmQgaXQgc2VlbXMgdG8gYmUgdW50ZXN0ZWQvYnVnZ3lcbiAgICAgICAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCB3ZSBhcmUgc2V0dGluZyBjb250ZW50SGludCB0byBmb3JjZSBpdCB0byBnbyB0aHJvdWdoIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIHBhdGggYXMgcmVndWxhciBjYW1lcmEgdmlkZW8uIFdoaWxlIHRoaXMgaXMgbm90IG9wdGltYWwsIGl0IGRlbGl2ZXJzIHRoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAvLyB0aGF0IHdlIG5lZWRcbiAgICAgICAgICAgICAgaWYgKCdjb250ZW50SGludCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY29udGVudEhpbnQgPSAnbW90aW9uJztcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdmb3JjaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiBmb3Igc2NyZWVuc2hhcmUgd2l0aCBTVkMgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAoX2UgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ0wzVDNfS0VZJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0ge1xuICAgICAgICAgICAgICBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjICYmIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCBjb2RlY3NcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgICAgIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCByZXF1aXJlcyBkeW5hY2FzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcy5wdXNoKG5ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICAgIGNvZGVjOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgICAgICAgICAgICBjaWQ6ICcnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncywgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICBlbmNvZGluZ3MgPSBbe1xuICAgICAgICAgIG1heEJpdHJhdGU6IChfZiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXhCaXRyYXRlLFxuICAgICAgICAgIHByaW9yaXR5OiAoX2ggPSAoX2cgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucHJpb3JpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICdoaWdoJyxcbiAgICAgICAgICBuZXR3b3JrUHJpb3JpdHk6IChfayA9IChfaiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5wcmlvcml0eSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogJ2hpZ2gnXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWdvdGlhdGUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoIXRoaXMuZW5naW5lLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwY01hbmFnZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2VuZGVyID0geWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFNlbmRlckNyZWF0ZWQsIHRyYWNrLnNlbmRlciwgdHJhY2spO1xuICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgKF9hID0gb3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjayk7XG4gICAgICAgICAgdHJhY2suc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgaWYgKGlzRmlyZUZveCgpICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAgIC8qIFJlZmVyIHRvIFJGQyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc1ODcjc2VjdGlvbi02LjEsXG4gICAgICAgICAgICAgICBsaXZla2l0LXNlcnZlciB1c2VzIG1heGF2ZXJhZ2ViaXRyYXRlPTUxMDAwMCBpbiB0aGUgYW5zd2VyIHNkcCB0byBwZXJtaXQgY2xpZW50IHRvXG4gICAgICAgICAgICAgICBwdWJsaXNoIGhpZ2ggcXVhbGl0eSBhdWRpbyB0cmFjay4gQnV0IGZpcmVmb3ggYWx3YXlzIHVzZXMgdGhpcyB2YWx1ZSBhcyB0aGUgYWN0dWFsXG4gICAgICAgICAgICAgICBiaXRyYXRlcywgY2F1c2luZyB0aGUgYXVkaW8gYml0cmF0ZXMgdG8gcmlzZSB0byA1MTBLYnBzIGluIGFueSBzdGVyZW8gY2FzZSB1bmV4cGVjdGVkbHkuXG4gICAgICAgICAgICAgICBTbyB0aGUgY2xpZW50IG5lZWQgdG8gbW9kaWZ5IG1heGF2ZXJyYWdlYml0cmF0ZXMgaW4gYW5zd2VyIHNkcCB0byB1c2VyIHByb3ZpZGVkIHZhbHVlIHRvXG4gICAgICAgICAgICAgICBmaXggdGhlIGlzc3VlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgdHJhY2tUcmFuc2NlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFjay5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgIGNvZGVjOiAnb3B1cycsXG4gICAgICAgICAgICAgICAgbWF4YnI6ICgoX2IgPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhCaXRyYXRlKSA/IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMCA6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFjay5jb2RlYyAmJiBpc1NWQ0NvZGVjKHRyYWNrLmNvZGVjKSAmJiAoKF9jID0gZW5jb2RpbmdzWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4Qml0cmF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgICBjaWQ6IHJlcS5jaWQsXG4gICAgICAgICAgICAgIGNvZGVjOiB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgICAgbWF4YnI6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBsZXQgdGk7XG4gICAgICBjb25zdCBhZGRUcmFja1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICAgICAgcmVzb2x2ZSh0aSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICh0cmFjay5zZW5kZXIgJiYgKChfYSA9IHRoaXMuZW5naW5lLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1Ymxpc2hlcikpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIucmVtb3ZlVHJhY2sodHJhY2suc2VuZGVyKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpLmNhdGNoKG5lZ290aWF0ZUVyciA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdmYWlsZWQgdG8gbmVnb3RpYXRlIGFmdGVyIHJlbW92aW5nIHRyYWNrIGR1ZSB0byBmYWlsZWQgYWRkIHRyYWNrIHJlcXVlc3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5lZ290aWF0ZUVyclxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXRzID0geWllbGQgUHJvbWlzZS5hbGwoW2FkZFRyYWNrUHJvbWlzZSwgbmVnb3RpYXRlKCldKTtcbiAgICAgICAgdGkgPSByZXRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGkgPSB5aWVsZCBhZGRUcmFja1Byb21pc2U7XG4gICAgICAgIC8vIHNlcnZlciBtaWdodCBub3Qgc3VwcG9ydCB0aGUgY29kZWMgdGhlIGNsaWVudCBoYXMgcmVxdWVzdGVkLCBpbiB0aGF0IGNhc2UsIGZhbGxiYWNrXG4gICAgICAgIC8vIHRvIGEgc3VwcG9ydGVkIGNvZGVjXG4gICAgICAgIGxldCBwcmltYXJ5Q29kZWNNaW1lO1xuICAgICAgICB0aS5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJpbWFyeUNvZGVjTWltZSA9IGNvZGVjLm1pbWVUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmltYXJ5Q29kZWNNaW1lICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQ29kZWMgPSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhwcmltYXJ5Q29kZWNNaW1lKTtcbiAgICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZmFsbGluZyBiYWNrIHRvIHNlcnZlciBzZWxlY3RlZCBjb2RlYycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgICAgY29kZWM6IHVwZGF0ZWRDb2RlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdXBkYXRlZENvZGVjO1xuICAgICAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHJlcS53aWR0aCwgcmVxLmhlaWdodCwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIG5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGljYXRpb24gPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKHRyYWNrLmtpbmQsIHRpLCB0cmFjaywge1xuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICB9KTtcbiAgICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuQ3B1Q29uc3RyYWluZWQsIGNvbnN0cmFpbmVkVHJhY2sgPT4gdGhpcy5vblRyYWNrQ3B1Q29uc3RyYWluZWQoY29uc3RyYWluZWRUcmFjaywgcHVibGljYXRpb24pKTtcbiAgICAgIC8vIHNhdmUgb3B0aW9ucyBmb3Igd2hlbiBpdCBuZWVkcyB0byBiZSByZXB1Ymxpc2hlZCBhZ2FpblxuICAgICAgcHVibGljYXRpb24ub3B0aW9ucyA9IG9wdHM7XG4gICAgICB0cmFjay5zaWQgPSB0aS5zaWQ7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hpbmcgXCIuY29uY2F0KHRyYWNrLmtpbmQsIFwiIHdpdGggZW5jb2RpbmdzXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KSk7XG4gICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyYWNrLnN0YXJ0TW9uaXRvcih0aGlzLmVuZ2luZS5jbGllbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgJiYgdGkuYXVkaW9GZWF0dXJlcy5pbmNsdWRlcyhBdWRpb1RyYWNrRmVhdHVyZS5URl9QUkVDT05ORUNUX0JVRkZFUikpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gdHJhY2suZ2V0UHJlQ29ubmVjdEJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHRyYWNrLmdldFByZUNvbm5lY3RCdWZmZXJNaW1lVHlwZSgpO1xuICAgICAgICAvLyBUT0RPOiB3ZSdyZSByZWdpc3RlcmluZyB0aGUgbGlzdGVuZXIgYWZ0ZXIgbmVnb3RpYXRpb24sIHNvIHRoZXJlIG1pZ2h0IGJlIGEgcmFjZVxuICAgICAgICB0aGlzLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHB1YiA9PiB7XG4gICAgICAgICAgaWYgKHB1Yi50cmFja1NpZCA9PT0gdGkuc2lkKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLmhhc1ByZUNvbm5lY3RCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cud2Fybignc3Vic2NyaWJlIGV2ZW50IGNhbWUgdG8gbGF0ZSwgYnVmZmVyIGFscmVhZHkgY2xvc2VkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2ZpbmlzaGVkIHJlY29yZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgIHRyYWNrLnN0b3BQcmVDb25uZWN0QnVmZmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlclN0cmVhbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgdmFyIF9kLCBfZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBhZ2VudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgICAgY29uc3QgYWdlbnRBY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYWdlbnQgbm90IGFjdGl2ZSB3aXRoaW4gMTAgc2Vjb25kcycpKTtcbiAgICAgICAgICAgICAgfSwgMTAwMDApO1xuICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IHlpZWxkIHRoaXMud2FpdFVudGlsQWN0aXZlQWdlbnRQcmVzZW50KCk7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChhZ2VudEFjdGl2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5zdHJlYW1CeXRlcyh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3ByZWNvbm5lY3QtYnVmZmVyJyxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICB0b3BpYzogJ2xrLmFnZW50LnByZS1jb25uZWN0LWF1ZGlvLWJ1ZmZlcicsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbYWdlbnQuaWRlbnRpdHldLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHB1YmxpY2F0aW9uLnRyYWNrU2lkLFxuICAgICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogU3RyaW5nKChfZCA9IHNldHRpbmdzLnNhbXBsZVJhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICc0ODAwMCcpLFxuICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IFN0cmluZygoX2UgPSBzZXR0aW5ncy5jaGFubmVsQ291bnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICcxJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgc3RyZWFtXzEgPSBfX2FzeW5jVmFsdWVzKHN0cmVhbSksIHN0cmVhbV8xXzE7IHN0cmVhbV8xXzEgPSB5aWVsZCBzdHJlYW1fMS5uZXh0KCksIF9hID0gc3RyZWFtXzFfMS5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgX2MgPSBzdHJlYW1fMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogZV8yXzFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBzdHJlYW1fMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKHN0cmVhbV8xKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGJ1ZmZlclN0cmVhbVByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncHJlY29ubmVjdCBidWZmZXIgc2VudCBzdWNjZXNzZnVsbHknLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igc2VuZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWxcbiAgICogcHVibGlzaCBhZGRpdGlvbmFsIGNvZGVjIHRvIGV4aXN0aW5nIHRyYWNrXG4gICAqL1xuICBwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2sodHJhY2ssIHZpZGVvQ29kZWMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgLy8gVE9ETyByZW1vdmUgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIHRyYWNrc1xuICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlzIGl0IG5vdCBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBwdWJsaXNoZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IGEgdmlkZW8gdHJhY2snKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cyk7XG4gICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcbiAgICAgIGlmICghc2ltdWxjYXN0VHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICAgIGNpZDogc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgc2lkOiB0cmFjay5zaWQsXG4gICAgICAgIHNpbXVsY2FzdENvZGVjczogW3tcbiAgICAgICAgICBjb2RlYzogb3B0cy52aWRlb0NvZGVjLFxuICAgICAgICAgIGNpZDogc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzKTtcbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVnb3RpYXRlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmV0cyA9IHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpLCBuZWdvdGlhdGUoKV0pO1xuICAgICAgY29uc3QgdGkgPSByZXRzWzBdO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoZWQgXCIuY29uY2F0KHZpZGVvQ29kZWMsIFwiIGZvciB0cmFjayBcIikuY29uY2F0KHRyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFjayh0cmFjaywgc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSkge1xuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZSA9IHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5nZXQodHJhY2spO1xuICAgICAgICBpZiAocHVibGlzaFByb21pc2UpIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdhd2FpdGluZyBwdWJsaXNoIHByb21pc2UgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdW5wdWJsaXNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgIHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBsb29rIHRocm91Z2ggYWxsIHB1Ymxpc2hlZCB0cmFja3MgdG8gZmluZCB0aGUgcmlnaHQgb25lc1xuICAgICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xuICAgICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHB1YmxpY2F0aW9uLnRyYWNrO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0b3BPblVucHVibGlzaCA9IChfYiA9IChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCkge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFjay5zdG9wTW9uaXRvcigpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZ290aWF0aW9uTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB0cmFja1NlbmRlciA9IHRyYWNrLnNlbmRlcjtcbiAgICAgIHRyYWNrLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmVuZ2luZS5wY01hbmFnZXIgJiYgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSA8IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEICYmIHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXG4gICAgICAgICAgICAvLyByZW1vdmVUcmFjayB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBlbmQgdXAgc3VjY2Vzc2Z1bGx5IHJlbW92aW5nIHRoZSB0cmFjaywgbWFudWFsbHkgc2V0XG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrU2VuZGVyKSB7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrSW5mby5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrSW5mby5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnNpbXVsY2FzdENvZGVjcy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byB1bnB1Ymxpc2ggdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgZnJvbSBvdXIgbWFwc1xuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgICAgaWYgKG5lZ290aWF0aW9uTmVlZGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIHVucHVibGlzaFRyYWNrcyh0cmFja3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodHJhY2sgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcih0cmFjayA9PiAhIXRyYWNrKTtcbiAgICB9KTtcbiAgfVxuICByZXB1Ymxpc2hBbGxUcmFja3Mob3B0aW9uc18xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgbGV0IHJlc3RhcnRUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcHVibGlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLnJlcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxQdWJzID0gW107XG4gICAgICAgICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBwdWIub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHViLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQdWJzLnB1c2gocHViKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsb2NhbFB1YnMubWFwKHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChyZXN0YXJ0VHJhY2tzICYmICF0cmFjay5pc011dGVkICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8gJiYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpICYmICF0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYWxseSB3ZSBuZWVkIHRvIHJlc3RhcnQgdGhlIHRyYWNrIGJlZm9yZSBwdWJsaXNoaW5nLCBvZnRlbiBhIGZ1bGwgcmVjb25uZWN0XG4gICAgICAgICAgICAgICAgLy8gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgY29tcHV0ZXIgaGFkIGdvbmUgdG8gc2xlZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFjaywgcHViLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZXB1Ymxpc2hQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB5aWVsZCBfdGhpczMucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyBkYXRhIHBheWxvYWQgdG8gdGhlIHJvb20uIERhdGEgd2lsbCBiZSBmb3J3YXJkZWQgdG8gZWFjaFxuICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gZmllbGQgaW4gcHVibGlzaE9wdGlvbnMgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgVWludDhBcnJheSBvZiB0aGUgcGF5bG9hZC4gVG8gc2VuZCBzdHJpbmcgZGF0YSwgdXNlIFRleHRFbmNvZGVyLmVuY29kZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25hbGx5IHNwZWNpZnkgYSBgcmVsaWFibGVgLCBgdG9waWNgIGFuZCBgZGVzdGluYXRpb25gXG4gICAqL1xuICBwdWJsaXNoRGF0YShkYXRhXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qga2luZCA9IG9wdGlvbnMucmVsaWFibGUgPyBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUgOiBEYXRhUGFja2V0X0tpbmQuTE9TU1k7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnMudG9waWM7XG4gICAgICAgIGxldCB1c2VyUGFja2V0ID0gbmV3IFVzZXJQYWNrZXQoe1xuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IF90aGlzNC5pZGVudGl0eSxcbiAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICB0b3BpY1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNhc2U6ICd1c2VyJyxcbiAgICAgICAgICAgIHZhbHVlOiB1c2VyUGFja2V0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgX3RoaXM0LmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIFNJUCBEVE1GIG1lc3NhZ2UgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIERUTUYgY29kZVxuICAgKiBAcGFyYW0gZGlnaXQgRFRNRiBkaWdpdFxuICAgKi9cbiAgcHVibGlzaER0bWYoY29kZSwgZGlnaXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3NpcER0bWYnLFxuICAgICAgICAgIHZhbHVlOiBuZXcgU2lwRFRNRih7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgZGlnaXQ6IGRpZ2l0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIENvbnNpZGVyIG1pZ3JhdGluZyB0byB7QGxpbmsgc2VuZFRleHR9ICovXG4gIHNlbmRDaGF0TWVzc2FnZSh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIG1lc3NhZ2U6IHRleHQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYXR0YWNoZWRGaWxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzXG4gICAgICB9O1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdjaGF0TWVzc2FnZScsXG4gICAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1zZyksIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCBtc2cpO1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9KTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQ29uc2lkZXIgbWlncmF0aW5nIHRvIHtAbGluayBzZW5kVGV4dH0gKi9cbiAgZWRpdENoYXRNZXNzYWdlKGVkaXRUZXh0LCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbXNnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbE1lc3NhZ2UpLCB7XG4gICAgICAgIG1lc3NhZ2U6IGVkaXRUZXh0LFxuICAgICAgICBlZGl0VGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAnY2hhdE1lc3NhZ2UnLFxuICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtc2cpLCB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLnRpbWVzdGFtcCksXG4gICAgICAgICAgICBlZGl0VGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy5lZGl0VGltZXN0YW1wKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCBtc2cpO1xuICAgICAgcmV0dXJuIG1zZztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgdGhlIGdpdmVuIHN0cmluZyB0byBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gdmlhIHRoZSBkYXRhIGNoYW5uZWwuXG4gICAqIEZvciBsb25nZXIgbWVzc2FnZXMsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBzdHJlYW1UZXh0fSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBwYXlsb2FkXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvcGljIFRvcGljIGlkZW50aWZpZXIgdXNlZCB0byByb3V0ZSB0aGUgc3RyZWFtIHRvIGFwcHJvcHJpYXRlIGhhbmRsZXJzLlxuICAgKi9cbiAgc2VuZFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlci5zZW5kVGV4dCh0ZXh0LCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUZXh0U3RyZWFtV3JpdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0cmVhbSB0ZXh0IGluY3JlbWVudGFsbHlcbiAgICogdG8gcGFydGljaXBhbnRzIGluIHRoZSByb29tIHZpYSB0aGUgZGF0YSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy50b3BpYyBUb3BpYyBpZGVudGlmaWVyIHVzZWQgdG8gcm91dGUgdGhlIHN0cmVhbSB0byBhcHByb3ByaWF0ZSBoYW5kbGVycy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWwgQ0FVVElPTiwgbWlnaHQgZ2V0IHJlbW92ZWQgaW4gYSBtaW5vciByZWxlYXNlXG4gICAqL1xuICBzdHJlYW1UZXh0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vbU91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIuc3RyZWFtVGV4dChvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKiogU2VuZCBhIEZpbGUgdG8gYWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB2aWEgdGhlIGRhdGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIGZpbGUgVGhlIEZpbGUgb2JqZWN0IHBheWxvYWRcbiAgICogQHBhcmFtIG9wdGlvbnMudG9waWMgVG9waWMgaWRlbnRpZmllciB1c2VkIHRvIHJvdXRlIHRoZSBzdHJlYW0gdG8gYXBwcm9wcmlhdGUgaGFuZGxlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uUHJvZ3Jlc3MgQSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIG1vbml0b3IgdGhlIHVwbG9hZCBwcm9ncmVzcyBwZXJjZW50YWdlLlxuICAgKi9cbiAgc2VuZEZpbGUoZmlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb29tT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlci5zZW5kRmlsZShmaWxlLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtIGJ5dGVzIGluY3JlbWVudGFsbHkgdG8gcGFydGljaXBhbnRzIGluIHRoZSByb29tIHZpYSB0aGUgZGF0YSBjaGFubmVsLlxuICAgKiBGb3Igc2VuZGluZyBmaWxlcywgY29uc2lkZXIgdXNpbmcge0BsaW5rIHNlbmRGaWxlfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy50b3BpYyBUb3BpYyBpZGVudGlmaWVyIHVzZWQgdG8gcm91dGUgdGhlIHN0cmVhbSB0byBhcHByb3ByaWF0ZSBoYW5kbGVycy5cbiAgICovXG4gIHN0cmVhbUJ5dGVzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vbU91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIuc3RyZWFtQnl0ZXMob3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlIGFuIFJQQyBjYWxsIHRvIGEgcmVtb3RlIHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBpbml0aWF0aW5nIHRoZSBSUEMgY2FsbCwgc2VlIHtAbGluayBQZXJmb3JtUnBjUGFyYW1zfVxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBwYXlsb2FkIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cbiAgICogQHRocm93cyBFcnJvciBvbiBmYWlsdXJlLiBEZXRhaWxzIGluIGBtZXNzYWdlYC5cbiAgICovXG4gIHBlcmZvcm1ScGMoX2EpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgbGV0IHtcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0eSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICByZXNwb25zZVRpbWVvdXQgPSAxNTAwMFxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG1heFJvdW5kVHJpcExhdGVuY3kgPSA3MDAwO1xuICAgICAgICBjb25zdCBtaW5FZmZlY3RpdmVUaW1lb3V0ID0gbWF4Um91bmRUcmlwTGF0ZW5jeSArIDEwMDA7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXM1LCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGgocGF5bG9hZCkgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0UnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5lbmdpbmUubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucygoX2QgPSAoX2MgPSB0aGlzLmVuZ2luZS5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmVyc2lvbiwgJzEuOC4wJykgPCAwKSB7XG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfU0VSVkVSJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlZmZlY3RpdmVUaW1lb3V0ID0gTWF0aC5tYXgocmVzcG9uc2VUaW1lb3V0LCBtaW5FZmZlY3RpdmVUaW1lb3V0KTtcbiAgICAgICAgICBjb25zdCBpZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoUnBjUmVxdWVzdChkZXN0aW5hdGlvbklkZW50aXR5LCBpZCwgbWV0aG9kLCBwYXlsb2FkLCBlZmZlY3RpdmVUaW1lb3V0KTtcbiAgICAgICAgICBjb25zdCBhY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdDT05ORUNUSU9OX1RJTUVPVVQnKSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXRJZCk7XG4gICAgICAgICAgfSwgbWF4Um91bmRUcmlwTGF0ZW5jeSk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5zZXQoaWQsIHtcbiAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVvdXRJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZGVzdGluYXRpb25JZGVudGl0eVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdSRVNQT05TRV9USU1FT1VUJykpO1xuICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLnNldChpZCwge1xuICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3BvbnNlUGF5bG9hZCwgcmVzcG9uc2VFcnJvcikgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQWNrcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybignUlBDIHJlc3BvbnNlIHJlY2VpdmVkIGJlZm9yZSBhY2snLCBpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChhY2tUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRXJyb3IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VQYXlsb2FkICE9PSBudWxsICYmIHJlc3BvbnNlUGF5bG9hZCAhPT0gdm9pZCAwID8gcmVzcG9uc2VQYXlsb2FkIDogJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZGVzdGluYXRpb25JZGVudGl0eVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgcm9vbS5yZWdpc3RlclJwY01ldGhvZGAgaW5zdGVhZFxuICAgKi9cbiAgcmVnaXN0ZXJScGNNZXRob2QobWV0aG9kLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMucnBjSGFuZGxlcnMuaGFzKG1ldGhvZCkpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oXCJ5b3UncmUgb3ZlcnJpZGluZyB0aGUgUlBDIGhhbmRsZXIgZm9yIG1ldGhvZCBcIi5jb25jYXQobWV0aG9kLCBcIiwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3JcIikpO1xuICAgIH1cbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHJvb20udW5yZWdpc3RlclJwY01ldGhvZGAgaW5zdGVhZFxuICAgKi9cbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcbiAgICB0aGlzLnJwY0hhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgKlxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcbiAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXG4gICAqL1xuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50c0FsbG93ZWQpIHtcbiAgICBsZXQgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucztcbiAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSA9IGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ7XG4gICAgaWYgKCF0aGlzLmVuZ2luZS5jbGllbnQuaXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVJbmNvbWluZ1JwY0FjayhyZXF1ZXN0SWQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wZW5kaW5nQWNrcy5nZXQocmVxdWVzdElkKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlci5yZXNvbHZlKCk7XG4gICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBY2sgcmVjZWl2ZWQgZm9yIHVuZXhwZWN0ZWQgUlBDIHJlcXVlc3QnLCByZXF1ZXN0SWQpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlKHJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmdldChyZXF1ZXN0SWQpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyLnJlc29sdmUocGF5bG9hZCwgZXJyb3IpO1xuICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSZXNwb25zZSByZWNlaXZlZCBmb3IgdW5leHBlY3RlZCBSUEMgcmVxdWVzdCcsIHJlcXVlc3RJZCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGlzaFJwY1JlcXVlc3QoZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3JwY1JlcXVlc3QnLFxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjUmVxdWVzdCh7XG4gICAgICAgICAgICBpZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dE1zOiByZXNwb25zZVRpbWVvdXQsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgZm9yIChjb25zdCBbaWQsIHtcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlbmRpbmdJZGVudGl0eVxuICAgIH1dIG9mIHRoaXMucGVuZGluZ0Fja3MpIHtcbiAgICAgIGlmIChwZW5kaW5nSWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwge1xuICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGVuZGluZ0lkZW50aXR5LFxuICAgICAgcmVzb2x2ZVxuICAgIH1dIG9mIHRoaXMucGVuZGluZ1Jlc3BvbnNlcykge1xuICAgICAgaWYgKHBlbmRpbmdJZGVudGl0eSA9PT0gcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICByZXNvbHZlKG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1JFQ0lQSUVOVF9ESVNDT05ORUNURUQnKSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEVuYWJsZWRQdWJsaXNoQ29kZWNzKGNvZGVjcykge1xuICAgIHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcyA9IGNvZGVjcy5maWx0ZXIoYyA9PiBjLm1pbWUuc3BsaXQoJy8nKVswXS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyByZWNvbmNpbGUgdHJhY2sgbXV0ZSBzdGF0dXMuXG4gICAgLy8gaWYgc2VydmVyJ3MgdHJhY2sgbXV0ZSBzdGF0dXMgZG9lc24ndCBtYXRjaCBhY3R1YWwsIHdlJ2xsIGhhdmUgdG8gdXBkYXRlXG4gICAgLy8gdGhlIHNlcnZlcidzIGNvcHlcbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKHRpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh0aS5zaWQpO1xuICAgICAgaWYgKHB1Yikge1xuICAgICAgICBjb25zdCBtdXRlZE9uU2VydmVyID0gcHViLmlzTXV0ZWQgfHwgKChfYiA9IChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBzdHJlYW1QYXVzZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKTtcbiAgICAgICAgaWYgKG11dGVkT25TZXJ2ZXIgIT09IHRpLm11dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHNlcnZlciBtdXRlIHN0YXRlIGFmdGVyIHJlY29uY2lsZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YikpLCB7XG4gICAgICAgICAgICBtdXRlZE9uU2VydmVyXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRpLnNpZCwgbXV0ZWRPblNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEFjdGl2ZUFnZW50KGFnZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHRoaXMuZmlyc3RBY3RpdmVBZ2VudCA9IGFnZW50O1xuICAgIGlmIChhZ2VudCAmJiAhdGhpcy5maXJzdEFjdGl2ZUFnZW50KSB7XG4gICAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSBhZ2VudDtcbiAgICB9XG4gICAgaWYgKGFnZW50KSB7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGFnZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKF9kID0gKF9jID0gdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIG5ldyBFcnJvcignQWdlbnQgZGlzY29ubmVjdGVkJykpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlID0gdW5kZWZpbmVkO1xuICB9XG4gIHdhaXRVbnRpbEFjdGl2ZUFnZW50UHJlc2VudCgpIHtcbiAgICBpZiAodGhpcy5maXJzdEFjdGl2ZUFnZW50KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmlyc3RBY3RpdmVBZ2VudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkge1xuICAgICAgdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUucHJvbWlzZTtcbiAgfVxuICBnZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKSB7XG4gICAgbGV0IHB1YmxpY2F0aW9uO1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxvb2tzIG92ZXJseSBjb21wbGljYXRlZCBkdWUgdG8gdGhpcyBvYmplY3QgdHJlZVxuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sobG9jYWxUcmFjaykgfHwgaXNMb2NhbFZpZGVvVHJhY2sobG9jYWxUcmFjaykpIHtcbiAgICAgICAgICBpZiAobG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgICAgcHVibGljYXRpb24gPSBwdWI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrID09PSBsb2NhbFRyYWNrKSB7XG4gICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuICB3YWl0Rm9yUGVuZGluZ1B1YmxpY2F0aW9uT2ZTb3VyY2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHdhaXRGb3JQZW5kaW5nVGltZW91dCA9IDEwMDAwO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgc3RhcnRUaW1lICsgd2FpdEZvclBlbmRpbmdUaW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlRW50cnkgPSBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5lbnRyaWVzKCkpLmZpbmQoX3JlZjQgPT4ge1xuICAgICAgICAgIGxldCBbcGVuZGluZ1RyYWNrXSA9IF9yZWY0O1xuICAgICAgICAgIHJldHVybiBwZW5kaW5nVHJhY2suc291cmNlID09PSBzb3VyY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHVibGlzaFByb21pc2VFbnRyeSkge1xuICAgICAgICAgIHJldHVybiBwdWJsaXNoUHJvbWlzZUVudHJ5WzFdO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHNsZWVwKDIwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufWNsYXNzIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgY29uc3RydWN0b3Ioa2luZCwgdGksIGF1dG9TdWJzY3JpYmUsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0ZWREaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuaGFuZGxlRW5kZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdHJhY2spO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gdmlzaWJsZSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImFkYXB0aXZlc3RyZWFtIHZpZGVvIHZpc2liaWxpdHkgXCIuY29uY2F0KHRoaXMudHJhY2tTaWQsIFwiLCB2aXNpYmxlPVwiKS5jb25jYXQodmlzaWJsZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gZGltZW5zaW9ucyA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImFkYXB0aXZlc3RyZWFtIHZpZGVvIGRpbWVuc2lvbnMgXCIuY29uY2F0KGRpbWVuc2lvbnMud2lkdGgsIFwieFwiKS5jb25jYXQoZGltZW5zaW9ucy5oZWlnaHQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSA9IGRpbWVuc2lvbnM7XG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gYXV0b1N1YnNjcmliZTtcbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgdG8gdGhpcyByZW1vdGUgdHJhY2tcbiAgICogQHBhcmFtIHN1YnNjcmliZWQgdHJ1ZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgZmFsc2UgdG8gdW5zdWJzY3JpYmVcbiAgICovXG4gIHNldFN1YnNjcmliZWQoc3Vic2NyaWJlZCkge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgIC8vIHJlc2V0IGFsbG93ZWQgc3RhdHVzIHdoZW4gZGVzaXJlZCBzdWJzY3JpcHRpb24gc3RhdGUgY2hhbmdlc1xuICAgIC8vIHNlcnZlciB3aWxsIG5vdGlmeSBjbGllbnQgdmlhIHNpZ25hbCBtZXNzYWdlIGlmIGl0J3Mgbm90IGFsbG93ZWRcbiAgICBpZiAoc3Vic2NyaWJlZCkge1xuICAgICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIHN1YnNjcmliZTogdGhpcy5zdWJzY3JpYmVkLFxuICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtuZXcgUGFydGljaXBhbnRUcmFja3Moe1xuICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XG4gICAgICAgIC8vIHRoaXMgaXMgZmlsbGVkIGluIGJ5IHRoZSBwYXJ0aWNpcGFudCB0aGF0IHJlY2VpdmVzIHRoaXMgbWVzc2FnZVxuICAgICAgICBwYXJ0aWNpcGFudFNpZDogJycsXG4gICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdXG4gICAgICB9KV1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1Yik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICB9XG4gIGdldCBzdWJzY3JpcHRpb25TdGF0dXMoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5VbnN1YnNjcmliZWQ7XG4gICAgfVxuICAgIGlmICghc3VwZXIuaXNTdWJzY3JpYmVkKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuRGVzaXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlN1YnNjcmliZWQ7XG4gIH1cbiAgZ2V0IHBlcm1pc3Npb25TdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZCA/IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5BbGxvd2VkIDogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLk5vdEFsbG93ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0cmFjayBpcyBzdWJzY3JpYmVkLCBhbmQgcmVhZHkgZm9yIHBsYXliYWNrXG4gICAqL1xuICBnZXQgaXNTdWJzY3JpYmVkKCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XG4gIH1cbiAgLy8gcmV0dXJucyBjbGllbnQncyBkZXNpcmUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGFsc28gdHJ1ZSBpZiBhdXRvU3Vic2NyaWJlIGlzIGVuYWJsZWRcbiAgZ2V0IGlzRGVzaXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVkICE9PSBmYWxzZTtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RlZERpc2FibGVkICE9PSB1bmRlZmluZWQgPyAhdGhpcy5yZXF1ZXN0ZWREaXNhYmxlZCA6IHRoaXMuaXNBZGFwdGl2ZVN0cmVhbSA/IHRoaXMudmlzaWJsZSA6IHRydWU7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBkaXNhYmxlIHNlcnZlciBmcm9tIHNlbmRpbmcgZG93biBkYXRhIGZvciB0aGlzIHRyYWNrLiB0aGlzIGlzIHVzZWZ1bCB3aGVuXG4gICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cbiAgICogdG8gcmVkdWNlIGJhbmR3aWR0aCByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIGVuYWJsZWRcbiAgICovXG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLnJlcXVlc3RlZERpc2FibGVkID09PSAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RlZERpc2FibGVkID0gIWVuYWJsZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogZm9yIHRyYWNrcyB0aGF0IHN1cHBvcnQgc2ltdWxjYXN0aW5nLCBhZGp1c3Qgc3Vic2NyaWJlZCBxdWFsaXR5XG4gICAqXG4gICAqIFRoaXMgaW5kaWNhdGVzIHRoZSBoaWdoZXN0IHF1YWxpdHkgdGhlIGNsaWVudCBjYW4gYWNjZXB0LiBpZiBuZXR3b3JrXG4gICAqIGJhbmR3aWR0aCBkb2VzIG5vdCBhbGxvdywgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgcXVhbGl0eSB0b1xuICAgKiBvcHRpbWl6ZSBmb3IgdW5pbnRlcnJ1cHRlZCB2aWRlb1xuICAgKi9cbiAgc2V0VmlkZW9RdWFsaXR5KHF1YWxpdHkpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5ID09PSBxdWFsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRWaWRlb0RpbWVuc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogRXhwbGljaXRseSBzZXQgdGhlIHZpZGVvIGRpbWVuc2lvbnMgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIFRoaXMgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhZGFwdGl2ZSBzdHJlYW0gZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGRpbWVuc2lvbnMgVGhlIHZpZGVvIGRpbWVuc2lvbnMgdG8gc2V0LlxuICAgKi9cbiAgc2V0VmlkZW9EaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKChfYSA9IHRoaXMucmVxdWVzdGVkVmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBkaW1lbnNpb25zLndpZHRoICYmICgoX2IgPSB0aGlzLnJlcXVlc3RlZFZpZGVvRGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IGRpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlbW90ZVZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHRoaXMucmVxdWVzdGVkVmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgc2V0VmlkZW9GUFMoZnBzKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZwcyA9PT0gZnBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnBzID0gZnBzO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgZ2V0IHZpZGVvUXVhbGl0eSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBjb25zdCBwcmV2VHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIGlmIChwcmV2VHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmV2VHJhY2spIHtcbiAgICAgIC8vIHVucmVnaXN0ZXIgbGlzdGVuZXJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgcHJldlRyYWNrLmRldGFjaCgpO1xuICAgICAgcHJldlRyYWNrLnN0b3BNb25pdG9yKCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZUcmFjayk7XG4gICAgfVxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnNpZCA9IHRoaXMudHJhY2tTaWQ7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0QWxsb3dlZChhbGxvd2VkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHN1cGVyLnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhTXV0ZWQgPSB0aGlzLm1ldGFkYXRhTXV0ZWQ7XG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gaW5mby5tdXRlZDtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5zZXRNdXRlZChpbmZvLm11dGVkKTtcbiAgICB9IGVsc2UgaWYgKHByZXZNZXRhZGF0YU11dGVkICE9PSBpbmZvLm11dGVkKSB7XG4gICAgICB0aGlzLmVtaXQoaW5mby5tdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQpO1xuICAgIH1cbiAgfVxuICBlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gY3VycmVudFN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBjdXJyZW50U3RhdHVzLCBwcmV2aW91c1N0YXR1cyk7XG4gIH1cbiAgZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzICE9PSBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCB0aGlzLnBlcm1pc3Npb25TdGF0dXMsIHByZXZpb3VzUGVybWlzc2lvblN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHtcbiAgICBpZiAoIXRoaXMuaXNEZXNpcmVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjYW5ub3QgdXBkYXRlIHRyYWNrIHNldHRpbmdzIHdoZW4gbm90IHN1YnNjcmliZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZW1pdFRyYWNrVXBkYXRlKCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3Moe1xuICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF0sXG4gICAgICBkaXNhYmxlZDogIXRoaXMuaXNFbmFibGVkLFxuICAgICAgZnBzOiB0aGlzLmZwc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGxldCBtaW5EaW1lbnNpb25zID0gdGhpcy5yZXF1ZXN0ZWRWaWRlb0RpbWVuc2lvbnM7XG4gICAgICBpZiAodGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtaW5EaW1lbnNpb25zKSB7XG4gICAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgYWRhcHRpdmUgc3RyZWFtIGRpbWVuc2lvbnMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYW5kIHVzZSBzbWFsbGVyIG9uZVxuICAgICAgICAgIGNvbnN0IHNtYWxsZXJBZGFwdGl2ZSA9IGFyZURpbWVuc2lvbnNTbWFsbGVyKHRoaXMudmlkZW9EaW1lbnNpb25zQWRhcHRpdmVTdHJlYW0sIG1pbkRpbWVuc2lvbnMpO1xuICAgICAgICAgIGlmIChzbWFsbGVyQWRhcHRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGFwdGl2ZSBzdHJlYW0gZGltZW5zaW9ucyBpbnN0ZWFkIG9mIHJlcXVlc3RlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSkpO1xuICAgICAgICAgICAgbWluRGltZW5zaW9ucyA9IHRoaXMudmlkZW9EaW1lbnNpb25zQWRhcHRpdmVTdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudHJhY2tJbmZvKSB7XG4gICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhZGFwdGl2ZSBzdHJlYW0gZGltZW5zaW9ucyBhcmUgc21hbGxlciB0aGFuIHRoZSBtYXggcXVhbGl0eSBsYXllciBhbmQgdXNlIHNtYWxsZXIgb25lXG4gICAgICAgICAgY29uc3QgbWF4UXVhbGl0eUxheWVyID0gbGF5ZXJEaW1lbnNpb25zRm9yKHRoaXMudHJhY2tJbmZvLCB0aGlzLnJlcXVlc3RlZE1heFF1YWxpdHkpO1xuICAgICAgICAgIGlmIChtYXhRdWFsaXR5TGF5ZXIgJiYgYXJlRGltZW5zaW9uc1NtYWxsZXIodGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbSwgbWF4UXVhbGl0eUxheWVyKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGFkYXB0aXZlIHN0cmVhbSBkaW1lbnNpb25zIGluc3RlYWQgb2YgbWF4IHF1YWxpdHkgbGF5ZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHRoaXMudmlkZW9EaW1lbnNpb25zQWRhcHRpdmVTdHJlYW0pKTtcbiAgICAgICAgICAgIG1pbkRpbWVuc2lvbnMgPSB0aGlzLnZpZGVvRGltZW5zaW9uc0FkYXB0aXZlU3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYWRhcHRpdmUgc3RyZWFtIGRpbWVuc2lvbnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHRoaXMudmlkZW9EaW1lbnNpb25zQWRhcHRpdmVTdHJlYW0pKTtcbiAgICAgICAgICBtaW5EaW1lbnNpb25zID0gdGhpcy52aWRlb0RpbWVuc2lvbnNBZGFwdGl2ZVN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pbkRpbWVuc2lvbnMpIHtcbiAgICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwobWluRGltZW5zaW9ucy53aWR0aCk7XG4gICAgICAgIHNldHRpbmdzLmhlaWdodCA9IE1hdGguY2VpbChtaW5EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdGVkTWF4UXVhbGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyByZXF1ZXN0ZWQgbWF4IHF1YWxpdHknLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBxdWFsaXR5OiB0aGlzLnJlcXVlc3RlZE1heFF1YWxpdHlcbiAgICAgICAgfSkpO1xuICAgICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gdGhpcy5yZXF1ZXN0ZWRNYXhRdWFsaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGRlZmF1bHQgcXVhbGl0eScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdIXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICAgIHNldHRpbmdzLnF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufWNsYXNzIFJlbW90ZVBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBmcm9tUGFydGljaXBhbnRJbmZvKHNpZ25hbENsaWVudCwgcGksIGxvZ2dlck9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHNpZ25hbENsaWVudCwgcGkuc2lkLCBwaS5pZGVudGl0eSwgcGkubmFtZSwgcGkubWV0YWRhdGEsIHBpLmF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMsIHBpLmtpbmQpO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLmxvZ0NvbnRleHQpLCB7XG4gICAgICBycElEOiB0aGlzLnNpZCxcbiAgICAgIHJlbW90ZVBhcnRpY2lwYW50OiB0aGlzLmlkZW50aXR5XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgbGV0IGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IFBhcnRpY2lwYW50SW5mb19LaW5kLlNUQU5EQVJEO1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHkgfHwgJycsIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zLCBraW5kKTtcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52b2x1bWVNYXAgPSBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIHN1cGVyLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgIC8vIHJlZ2lzdGVyIGFjdGlvbiBldmVudHNcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZCB1cGRhdGUgc2V0dGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpLCB7XG4gICAgICAgIHNldHRpbmdzXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1YiA9PiB7XG4gICAgICBzdWIucGFydGljaXBhbnRUcmFja3MuZm9yRWFjaChwdCA9PiB7XG4gICAgICAgIHB0LnBhcnRpY2lwYW50U2lkID0gdGhpcy5zaWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBzdGF0dXMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBzdGF0dXMgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldmlvdXNUcmFjayA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgcHJldmlvdXNUcmFjaywgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uRmFpbGVkLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgcHVibGljYXRpb24udHJhY2tTaWQsIGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSkge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgYXVkaW8gdHJhY2tcbiAgICogYnkgZGVmYXVsdCwgdGhpcyBhZmZlY3RzIHRoZSBtaWNyb3Bob25lIHB1YmxpY2F0aW9uXG4gICAqIGEgZGlmZmVyZW50IHNvdXJjZSBjYW4gYmUgcGFzc2VkIGluIGFzIGEgc2Vjb25kIGFyZ3VtZW50XG4gICAqIGlmIG5vIHRyYWNrIGV4aXN0cyB0aGUgdm9sdW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBtaWNyb3Bob25lIHRyYWNrIGlzIGFkZGVkXG4gICAqL1xuICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgdGhpcy52b2x1bWVNYXAuc2V0KHNvdXJjZSwgdm9sdW1lKTtcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgYXVkaW9QdWJsaWNhdGlvbi50cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmIChhdWRpb1B1YmxpY2F0aW9uICYmIGF1ZGlvUHVibGljYXRpb24udHJhY2spIHtcbiAgICAgIHJldHVybiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrLmdldFZvbHVtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52b2x1bWVNYXAuZ2V0KHNvdXJjZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCBzaWQsIG1lZGlhU3RyZWFtLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgdHJpZXNMZWZ0KSB7XG4gICAgLy8gZmluZCB0aGUgdHJhY2sgcHVibGljYXRpb25cbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgbWVkaWEgdHJhY2sgdG8gYXJyaXZlIGJlZm9yZSBwYXJ0aWNpcGFudCBpbmZvXG4gICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQoc2lkKTtcbiAgICAvLyBpdCdzIGFsc28gcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBkaWRuJ3QgaG9ub3Igb3VyIG9yaWdpbmFsIHRyYWNrIGlkXG4gICAgLy8gRmlyZUZveCB3b3VsZCB1c2UgaXRzIG93biBsb2NhbCB1dWlkIGluc3RlYWQgb2Ygc2VydmVyIHRyYWNrIGlkXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKCFzaWQuc3RhcnRzV2l0aCgnVFInKSkge1xuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdHlwZVxuICAgICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxuICAgIC8vIHlldCBhcnJpdmVkLiBXYWl0IGEgYml0IGxvbmdlciBmb3IgaXQgdG8gYXJyaXZlLCBvciBmaXJlIGFuIGVycm9yXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGZpbmQgcHVibGlzaGVkIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgdHJhY2tTaWQ6IHNpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCAtIDEpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ3VuYWJsZSB0byBzdWJzY3JpYmUgYmVjYXVzZSBNZWRpYVN0cmVhbVRyYWNrIGlzIGVuZGVkLiBEbyBub3QgY2FsbCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xuICAgIGxldCB0cmFjaztcbiAgICBpZiAoaXNWaWRlbykge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlQXVkaW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb091dHB1dCk7XG4gICAgfVxuICAgIC8vIHNldCB0cmFjayBpbmZvXG4gICAgdHJhY2suc291cmNlID0gcHVibGljYXRpb24uc291cmNlO1xuICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcbiAgICB0cmFjay5pc011dGVkID0gcHVibGljYXRpb24uaXNNdXRlZDtcbiAgICB0cmFjay5zZXRNZWRpYVN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgdHJhY2suc3RhcnQoKTtcbiAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh0cmFjayk7XG4gICAgLy8gc2V0IHBhcnRpY2lwYW50IHZvbHVtZXMgb24gbmV3IGF1ZGlvIHRyYWNrc1xuICAgIGlmICh0aGlzLnZvbHVtZU1hcC5oYXMocHVibGljYXRpb24uc291cmNlKSAmJiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgaGFzTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXJ0aWNpcGFudEluZm87XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldChzaWQpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHdlIGFyZSBnZXR0aW5nIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHRyYWNrcywgcmVjb25jaWxlIGluIGhlcmVcbiAgICAvLyBhbmQgc2VuZCBvdXQgZXZlbnRzIGZvciBjaGFuZ2VzXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIHB1YmxpY2F0aW9ucywgcHVibGlzaCBldmVudHMgb25seSBpZiBtZXRhZGF0YSBpcyBhbHJlYWR5IHRoZXJlXG4gICAgLy8gaS5lLiBjaGFuZ2VzIHNpbmNlIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCBoYXMgam9pbmVkXG4gICAgY29uc3QgdmFsaWRUcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGluZm8udHJhY2tzLmZvckVhY2godGkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oa2luZCwgdGksIChfYSA9IHRoaXMuc2lnbmFsQ2xpZW50LmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1N1YnNjcmliZSwge1xuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIGxvZ2dlck5hbWU6IChfYiA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxvZ2dlck5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICBuZXdUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gcHVibGlzaGVkVHJhY2suc291cmNlID09PSAocHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHB1YmxpY2F0aW9uLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciBcIi5jb25jYXQodGhpcy5pZGVudGl0eSwgXCIgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiKS5jb25jYXQocHVibGljYXRpb24uc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBvbGRUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1RyYWNrT2ZTb3VyY2UpLFxuICAgICAgICAgICAgbmV3VHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkVHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbHdheXMgZW1pdCBldmVudHMgZm9yIG5ldyBwdWJsaWNhdGlvbnMsIFJvb20gd2lsbCBub3QgZm9yd2FyZCB0aGVtIHVubGVzcyBpdCdzIHJlYWR5XG4gICAgbmV3VHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVucHVibGlzaFRyYWNrKHNpZCwgc2VuZFVucHVibGlzaCkge1xuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQoc2lkKTtcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFsc28gc2VuZCB1bnN1YnNjcmliZSwgaWYgdHJhY2sgaXMgYWN0aXZlbHkgc3Vic2NyaWJlZFxuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNrXG4gICAgfSA9IHB1YmxpY2F0aW9uO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHRyYWNrIGZyb20gbWFwcyBvbmx5IGFmdGVyIHVuc3Vic2NyaWJlZCBoYXMgYmVlbiBmaXJlZFxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XG4gICAgLy8gcmVtb3ZlIGZyb20gdGhlIHJpZ2h0IHR5cGUgbWFwXG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZW5kVW5wdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvT3V0cHV0KG91dHB1dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmF1ZGlvT3V0cHV0ID0gb3V0cHV0O1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGlzQXVkaW9UcmFjayhwdWIudHJhY2spICYmIGlzUmVtb3RlVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZCgoX2EgPSBvdXRwdXQuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdkZWZhdWx0JykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5sb2cudHJhY2UoJ3BhcnRpY2lwYW50IGV2ZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBldmVudCxcbiAgICAgIGFyZ3NcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9XG59dmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiU2lnbmFsUmVjb25uZWN0aW5nXCJdID0gXCJzaWduYWxSZWNvbm5lY3RpbmdcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmNvbnN0IENPTk5FQ1RJT05fUkVDT05DSUxFX0ZSRVFVRU5DWV9NUyA9IDQgKiAxMDAwO1xuLyoqXG4gKiBJbiBMaXZlS2l0LCBhIHJvb20gaXMgdGhlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGEgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gKiBQYXJ0aWNpcGFudHMgaW4gYSByb29tIGNhbiBwdWJsaXNoIHRyYWNrcywgYW5kIHN1YnNjcmliZSB0byBvdGhlcnMnIHRyYWNrcy5cbiAqXG4gKiBhIFJvb20gZmlyZXMgW1tSb29tRXZlbnQgfCBSb29tRXZlbnRzXV0uXG4gKlxuICogQG5vSW5oZXJpdERvY1xuICovXG5jbGFzcyBSb29tIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgaGFzRTJFRVNldHVwKCkge1xuICAgIHJldHVybiB0aGlzLmUyZWVNYW5hZ2VyICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgc3VwZXIoKTtcbiAgICBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXG4gICAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAvKiogcmVmbGVjdHMgdGhlIHNlbmRlciBlbmNyeXB0aW9uIHN0YXR1cyBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQgKi9cbiAgICB0aGlzLmlzRTJFRUVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJwY0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29ubmVjdCA9ICh1cmwsIHRva2VuLCBvcHRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWlzQnJvd3NlclN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIldlYlJUQyBpc24ndCBkZXRlY3RlZCwgaGF2ZSB5b3UgY2FsbGVkIHJlZ2lzdGVyR2xvYmFscz9cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJMaXZlS2l0IGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLiBUcnkgdG8gdXBkYXRlIHlvdXIgYnJvd3NlciBhbmQgbWFrZSBzdXJlIG5vIGJyb3dzZXIgZXh0ZW5zaW9ucyBhcmUgZGlzYWJsaW5nIHdlYlJUQy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEluIGNhc2UgYSBkaXNjb25uZWN0IGNhbGxlZCBoYXBwZW5lZCByaWdodCBiZWZvcmUgdGhlIGNvbm5lY3QgY2FsbCwgbWFrZSBzdXJlIHRoZSBkaXNjb25uZWN0IGlzIGNvbXBsZXRlZCBmaXJzdCBieSBhd2FpdGluZyBpdHMgbG9ja1xuICAgICAgY29uc3QgdW5sb2NrRGlzY29ubmVjdCA9IHlpZWxkIHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgaXMgcmVjb25uZWN0aW5nIG9yIGNvbm5lY3RlZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJhbHJlYWR5IGNvbm5lY3RlZCB0byByb29tIFwiLmNvbmNhdCh0aGlzLm5hbWUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VydmVyVXJsKCkudG9TdHJpbmcoKSkgIT09IGVuc3VyZVRyYWlsaW5nU2xhc2godXJsKSkge1xuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgZmV0Y2ggd2l0aG91dCB3YWl0aW5nIGZvciBhIHJlc3BvbnNlXG4gICAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcnVuc1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3MoKS50aGVuKHNldHRpbmdzID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhzZXR0aW5ncyk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3RGbiA9IChyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGxpY2l0IGNyZWF0aW9uIGFzIGxvY2FsIHZhciBuZWVkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciB3aGVuIHBhc3NpbmcgaXQgdG8gYGF0dGVtcHRDb25uZWN0aW9uYCBmdXJ0aGVyIGRvd25cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgaW50ZW50aW9uIHRvIGNvbm5lY3QgaGFzIGJlZW4gc2lnbmFsbGVkIHNvIHdlIGNhbiBhbGxvdyBjYW5jZWxsaW5nIG9mIHRoZSBjb25uZWN0aW9uIHZpYSBkaXNjb25uZWN0KCkgYWdhaW5cbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCA9PT0gbnVsbCB8fCB1bmxvY2tEaXNjb25uZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgQmFja09mZlN0cmF0ZWd5LmdldEluc3RhbmNlKCkuZ2V0QmFja09mZlByb21pc2UodXJsKTtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBDb25uZWN0aW9uRXJyb3IuY2FuY2VsbGVkKCdDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCB0aGlzLmF0dGVtcHRDb25uZWN0aW9uKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyICYmIGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAmJiBlcnJvci5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFVybCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnRmV0Y2hpbmcgbmV4dCByZWdpb24nKTtcbiAgICAgICAgICAgICAgbmV4dFVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKF9hID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWwpO1xuICAgICAgICAgICAgfSBjYXRjaCAocmVnaW9uRmV0Y2hFcnJvcikge1xuICAgICAgICAgICAgICBpZiAocmVnaW9uRmV0Y2hFcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiAocmVnaW9uRmV0Y2hFcnJvci5zdGF0dXMgPT09IDQwMSB8fCByZWdpb25GZXRjaEVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgICAgIHJlamVjdChyZWdpb25GZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIG1ha2luZyBzdXJlIHdlIG9ubHkgcmVnaXN0ZXIgZmFpbGVkIGF0dGVtcHRzIG9uIHRoaW5ncyB3ZSBhY3R1YWxseSBjYXJlIGFib3V0XG4gICAgICAgICAgICBbQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLlRpbWVvdXRdLmluY2x1ZGVzKGVycm9yLnJlYXNvbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0FkZGluZyBmYWlsZWQgY29ubmVjdGlvbiBhdHRlbXB0IHRvIGJhY2sgb2ZmJyk7XG4gICAgICAgICAgICAgIEJhY2tPZmZTdHJhdGVneS5nZXRJbnN0YW5jZSgpLmFkZEZhaWxlZENvbm5lY3Rpb25BdHRlbXB0KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFVybCAmJiAhKChfYiA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJJbml0aWFsIGNvbm5lY3Rpb24gZmFpbGVkIHdpdGggQ29ubmVjdGlvbkVycm9yOiBcIi5jb25jYXQoZXJyb3IubWVzc2FnZSwgXCIuIFJldHJ5aW5nIHdpdGggYW5vdGhlciByZWdpb246IFwiKS5jb25jYXQobmV4dFVybCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICAgICAgeWllbGQgY29ubmVjdEZuKHJlc29sdmUsIHJlamVjdCwgbmV4dFVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXNjb25uZWN0UmVhc29uID0gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICBkaXNjb25uZWN0UmVhc29uID0gZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBkaXNjb25uZWN0UmVhc29uKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHRoaXMucmVnaW9uVXJsO1xuICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdEZuKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25GdXR1cmVzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3RTaWduYWwgPSAodXJsLCB0b2tlbiwgZW5naW5lLCBjb25uZWN0T3B0aW9ucywgcm9vbU9wdGlvbnMsIGFib3J0Q29udHJvbGxlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCBlbmdpbmUuam9pbih1cmwsIHRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IGNvbm5lY3RPcHRpb25zLmF1dG9TdWJzY3JpYmUsXG4gICAgICAgIGFkYXB0aXZlU3RyZWFtOiB0eXBlb2Ygcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnID8gdHJ1ZSA6IHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtLFxuICAgICAgICBtYXhSZXRyaWVzOiBjb25uZWN0T3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgICBlMmVlRW5hYmxlZDogISF0aGlzLmUyZWVNYW5hZ2VyLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiBjb25uZWN0T3B0aW9ucy53ZWJzb2NrZXRUaW1lb3V0LFxuICAgICAgICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogcm9vbU9wdGlvbnMuc2luZ2xlUGVlckNvbm5lY3Rpb25cbiAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgbGV0IHNlcnZlckluZm8gPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbztcbiAgICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgICBzZXJ2ZXJJbmZvID0ge1xuICAgICAgICAgIHZlcnNpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uLFxuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0gc2VydmVySW5mbztcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGVkIHRvIExpdmVraXQgU2VydmVyIFwiLmNvbmNhdChPYmplY3QuZW50cmllcyhzZXJ2ZXJJbmZvKS5tYXAoX3JlZiA9PiB7XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9KS5qb2luKCcsICcpKSwge1xuICAgICAgICByb29tOiAoX2EgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUsXG4gICAgICAgIHJvb21TaWQ6IChfYiA9IGpvaW5SZXNwb25zZS5yb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2lkLFxuICAgICAgICBpZGVudGl0eTogKF9jID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWRlbnRpdHlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZXJ2ZXJJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkU2VydmVyKCd1bmtub3duIHNlcnZlciB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2VydmVySW5mby52ZXJzaW9uID09PSAnMC4xNS4xJyAmJiB0aGlzLm9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBkeW5hY2FzdCBoYXMgYSBidWcgaW4gMC4xNS4xLCBzbyB3ZSBjYW5ub3QgdXNlIGl0IHRoZW5cbiAgICAgICAgcm9vbU9wdGlvbnMuZHluYWNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gICAgfSk7XG4gICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCBwaSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudDtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgPSBwaS5zaWQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPSBwaS5pZGVudGl0eTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRFbmFibGVkUHVibGlzaENvZGVjcyhqb2luUmVzcG9uc2UuZW5hYmxlZFB1Ymxpc2hDb2RlY3MpO1xuICAgICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFNpZlRyYWlsZXIoam9pblJlc3BvbnNlLnNpZlRyYWlsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ0NvdWxkIG5vdCBzZXQgU2lmVHJhaWxlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHBvcHVsYXRlIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHRoZXNlIHNob3VsZCBub3QgdHJpZ2dlciBuZXcgZXZlbnRzXG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcGksIC4uLmpvaW5SZXNwb25zZS5vdGhlclBhcnRpY2lwYW50c10pO1xuICAgICAgaWYgKGpvaW5SZXNwb25zZS5yb29tKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZShqb2luUmVzcG9uc2Uucm9vbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF0dGVtcHRDb25uZWN0aW9uID0gKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAoKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZW5kaW5nUmVjb25uZWN0KSkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGNsb3NlIGFuZCByZWNyZWF0ZSB0aGUgZXhpc3RpbmcgZW5naW5lIGluIG9yZGVyIHRvIGdldCByaWQgb2YgYW55IHBvdGVudGlhbGx5IG9uZ29pbmcgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBlbmdpbmUgaWYgcHJldmlvdXNseSBkaXNjb25uZWN0ZWRcbiAgICAgICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuc2V0UmVnaW9uVXJsUHJvdmlkZXIodGhpcy5yZWdpb25VcmxQcm92aWRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKTtcbiAgICAgIHRoaXMuY29ubk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMpLCBvcHRzKTtcbiAgICAgIGlmICh0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZykge1xuICAgICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY29ubmVjdFNpZ25hbCh1cmwsIHRva2VuLCB0aGlzLmVuZ2luZSwgdGhpcy5jb25uT3B0aW9ucywgdGhpcy5vcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICAgIC8vIGZvcndhcmQgbWV0YWRhdGEgY2hhbmdlZCBmb3IgdGhlIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgICAgIHRoaXMuc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ0Vycm9yID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkID8gQ29ubmVjdGlvbkVycm9yLmNhbmNlbGxlZCgnU2lnbmFsIGNvbm5lY3Rpb24gYWJvcnRlZCcpIDogQ29ubmVjdGlvbkVycm9yLnNlcnZlclVucmVhY2hhYmxlKCdjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uJyk7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChyZXN1bHRpbmdFcnJvci5tZXNzYWdlLCBcIjogXCIpLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnJlYXNvbiA9IGVyci5yZWFzb247XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImVycm9yIHRyeWluZyB0byBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KSk7XG4gICAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IENvbm5lY3Rpb25FcnJvci5jYW5jZWxsZWQoXCJDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBhbHNvIGhvb2sgdW5sb2FkIGV2ZW50XG4gICAgICBpZiAoaXNXZWIoKSAmJiB0aGlzLm9wdGlvbnMuZGlzY29ubmVjdE9uUGFnZUxlYXZlKSB7XG4gICAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XG4gICAgICBCYWNrT2ZmU3RyYXRlZ3kuZ2V0SW5zdGFuY2UoKS5yZXNldEZhaWxlZENvbm5lY3Rpb25BdHRlbXB0cyh1cmwpO1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIC8vIE5vdGlmeSByZWdpb24gcHJvdmlkZXIgYWJvdXQgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uXG4gICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLm5vdGlmeUNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgICAqL1xuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzXzEgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NfMVtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIFsuLi5hcmdzXzFdLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgIGxldCBzdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpczIuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5sb2cuZGVidWcoJ2FscmVhZHkgZGlzY29ubmVjdGVkJywgX3RoaXMyLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oJ2Rpc2Nvbm5lY3QgZnJvbSByb29tJywgT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IF90aGlzMi5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCBfdGhpczIuaXNSZXN1bWluZykge1xuICAgICAgICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCBkdWUgdG8gdXNlciBpbml0aWF0ZWQgZGlzY29ubmVjdCc7XG4gICAgICAgICAgICAgIF90aGlzMi5sb2cud2Fybihtc2csIF90aGlzMi5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgKF9hID0gX3RoaXMyLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KG1zZyk7XG4gICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpczIuY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIENvbm5lY3Rpb25FcnJvci5jYW5jZWxsZWQoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcpKTtcbiAgICAgICAgICAgICAgX3RoaXMyLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbG9zZSBlbmdpbmUgKGFsc28gY2xvc2VzIGNsaWVudClcbiAgICAgICAgICAgIGlmIChfdGhpczIuZW5naW5lKSB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgbGVhdmVcbiAgICAgICAgICAgICAgaWYgKCFfdGhpczIuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5lbmdpbmUuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVEaXNjb25uZWN0KHN0b3BUcmFja3MsIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCk7XG4gICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICBfdGhpczIuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vblBhZ2VMZWF2ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oJ1BhZ2UgbGVhdmUgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICAgKiBJbiB0aG9zZSBjYXNlcywgYXVkaW8gd2lsbCBiZSBzaWxlbnQgdW50aWwgYSBjbGljay90YXAgdHJpZ2dlcmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRBdWRpbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5vcyA9PT0gJ2lPUycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlPUyBibG9ja3MgYXVkaW8gZWxlbWVudCBwbGF5YmFjayBpZlxuICAgICAgICAgKiAtIHVzZXIgaXMgbm90IHB1Ymxpc2hpbmcgYXVkaW8gdGhlbXNlbHZlcyBhbmRcbiAgICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBhcyBhIHdvcmthcm91bmQsIHdlIGNyZWF0ZSBhbiBhdWRpbyBlbGVtZW50IHdpdGggYW4gZW1wdHkgdHJhY2ssIHNvIHRoYXRcbiAgICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdWRpb0lkID0gJ2xpdmVraXQtZHVtbXktYXVkaW8tZWwnO1xuICAgICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCk7XG4gICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzcmNPYmplY3QgdG8gbnVsbCBvbiBwYWdlIGhpZGUgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NrIHNjcmVlbiBjb250cm9scyB0byBzaG93IHVwIGZvciBpdFxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEF1ZGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcbiAgICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID09PSBudWxsIHx8IGR1bW15QXVkaW9FbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVtbXlBdWRpb0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGR1bW15QXVkaW9FbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAodC50cmFjaykge1xuICAgICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksIC4uLmVsZW1lbnRzLm1hcChlID0+IHtcbiAgICAgICAgICBlLm11dGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGUucGxheSgpO1xuICAgICAgICB9KV0pO1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0VmlkZW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdHIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5pbmNsdWRlcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGVsID0+IGVsLnBsYXkoKSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBpbiBjYXNlIHdlIHdlbnQgZnJvbSByZXN1bWluZyB0byBmdWxsLXJlY29ubmVjdCwgbWFrZSBzdXJlIHRvIHJlZmxlY3QgaXQgb24gdGhlIGlzUmVzdW1pbmcgZmxhZ1xuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLmlkZW50aXR5LCBwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBqb2luUmVzcG9uc2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJzaWduYWwgcmVjb25uZWN0ZWQgdG8gc2VydmVyLCByZWdpb24gXCIuY29uY2F0KGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICAgIHlpZWxkIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlclwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gcmVjb25uZWN0aW9uIGZhaWxlZCwgaGFuZGxlRGlzY29ubmVjdCBpcyBiZWluZyBpbnZva2VkIGFscmVhZHksIGp1c3QgcmV0dXJuIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgdGhpcy5lbWl0QnVmZmVyZWRFdmVudHMoKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IHBhcnRpY2lwYW50SW5mb3MgPT4ge1xuICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGl2ZUtpdCBzZXJ2ZXIgZG9lc24ndCBzZW5kIGlkZW50aXR5IGluZm8gcHJpb3IgdG8gdmVyc2lvbiAxLjUuMiBpbiBkaXNjb25uZWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gc28gd2UgdHJ5IHRvIG1hcCBhbiBlbXB0eSBpZGVudGl0eSB0byBhbiBhbHJlYWR5IGtub3duIHNJRCBtYW51YWxseVxuICAgICAgICBpZiAoaW5mby5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgICAgICBpbmZvLmlkZW50aXR5ID0gKF9hID0gdGhpcy5zaWRUb0lkZW50aXR5LmdldChpbmZvLnNpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXG4gICAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpbmZvLmlkZW50aXR5LCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLmlkZW50aXR5LCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBzZWVuU2lkc1tzcGVha2VyLnNpZF0gPSB0cnVlO1xuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3BlYWtlci5zaWQpO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocC5pZGVudGl0eSk7XG4gICAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudCAmJiByZW1vdGVQYXJ0aWNpcGFudC5zaWQgIT09IHAuc2lkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTcGVha2Vycy5zZXQocC5zaWQsIHApO1xuICAgICAgfSk7XG4gICAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBsZXQgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XG4gICAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG4gICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5zZXQoc3BlYWtlci5zaWQsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgICAgYWN0aXZlU3BlYWtlcnMuc29ydCgoYSwgYikgPT4gYi5hdWRpb0xldmVsIC0gYS5hdWRpb0xldmVsKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IHN0cmVhbVN0YXRlVXBkYXRlID0+IHtcbiAgICAgIHN0cmVhbVN0YXRlVXBkYXRlLnN0cmVhbVN0YXRlcy5mb3JFYWNoKHN0cmVhbVN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3RyZWFtU3RhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICAgIHB1Yi50cmFjay5zZXRTdHJlYW1TdGF0ZShuZXdTdHJlYW1TdGF0ZSk7XG4gICAgICAgIGlmIChuZXdTdHJlYW1TdGF0ZSAhPT0gcHViLnRyYWNrLnN0cmVhbVN0YXRlKSB7XG4gICAgICAgICAgcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHVwZGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldEFsbG93ZWQodXBkYXRlLmFsbG93ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvciA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnRyYWNrUHVibGljYXRpb25zLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0U3Vic2NyaXB0aW9uRXJyb3IodXBkYXRlLmVycik7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSAocGFja2V0LCBlbmNyeXB0aW9uVHlwZSkgPT4ge1xuICAgICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXNlclBhY2tldChwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlLCBwYWNrZXQua2luZCwgZW5jcnlwdGlvblR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3RyYW5zY3JpcHRpb24nKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNjcmlwdGlvbihwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzaXBEdG1mJykge1xuICAgICAgICB0aGlzLmhhbmRsZVNpcER0bWYocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnY2hhdE1lc3NhZ2UnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhdE1lc3NhZ2UocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnbWV0cmljcycpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVNZXRyaWNzKHBhY2tldC52YWx1ZS52YWx1ZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUhlYWRlcicgfHwgcGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1DaHVuaycgfHwgcGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1UcmFpbGVyJykge1xuICAgICAgICB0aGlzLmhhbmRsZURhdGFTdHJlYW0ocGFja2V0LCBlbmNyeXB0aW9uVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAncnBjUmVxdWVzdCcpIHtcbiAgICAgICAgY29uc3QgcnBjID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVxdWVzdChwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSwgcnBjLmlkLCBycGMubWV0aG9kLCBycGMucGF5bG9hZCwgcnBjLnJlc3BvbnNlVGltZW91dE1zLCBycGMudmVyc2lvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQgPSAocGFydGljaXBhbnQsIHVzZXJQYWNrZXQsIGtpbmQsIGVuY3J5cHRpb25UeXBlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBwYXJ0aWNpcGFudCwga2luZCwgdXNlclBhY2tldC50b3BpYywgZW5jcnlwdGlvblR5cGUpO1xuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwga2luZCwgZW5jcnlwdGlvblR5cGUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaXBEdG1mID0gKHBhcnRpY2lwYW50LCBkdG1mKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpcERUTUZSZWNlaXZlZCwgZHRtZiwgcGFydGljaXBhbnQpO1xuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uID0gKF9yZW1vdGVQYXJ0aWNpcGFudCwgdHJhbnNjcmlwdGlvbikgPT4ge1xuICAgICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdHJhbnNjcmlwdGlvbi50cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA/IHRoaXMubG9jYWxQYXJ0aWNpcGFudCA6IHRoaXMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHRyYW5zY3JpcHRpb24udHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFuc2NyaXB0aW9uLnRyYWNrSWQpO1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKHRyYW5zY3JpcHRpb24sIHRoaXMudHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXMpO1xuICAgICAgcHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLmVtaXQoVHJhY2tFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzKTtcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cywgcHVibGljYXRpb24pO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzLCBwYXJ0aWNpcGFudCwgcHVibGljYXRpb24pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDaGF0TWVzc2FnZSA9IChwYXJ0aWNpcGFudCwgY2hhdE1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IG1zZyA9IGV4dHJhY3RDaGF0TWVzc2FnZShjaGF0TWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNoYXRNZXNzYWdlLCBtc2csIHBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlTWV0cmljcyA9IChtZXRyaWNzLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZXRyaWNzUmVjZWl2ZWQsIG1ldHJpY3MsIHBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YVN0cmVhbSA9IChwYWNrZXQsIGVuY3J5cHRpb25UeXBlKSA9PiB7XG4gICAgICB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIuaGFuZGxlRGF0YVN0cmVhbVBhY2tldChwYWNrZXQsIGVuY3J5cHRpb25UeXBlKTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWRTZWdtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCA9IGUgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHBsYXliYWNrIGF1ZGlvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9zKSAhPT0gJ2lPUycpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBkZXZpY2VzIGFyZSBub24gZGV0ZXJtaW5pc3RpYyBvbiBpT1MsIHNvIHdlIGRvbid0IGF0dGVtcHQgdG8gc2VsZWN0IHRoZW0gaGVyZVxuICAgICAgICB5aWVsZCB0aGlzLnNlbGVjdERlZmF1bHREZXZpY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb20gPT4ge1xuICAgICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcbiAgICAgIGlmIChvbGRSb29tICYmIG9sZFJvb20ubWV0YWRhdGEgIT09IHJvb20ubWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKG9sZFJvb20gPT09IG51bGwgfHwgb2xkUm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkUm9vbS5hY3RpdmVSZWNvcmRpbmcpICE9PSByb29tLmFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKGluZm8ucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCA9IGNoYW5nZWRBdHRyaWJ1dGVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja011dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUgPSBwcm9jZXNzb3IgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gcHJvY2Vzc29yID09PSBudWxsIHx8IHByb2Nlc3NvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzc29yLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvY2Vzc29yLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub24oVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcbiAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uKFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCk7XG4gICAgICAoX2UgPSAoX2QgPSAoX2MgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9jZXNzb3IoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgcHViLnRyYWNrLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCAoX2YgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXREZXZpY2VJZChmYWxzZSk7XG4gICAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHB1YiA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2ZmKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vZmYoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMub25Mb2NhbFRyYWNrUmVzdGFydGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgdHJhY2suZ2V0RGV2aWNlSWQoZmFsc2UpO1xuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZCh0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwibG9jYWwgdHJhY2sgcmVzdGFydGVkLCBzZXR0aW5nIFwiLmNvbmNhdChkZXZpY2VLaW5kLCBcIiBcIikuY29uY2F0KGRldmljZUlkLCBcIiBhY3RpdmVcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gcXVhbGl0eSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYURldmljZXNFcnJvciA9IChlLCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlLCBraW5kKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCA9IG1zZyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNoYXRNZXNzYWdlLCBtc2csIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21PcHRpb25EZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5Sb29tKTtcbiAgICB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXVkaW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICB0aGlzLm9wdGlvbnMucHVibGlzaERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHVibGlzaERlZmF1bHRzKTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgdGhpcy5pbmNvbWluZ0RhdGFTdHJlYW1NYW5hZ2VyID0gbmV3IEluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIoKTtcbiAgICB0aGlzLm91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIgPSBuZXcgT3V0Z29pbmdEYXRhU3RyZWFtTWFuYWdlcih0aGlzLmVuZ2luZSwgdGhpcy5sb2cpO1xuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KCcnLCAnJywgdGhpcy5lbmdpbmUsIHRoaXMub3B0aW9ucywgdGhpcy5ycGNIYW5kbGVycywgdGhpcy5vdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUgfHwgdGhpcy5vcHRpb25zLmVuY3J5cHRpb24pIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFKCk7XG4gICAgfVxuICAgIHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyID0gdGhpcy5lMmVlTWFuYWdlcjtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldCgndmlkZW9pbnB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCdhdWRpb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgaWYgKChfYiA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSB7XG4gICAgICB0aGlzLnN3aXRjaEFjdGl2ZURldmljZSgnYXVkaW9vdXRwdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCkpLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiBcIi5jb25jYXQoZS5tZXNzYWdlKSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAvLyBpbiBvcmRlciB0byBjYXRjaCBkZXZpY2UgY2hhbmdlcyBwcmlvciB0byByb29tIGNvbm5lY3Rpb24gd2UgbmVlZCB0byByZWdpc3RlciB0aGUgZXZlbnQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAoX2MgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmIChSb29tLmNsZWFudXBSZWdpc3RyeSkge1xuICAgICAgICBSb29tLmNsZWFudXBSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKTtcbiAgfVxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spO1xuICB9XG4gIHVucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYykge1xuICAgIHJldHVybiB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKTtcbiAgfVxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgdGhlIHBhcnRpY2lwYW50IGFzIGEgcmVjZWl2ZXIgZm9yIGNhbGxzIG9mIHRoZSBzcGVjaWZpZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBpbmRpY2F0ZWQgUlBDIG1ldGhvZFxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFdpbGwgYmUgaW52b2tlZCB3aGVuIGFuIFJQQyByZXF1ZXN0IGZvciB0aGlzIG1ldGhvZCBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRob2QgaXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWRcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGEgaGFuZGxlciBmb3IgdGhpcyBtZXRob2QgaXMgYWxyZWFkeSByZWdpc3RlcmVkIChtdXN0IGNhbGwgdW5yZWdpc3RlclJwY01ldGhvZCBmaXJzdClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByb29tLmxvY2FsUGFydGljaXBhbnQ/LnJlZ2lzdGVyUnBjTWV0aG9kKFxuICAgKiAgICdncmVldCcsXG4gICAqICAgYXN5bmMgKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgZ3JlZXRpbmcgZnJvbSAke2RhdGEuY2FsbGVySWRlbnRpdHl9OiAke2RhdGEucGF5bG9hZH1gKTtcbiAgICogICAgIHJldHVybiBgSGVsbG8sICR7ZGF0YS5jYWxsZXJJZGVudGl0eX0hYDtcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgKiBJZiB1bmFibGUgdG8gcmVzcG9uZCB3aXRoaW4gYHJlc3BvbnNlVGltZW91dGAsIHRoZSByZXF1ZXN0IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIG9uIHRoZSBjYWxsZXIncyBzaWRlLlxuICAgKlxuICAgKiBZb3UgbWF5IHRocm93IGVycm9ycyBvZiB0eXBlIGBScGNFcnJvcmAgd2l0aCBhIHN0cmluZyBgbWVzc2FnZWAgaW4gdGhlIGhhbmRsZXIsXG4gICAqIGFuZCB0aGV5IHdpbGwgYmUgcmVjZWl2ZWQgb24gdGhlIGNhbGxlcidzIHNpZGUgd2l0aCB0aGUgbWVzc2FnZSBpbnRhY3QuXG4gICAqIE90aGVyIGVycm9ycyB0aHJvd24gaW4geW91ciBoYW5kbGVyIHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIGFzLWlzLCBhbmQgd2lsbCBpbnN0ZWFkIGFycml2ZSB0byB0aGUgY2FsbGVyIGFzIGAxNTAwYCAoXCJBcHBsaWNhdGlvbiBFcnJvclwiKS5cbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlJQQyBoYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kIFwiLmNvbmNhdChtZXRob2QsIFwiLCB1bnJlZ2lzdGVyUnBjTWV0aG9kIGJlZm9yZSB0cnlpbmcgdG8gcmVnaXN0ZXIgYWdhaW5cIikpO1xuICAgIH1cbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG5hbWUgb2YgdGhlIFJQQyBtZXRob2QgdG8gdW5yZWdpc3RlclxuICAgKi9cbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcbiAgICB0aGlzLnJwY0hhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICB9XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCldKTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwRTJFRSgpIHtcbiAgICAvLyB3aGVuIGVuY3J5cHRpb24gaXMgZW5hYmxlZCB2aWEgYG9wdGlvbnMuZW5jcnlwdGlvbmAsIHdlIGVuYWJsZSBkYXRhIGNoYW5uZWwgZW5jcnlwdGlvblxuICAgIHZhciBfYTtcbiAgICBjb25zdCBkY0VuY3J5cHRpb25FbmFibGVkID0gISF0aGlzLm9wdGlvbnMuZW5jcnlwdGlvbjtcbiAgICBjb25zdCBlMmVlT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5lbmNyeXB0aW9uIHx8IHRoaXMub3B0aW9ucy5lMmVlO1xuICAgIGlmIChlMmVlT3B0aW9ucykge1xuICAgICAgaWYgKCdlMmVlTWFuYWdlcicgaW4gZTJlZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IGUyZWVPcHRpb25zLmUyZWVNYW5hZ2VyO1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLmlzRGF0YUNoYW5uZWxFbmNyeXB0aW9uRW5hYmxlZCA9IGRjRW5jcnlwdGlvbkVuYWJsZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gbmV3IEUyRUVNYW5hZ2VyKGUyZWVPcHRpb25zLCBkY0VuY3J5cHRpb25FbmFibGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIChlbmFibGVkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBpZiAoaXNMb2NhbFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KSkge1xuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgKGVycm9yLCBwYXJ0aWNpcGFudElkZW50aXR5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gcGFydGljaXBhbnRJZGVudGl0eSA/IHRoaXMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHBhcnRpY2lwYW50SWRlbnRpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pO1xuICAgICAgKF9hID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldHVwKHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubmFtZSxcbiAgICAgIHJvb21JRDogKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICBwSUQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQuXG4gICAqIHJldHVybnMgb25jZSBhIHNpZCBoYXMgYmVlbiBpc3N1ZWQgYnkgdGhlIHNlcnZlci5cbiAgICovXG4gIGdldFNpZCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucm9vbUluZm8gJiYgdGhpcy5yb29tSW5mby5zaWQgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb21JbmZvLnNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVJvb21VcGRhdGUgPSByb29tSW5mbyA9PiB7XG4gICAgICAgICAgaWYgKHJvb21JbmZvLnNpZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICAgIHJlc29sdmUocm9vbUluZm8uc2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xuICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICByZWplY3QoJ1Jvb20gZGlzY29ubmVjdGVkIGJlZm9yZSByb29tIHNlcnZlciBpZCB3YXMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIHVzZXIgYXNzaWduZWQgbmFtZSwgZGVyaXZlZCBmcm9tIEpXVCB0b2tlbiAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gIH1cbiAgLyoqIHJvb20gbWV0YWRhdGEgKi9cbiAgZ2V0IG1ldGFkYXRhKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhO1xuICB9XG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bVBhcnRpY2lwYW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBnZXQgbnVtUHVibGlzaGVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUHVibGlzaGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgfVxuICBtYXliZUNyZWF0ZUVuZ2luZSgpIHtcbiAgICBpZiAodGhpcy5lbmdpbmUgJiYgIXRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5naW5lID0gbmV3IFJUQ0VuZ2luZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuZW5naW5lLmUyZWVNYW5hZ2VyID0gdGhpcy5lMmVlTWFuYWdlcjtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMpLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCkub24oRW5naW5lRXZlbnQuU3RyZWFtU3RhdGVDaGFuZ2VkLCB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlKS5vbihFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkub24oRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCAobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikgPT4ge1xuICAgICAgdGhpcy5vblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcik7XG4gICAgfSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCByZWFzb24pO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlKS5vbihFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIHRoaXMuaGFuZGxlRGF0YVBhY2tldCkub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLmlzUmVzdW1pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuU2lnbmFsUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdW1lZCwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1lZCBzaWduYWwgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkRXZlbnRzKCk7XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZykge1xuICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQpLm9uKEVuZ2luZUV2ZW50Lk9mZmxpbmUsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgKHN0YXR1cywga2luZCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgfSkub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHN1YnNjcmliZWRTaWQgPT4ge1xuICAgICAgY29uc3QgdHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpLmZpbmQoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHRyYWNrU2lkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2lkID09PSBzdWJzY3JpYmVkU2lkO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGZpbmQgbG9jYWwgdHJhY2sgc3Vic2NyaXB0aW9uIGZvciBzdWJzY3JpYmVkIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tQdWJsaWNhdGlvbiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5Sb29tTW92ZWQsIHJvb21Nb3ZlZCA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygncm9vbSBtb3ZlZCcsIHJvb21Nb3ZlZCk7XG4gICAgICBpZiAocm9vbU1vdmVkLnJvb20pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKHJvb21Nb3ZlZC5yb29tKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50LCBpZGVudGl0eSkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTW92ZWQsIHJvb21Nb3ZlZC5yb29tLm5hbWUpO1xuICAgICAgaWYgKHJvb21Nb3ZlZC5wYXJ0aWNpcGFudCkge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcm9vbU1vdmVkLnBhcnRpY2lwYW50LCAuLi5yb29tTW92ZWQub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKHJvb21Nb3ZlZC5vdGhlclBhcnRpY2lwYW50cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRnb2luZ0RhdGFTdHJlYW1NYW5hZ2VyKSB7XG4gICAgICB0aGlzLm91dGdvaW5nRGF0YVN0cmVhbU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IHJlcXVlc3RzIGRldmljZSBwZXJtaXNzaW9ucyBieSBkZWZhdWx0IGlmIG5lZWRlZFxuICAgKiBhbmQgbWFrZXMgc3VyZSB0aGUgcmV0dXJuZWQgZGV2aWNlIGRvZXMgbm90IGNvbnNpc3Qgb2YgZHVtbXkgZGV2aWNlc1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGxvY2FsIGRldmljZXNcbiAgICovXG4gIHN0YXRpYyBnZXRMb2NhbERldmljZXMoa2luZCkge1xuICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXREZXZpY2VzKGtpbmQsIHJlcXVlc3RQZXJtaXNzaW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIHByZXBhcmVDb25uZWN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyBsb2FkZWQsIGluIG9yZGVyXG4gICAqIHRvIHNwZWVkIHVwIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAtIHBlcmZvcm0gRE5TIHJlc29sdXRpb24gYW5kIHByZS13YXJtIHRoZSBETlMgY2FjaGVcbiAgICogLSBlc3RhYmxpc2ggVExTIGNvbm5lY3Rpb24gYW5kIGNhY2hlIFRMUyBrZXlzXG4gICAqXG4gICAqIFdpdGggTGl2ZUtpdCBDbG91ZCwgaXQgd2lsbCBhbHNvIGRldGVybWluZSB0aGUgYmVzdCBlZGdlIGRhdGEgY2VudGVyIGZvclxuICAgKiB0aGUgY3VycmVudCBjbGllbnQgdG8gY29ubmVjdCB0byBpZiBhIHRva2VuIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgcHJlcGFyZUNvbm5lY3Rpb24odXJsLCB0b2tlbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSAmJiB0b2tlbikge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICAgIC8vIHdlIHdpbGwgbm90IHJlcGxhY2UgdGhlIHJlZ2lvblVybCBpZiBhbiBhdHRlbXB0IGhhZCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgICBpZiAocmVnaW9uVXJsICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uVXJsID0gcmVnaW9uVXJsO1xuICAgICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBmZXRjaCh0b0h0dHBVcmwodXJsKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcHJlcGFyZSBjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxuICAgKiBAcGFyYW0gaWRlbnRpdHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xuICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIGZvciB0ZXN0aW5nXG4gICAqL1xuICBzaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvLCBhcmcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7fSk7XG4gICAgICBsZXQgcmVxO1xuICAgICAgc3dpdGNoIChzY2VuYXJpbykge1xuICAgICAgICBjYXNlICdzaWduYWwtcmVjb25uZWN0JzpcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGVha2VyJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc3BlYWtlclVwZGF0ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiAzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VydmVyLWxlYXZlJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnc2VydmVyTGVhdmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWdyYXRpb24nOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdtaWdyYXRpb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcbiAgICAgICAgICB0aGlzLmVuZ2luZS5mYWlsTmV4dCgpO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBmdWxsLXJlY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgICBjYXNlICdmb3JjZS10bHMnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzd2l0Y2hDYW5kaWRhdGVQcm90b2NvbCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvbkxlYXZlID0gdGhpcy5lbmdpbmUuY2xpZW50Lm9uTGVhdmU7XG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgICBvbkxlYXZlKG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAgICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1RcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWJzY3JpYmVyLWJhbmR3aWR0aCc6XG4gICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzdWJzY3JpYmVyQmFuZHdpZHRoJyxcbiAgICAgICAgICAgICAgdmFsdWU6IG51bWJlclRvQmlnSW50KGFyZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVhdmUtZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdsZWF2ZVJlcXVlc3RGdWxsUmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICAgIHlpZWxkIHBvc3RBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja0F1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG4gIGdldEFjdGl2ZURldmljZShraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZXMgdXNlZCBpbiB0aGlzIHJvb20gdG8gdGhlIGdpdmVuIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICAgKlxuICAgKiBAcGFyYW0ga2luZCB1c2UgYHZpZGVvaW5wdXRgIGZvciBjYW1lcmEgdHJhY2ssXG4gICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXG4gICAqICBgYXVkaW9vdXRwdXRgIHRvIHNldCBzcGVha2VyIGZvciBhbGwgaW5jb21pbmcgYXVkaW8gdHJhY2tzXG4gICAqIEBwYXJhbSBkZXZpY2VJZFxuICAgKi9cbiAgc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmRfMSwgZGV2aWNlSWRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kLCBkZXZpY2VJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBsZXQgZXhhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHZhciBfZztcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBsZXQgc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkZXZpY2VDb25zdHJhaW50ID0gZXhhY3QgPyB7XG4gICAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICAgIH0gOiBkZXZpY2VJZDtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9hID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQuYXVkaW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTXV0ZWQgPSB0cmFja3Muc29tZSh0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdC50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzTXV0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzdWNjZXNzICYmIGlzTXV0ZWQpIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9iID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNNdXRlZCA9IHRyYWNrcy5zb21lKHQgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0LnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNNdXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgaXNNdXRlZCkgc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgICAgIHNob3VsZFRyaWdnZXJJbW1lZGlhdGVEZXZpY2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoKSAmJiAhX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggfHwgX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggJiYgX3RoaXMzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIF90aGlzMy5hdWRpb0NvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCB0aGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgaXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBkZWZhdWx0YCBmb3Igd2ViIGF1ZGlvIG91dHB1dCBkb2Vzbid0IHdvcmssIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBpZCBiZWZvcmVcbiAgICAgICAgICAgIGRldmljZUlkID0gKF9jID0geWllbGQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKCdhdWRpb291dHB1dCcsIGRldmljZUlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfZCA9IChfZyA9IF90aGlzMy5vcHRpb25zKS5hdWRpb091dHB1dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX2cuYXVkaW9PdXRwdXQgPSB7fTtcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2UgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgICAoX2YgPSBfdGhpczMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gc2V0IGF1ZGlvIG91dHB1dCBvbiBhbGwgYXVkaW8gZWxlbWVudHMsIGV2ZW4gaWYgd2ViQXVkaW9NaXggaXMgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGVjaG8gY2FuY2VsbGF0aW9uIG5vdCB3b3JraW5nIG9uIGNocm9tZSB3aXRoIG5vbi1kZWZhdWx0IG91dHB1dCBkZXZpY2VzXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI1MjkxMSNjb21tZW50N1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShfdGhpczMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5tYXAocCA9PiBwLnNldEF1ZGlvT3V0cHV0KHtcbiAgICAgICAgICAgICAgZGV2aWNlSWRcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVHJpZ2dlckltbWVkaWF0ZURldmljZUNoYW5nZSkge1xuICAgICAgICAgIF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwgZGV2aWNlSWQpO1xuICAgICAgICAgIF90aGlzMy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCkge1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub24oUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XG4gIH1cbiAgcmVjcmVhdGVFbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgLy8gY2xlYXIgb3V0IGV4aXN0aW5nIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHNpbmNlIHRoZXkgbWF5IGhhdmUgYXR0YWNoZWRcbiAgICAvLyB0aGUgb2xkIGVuZ2luZVxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgfVxuICBvblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkZWZlcnJpbmcgb24gdHJhY2sgZm9yIGxhdGVyJywge1xuICAgICAgICAgIG1lZGlhVHJhY2tJZDogbWVkaWFUcmFjay5pZCxcbiAgICAgICAgICBtZWRpYVN0cmVhbUlkOiBzdHJlYW0uaWQsXG4gICAgICAgICAgdHJhY2tzSW5TdHJlYW06IHN0cmVhbS5nZXRUcmFja3MoKS5tYXAodHJhY2sgPT4gdHJhY2suaWQpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5sb2cud2Fybignc2tpcHBpbmcgaW5jb21pbmcgdHJhY2sgYWZ0ZXIgUm9vbSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhcyBpdCBhbHJlYWR5IGVuZGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50U2lkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuICAgIGlmIChwYXJ0aWNpcGFudFNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgdGhpcy5sb2cud2FybigndHJpZWQgdG8gY3JlYXRlIFJlbW90ZVBhcnRpY2lwYW50IGZvciBsb2NhbCBwYXJ0aWNpcGFudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAuc2lkID09PSBwYXJ0aWNpcGFudFNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGluIHNpbmdsZSBwZWVyIGNvbm5lY3Rpb24gY2FzZSwgdGhlIHRyYWNrSUQgaXMgbG9jYWxseSBnZW5lcmF0ZWQsXG4gICAgLy8gbm90IHRoZSBUUl8gcHJlZml4ZWQgb25lIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyLFxuICAgIC8vIHVzZSBgbWlkYCB0byBmaW5kIHRoZSBhcHByb3ByaWF0ZSB0cmFjay5cbiAgICBpZiAoIXRyYWNrSWQuc3RhcnRzV2l0aCgnVFInKSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmVuZ2luZS5nZXRUcmFja0lkRm9yUmVjZWl2ZXIocmVjZWl2ZXIpO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIlRyaWVkIHRvIGFkZCBhIHRyYWNrIHdob3NlICdzaWQnIGNvdWxkIG5vdCBiZSBmb3VuZCBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICB9XG4gICAgaWYgKCF0cmFja0lkLnN0YXJ0c1dpdGgoJ1RSJykpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oXCJUcmllZCB0byBhZGQgYSB0cmFjayB3aG9zZSAnc2lkJyBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudFNpZCwgXCIsIHN0cmVhbUlkOiBcIikuY29uY2F0KHN0cmVhbUlkLCBcIiwgdHJhY2tJZDogXCIpLmNvbmNhdCh0cmFja0lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJwSUQ6IHBhcnRpY2lwYW50U2lkLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdHJhY2tJZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBsZXQgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgICBpZiAodGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljYXRpb24gPSBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCB0cmFja0lkLCBzdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICBpZiAoKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5pc0VuY3J5cHRlZCkgJiYgIXRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgXCIuY29uY2F0KHB1YmxpY2F0aW9uLnNvdXJjZSwgXCIgdHJhY2sgcmVjZWl2ZWQgZnJvbSBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50LnNpZCwgXCIsIGJ1dCByb29tIGRvZXMgbm90IGhhdmUgZW5jcnlwdGlvbiBlbmFibGVkIVwiKSkpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgIGxldCBzaG91bGRTdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcy5jbGVhcigpO1xuICAgIHRoaXMuaW5jb21pbmdEYXRhU3RyZWFtTWFuYWdlci5jbGVhckNvbnRyb2xsZXJzKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgLy8gTm90aWZ5IHJlZ2lvbiBwcm92aWRlciBhYm91dCBkaXNjb25uZWN0IHRvIHBvdGVudGlhbGx5IHN0b3AgYXV0by1yZWZldGNoXG4gICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIubm90aWZ5RGlzY29ubmVjdGVkKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2ssIHNob3VsZFN0b3BUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTdG9wVHJhY2tzKSB7XG4gICAgICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV0YWNoKCk7XG4gICAgICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYyA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0b3BNb25pdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICAoX2EgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaWRlbnRpdHksIHBhcnRpY2lwYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHJlbW92ZSBhbmQgc2VuZCBldmVudFxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmRlbGV0ZShpZGVudGl0eSk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluY29taW5nRGF0YVN0cmVhbU1hbmFnZXIudmFsaWRhdGVQYXJ0aWNpcGFudEhhc05vQWN0aXZlRGF0YVN0cmVhbXMoaWRlbnRpdHkpO1xuICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICBwYXJ0aWNpcGFudC5zZXREaXNjb25uZWN0ZWQoKTtcbiAgICAoX2EgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0KGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG1ldGhvZCwgcGF5bG9hZCwgcmVzcG9uc2VUaW1lb3V0LCB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNBY2soY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCk7XG4gICAgICBpZiAodmVyc2lvbiAhPT0gMSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgbnVsbCwgUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfVkVSU0lPTicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucnBjSGFuZGxlcnMuZ2V0KG1ldGhvZCk7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1VOU1VQUE9SVEVEX01FVEhPRCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3BvbnNlRXJyb3IgPSBudWxsO1xuICAgICAgbGV0IHJlc3BvbnNlUGF5bG9hZCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGhhbmRsZXIoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBjYWxsZXJJZGVudGl0eSxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIHJlc3BvbnNlVGltZW91dFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGgocmVzcG9uc2UpID4gTUFYX1BBWUxPQURfQllURVMpIHtcbiAgICAgICAgICByZXNwb25zZUVycm9yID0gUnBjRXJyb3IuYnVpbHRJbignUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UnKTtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiUlBDIFJlc3BvbnNlIHBheWxvYWQgdG9vIGxhcmdlIGZvciBcIi5jb25jYXQobWV0aG9kKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2VQYXlsb2FkID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJwY0Vycm9yKSB7XG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJVbmNhdWdodCBlcnJvciByZXR1cm5lZCBieSBSUEMgaGFuZGxlciBmb3IgXCIuY29uY2F0KG1ldGhvZCwgXCIuIFJldHVybmluZyBBUFBMSUNBVElPTl9FUlJPUiBpbnN0ZWFkLlwiKSwgZXJyb3IpO1xuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBScGNFcnJvci5idWlsdEluKCdBUFBMSUNBVElPTl9FUlJPUicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgcmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYXR0ZW1wdCB0byBzZWxlY3QgdGhlIGRlZmF1bHQgZGV2aWNlcyBpZiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBkZXZpY2VzIGFyZSBubyBsb25nZXIgYXZhaWxhYmxlIGFmdGVyIGEgZGV2aWNlIGNoYW5nZSBldmVudFxuICAgKi9cbiAgc2VsZWN0RGVmYXVsdERldmljZXMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3QgcHJldmlvdXNEZXZpY2VzID0gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnByZXZpb3VzRGV2aWNlcztcbiAgICAgIC8vIGNoZWNrIGZvciBhdmFpbGFibGUgZGV2aWNlcywgYnV0IGRvbid0IHJlcXVlc3QgcGVybWlzc2lvbnMgaW4gb3JkZXIgdG8gYXZvaWQgcHJvbXB0cyBmb3Iga2luZHMgdGhhdCBoYXZlbid0IGJlZW4gdXNlZCBiZWZvcmVcbiAgICAgIGNvbnN0IGF2YWlsYWJsZURldmljZXMgPSB5aWVsZCBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgICAgZm9yIChsZXQgYXZhaWxhYmxlRGV2aWNlIG9mIGF2YWlsYWJsZURldmljZXMpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0RldmljZSA9IHByZXZpb3VzRGV2aWNlcy5maW5kKGluZm8gPT4gaW5mby5kZXZpY2VJZCA9PT0gYXZhaWxhYmxlRGV2aWNlLmRldmljZUlkKTtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXZpY2UgJiYgcHJldmlvdXNEZXZpY2UubGFiZWwgIT09ICcnICYmIHByZXZpb3VzRGV2aWNlLmtpbmQgPT09IGF2YWlsYWJsZURldmljZS5raW5kICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSBhdmFpbGFibGVEZXZpY2UubGFiZWwpIHtcbiAgICAgICAgICAgIC8vIGxhYmVsIGhhcyBjaGFuZ2VkIG9uIGRldmljZSB0aGUgc2FtZSBkZXZpY2VJZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBkZWZhdWx0IGRldmljZSBoYXMgY2hhbmdlZCBvbiB0aGUgT1MgbGV2ZWxcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZURldmljZShhdmFpbGFibGVEZXZpY2Uua2luZCkgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAvLyBlbWl0IGFuIGFjdGl2ZSBkZXZpY2UgY2hhbmdlIGV2ZW50IG9ubHkgaWYgdGhlIHNlbGVjdGVkIG91dHB1dCBkZXZpY2UgaXMgYWN0dWFsbHkgb24gYGRlZmF1bHRgXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgYXZhaWxhYmxlRGV2aWNlLmtpbmQsIGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBraW5kcyA9IFsnYXVkaW9vdXRwdXQnLCAnYXVkaW9pbnB1dCcsICd2aWRlb2lucHV0J107XG4gICAgICBmb3IgKGxldCBraW5kIG9mIGtpbmRzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFNvdXJjZSA9IGtpbmRUb1NvdXJjZShraW5kKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UHVibGljYXRpb24gPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih0YXJnZXRTb3VyY2UpO1xuICAgICAgICBpZiAodGFyZ2V0UHVibGljYXRpb24gJiYgKChfYSA9IHRhcmdldFB1YmxpY2F0aW9uLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVc2VyUHJvdmlkZWQpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHRyYWNrIGlzIHVzZXIgcHJvdmlkZWQsIHdlIGRvbid0IHdhbnQgdG8gc3dpdGNoIGRldmljZXMgb24gYmVoYWxmIG9mIHRoZSB1c2VyXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV2aWNlc09mS2luZCA9IGF2YWlsYWJsZURldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSBraW5kKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRGV2aWNlID0gdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCk7XG4gICAgICAgIGlmIChhY3RpdmVEZXZpY2UgPT09ICgoX2IgPSBwcmV2aW91c0RldmljZXMuZmlsdGVyKGluZm8gPT4gaW5mby5raW5kID09PSBraW5kKVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSkge1xuICAgICAgICAgIC8vIGluICBTYWZhcmkgdGhlIGZpcnN0IGRldmljZSBpcyBhbHdheXMgdGhlIGRlZmF1bHQsIHNvIHdlIGFzc3VtZSBhIHVzZXIgb24gdGhlIGRlZmF1bHQgZGV2aWNlIHdvdWxkIGxpa2UgdG8gc3dpdGNoIHRvIHRoZSBkZWZhdWx0IG9uY2UgaXQgY2hhbmdlc1xuICAgICAgICAgIC8vIEZGIGRvZXNuJ3QgZW1pdCBhbiBldmVudCB3aGVuIHRoZSBkZWZhdWx0IGRldmljZSBjaGFuZ2VzLCBzbyB3ZSBwZXJmb3JtIHRoZSBzYW1lIGJlc3QgZWZmb3J0IGFuZCBzd2l0Y2ggdG8gdGhlIG5ldyBkZXZpY2Ugb25jZSBjb25uZWN0ZWQgYW5kIGlmIGl0J3MgdGhlIGZpcnN0IGluIHRoZSBhcnJheVxuICAgICAgICAgIGlmIChkZXZpY2VzT2ZLaW5kLmxlbmd0aCA+IDAgJiYgKChfYyA9IGRldmljZXNPZktpbmRbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZXZpY2VJZCkgIT09IGFjdGl2ZURldmljZSkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZCwgZGV2aWNlc09mS2luZFswXS5kZXZpY2VJZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0JyAmJiAhaXNTYWZhcmlCYXNlZCgpIHx8IGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgIC8vIGFpcnBvZHMgb24gU2FmYXJpIG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgYXVkaW9pbnB1dCBhcyB0aGUgdHJhY2sgZG9lc24ndCBlbmQgYXMgc29vbiBhcyB5b3UgdGFrZSB0aGVtIG91dFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBmaXJzdCBhdmFpbGFibGUgZGV2aWNlIGlmIHByZXZpb3VzbHkgYWN0aXZlIGRldmljZSBpcyBub3QgYXZhaWxhYmxlIGFueSBtb3JlXG4gICAgICAgIGlmIChkZXZpY2VzT2ZLaW5kLmxlbmd0aCA+IDAgJiYgIWRldmljZXNPZktpbmQuZmluZChkZXZpY2VJbmZvID0+IGRldmljZUluZm8uZGV2aWNlSWQgPT09IHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAmJiAoXG4gICAgICAgIC8vIGF2b2lkIHN3aXRjaGluZyBhdWRpbyBvdXRwdXQgb24gc2FmYXJpIHdpdGhvdXQgZXhwbGljaXQgdXNlciBhY3Rpb24gYXMgaXQgbGVhZHMgdG8gc2xvd2VkIGRvd24gYXVkaW8gcGxheWJhY2tcbiAgICAgICAga2luZCAhPT0gJ2F1ZGlvb3V0cHV0JyB8fCAhaXNTYWZhcmlCYXNlZCgpKSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmQsIGRldmljZXNPZktpbmRbMF0uZGV2aWNlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiYgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAvLyBvdmVycmlkZSBhdWRpbyBjb250ZXh0IHdpdGggY3VzdG9tIGF1ZGlvIGNvbnRleHQgaWYgc3VwcGxpZWQgYnkgdXNlclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy53ZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvQ29udGV4dCB8fCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgLy8gYnkgdXNpbmcgYW4gQXVkaW9Db250ZXh0LCBpdCByZWR1Y2VzIGxhZyBvbiBhdWRpbyBlbGVtZW50c1xuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSAoX2EgPSBnZXROZXdBdWRpb0NvbnRleHQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCkge1xuICAgICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIC8vIGZvciBpT1MgYSBuZXdseSBjcmVhdGVkIEF1ZGlvQ29udGV4dCBpcyBhbHdheXMgaW4gYHN1c3BlbmRlZGAgc3RhdGUuXG4gICAgICAgIC8vIHdlIHRyeSBvdXIgYmVzdCB0byByZXN1bWUgdGhlIGNvbnRleHQgaGVyZSwgaWYgdGhhdCBkb2Vzbid0IHdvcmssIHdlIGp1c3QgY29udGludWUgd2l0aCByZWd1bGFyIHByb2Nlc3NpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW3RoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpLCBzbGVlcCgyMDApXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb250ZXh0SXNSdW5uaW5nID0gKChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpID09PSAncnVubmluZyc7XG4gICAgICBpZiAobmV3Q29udGV4dElzUnVubmluZyAhPT0gdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgbmV3Q29udGV4dElzUnVubmluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpY2lwYW50ID0gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHRoaXMuZW5naW5lLmNsaWVudCwgJycsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuICAgIGlmICgoX2EgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VJZCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9PdXRwdXQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbykge1xuICAgIGlmICh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5oYXMoaWRlbnRpdHkpKSB7XG4gICAgICBjb25zdCBleGlzdGluZ1BhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHdhc1VwZGF0ZWQgPSBleGlzdGluZ1BhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIGlmICh3YXNVcGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LnNldChpbmZvLnNpZCwgaW5mby5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZ1BhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pO1xuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnNldChpZGVudGl0eSwgcGFydGljaXBhbnQpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5zZXQoaW5mby5zaWQsIGluZm8uaWRlbnRpdHkpO1xuICAgIC8vIGlmIHdlIGhhdmUgdmFsaWQgaW5mbyBhbmQgdGhlIHBhcnRpY2lwYW50IHdhc24ndCBpbiB0aGUgbWFwIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGUgcGFydGljaXBhbnQgaXMgbmV3XG4gICAgLy8gZmlyaW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYFBhcnRpY2lwYW50Q29ubmVjdGVkYCBmaXJlcyBiZWZvcmUgdGhlIGluaXRpYWwgdHJhY2sgZXZlbnRzXG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXG4gICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxuICAgIHBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrVW5tdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcyA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5ID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsICh0cmFja1NpZCwgZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQWN0aXZlLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudEFjdGl2ZSwgcGFydGljaXBhbnQpO1xuICAgICAgaWYgKHBhcnRpY2lwYW50LmtpbmQgPT09IFBhcnRpY2lwYW50SW5mb19LaW5kLkFHRU5UKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBY3RpdmVBZ2VudChwYXJ0aWNpcGFudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIGluZm8gYXQgdGhlIGVuZCBhZnRlciBjYWxsYmFja3MgaGF2ZSBiZWVuIHNldCB1cFxuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZSgpIHtcbiAgICBjb25zdCByZW1vdGVUcmFja3MgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIGFjYy5wdXNoKC4uLnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25zKCkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBsb2NhbFRyYWNrcyA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9ucyBkaXJlY3RseSBpbnN0ZWFkIG9mIHRoZSB0eXBlIGNhc3RcbiAgICB0aGlzLmVuZ2luZS5zZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpO1xuICB9XG4gIC8qKlxuICAgKiBBZnRlciByZXN1bWluZywgd2UnbGwgbmVlZCB0byBub3RpZnkgdGhlIHNlcnZlciBvZiB0aGUgY3VycmVudFxuICAgKiBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXG4gICAqL1xuICB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChwdWIuaXNTdWJzY3JpYmVkICYmIGlzUmVtb3RlUHViKHB1YikpIHtcbiAgICAgICAgICBwdWIuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzaWQpIHtcbiAgICBjb25zdCBpZGVudGl0eSA9IHRoaXMuc2lkVG9JZGVudGl0eS5nZXQoc2lkKTtcbiAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBlbnN1cmUgd2UgZGlkbid0IHRlYXIgaXQgZG93blxuICAgICAgIXRoaXMuZW5naW5lIHx8XG4gICAgICAvLyBlbmdpbmUgZGV0ZWN0ZWQgY2xvc2UsIGJ1dCBSb29tIG1pc3NlZCBpdFxuICAgICAgdGhpcy5lbmdpbmUuaXNDbG9zZWQgfHxcbiAgICAgIC8vIHRyYW5zcG9ydHMgZmFpbGVkIHdpdGhvdXQgbm90aWZ5aW5nIGVuZ2luZVxuICAgICAgIXRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpKSB7XG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcbiAgICAgICAgdGhpcy5sb2cud2FybignZGV0ZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZSBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIG51bUZhaWx1cmVzOiBjb25zZWN1dGl2ZUZhaWx1cmVzLFxuICAgICAgICAgIGVuZ2luZTogdGhpcy5lbmdpbmUgPyB7XG4gICAgICAgICAgICBjbG9zZWQ6IHRoaXMuZW5naW5lLmlzQ2xvc2VkLFxuICAgICAgICAgICAgdHJhbnNwb3J0c0Nvbm5lY3RlZDogdGhpcy5lbmdpbmUudmVyaWZ5VHJhbnNwb3J0KClcbiAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgIH1cbiAgICB9LCBDT05ORUNUSU9OX1JFQ09OQ0lMRV9GUkVRVUVOQ1lfTVMpO1xuICB9XG4gIGNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICBzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICAvLyB1bmNoYW5nZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZW1pdEJ1ZmZlcmVkRXZlbnRzKCkge1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICBsZXQgW2V2LCBhcmdzXSA9IF9yZWYzO1xuICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9KTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gIH1cbiAgZW1pdFdoZW5Db25uZWN0ZWQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcgfHwgdGhpcy5pc1Jlc3VtaW5nIHx8ICF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5wZW5kaW5nUmVjb25uZWN0KSB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSByb29tIGlzIHJlY29ubmVjdGluZywgYnVmZmVyIHRoZSBldmVudHMgYnkgZmlyaW5nIHRoZW0gbGF0ZXIgYWZ0ZXIgZW1pdHRpbmcgUm9vbUV2ZW50LlJlY29ubmVjdGVkXG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLnB1c2goW2V2ZW50LCBhcmdzXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gcG9wdWxhdGUgYSByb29tIHdpdGggc2ltdWxhdGVkIHBhcnRpY2lwYW50cy5cbiAgICogTm8gYWN0dWFsIGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIgd2lsbCBiZSBlc3RhYmxpc2hlZCwgYWxsIHN0YXRlIGlzXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNpbXVsYXRlUGFydGljaXBhbnRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgdXNlUmVhbFRyYWNrczogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMucHVibGlzaCk7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY291bnQ6IDksXG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXVxuICAgICAgfSwgb3B0aW9ucy5wYXJ0aWNpcGFudHMpO1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJvb21JbmZvID0gbmV3IFJvb20kMSh7XG4gICAgICAgIHNpZDogJ1JNX1NJTVVMQVRFRCcsXG4gICAgICAgIG5hbWU6ICdzaW11bGF0ZWQtcm9vbScsXG4gICAgICAgIGVtcHR5VGltZW91dDogMCxcbiAgICAgICAgbWF4UGFydGljaXBhbnRzOiAwLFxuICAgICAgICBjcmVhdGlvblRpbWU6IHByb3RvSW50NjQucGFyc2UobmV3IERhdGUoKS5nZXRUaW1lKCkpLFxuICAgICAgICBtZXRhZGF0YTogJycsXG4gICAgICAgIG51bVBhcnRpY2lwYW50czogMSxcbiAgICAgICAgbnVtUHVibGlzaGVyczogMSxcbiAgICAgICAgdHVyblBhc3N3b3JkOiAnJyxcbiAgICAgICAgZW5hYmxlZENvZGVjczogW10sXG4gICAgICAgIGFjdGl2ZVJlY29yZGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8obmV3IFBhcnRpY2lwYW50SW5mbyh7XG4gICAgICAgIGlkZW50aXR5OiAnc2ltdWxhdGVkLWxvY2FsJyxcbiAgICAgICAgbmFtZTogJ2xvY2FsLW5hbWUnXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oVHJhY2suS2luZC5WaWRlbywgbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgICAgbmFtZTogJ3ZpZGVvLWR1bW15J1xuICAgICAgICB9KSwgbmV3IExvY2FsVmlkZW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgdmlkZW86IHRydWVcbiAgICAgICAgfSkpLmdldFZpZGVvVHJhY2tzKClbMF0gOiBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soMTYwICogKChfYSA9IHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpLCAxNjAsIHRydWUsIHRydWUpLCB1bmRlZmluZWQsIGZhbHNlLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSksIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihjYW1QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGNhbVB1Yik7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgY29uc3QgYXVkaW9QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuQXVkaW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICB9KSwgbmV3IExvY2FsQXVkaW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZVxuICAgICAgICB9KSkuZ2V0QXVkaW9UcmFja3MoKVswXSA6IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpLCB1bmRlZmluZWQsIGZhbHNlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGF1ZGlvUHViKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRPcHRpb25zLmNvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGxldCBpbmZvID0gbmV3IFBhcnRpY2lwYW50SW5mbyh7XG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBpZGVudGl0eTogXCJzaW11bGF0ZWQtXCIuY29uY2F0KGkpLFxuICAgICAgICAgIHN0YXRlOiBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFLFxuICAgICAgICAgIHRyYWNrczogW10sXG4gICAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgICBjb25zdCBkdW1teVZpZGVvID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2IgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zW2kgJSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zLmxlbmd0aF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpLCAxNjAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLkNBTUVSQSxcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VmlkZW8sIHZpZGVvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VmlkZW9dKSwgbmV3IFJUQ1J0cFJlY2VpdmVyKCkpO1xuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCB2aWRlb1RyYWNrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlUcmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VHJhY2ssIGF1ZGlvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VHJhY2tdKSwgbmV3IFJUQ1J0cFJlY2VpdmVyKCkpO1xuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCBhdWRpb1RyYWNrXTtcbiAgICAgICAgfVxuICAgICAgICBwLnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0KGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIC8vIGFjdGl2ZSBzcGVha2VyIHVwZGF0ZXMgYXJlIHRvbyBzcGFtbXlcbiAgICBpZiAoZXZlbnQgIT09IFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQgJiYgZXZlbnQgIT09IFJvb21FdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQpIHtcbiAgICAgIC8vIG9ubHkgZXh0cmFjdCBsb2dDb250ZXh0IGZyb20gYXJndW1lbnRzIGluIG9yZGVyIHRvIGF2b2lkIGxvZ2dpbmcgdGhlIHdob2xlIG9iamVjdCB0cmVlXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBcmdzID0gbWFwQXJncyhhcmdzKS5maWx0ZXIoYXJnID0+IGFyZyAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIGlmIChldmVudCA9PT0gUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCB8fCBldmVudCA9PT0gUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKFwic3Vic2NyaWJlIHRyYWNlOiBcIi5jb25jYXQoZXZlbnQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBhcmdzOiBtaW5pbWl6ZWRBcmdzXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicm9vbSBldmVudCBcIi5jb25jYXQoZXZlbnQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGFyZ3M6IG1pbmltaXplZEFyZ3NcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9XG59XG5Sb29tLmNsZWFudXBSZWdpc3RyeSA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGNsZWFudXAgPT4ge1xuICBjbGVhbnVwKCk7XG59KTtcbmZ1bmN0aW9uIG1hcEFyZ3MoYXJncykge1xuICByZXR1cm4gYXJncy5tYXAoYXJnID0+IHtcbiAgICBpZiAoIWFyZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICByZXR1cm4gbWFwQXJncyhhcmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAnbG9nQ29udGV4dCcgaW4gYXJnID8gYXJnLmxvZ0NvbnRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH0pO1xufS8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGZyb20gSlNPTiBTY2hlbWEgdXNpbmcgcXVpY2t0eXBlLCBkbyBub3QgbW9kaWZ5IGl0IGRpcmVjdGx5LlxuLy8gVGhlIGNvZGUgZ2VuZXJhdGlvbiBsaXZlcyBhdCBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC9hdHRyaWJ1dGUtZGVmaW5pdGlvbnNcbi8vXG4vLyBUbyBwYXJzZSB0aGlzIGRhdGE6XG4vL1xuLy8gICBpbXBvcnQgeyBDb252ZXJ0LCBBZ2VudEF0dHJpYnV0ZXMsIFRyYW5zY3JpcHRpb25BdHRyaWJ1dGVzIH0gZnJvbSBcIi4vZmlsZVwiO1xuLy9cbi8vICAgY29uc3QgYWdlbnRBdHRyaWJ1dGVzID0gQ29udmVydC50b0FnZW50QXR0cmlidXRlcyhqc29uKTtcbi8vICAgY29uc3QgdHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMgPSBDb252ZXJ0LnRvVHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMoanNvbik7XG4vLyBDb252ZXJ0cyBKU09OIHN0cmluZ3MgdG8vZnJvbSB5b3VyIHR5cGVzXG5jbGFzcyBDb252ZXJ0IHtcbiAgc3RhdGljIHRvQWdlbnRBdHRyaWJ1dGVzKGpzb24pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgfVxuICBzdGF0aWMgYWdlbnRBdHRyaWJ1dGVzVG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgdG9UcmFuc2NyaXB0aW9uQXR0cmlidXRlcyhqc29uKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gIH1cbiAgc3RhdGljIHRyYW5zY3JpcHRpb25BdHRyaWJ1dGVzVG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufXZhciBhdHRyaWJ1dGVUeXBpbmdzPS8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb252ZXJ0OkNvbnZlcnR9KTt2YXIgQ2hlY2tTdGF0dXM7XG4oZnVuY3Rpb24gKENoZWNrU3RhdHVzKSB7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU0tJUFBFRFwiXSA9IDJdID0gXCJTS0lQUEVEXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiRkFJTEVEXCJdID0gNF0gPSBcIkZBSUxFRFwiO1xufSkoQ2hlY2tTdGF0dXMgfHwgKENoZWNrU3RhdHVzID0ge30pKTtcbmNsYXNzIENoZWNrZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXR1cyA9IENoZWNrU3RhdHVzLklETEU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHJ1bihvbkNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY2hlY2sgaXMgcnVubmluZyBhbHJlYWR5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXJyb3JzQXNXYXJuaW5ncykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIC8vIHNsZWVwIGZvciBhIGJpdCB0byBlbnN1cmUgZGlzY29ubmVjdFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5TS0lQUEVEKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHRoaXMuaXNTdWNjZXNzKCkgPyBDaGVja1N0YXR1cy5TVUNDRVNTIDogQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEluZm8oKTtcbiAgICB9KTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuICF0aGlzLmxvZ3Muc29tZShsID0+IGwubGV2ZWwgPT09ICdlcnJvcicpO1xuICB9XG4gIGNvbm5lY3QodXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgICAgIH1cbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodXJsLCB0aGlzLnRva2VuLCB0aGlzLmNvbm5lY3RPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucm9vbSAmJiB0aGlzLnJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yb29tLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgLy8gd2FpdCBmb3IgaXQgdG8gZ28gdGhyb3VnaFxuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2tpcCgpIHtcbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5TS0lQUEVEKTtcbiAgfVxuICBzd2l0Y2hQcm90b2NvbChwcm90b2NvbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgaGFzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBsZXQgaGFzUmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XG4gICAgICAgIGhhc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vbS5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICBoYXNSZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vbS5zaW11bGF0ZVNjZW5hcmlvKFwiZm9yY2UtXCIuY29uY2F0KHByb3RvY29sKSk7XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgaWYgKCFoYXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byB3YWl0IGZvciByZWNvbm5lY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gd2FpdCBmb3IgMTAgc2Vjb25kcyBmb3IgcmVjb25uZWN0aW9uXG4gICAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArIDEwMDAwO1xuICAgICAgd2hpbGUgKERhdGUubm93KCkgPCB0aW1lb3V0KSB7XG4gICAgICAgIGlmIChoYXNSZWNvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlY29ubmVjdCB1c2luZyBcIi5jb25jYXQocHJvdG9jb2wsIFwiIHByb3RvY29sIGFmdGVyIDEwIHNlY29uZHNcIikpO1xuICAgIH0pO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHRoaXMubG9ncy5wdXNoKHtcbiAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgYXBwZW5kV2FybmluZyhtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGdldCBlbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmdpbmU7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxufS8qKlxuICogQ2hlY2tzIGZvciBjb25uZWN0aW9ucyBxdWFsaXR5IHRvIGNsb3Nlc3RzIENsb3VkIHJlZ2lvbnMgYW5kIGRldGVybWluaW5nIHRoZSBiZXN0IHF1YWxpdHlcbiAqL1xuY2xhc3MgQ2xvdWRSZWdpb25DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDbG91ZCByZWdpb25zJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZWdpb25Qcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgICBpZiAoIXJlZ2lvblByb3ZpZGVyLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uU3RhdHMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5VcmxzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgcmVnaW9uUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgaWYgKCFyZWdpb25VcmwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlblVybHMuaGFzKHJlZ2lvblVybCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuVXJscy5hZGQocmVnaW9uVXJsKTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ2xvdWRSZWdpb24ocmVnaW9uVXJsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiXCIuY29uY2F0KHN0YXRzLnJlZ2lvbiwgXCIgUlRUOiBcIikuY29uY2F0KHN0YXRzLnJ0dCwgXCJtcywgZHVyYXRpb246IFwiKS5jb25jYXQoc3RhdHMuZHVyYXRpb24sIFwibXNcIikpO1xuICAgICAgICByZWdpb25TdGF0cy5wdXNoKHN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHJlZ2lvblN0YXRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIChhLmR1cmF0aW9uIC0gYi5kdXJhdGlvbikgKiAwLjUgKyAoYS5ydHQgLSBiLnJ0dCkgKiAwLjU7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJlc3RSZWdpb24gPSByZWdpb25TdGF0c1swXTtcbiAgICAgIHRoaXMuYmVzdFN0YXRzID0gYmVzdFJlZ2lvbjtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcImJlc3QgQ2xvdWQgcmVnaW9uOiBcIi5jb25jYXQoYmVzdFJlZ2lvbi5yZWdpb24pKTtcbiAgICB9KTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cbiAgY2hlY2tDbG91ZFJlZ2lvbih1cmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCh1cmwpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gJ3RjcCcpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb24gPSAoX2EgPSB0aGlzLnJvb20uc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZ2lvbjtcbiAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaW9uIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuc3RyZWFtVGV4dCh7XG4gICAgICAgIHRvcGljOiAndGVzdCdcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAwMDsgLy8gZWFjaCBjaHVuayBpcyBhYm91dCAxMDAwIGJ5dGVzXG4gICAgICBjb25zdCB0b3RhbFNpemUgPSAxMDAwMDAwOyAvLyBhcHByb3hpbWF0ZWx5IDFNQiBvZiBkYXRhXG4gICAgICBjb25zdCBudW1DaHVua3MgPSB0b3RhbFNpemUgLyBjaHVua1NpemU7IC8vIHdpbGwgeWllbGQgMTAwMCBjaHVua3NcbiAgICAgIGNvbnN0IGNodW5rRGF0YSA9ICdBJy5yZXBlYXQoY2h1bmtTaXplKTsgLy8gY3JlYXRlIGEgc3RyaW5nIG9mIDEwMDAgJ0EnIGNoYXJhY3RlcnNcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNodW5rczsgaSsrKSB7XG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZShjaHVua0RhdGEpO1xuICAgICAgfVxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9iID0gdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdWJsaXNoZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGNvbnN0IHJlZ2lvblN0YXRzID0ge1xuICAgICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgICAgcnR0OiAxMDAwMCxcbiAgICAgICAgZHVyYXRpb246IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIH07XG4gICAgICBzdGF0cyA9PT0gbnVsbCB8fCBzdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJiBzdGF0Lm5vbWluYXRlZCkge1xuICAgICAgICAgIHJlZ2lvblN0YXRzLnJ0dCA9IHN0YXQuY3VycmVudFJvdW5kVHJpcFRpbWUgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHJlZ2lvblN0YXRzO1xuICAgIH0pO1xuICB9XG59Y29uc3QgVEVTVF9EVVJBVElPTiA9IDEwMDAwO1xuY2xhc3MgQ29ubmVjdGlvblByb3RvY29sQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ29ubmVjdGlvbiB2aWEgVURQIHZzIFRDUCc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdWRwU3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ29ubmVjdGlvblByb3RvY29sKCd1ZHAnKTtcbiAgICAgIGNvbnN0IHRjcFN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndGNwJyk7XG4gICAgICB0aGlzLmJlc3RTdGF0cyA9IHVkcFN0YXRzO1xuICAgICAgLy8gdWRwIHNob3VsZCBpcyB0aGUgYmV0dGVyIHByb3RvY29sIHR5cGljYWxseS4gaG93ZXZlciwgd2UnZCBwcmVmZXIgVENQIHdoZW4gZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gICAgICAvLyAxLiB0aGUgYmFuZHdpZHRoIGxpbWl0YXRpb24gaXMgd29yc2Ugb24gVURQIGJ5IDUwMG1zXG4gICAgICAvLyAyLiB0aGUgcGFja2V0IGxvc3MgaXMgaGlnaGVyIG9uIFVEUCBieSAxJVxuICAgICAgaWYgKHVkcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAtIHRjcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCA+IDAuNSB8fCAodWRwU3RhdHMucGFja2V0c0xvc3QgLSB0Y3BTdGF0cy5wYWNrZXRzTG9zdCkgLyB1ZHBTdGF0cy5wYWNrZXRzU2VudCA+IDAuMDEpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdiZXN0IGNvbm5lY3Rpb24gcXVhbGl0eSB2aWEgdGNwJyk7XG4gICAgICAgIHRoaXMuYmVzdFN0YXRzID0gdGNwU3RhdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB1ZHAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJ1cHN0cmVhbSBiaXRyYXRlOiBcIi5jb25jYXQoKHN0YXRzLmJpdHJhdGVUb3RhbCAvIHN0YXRzLmNvdW50IC8gMTAwMCAvIDEwMDApLnRvRml4ZWQoMiksIFwiIG1icHNcIikpO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiUlRUOiBcIi5jb25jYXQoKHN0YXRzLnJ0dFRvdGFsIC8gc3RhdHMuY291bnQgKiAxMDAwKS50b0ZpeGVkKDIpLCBcIiBtc1wiKSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJqaXR0ZXI6IFwiLmNvbmNhdCgoc3RhdHMuaml0dGVyVG90YWwgLyBzdGF0cy5jb3VudCAqIDEwMDApLnRvRml4ZWQoMiksIFwiIG1zXCIpKTtcbiAgICAgIGlmIChzdGF0cy5wYWNrZXRzTG9zdCA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwicGFja2V0cyBsb3N0OiBcIi5jb25jYXQoKHN0YXRzLnBhY2tldHNMb3N0IC8gc3RhdHMucGFja2V0c1NlbnQgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoID4gMSkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJiYW5kd2lkdGggbGltaXRlZCBcIi5jb25jYXQoKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAvIChURVNUX0RVUkFUSU9OIC8gMTAwMCkgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuY3B1ID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJjcHUgbGltaXRlZCBcIi5jb25jYXQoKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmNwdSAvIChURVNUX0RVUkFUSU9OIC8gMTAwMCkgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0SW5mbygpO1xuICAgIGluZm8uZGF0YSA9IHRoaXMuYmVzdFN0YXRzO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgaWYgKHByb3RvY29sID09PSAndGNwJykge1xuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd0Y3AnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoUHJvdG9jb2woJ3VkcCcpO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlIGEgY2FudmFzIHdpdGggYW5pbWF0ZWQgY29udGVudFxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSAxMjgwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IDcyMDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBsZXQgaHVlID0gMDtcbiAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgIGh1ZSA9IChodWUgKyAxKSAlIDM2MDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiaHNsKFwiLmNvbmNhdChodWUsIFwiLCAxMDAlLCA1MCUpXCIpO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgfTtcbiAgICAgIGFuaW1hdGUoKTtcbiAgICAgIC8vIGNyZWF0ZSB2aWRlbyB0cmFjayBmcm9tIGNhbnZhc1xuICAgICAgY29uc3Qgc3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oMzApOyAvLyAzMGZwc1xuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgLy8gcHVibGlzaCB0byByb29tXG4gICAgICBjb25zdCBwdWIgPSB5aWVsZCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodmlkZW9UcmFjaywge1xuICAgICAgICBzaW11bGNhc3Q6IGZhbHNlLFxuICAgICAgICBkZWdyYWRhdGlvblByZWZlcmVuY2U6ICdtYWludGFpbi1yZXNvbHV0aW9uJyxcbiAgICAgICAgdmlkZW9FbmNvZGluZzoge1xuICAgICAgICAgIG1heEJpdHJhdGU6IDIwMDAwMDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGNvbnN0IHByb3RvY29sU3RhdHMgPSB7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwYWNrZXRzTG9zdDogMCxcbiAgICAgICAgcGFja2V0c1NlbnQ6IDAsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB7fSxcbiAgICAgICAgcnR0VG90YWw6IDAsXG4gICAgICAgIGppdHRlclRvdGFsOiAwLFxuICAgICAgICBiaXRyYXRlVG90YWw6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgLy8gZ2F0aGVyIHN0YXRzIG9uY2UgYSBzZWNvbmRcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRyYWNrLmdldFJUQ1N0YXRzUmVwb3J0KCk7XG4gICAgICAgIHN0YXRzID09PSBudWxsIHx8IHN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNTZW50ID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMgPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zO1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5iaXRyYXRlVG90YWwgKz0gc3RhdC50YXJnZXRCaXRyYXRlO1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5jb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdC50eXBlID09PSAncmVtb3RlLWluYm91bmQtcnRwJykge1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5wYWNrZXRzTG9zdCA9IHN0YXQucGFja2V0c0xvc3Q7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnJ0dFRvdGFsICs9IHN0YXQucm91bmRUcmlwVGltZTtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuaml0dGVyVG90YWwgKz0gc3RhdC5qaXR0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLCAxMDAwKTtcbiAgICAgIC8vIHdhaXQgYSBiaXQgdG8gZ2F0aGVyIHN0YXRzXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgVEVTVF9EVVJBVElPTikpO1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB2aWRlb1RyYWNrLnN0b3AoKTtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHByb3RvY29sU3RhdHM7XG4gICAgfSk7XG4gIH1cbn1jbGFzcyBQdWJsaXNoQXVkaW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCBhdWRpbyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRyYWNrLCAxMDAwKTtcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVjdCBhdWRpbyBmcm9tIG1pY3JvcGhvbmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnZGV0ZWN0ZWQgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgZmV3IHNlY29uZHMgdG8gcHVibGlzaFxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9hID0gdHJhY2suc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMoKTtcbiAgICAgIGlmICghc3RhdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiAoc3RhdC5raW5kID09PSAnYXVkaW8nIHx8ICFzdGF0LmtpbmQgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICdhdWRpbycpKSB7XG4gICAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgYXVkaW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbn1jbGFzcyBQdWJsaXNoVmlkZW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbFZpZGVvVHJhY2soKTtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdmlkZW8gZnJvbSBjYW1lcmFcbiAgICAgIHlpZWxkIHRoaXMuY2hlY2tGb3JWaWRlbyh0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xuICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIChzdGF0LmtpbmQgPT09ICd2aWRlbycgfHwgIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ3ZpZGVvJykpIHtcbiAgICAgICAgICBudW1QYWNrZXRzICs9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgdmlkZW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tGb3JWaWRlbyh0cmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjay5jbG9uZSgpKTtcbiAgICAgIC8vIENyZWF0ZSB2aWRlbyBlbGVtZW50IHRvIGNoZWNrIGZyYW1lc1xuICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgdmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgdmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgLy8gRm9yIGlPUyBTYWZhcmlcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdmlkZW8ub25wbGF5ID0gKCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IChfYiA9IChfYSA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aWRlby52aWRlb1dpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxMjgwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKF9kID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB2aWRlby52aWRlb0hlaWdodCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogNzIwO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAvLyBEcmF3IHZpZGVvIGZyYW1lIHRvIGNhbnZhc1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCk7XG4gICAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBhbmQgY2hlY2sgaWYgYWxsIHBpeGVscyBhcmUgYmxhY2tcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIGxldCBpc0FsbEJsYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMCB8fCBkYXRhW2kgKyAxXSAhPT0gMCB8fCBkYXRhW2kgKyAyXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlzQWxsQmxhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQWxsQmxhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcignY2FtZXJhIGFwcGVhcnMgdG8gYmUgcHJvZHVjaW5nIG9ubHkgYmxhY2sgZnJhbWVzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ3JlY2VpdmVkIHZpZGVvIGZyYW1lcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpO1xuICAgICAgdmlkZW8ucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbn1jbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdSZXN1bWluZyBjb25uZWN0aW9uIGFmdGVyIGludGVycnVwdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgbGV0IHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgbGV0IHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgcmVjb25uZWN0UmVzb2x2ZXI7XG4gICAgICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGFuZGxlUmVjb25uZWN0aW5nID0gKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIHJvb20ub24oUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZywgaGFuZGxlUmVjb25uZWN0aW5nKS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCBoYW5kbGVSZWNvbm5lY3RpbmcpLm9uKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyKHRydWUpO1xuICAgICAgfSk7XG4gICAgICAoX2EgPSByb29tLmVuZ2luZS5jbGllbnQud3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgY29uc3Qgb25DbG9zZSA9IHJvb20uZW5naW5lLmNsaWVudC5vbkNsb3NlO1xuICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgb25DbG9zZSgnJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCByZWNvbm5lY3RUaW1lb3V0O1xuICAgICAgaWYgKCFyZWNvbm5lY3RpbmdUcmlnZ2VyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGF0dGVtcHQgdG8gcmVjb25uZWN0Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFyZWNvbm5lY3RlZCB8fCByb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncmVjb25uZWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaW4gUmVkaXMtYmFzZWQgY29uZmlndXJhdGlvbnMnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYWJsZSB0byByZWNvbm5lY3QnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufWNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHRoaXMudXJsKSkpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdVc2luZyByZWdpb24gc3BlY2lmaWMgdXJsJyk7XG4gICAgICAgIHRoaXMudXJsID0gKF9hID0geWllbGQgbmV3IFJlZ2lvblVybFByb3ZpZGVyKHRoaXMudXJsLCB0aGlzLnRva2VuKS5nZXROZXh0QmVzdFJlZ2lvblVybCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnVybDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc1RMUyA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1RVUk4gPSBmYWxzZTtcbiAgICAgIGxldCBoYXNTVFVOID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpY2VTZXJ2ZXIgb2Ygam9pblJlcy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGZvciAobGV0IHVybCBvZiBpY2VTZXJ2ZXIudXJscykge1xuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybjonKSkge1xuICAgICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuczonKSkge1xuICAgICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1RMUyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnc3R1bjonKSkge1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1NUVU4pIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBTVFVOIHNlcnZlcnMgY29uZmlndXJlZCBvbiBzZXJ2ZXIgc2lkZS4nKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzVFVSTiAmJiAhaGFzVExTKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnVFVSTiBpcyBjb25maWd1cmVkIHNlcnZlciBzaWRlLCBidXQgVFVSTi9UTFMgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcbiAgICAgIGlmICgoKF9jID0gKF9iID0gdGhpcy5jb25uZWN0T3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJ0Y0NvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmljZVNlcnZlcnMpIHx8IGhhc1RVUk4pIHtcbiAgICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgICBydGNDb25maWc6IHtcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ3JlbGF5J1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFRVUk4gc2VydmVycyBjb25maWd1cmVkLicpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufWNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGhhc1RjcCA9IGZhbHNlO1xuICAgICAgbGV0IGhhc0lwdjRVZHAgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcHJldlRyaWNrbGUgPSB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGU7XG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgaWYgKHNkLmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShzZCk7XG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIi5jb25jYXQoY2FuZGlkYXRlLnByb3RvY29sLCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS5hZGRyZXNzLCBcIjpcIikuY29uY2F0KGNhbmRpZGF0ZS5wb3J0LCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS50eXBlKTtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuYWRkcmVzcykge1xuICAgICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgKHByaXZhdGUpJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNUY3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgc3RyICs9ICcgKHBhc3NpdmUpJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0lwdjRVZHAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKHN0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VHJpY2tsZSkge1xuICAgICAgICAgICAgcHJldlRyaWNrbGUoc2QsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZUVycm9yID0gZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogXCIuY29uY2F0KGV2LmVycm9yQ29kZSwgXCIgXCIpLmNvbmNhdChldi5lcnJvclRleHQsIFwiIFwiKS5jb25jYXQoZXYudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdub3cgdGhlIHJvb20gaXMgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIElDRS9UQ1AnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzcykge1xuICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGlmIChwYXJ0c1swXSA9PT0gJzEwJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE5MicgJiYgcGFydHNbMV0gPT09ICcxNjgnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTcyJykge1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgIGlmIChzZWNvbmQgPj0gMTYgJiYgc2Vjb25kIDw9IDMxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59Y2xhc3MgV2ViU29ja2V0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICh0aGlzLnVybC5zdGFydHNXaXRoKCd3czonKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKCdodHRwOicpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIGluc2VjdXJlLCBjbGllbnRzIG1heSBibG9jayBjb25uZWN0aW9ucyB0byBpdCcpO1xuICAgICAgfVxuICAgICAgbGV0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGxldCBqb2luUmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgam9pblJlcyA9IHlpZWxkIHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgICBzaW5nbGVQZWVyQ29ubmVjdGlvbjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodGhpcy51cmwpKSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkluaXRpYWwgY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBlcnJvciBcIi5jb25jYXQoZS5tZXNzYWdlLCBcIi4gUmV0cnlpbmcgd2l0aCByZWdpb24gZmFsbGJhY2tcIikpO1xuICAgICAgICAgIGNvbnN0IHJlZ2lvblByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICAgICAgICBjb25zdCByZWdpb25VcmwgPSB5aWVsZCByZWdpb25Qcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICAgIGlmIChyZWdpb25VcmwpIHtcbiAgICAgICAgICAgIGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbihyZWdpb25VcmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgICAgICAgc2luZ2xlUGVlckNvbm5lY3Rpb246IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkZhbGxiYWNrIHRvIHJlZ2lvbiB3b3JrZWQuIFRvIGF2b2lkIGluaXRpYWwgY29ubmVjdGlvbnMgZmFpbGluZywgZW5zdXJlIHlvdSdyZSBjYWxsaW5nIHJvb20ucHJlcGFyZUNvbm5lY3Rpb24oKSBhaGVhZCBvZiB0aW1lXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGpvaW5SZXMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiQ29ubmVjdGVkIHRvIHNlcnZlciwgdmVyc2lvbiBcIi5jb25jYXQoam9pblJlcy5zZXJ2ZXJWZXJzaW9uLCBcIi5cIikpO1xuICAgICAgICBpZiAoKChfYSA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVkaXRpb24pID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgKChfYiA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lvbikpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJMaXZlS2l0IENsb3VkOiBcIi5jb25jYXQoKF9jID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVnaW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoXCJXZWJzb2NrZXQgY29ubmVjdGlvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWRcIik7XG4gICAgICB9XG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxufWNsYXNzIENvbm5lY3Rpb25DaGVjayBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0SWQ7XG4gIH1cbiAgdXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKS5ldmVyeShyID0+IHIuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICB9XG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG4gIGNyZWF0ZUFuZFJ1bkNoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgICBjb25zdCB0ZXN0ID0gbmV3IGNoZWNrKHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gaW5mbyA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbyk7XG4gICAgICB9O1xuICAgICAgdGVzdC5vbigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRlc3QucnVuKCk7XG4gICAgICB0ZXN0Lm9mZigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tXZWJzb2NrZXQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFdlYlNvY2tldENoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1dlYlJUQygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViUlRDQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrVFVSTigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soVFVSTkNoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1JlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUmVjb25uZWN0Q2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUHVibGlzaEF1ZGlvKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoQXVkaW9DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tQdWJsaXNoVmlkZW8oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hWaWRlb0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgaW5mbyA9IHlpZWxkIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soQ29ubmVjdGlvblByb3RvY29sQ2hlY2spO1xuICAgICAgaWYgKGluZm8uZGF0YSAmJiAncHJvdG9jb2wnIGluIGluZm8uZGF0YSkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGluZm8uZGF0YTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnByb3RvY29sID0gc3RhdHMucHJvdG9jb2w7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9KTtcbiAgfVxuICBjaGVja0Nsb3VkUmVnaW9uKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDbG91ZFJlZ2lvbkNoZWNrKTtcbiAgICB9KTtcbiAgfVxufS8qKiBBIEZpeGVkIFRva2VuU291cmNlIGlzIGEgdG9rZW4gc291cmNlIHRoYXQgdGFrZXMgbm8gcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIGNvbXBsZXRlbHlcbiAqIGluZGVwZW5kZW50bHkgZGVyaXZlZCB2YWx1ZSBvbiBlYWNoIGZldGNoKCkgY2FsbC5cbiAqXG4gKiBUaGUgbW9zdCBjb21tb24gZG93bnN0cmVhbSBpbXBsZW1lbnRlciBpcyB7QGxpbmsgVG9rZW5Tb3VyY2VMaXRlcmFsfS5cbiAqL1xuY2xhc3MgVG9rZW5Tb3VyY2VGaXhlZCB7fVxuLyoqIEEgQ29uZmlndXJhYmxlIFRva2VuU291cmNlIGlzIGEgdG9rZW4gc291cmNlIHRoYXQgdGFrZXMgYVxuICoge0BsaW5rIFRva2VuU291cmNlRmV0Y2hPcHRpb25zfSBvYmplY3QgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBkZXRlcm1pbmlzdGljXG4gKiB7QGxpbmsgVG9rZW5Tb3VyY2VSZXNwb25zZU9iamVjdH0gb3V0cHV0IGJhc2VkIG9uIHRoZSBvcHRpb25zIHNwZWNpZmllZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgb3B0aW9ucy5wYXJ0aWNpcGFudE5hbWUgaXMgc2V0LCBpdCBzaG91bGQgYmUgZXhwZWN0ZWQgdGhhdFxuICogYWxsIHRva2VucyB0aGF0IGFyZSBnZW5lcmF0ZWQgd2lsbCBoYXZlIHBhcnRpY2lwYW50IG5hbWUgZmllbGQgc2V0IHRvIHRoZVxuICogcHJvdmlkZWQgdmFsdWUuXG4gKlxuICogQSBmZXcgY29tbW9uIGRvd25zdHJlYW0gaW1wbGVtZW50ZXJzIGFyZSB7QGxpbmsgVG9rZW5Tb3VyY2VFbmRwb2ludH1cbiAqIGFuZCB7QGxpbmsgVG9rZW5Tb3VyY2VDdXN0b219LlxuICovXG5jbGFzcyBUb2tlblNvdXJjZUNvbmZpZ3VyYWJsZSB7fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufW5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO2Z1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KGVuY29kZWQpO1xuICB9XG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoZW5jb2RlZCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IGRlY29kZXIuZGVjb2RlKGlucHV0KSwge1xuICAgICAgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnXG4gICAgfSk7XG4gIH1cbiAgbGV0IGVuY29kZWQgPSBpbnB1dDtcbiAgaWYgKGVuY29kZWQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZW5jb2RlZCA9IGRlY29kZXIuZGVjb2RlKGVuY29kZWQpO1xuICB9XG4gIGVuY29kZWQgPSBlbmNvZGVkLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZUJhc2U2NChlbmNvZGVkKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBpbnB1dCB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC4nKTtcbiAgfVxufWNsYXNzIEpPU0VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHZhciBfRXJyb3IkY2FwdHVyZVN0YWNrVHI7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pPU0VfR0VORVJJQycpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAoX0Vycm9yJGNhcHR1cmVTdGFja1RyID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpID09PSBudWxsIHx8IF9FcnJvciRjYXB0dXJlU3RhY2tUciA9PT0gdm9pZCAwIHx8IF9FcnJvciRjYXB0dXJlU3RhY2tUci5jYWxsKEVycm9yLCB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpPU0VFcnJvciwgXCJjb2RlXCIsICdFUlJfSk9TRV9HRU5FUklDJyk7XG5jbGFzcyBKV1RDbGFpbVZhbGlkYXRpb25GYWlsZWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXlsb2FkKSB7XG4gICAgbGV0IGNsYWltID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndW5zcGVjaWZpZWQnO1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICd1bnNwZWNpZmllZCc7XG4gICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgY2F1c2U6IHtcbiAgICAgICAgY2xhaW0sXG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV1RfQ0xBSU1fVkFMSURBVElPTl9GQUlMRUQnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGFpbVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYXNvblwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBheWxvYWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNsYWltID0gY2xhaW07XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXVENsYWltVmFsaWRhdGlvbkZhaWxlZCwgXCJjb2RlXCIsICdFUlJfSldUX0NMQUlNX1ZBTElEQVRJT05fRkFJTEVEJyk7XG5jbGFzcyBKV1RFeHBpcmVkIGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF5bG9hZCkge1xuICAgIGxldCBjbGFpbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3Vuc3BlY2lmaWVkJztcbiAgICBsZXQgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAndW5zcGVjaWZpZWQnO1xuICAgIHN1cGVyKG1lc3NhZ2UsIHtcbiAgICAgIGNhdXNlOiB7XG4gICAgICAgIGNsYWltLFxuICAgICAgICByZWFzb24sXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldUX0VYUElSRUQnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGFpbVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYXNvblwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBheWxvYWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNsYWltID0gY2xhaW07XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXVEV4cGlyZWQsIFwiY29kZVwiLCAnRVJSX0pXVF9FWFBJUkVEJyk7XG5jbGFzcyBKT1NFQWxnTm90QWxsb3dlZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pPU0VfQUxHX05PVF9BTExPV0VEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKT1NFQWxnTm90QWxsb3dlZCwgXCJjb2RlXCIsICdFUlJfSk9TRV9BTEdfTk9UX0FMTE9XRUQnKTtcbmNsYXNzIEpPU0VOb3RTdXBwb3J0ZWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KT1NFX05PVF9TVVBQT1JURUQnKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpPU0VOb3RTdXBwb3J0ZWQsIFwiY29kZVwiLCAnRVJSX0pPU0VfTk9UX1NVUFBPUlRFRCcpO1xuY2xhc3MgSldFRGVjcnlwdGlvbkZhaWxlZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGVjcnlwdGlvbiBvcGVyYXRpb24gZmFpbGVkJztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV0VfREVDUllQVElPTl9GQUlMRUQnKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXRURlY3J5cHRpb25GYWlsZWQsIFwiY29kZVwiLCAnRVJSX0pXRV9ERUNSWVBUSU9OX0ZBSUxFRCcpO1xuY2xhc3MgSldFSW52YWxpZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXRV9JTlZBTElEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0VJbnZhbGlkLCBcImNvZGVcIiwgJ0VSUl9KV0VfSU5WQUxJRCcpO1xuY2xhc3MgSldTSW52YWxpZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXU19JTlZBTElEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV1NJbnZhbGlkLCBcImNvZGVcIiwgJ0VSUl9KV1NfSU5WQUxJRCcpO1xuY2xhc3MgSldUSW52YWxpZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXVF9JTlZBTElEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV1RJbnZhbGlkLCBcImNvZGVcIiwgJ0VSUl9KV1RfSU5WQUxJRCcpO1xuY2xhc3MgSldLSW52YWxpZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXS19JTlZBTElEJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0tJbnZhbGlkLCBcImNvZGVcIiwgJ0VSUl9KV0tfSU5WQUxJRCcpO1xuY2xhc3MgSldLU0ludmFsaWQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV0tTX0lOVkFMSUQnKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXS1NJbnZhbGlkLCBcImNvZGVcIiwgJ0VSUl9KV0tTX0lOVkFMSUQnKTtcbmNsYXNzIEpXS1NOb01hdGNoaW5nS2V5IGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdubyBhcHBsaWNhYmxlIGtleSBmb3VuZCBpbiB0aGUgSlNPTiBXZWIgS2V5IFNldCc7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldLU19OT19NQVRDSElOR19LRVknKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXS1NOb01hdGNoaW5nS2V5LCBcImNvZGVcIiwgJ0VSUl9KV0tTX05PX01BVENISU5HX0tFWScpO1xuY2xhc3MgSldLU011bHRpcGxlTWF0Y2hpbmdLZXlzIGV4dGVuZHMgSk9TRUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdtdWx0aXBsZSBtYXRjaGluZyBrZXlzIGZvdW5kIGluIHRoZSBKU09OIFdlYiBLZXkgU2V0JztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsICdFUlJfSldLU19NVUxUSVBMRV9NQVRDSElOR19LRVlTJyk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShKV0tTTXVsdGlwbGVNYXRjaGluZ0tleXMsIFwiY29kZVwiLCAnRVJSX0pXS1NfTVVMVElQTEVfTUFUQ0hJTkdfS0VZUycpO1xuY2xhc3MgSldLU1RpbWVvdXQgZXh0ZW5kcyBKT1NFRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3JlcXVlc3QgdGltZWQgb3V0JztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgJ0VSUl9KV0tTX1RJTUVPVVQnKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEpXS1NUaW1lb3V0LCBcImNvZGVcIiwgJ0VSUl9KV0tTX1RJTUVPVVQnKTtcbmNsYXNzIEpXU1NpZ25hdHVyZVZlcmlmaWNhdGlvbkZhaWxlZCBleHRlbmRzIEpPU0VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnO1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCAnRVJSX0pXU19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxFRCcpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSldTU2lnbmF0dXJlVmVyaWZpY2F0aW9uRmFpbGVkLCBcImNvZGVcIiwgJ0VSUl9KV1NfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMRUQnKTtjb25zdCBpc09iamVjdExpa2UgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgaWYgKCFpc09iamVjdExpa2UoaW5wdXQpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IHByb3RvID0gaW5wdXQ7XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBwcm90bztcbn1mdW5jdGlvbiBkZWNvZGVKd3Qoand0KSB7XG4gIGlmICh0eXBlb2Ygand0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0pXVHMgbXVzdCB1c2UgQ29tcGFjdCBKV1Mgc2VyaWFsaXphdGlvbiwgSldUIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgY29uc3Qge1xuICAgIDE6IHBheWxvYWQsXG4gICAgbGVuZ3RoXG4gIH0gPSBqd3Quc3BsaXQoJy4nKTtcbiAgaWYgKGxlbmd0aCA9PT0gNSkgdGhyb3cgbmV3IEpXVEludmFsaWQoJ09ubHkgSldUcyB1c2luZyBDb21wYWN0IEpXUyBzZXJpYWxpemF0aW9uIGNhbiBiZSBkZWNvZGVkJyk7XG4gIGlmIChsZW5ndGggIT09IDMpIHRocm93IG5ldyBKV1RJbnZhbGlkKCdJbnZhbGlkIEpXVCcpO1xuICBpZiAoIXBheWxvYWQpIHRocm93IG5ldyBKV1RJbnZhbGlkKCdKV1RzIG11c3QgY29udGFpbiBhIHBheWxvYWQnKTtcbiAgbGV0IGRlY29kZWQ7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZShwYXlsb2FkKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgIHRocm93IG5ldyBKV1RJbnZhbGlkKCdGYWlsZWQgdG8gYmFzZTY0dXJsIGRlY29kZSB0aGUgcGF5bG9hZCcpO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShkZWNvZGVkKSk7XG4gIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgdGhyb3cgbmV3IEpXVEludmFsaWQoJ0ZhaWxlZCB0byBwYXJzZSB0aGUgZGVjb2RlZCBwYXlsb2FkIGFzIEpTT04nKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkpIHRocm93IG5ldyBKV1RJbnZhbGlkKCdJbnZhbGlkIEpXVCBDbGFpbXMgU2V0Jyk7XG4gIHJldHVybiByZXN1bHQ7XG59Y29uc3QgT05FX1NFQ09ORF9JTl9NSUxMSVNFQ09ORFMgPSAxMDAwO1xuY29uc3QgT05FX01JTlVURV9JTl9NSUxMSVNFQ09ORFMgPSA2MCAqIE9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTO1xuZnVuY3Rpb24gaXNSZXNwb25zZVRva2VuVmFsaWQocmVzcG9uc2UpIHtcbiAgY29uc3Qgand0UGF5bG9hZCA9IGRlY29kZVRva2VuUGF5bG9hZChyZXNwb25zZS5wYXJ0aWNpcGFudFRva2VuKTtcbiAgaWYgKCEoand0UGF5bG9hZCA9PT0gbnVsbCB8fCBqd3RQYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBqd3RQYXlsb2FkLm5iZikgfHwgIShqd3RQYXlsb2FkID09PSBudWxsIHx8IGp3dFBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGp3dFBheWxvYWQuZXhwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IG5iZkluTWlsbGlzZWNvbmRzID0gand0UGF5bG9hZC5uYmYgKiBPTkVfU0VDT05EX0lOX01JTExJU0VDT05EUztcbiAgY29uc3QgbmJmRGF0ZSA9IG5ldyBEYXRlKG5iZkluTWlsbGlzZWNvbmRzKTtcbiAgY29uc3QgZXhwSW5NaWxsaXNlY29uZHMgPSBqd3RQYXlsb2FkLmV4cCAqIE9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTO1xuICBjb25zdCBleHBEYXRlID0gbmV3IERhdGUoZXhwSW5NaWxsaXNlY29uZHMgLSBPTkVfTUlOVVRFX0lOX01JTExJU0VDT05EUyk7XG4gIHJldHVybiBuYmZEYXRlIDw9IG5vdyAmJiBleHBEYXRlID4gbm93O1xufVxuLyoqIEdpdmVuIGEgTGl2ZUtpdCBnZW5lcmF0ZWQgcGFydGljaXBhbnQgdG9rZW4sIGRlY29kZXMgYW5kIHJldHVybnMgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRva2VuUGF5bG9hZH0gZGF0YS4gKi9cbmZ1bmN0aW9uIGRlY29kZVRva2VuUGF5bG9hZCh0b2tlbikge1xuICBjb25zdCBwYXlsb2FkID0gZGVjb2RlSnd0KHRva2VuKTtcbiAgY29uc3Qge1xuICAgICAgcm9vbUNvbmZpZ1xuICAgIH0gPSBwYXlsb2FkLFxuICAgIHJlc3QgPSBfX3Jlc3QocGF5bG9hZCwgW1wicm9vbUNvbmZpZ1wiXSk7XG4gIGNvbnN0IG1hcHBlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7XG4gICAgcm9vbUNvbmZpZzogcGF5bG9hZC5yb29tQ29uZmlnID8gUm9vbUNvbmZpZ3VyYXRpb24uZnJvbUpzb24ocGF5bG9hZC5yb29tQ29uZmlnKSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIG1hcHBlZFBheWxvYWQ7XG59XG4vKiogR2l2ZW4gdHdvIFRva2VuU291cmNlRmV0Y2hPcHRpb25zIHZhbHVlcywgY2hlY2sgdG8gc2VlIGlmIHRoZXkgYXJlIGRlZXAgZXF1YWwuICovXG5mdW5jdGlvbiBhcmVUb2tlblNvdXJjZUZldGNoT3B0aW9uc0VxdWFsKGEsIGIpIHtcbiAgY29uc3QgYWxsS2V5c1NldCA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGEpLCAuLi5PYmplY3Qua2V5cyhiKV0pO1xuICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzU2V0KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ3Jvb21OYW1lJzpcbiAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TmFtZSc6XG4gICAgICBjYXNlICdwYXJ0aWNpcGFudElkZW50aXR5JzpcbiAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TWV0YWRhdGEnOlxuICAgICAgY2FzZSAncGFydGljaXBhbnRBdHRyaWJ1dGVzJzpcbiAgICAgIGNhc2UgJ2FnZW50TmFtZSc6XG4gICAgICBjYXNlICdhZ2VudE1ldGFkYXRhJzpcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gcmVmOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTgwMDk5OTJcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrZWRLZXkgPSBrZXk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMga2V5IFwiLmNvbmNhdChleGhhdXN0aXZlQ2hlY2tlZEtleSwgXCIgbm90IGJlaW5nIGNoZWNrZWQgZm9yIGVxdWFsaXR5IVwiKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufS8qKiBBIFRva2VuU291cmNlQ2FjaGVkIGlzIGEgVG9rZW5Tb3VyY2Ugd2hpY2ggY2FjaGVzIHRoZSBsYXN0IHtAbGluayBUb2tlblNvdXJjZVJlc3BvbnNlT2JqZWN0fSB2YWx1ZSBhbmQgcmV0dXJucyBpdFxuICogdW50aWwgYSkgaXQgZXhwaXJlcyBvciBiKSB0aGUge0BsaW5rIFRva2VuU291cmNlRmV0Y2hPcHRpb25zfSBwcm92aWRlZCB0byAuZmV0Y2goLi4uKSBjaGFuZ2UuICovXG5jbGFzcyBUb2tlblNvdXJjZUNhY2hlZCBleHRlbmRzIFRva2VuU291cmNlQ29uZmlndXJhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhY2hlZEZldGNoT3B0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5jYWNoZWRSZXNwb25zZSA9IG51bGw7XG4gICAgdGhpcy5mZXRjaE11dGV4ID0gbmV3IF8oKTtcbiAgfVxuICBpc1NhbWVBc0NhY2hlZEZldGNoT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlZEZldGNoT3B0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNhY2hlZEZldGNoT3B0aW9ucykpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ3Jvb21OYW1lJzpcbiAgICAgICAgY2FzZSAncGFydGljaXBhbnROYW1lJzpcbiAgICAgICAgY2FzZSAncGFydGljaXBhbnRJZGVudGl0eSc6XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TWV0YWRhdGEnOlxuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudEF0dHJpYnV0ZXMnOlxuICAgICAgICBjYXNlICdhZ2VudE5hbWUnOlxuICAgICAgICBjYXNlICdhZ2VudE1ldGFkYXRhJzpcbiAgICAgICAgICBpZiAodGhpcy5jYWNoZWRGZXRjaE9wdGlvbnNba2V5XSAhPT0gb3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU4MDA5OTkyXG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrZWRLZXkgPSBrZXk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBrZXkgXCIuY29uY2F0KGV4aGF1c3RpdmVDaGVja2VkS2V5LCBcIiBub3QgYmVpbmcgY2hlY2tlZCBmb3IgZXF1YWxpdHkhXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2hvdWxkUmV0dXJuQ2FjaGVkVmFsdWVGcm9tRmV0Y2goZmV0Y2hPcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNSZXNwb25zZVRva2VuVmFsaWQodGhpcy5jYWNoZWRSZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTYW1lQXNDYWNoZWRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRDYWNoZWRSZXNwb25zZUp3dFBheWxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVRva2VuUGF5bG9hZCh0aGlzLmNhY2hlZFJlc3BvbnNlLnBhcnRpY2lwYW50VG9rZW4pO1xuICB9XG4gIGZldGNoKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5mZXRjaE11dGV4LmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJldHVybkNhY2hlZFZhbHVlRnJvbUZldGNoKG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkUmVzcG9uc2UudG9Kc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRGZXRjaE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB0b2tlblJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FjaGVkUmVzcG9uc2UgPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gdG9rZW5SZXNwb25zZS50b0pzb24oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUb2tlblNvdXJjZUxpdGVyYWwgZXh0ZW5kcyBUb2tlblNvdXJjZUZpeGVkIHtcbiAgY29uc3RydWN0b3IobGl0ZXJhbE9yRm4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubGl0ZXJhbE9yRm4gPSBsaXRlcmFsT3JGbjtcbiAgfVxuICBmZXRjaCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpdGVyYWxPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWxPckZuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsT3JGbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVG9rZW5Tb3VyY2VDdXN0b20gZXh0ZW5kcyBUb2tlblNvdXJjZUNhY2hlZCB7XG4gIGNvbnN0cnVjdG9yKGN1c3RvbUZuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN1c3RvbUZuID0gY3VzdG9tRm47XG4gIH1cbiAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzdWx0TWF5YmVQcm9taXNlID0gdGhpcy5jdXN0b21GbihvcHRpb25zKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAocmVzdWx0TWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXN1bHQgPSB5aWVsZCByZXN1bHRNYXliZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRNYXliZVByb21pc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gVG9rZW5Tb3VyY2VSZXNwb25zZS5mcm9tSnNvbihyZXN1bHQsIHtcbiAgICAgICAgLy8gTk9URTogaXQgY291bGQgYmUgcG9zc2libGUgdGhhdCB0aGUgcmVzcG9uc2UgYm9keSBjb3VsZCBjb250YWluIG1vcmUgZmllbGRzIHRoYW4ganVzdFxuICAgICAgICAvLyB3aGF0J3MgaW4gVG9rZW5Tb3VyY2VSZXNwb25zZSBkZXBlbmRpbmcgb24gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlnbm9yZVVua25vd25GaWVsZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUb2tlblNvdXJjZUVuZHBvaW50IGV4dGVuZHMgVG9rZW5Tb3VyY2VDYWNoZWQge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmVuZHBvaW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgY3JlYXRlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFRva2VuU291cmNlUmVxdWVzdCgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdyb29tTmFtZSc6XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50TmFtZSc6XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50SWRlbnRpdHknOlxuICAgICAgICBjYXNlICdwYXJ0aWNpcGFudE1ldGFkYXRhJzpcbiAgICAgICAgICByZXF1ZXN0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BhcnRpY2lwYW50QXR0cmlidXRlcyc6XG4gICAgICAgICAgcmVxdWVzdC5wYXJ0aWNpcGFudEF0dHJpYnV0ZXMgPSAoX2EgPSBvcHRpb25zLnBhcnRpY2lwYW50QXR0cmlidXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FnZW50TmFtZSc6XG4gICAgICAgICAgcmVxdWVzdC5yb29tQ29uZmlnID0gKF9iID0gcmVxdWVzdC5yb29tQ29uZmlnKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgUm9vbUNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICBpZiAocmVxdWVzdC5yb29tQ29uZmlnLmFnZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcXVlc3Qucm9vbUNvbmZpZy5hZ2VudHMucHVzaChuZXcgUm9vbUFnZW50RGlzcGF0Y2goKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3Qucm9vbUNvbmZpZy5hZ2VudHNbMF0uYWdlbnROYW1lID0gb3B0aW9ucy5hZ2VudE5hbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FnZW50TWV0YWRhdGEnOlxuICAgICAgICAgIHJlcXVlc3Qucm9vbUNvbmZpZyA9IChfYyA9IHJlcXVlc3Qucm9vbUNvbmZpZykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFJvb21Db25maWd1cmF0aW9uKCk7XG4gICAgICAgICAgaWYgKHJlcXVlc3Qucm9vbUNvbmZpZy5hZ2VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJvb21Db25maWcuYWdlbnRzLnB1c2gobmV3IFJvb21BZ2VudERpc3BhdGNoKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0LnJvb21Db25maWcuYWdlbnRzWzBdLm1ldGFkYXRhID0gb3B0aW9ucy5hZ2VudE1ldGFkYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU4MDA5OTkyXG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrZWRLZXkgPSBrZXk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBrZXkgXCIuY29uY2F0KGV4aGF1c3RpdmVDaGVja2VkS2V5LCBcIiBub3QgYmVpbmcgaW5jbHVkZWQgaW4gZm9ybWluZyByZXF1ZXN0IVwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godGhpcy51cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lbmRwb2ludE9wdGlvbnMpLCB7XG4gICAgICAgIG1ldGhvZDogKF9hID0gdGhpcy5lbmRwb2ludE9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSwgdGhpcy5lbmRwb2ludE9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgIGJvZHk6IHJlcXVlc3QudG9Kc29uU3RyaW5nKHtcbiAgICAgICAgICB1c2VQcm90b0ZpZWxkTmFtZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSkpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIHRva2VuIGZyb20gZW5kcG9pbnQgXCIuY29uY2F0KHRoaXMudXJsLCBcIjogcmVjZWl2ZWQgXCIpLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsIFwiIC8gXCIpLmNvbmNhdCh5aWVsZCByZXNwb25zZS50ZXh0KCkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gVG9rZW5Tb3VyY2VSZXNwb25zZS5mcm9tSnNvbihib2R5LCB7XG4gICAgICAgIC8vIE5PVEU6IGl0IGNvdWxkIGJlIHBvc3NpYmxlIHRoYXQgdGhlIHJlc3BvbnNlIGJvZHkgY291bGQgY29udGFpbiBtb3JlIGZpZWxkcyB0aGFuIGp1c3RcbiAgICAgICAgLy8gd2hhdCdzIGluIFRva2VuU291cmNlUmVzcG9uc2UgZGVwZW5kaW5nIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiAoaWUsIFNhbmRib3hUb2tlblNlcnZlcilcbiAgICAgICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRva2VuU291cmNlU2FuZGJveFRva2VuU2VydmVyIGV4dGVuZHMgVG9rZW5Tb3VyY2VFbmRwb2ludCB7XG4gIGNvbnN0cnVjdG9yKHNhbmRib3hJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgYmFzZVVybCA9ICdodHRwczovL2Nsb3VkLWFwaS5saXZla2l0LmlvJ1xuICAgICAgfSA9IG9wdGlvbnMsXG4gICAgICByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcImJhc2VVcmxcIl0pO1xuICAgIHN1cGVyKFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiL2FwaS92Mi9zYW5kYm94L2Nvbm5lY3Rpb24tZGV0YWlsc1wiKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnWC1TYW5kYm94LUlEJzogc2FuZGJveElkXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG59XG5jb25zdCBUb2tlblNvdXJjZSA9IHtcbiAgLyoqIFRva2VuU291cmNlLmxpdGVyYWwgY29udGFpbnMgYSBzaW5nbGUsIGxpdGVyYWwgc2V0IG9mIHtAbGluayBUb2tlblNvdXJjZVJlc3BvbnNlT2JqZWN0fVxuICAgKiBjcmVkZW50aWFscywgZWl0aGVyIHByb3ZpZGVkIGRpcmVjdGx5IG9yIHJldHVybmVkIGZyb20gYSBwcm92aWRlZCBmdW5jdGlvbi4gKi9cbiAgbGl0ZXJhbChsaXRlcmFsT3JGbikge1xuICAgIHJldHVybiBuZXcgVG9rZW5Tb3VyY2VMaXRlcmFsKGxpdGVyYWxPckZuKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRva2VuU291cmNlLmN1c3RvbSBhbGxvd3MgYSB1c2VyIHRvIGRlZmluZSBhIG1hbnVhbCBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgbmV3XG4gICAqIHtAbGluayBUb2tlblNvdXJjZVJlc3BvbnNlT2JqZWN0fSB2YWx1ZXMgb24gZGVtYW5kLlxuICAgKlxuICAgKiBVc2UgdGhpcyB0byBnZXQgY3JlZGVudGlhbHMgZnJvbSBjdXN0b20gYmFja2VuZHMgLyBldGMuXG4gICAqL1xuICBjdXN0b20oY3VzdG9tRm4pIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU291cmNlQ3VzdG9tKGN1c3RvbUZuKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRva2VuU291cmNlLmVuZHBvaW50IGNyZWF0ZXMgYSB0b2tlbiBzb3VyY2UgdGhhdCBmZXRjaGVzIGNyZWRlbnRpYWxzIGZyb20gYSBnaXZlbiBVUkwgdXNpbmdcbiAgICogdGhlIHN0YW5kYXJkIGVuZHBvaW50IGZvcm1hdDpcbiAgICogQHNlZSBodHRwczovL2Nsb3VkLmxpdmVraXQuaW8vcHJvamVjdHMvcF8vc2FuZGJveC90ZW1wbGF0ZXMvdG9rZW4tc2VydmVyXG4gICAqL1xuICBlbmRwb2ludCh1cmwpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIG5ldyBUb2tlblNvdXJjZUVuZHBvaW50KHVybCwgb3B0aW9ucyk7XG4gIH0sXG4gIC8qKlxuICAgKiBUb2tlblNvdXJjZS5zYW5kYm94VG9rZW5TZXJ2ZXIgcXVlcmllcyBhIHNhbmRib3ggdG9rZW4gc2VydmVyIGZvciBjcmVkZW50aWFscyxcbiAgICogd2hpY2ggc3VwcG9ydHMgcXVpY2sgcHJvdG90eXBpbmcgLyBnZXR0aW5nIHN0YXJ0ZWQgdHlwZXMgb2YgdXNlIGNhc2VzLlxuICAgKlxuICAgKiBUaGlzIHRva2VuIHByb3ZpZGVyIGlzIElOU0VDVVJFIGFuZCBzaG91bGQgTk9UIGJlIHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogRm9yIG1vcmUgaW5mbzpcbiAgICogQHNlZSBodHRwczovL2Nsb3VkLmxpdmVraXQuaW8vcHJvamVjdHMvcF8vc2FuZGJveC90ZW1wbGF0ZXMvdG9rZW4tc2VydmVyXG4gICAqL1xuICBzYW5kYm94VG9rZW5TZXJ2ZXIoc2FuZGJveElkKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBuZXcgVG9rZW5Tb3VyY2VTYW5kYm94VG9rZW5TZXJ2ZXIoc2FuZGJveElkLCBvcHRpb25zKTtcbiAgfVxufTsvKipcbiAqIFRyeSB0byBhbmFseXplIHRoZSBsb2NhbCB0cmFjayB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIG9mIGEgdHJhY2suXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZXJlIGlzIG5vIHByb3BlcnR5IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMgdG8gZGV0ZWN0IHdoZXRoZXIgYSB2aWRlbyB0cmFjayBvcmlnaW5hdGVkIGZyb20gYSB1c2VyLSBvciBlbnZpcm9ubWVudC1mYWNpbmcgY2FtZXJhIGRldmljZS5cbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlIHRoZSBgZmFjaW5nTW9kZWAgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsIGJ1dCB3aWxsIGZhbGwgYmFjayBvbiBhIHN0cmluZy1iYXNlZCBhbmFseXNpcyBvZiB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKiBJZiBib3RoIG1ldGhvZHMgZmFpbCwgdGhlIGRlZmF1bHQgZmFjaW5nIG1vZGUgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMvZmFjaW5nTW9kZSB8IE1ETiBkb2NzIG9uIGZhY2luZ01vZGV9XG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayhsb2NhbFRyYWNrKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9hO1xuICBjb25zdCB0cmFjayA9IGlzTG9jYWxUcmFjayhsb2NhbFRyYWNrKSA/IGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA6IGxvY2FsVHJhY2s7XG4gIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGZhY2luZ01vZGU6IChfYSA9IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1c2VyJyxcbiAgICBjb25maWRlbmNlOiAnbG93J1xuICB9O1xuICAvLyAxLiBUcnkgdG8gZ2V0IGZhY2luZ01vZGUgZnJvbSB0cmFjayBzZXR0aW5ncy5cbiAgaWYgKCdmYWNpbmdNb2RlJyBpbiB0cmFja1NldHRpbmdzKSB7XG4gICAgY29uc3QgcmF3RmFjaW5nTW9kZSA9IHRyYWNrU2V0dGluZ3MuZmFjaW5nTW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyYXdGYWNpbmdNb2RlJywge1xuICAgICAgcmF3RmFjaW5nTW9kZVxuICAgIH0pO1xuICAgIGlmIChyYXdGYWNpbmdNb2RlICYmIHR5cGVvZiByYXdGYWNpbmdNb2RlID09PSAnc3RyaW5nJyAmJiBpc0ZhY2luZ01vZGVWYWx1ZShyYXdGYWNpbmdNb2RlKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBmYWNpbmdNb2RlOiByYXdGYWNpbmdNb2RlLFxuICAgICAgICBjb25maWRlbmNlOiAnaGlnaCdcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIDIuIElmIHdlIGRvbid0IGhhdmUgYSBoaWdoIGNvbmZpZGVuY2Ugd2UgdHJ5IHRvIGdldCB0aGUgZmFjaW5nIG1vZGUgZnJvbSB0aGUgZGV2aWNlIGxhYmVsLlxuICBpZiAoWydsb3cnLCAnbWVkaXVtJ10uaW5jbHVkZXMocmVzdWx0LmNvbmZpZGVuY2UpKSB7XG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZShcIlRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6IChcIi5jb25jYXQodHJhY2subGFiZWwsIFwiKVwiKSk7XG4gICAgY29uc3QgbGFiZWxBbmFseXNpc1Jlc3VsdCA9IGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwodHJhY2subGFiZWwpO1xuICAgIGlmIChsYWJlbEFuYWx5c2lzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGxhYmVsQW5hbHlzaXNSZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXAoW1snb2JzIHZpcnR1YWwgY2FtZXJhJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXAoW1snaXBob25lJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV0sIFsnaXBhZCcsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dXSk7XG4vKipcbiAqIEF0dGVtcHQgdG8gYW5hbHl6ZSB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKGRldmljZUxhYmVsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFiZWwgPSBkZXZpY2VMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gRW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgZGV2aWNlIGxhYmVsIGJ1dCB3ZSBjYW4ndCBpbmZlciBhbnl0aGluZyBmcm9tIGl0LlxuICBpZiAobGFiZWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCB3aWRlbHkga25vd24gZGV2aWNlIGxhYmVscy5cbiAgaWYgKGtub3duRGV2aWNlTGFiZWxzLmhhcyhsYWJlbCkpIHtcbiAgICByZXR1cm4ga25vd25EZXZpY2VMYWJlbHMuZ2V0KGxhYmVsKTtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gKF9hID0gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKF9yZWYgPT4ge1xuICAgIGxldCBbc2VjdGlvbl0gPSBfcmVmO1xuICAgIHJldHVybiBsYWJlbC5pbmNsdWRlcyhzZWN0aW9uKTtcbiAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbn1cbmZ1bmN0aW9uIGlzRmFjaW5nTW9kZVZhbHVlKGl0ZW0pIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndXNlcicsICdlbnZpcm9ubWVudCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgfHwgYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhpdGVtKTtcbn1leHBvcnR7QXVkaW9QcmVzZXRzLEJhY2t1cENvZGVjUG9saWN5LEJhc2VLZXlQcm92aWRlcixDaGVja1N0YXR1cyxDaGVja2VyLENvbm5lY3Rpb25DaGVjayxDb25uZWN0aW9uRXJyb3IsQ29ubmVjdGlvbkVycm9yUmVhc29uLENvbm5lY3Rpb25RdWFsaXR5LENvbm5lY3Rpb25TdGF0ZSxDcml0aWNhbFRpbWVycyxDcnlwdG9yRXJyb3IsQ3J5cHRvckVycm9yUmVhc29uLENyeXB0b3JFdmVudCxEYXRhUGFja2V0X0tpbmQsRGF0YVN0cmVhbUVycm9yLERhdGFTdHJlYW1FcnJvclJlYXNvbixEZWZhdWx0UmVjb25uZWN0UG9saWN5LERldmljZVVuc3VwcG9ydGVkRXJyb3IsRGlzY29ubmVjdFJlYXNvbixFbmNyeXB0aW9uRXZlbnQsRW5jcnlwdGlvbl9UeXBlLEVuZ2luZUV2ZW50LEV4dGVybmFsRTJFRUtleVByb3ZpZGVyLEtleUhhbmRsZXJFdmVudCxLZXlQcm92aWRlckV2ZW50LExpdmVraXRFcnJvcixMb2NhbEF1ZGlvVHJhY2ssTG9jYWxQYXJ0aWNpcGFudCxMb2NhbFRyYWNrLExvY2FsVHJhY2tQdWJsaWNhdGlvbixMb2NhbFRyYWNrUmVjb3JkZXIsTG9jYWxWaWRlb1RyYWNrLExvZ0xldmVsLExvZ2dlck5hbWVzLE1lZGlhRGV2aWNlRmFpbHVyZSxfIGFzIE11dGV4LE5lZ290aWF0aW9uRXJyb3IsUGFydGljaXBhbnQsUGFydGljaXBhbnRFdmVudCxQYXJ0aWNpcGFudEluZm9fS2luZCBhcyBQYXJ0aWNpcGFudEtpbmQsUHVibGlzaERhdGFFcnJvcixQdWJsaXNoVHJhY2tFcnJvcixSZW1vdGVBdWRpb1RyYWNrLFJlbW90ZVBhcnRpY2lwYW50LFJlbW90ZVRyYWNrLFJlbW90ZVRyYWNrUHVibGljYXRpb24sUmVtb3RlVmlkZW9UcmFjayxSb29tLFJvb21FdmVudCxScGNFcnJvcixTY3JlZW5TaGFyZVByZXNldHMsU2lnbmFsUmVjb25uZWN0RXJyb3IsU2lnbmFsUmVxdWVzdEVycm9yLFNpbXVsYXRlZEVycm9yLFN1YnNjcmlwdGlvbkVycm9yLFRva2VuU291cmNlLFRva2VuU291cmNlQ29uZmlndXJhYmxlLFRva2VuU291cmNlRml4ZWQsVHJhY2ssVHJhY2tFdmVudCxUcmFja0ludmFsaWRFcnJvcixUcmFja1B1YmxpY2F0aW9uLFRyYWNrVHlwZSxVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlLFVuc3VwcG9ydGVkU2VydmVyLFZpZGVvUHJlc2V0LFZpZGVvUHJlc2V0cyxWaWRlb1ByZXNldHM0MyxWaWRlb1F1YWxpdHksYXJlVG9rZW5Tb3VyY2VGZXRjaE9wdGlvbnNFcXVhbCxhc0VuY3J5cHRhYmxlUGFja2V0LGF0dGFjaFRvRWxlbWVudCxhdHRyaWJ1dGVUeXBpbmdzIGFzIGF0dHJpYnV0ZXMsYXVkaW9Db2RlY3MsY29tcGFyZVZlcnNpb25zLGNyZWF0ZUF1ZGlvQW5hbHlzZXIsY3JlYXRlRTJFRUtleSxjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nLGNyZWF0ZUxvY2FsQXVkaW9UcmFjayxjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyxjcmVhdGVMb2NhbFRyYWNrcyxjcmVhdGVMb2NhbFZpZGVvVHJhY2ssZGVjb2RlVG9rZW5QYXlsb2FkLGRlcml2ZUtleXMsZGV0YWNoVHJhY2ssZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCxmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2ssZ2V0QnJvd3NlcixnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2ssZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrLGdldExvZ2dlcixpbXBvcnRLZXksaXNBdWRpb0NvZGVjLGlzQXVkaW9UcmFjayxpc0JhY2t1cENvZGVjLGlzQmFja3VwVmlkZW9Db2RlYyxpc0Jyb3dzZXJTdXBwb3J0ZWQsaXNFMkVFU3VwcG9ydGVkLGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCxpc0xvY2FsUGFydGljaXBhbnQsaXNMb2NhbFRyYWNrLGlzUmVtb3RlUGFydGljaXBhbnQsaXNSZW1vdGVUcmFjayxpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCxpc1ZpZGVvQ29kZWMsaXNWaWRlb0ZyYW1lLGlzVmlkZW9UcmFjayxuZWVkc1Jic3BVbmVzY2FwaW5nLHBhcnNlUmJzcCxwcm90b2NvbFZlcnNpb24scmF0Y2hldCxzZXRMb2dFeHRlbnNpb24sc2V0TG9nTGV2ZWwsc3VwcG9ydHNBVjEsc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSxzdXBwb3J0c0F1ZGlvT3V0cHV0U2VsZWN0aW9uLHN1cHBvcnRzRHluYWNhc3Qsc3VwcG9ydHNWUDksdmVyc2lvbix2aWRlb0NvZGVjcyx3cml0ZVJic3B9Oy8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdmVraXQtY2xpZW50LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Frunner%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);